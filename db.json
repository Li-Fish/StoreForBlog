{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon32.png","path":"images/favicon32.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon16.png","path":"images/favicon16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/avatar.gif","path":"uploads/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1507362681498},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1507362681494},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1507362681494},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1507362681498},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1507362681494},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1507362681498},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1507362681498},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1507362681498},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1507362681498},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1507362681498},{"_id":"themes/next/README.cn.md","hash":"6d9177e7dad87e6129760e4b559bd3f7a15429d7","modified":1507362681498},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1507362681498},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1507362681498},{"_id":"themes/next/_config.yml","hash":"48cd812d268f59aa4b7554f1a2705635d844512b","modified":1507863351033},{"_id":"themes/next/README.md","hash":"1a79f01601517b777cfb238916635d4df7368473","modified":1507362681498},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1507362681506},{"_id":"source/categories/index.md","hash":"0a168e7357964c55459f57d5204e46d85e8262d5","modified":1507363657880},{"_id":"themes/next/package-lock.json","hash":"12a3557021ecf4570f4ae6f6ce603177a2d1044e","modified":1507362681506},{"_id":"source/_posts/12558-Egyptian-Fractions-HARD-version-（IDA-剪枝）.md","hash":"3eb08b222393f7a52aba4172f018a231aeaad6db","modified":1500778145000},{"_id":"source/_posts/2-SAT问题（模板）.md","hash":"8a5bff6b83db91f575b233378280152b195625e9","modified":1508295440052},{"_id":"source/_posts/2016年寒假集训.md","hash":"e66aa645884e8bed48d41dede755ea1ee3062a2b","modified":1503916504000},{"_id":"source/_posts/2048（游戏）.md","hash":"bc2278fb621a96689769c5b696762cb0d32561af","modified":1500782884000},{"_id":"source/_posts/690-Pipeline-Scheduling-DFS-状态压缩-剪枝.md","hash":"196f86f341357b46e0181a4ffe90dc645f2497c3","modified":1500778197000},{"_id":"source/_posts/2017年暑假集训.md","hash":"049a5d964dffde721585a071b323d6fba9c2e7b8","modified":1503924140000},{"_id":"source/_posts/CCPC2017哈理工比赛总结.md","hash":"f60fc22d7c4c493d12ec22d5d496248012375454","modified":1508930213712},{"_id":"source/_posts/818-Cutting-Chains-（枚举子集-状态压缩）.md","hash":"05dc481019e1dab532ba36815fa9e937c93d23a0","modified":1500778271000},{"_id":"source/_posts/BZOJ1500-维修数列-Splay.md","hash":"cfaf710214b2902b12207f3fbfaf367b7a849587","modified":1507644453924},{"_id":"source/_posts/AC自动机（模板）.md","hash":"2434387108e9a74e11e29af6f100e3470fca1883","modified":1506321966118},{"_id":"source/_posts/CF-766C-Mahmoud-and-a-Message-（DP-字符串）.md","hash":"f3fcc5294d2a13d1bf2c8bb7b08a895442ddb5d1","modified":1500779469000},{"_id":"source/_posts/CodeChef-MOU2H-Mountain-Holidays-2-（DP）.md","hash":"e54619f8e426f7a0762861bdfbe2f6254eb94946","modified":1500774999000},{"_id":"source/_posts/CodeForces-255C-Almost-Arithmetical-Progression-DP.md","hash":"4ad8546e159d404d0a5b17d3774ccba4e1608ece","modified":1500783401000},{"_id":"source/_posts/CodeForces734E-Anton-and-Tree（缩点-树的直径）.md","hash":"6832088d92e1d05d689edda6c87194db59f18162","modified":1500774709000},{"_id":"source/_posts/CodeForces732F-Tourist-Reform（边双连通-DFS）.md","hash":"7d7ef103cd8a5cedbeb210be6aafd1332a3aa8c4","modified":1508375816160},{"_id":"source/_posts/CodeForces740D-Alyona-and-a-tree-二分-树上差分.md","hash":"9113dbc67903cee3a61f7d3ad358863e5739f1ee","modified":1502929921000},{"_id":"source/_posts/CodeForces743D-Chloe-and-pleasant-prizes（树型DP）.md","hash":"a941ee7daf334717db3e561fd472c47ef8ecc3a1","modified":1500774626000},{"_id":"source/_posts/CodeForces743E-Vladik-and-cards（状压DP-二分）.md","hash":"4f7f1ad22027c72dd0bf22b1bb5569717341c27e","modified":1503576956000},{"_id":"source/_posts/CodeForces744B-Hongcow-s-Game（交互-二进制）.md","hash":"cec2e4e53add2d2d7133b928e61400e3939d738c","modified":1503111045000},{"_id":"source/_posts/CodeForces748E-Santa-Claus-and-Tangerines-递推-二分DP.md","hash":"c737f1314141168704c37be00e42a94770fcd638","modified":1503110874000},{"_id":"source/_posts/CodeForces868C-Qualification-Rounds-思维-二进制.md","hash":"d65baac9cf7fd0d1f8400a7c00644bf735bc2d29","modified":1507539241955},{"_id":"source/_posts/FZU-2112-Tickets-（欧拉回路-联通块判断）.md","hash":"def1af61234366e86c73cd978b22d6aa9161d8bf","modified":1500777415000},{"_id":"source/_posts/DAG上的动态规划.md","hash":"970a43261baf12b43d808b21e644e5276bd8d160","modified":1508375052928},{"_id":"source/_posts/Gym-100917J-Judgement-背包DP-bitset.md","hash":"a9c581b561db61b308da0cf3782d0dfd12ecc6dc","modified":1503629711000},{"_id":"source/_posts/HDU1024-Max-Sum-Plus-Plus（DP-降维优化）.md","hash":"98bd120c29767c3d9fd5d32a2bb488ad7c3f97e7","modified":1500774295000},{"_id":"source/_posts/HDOJ1176-免费馅饼-（DP）.md","hash":"e190a28a6ae748603ebd257b847fb209f335b757","modified":1500783446000},{"_id":"source/_posts/HDU1269-迷宫城堡-强连通.md","hash":"e7460bff3f21cf00685d7f23da0a328d7cbf4f64","modified":1501678822000},{"_id":"source/_posts/HDU1394-Minimum-Inversion-Number（线段树）.md","hash":"3d3eb8ffb1b8b53e2c515973a4a1b4ac12f095e8","modified":1500775155000},{"_id":"source/_posts/HDU1827-Summer-Holiday-强连通-缩点.md","hash":"5bb8d12676fc0e7d9819be1bff12b2d378b42c57","modified":1501680536000},{"_id":"source/_posts/HDU2196-Computer（树的直径-DP）.md","hash":"57f9e5f4149233fe18815e850fb1fa1bfe1a54b0","modified":1500774456000},{"_id":"source/_posts/HDU2242-考研路茫茫——空调教室（边双连通-树型DP）.md","hash":"a7a8bf216d5f1e170272738c0f3cca3d8b967500","modified":1501728983000},{"_id":"source/_posts/HDU3085-Nightmare-Ⅱ（双向BFS）.md","hash":"9f8a7a45b6ac9cab556a79be1b746cda3460fe8a","modified":1500776681000},{"_id":"source/_posts/HDU3639-Hawk-and-Chicken（强连通-缩点）.md","hash":"0878581d6e1556aac2bcd40f8692829b2533d6f1","modified":1501722318000},{"_id":"source/_posts/HDU3487-Play-with-Chain-Splay-模板详解.md","hash":"4bd4c7ad82af823791714a4c53b830963703e3c1","modified":1507645107424},{"_id":"source/_posts/HDU3829-Cat-VS-Dog（二分图匹配）.md","hash":"b0224fccd02eda49d0e81f02ceaa6ceda1bed3fc","modified":1503027961000},{"_id":"source/_posts/HDU3861-The-King’s-Problem（强连通-缩点-匈牙利）.md","hash":"ef6e1ac7c3d0b94581bb67060ad4a666b5928d02","modified":1501720851000},{"_id":"source/_posts/HDU3966-Aragorn-s-Story（树链剖分-模板）.md","hash":"7566213891ae48684e50fa273f4727b54662cb26","modified":1502277922000},{"_id":"source/_posts/HDU4027-Can-you-answer-these-queries-（线段树）.md","hash":"c2c54a36fa51a7f45a24e2cf5697048aaa8cd5e3","modified":1500775608000},{"_id":"source/_posts/HDU4280-Island-Transport（最大流-Dinic模板）.md","hash":"403e6bdf1068392bec40a4a092d9822da20929e5","modified":1501116419000},{"_id":"source/_posts/HDU4819-Mosaic（二维线段树-单点更新区间查询-模板）.md","hash":"da500eb7d6cfe982c1b6320d1ca82a2f3f07945a","modified":1509100006537},{"_id":"source/_posts/HDU4289-Control（最大流最小割）.md","hash":"41d1e0f00151a7bd8b0b389361d4bac8803effab","modified":1502161441000},{"_id":"source/_posts/HDU4288-Coder（线段树）.md","hash":"84dbfe9201797087c48b06188f8a25fe3ce8debf","modified":1502161456000},{"_id":"source/_posts/HDU4725-The-Shortest-Path-in-Nya-Graph-（Dijstra-建图）.md","hash":"17cbf639c9f044e9108d007fbd81fdc2c70ec246","modified":1500776871000},{"_id":"source/_posts/HDU5527-Too-Rich（贪心）.md","hash":"3af4a59223ff6222b5c5f1955223a6cd87994e3b","modified":1500774911000},{"_id":"source/_posts/HDU5550-Game-room-（DP）.md","hash":"c70b78b3f540713b93387fba0b93de08ef770b5b","modified":1500776946000},{"_id":"source/_posts/HDU6070-Dirt-Ratio（线段树-二分答案）.md","hash":"9ffd3e0bfa09ea32364c9c7848b01360ac259ec2","modified":1501813464000},{"_id":"source/_posts/HDU6156-Palindrome-Function（数位DP）.md","hash":"68639a9641ef8a508a202b5d7a887abac3e5eae4","modified":1503629581000},{"_id":"source/_posts/HackerRank-pairs-again（暴力-预处理）.md","hash":"59765c3c2e71c0ce6cf628eea01d2330a8afbe83","modified":1503206886000},{"_id":"source/_posts/HDUOJ3549-Flow-Problem（网络流-最大流最小割-模板）.md","hash":"07678de635e52753cbbe21bba979354c872a68bc","modified":1500777004000},{"_id":"source/_posts/HihoCoder1424-Asa-s-Chess-Problem（有上下流量限制的费用流）.md","hash":"8810e3dee2ed0787c8edb9671db71b45bbf3f11e","modified":1508150862451},{"_id":"source/_posts/LightOJ1197-Help-Hanzo（区间素数筛-模板）.md","hash":"4da9eedc130074eea8c9e1a7d22ad07e9bab7824","modified":1503206961000},{"_id":"source/_posts/LightOJ1214-Large-Division（高精度取模-模板）.md","hash":"ec7e1686fe033e3f8c5acee6901299e5460e38c4","modified":1503206816000},{"_id":"source/_posts/LightOJ1236-Pairs-Forming-LCM（LCM-唯一分解定理）.md","hash":"90eb440222b65090707e38164e651f10ae05199f","modified":1503206834000},{"_id":"source/_posts/LightOJ1282-Leading-and-Trailing（快速幂-数学）.md","hash":"5eb9963484703e772b77eb84d6b1d14da5b26a0e","modified":1503206850000},{"_id":"source/_posts/LightOJ1370-Bi-shoe-and-Phi-shoe（欧拉函数-打表）.md","hash":"3c17789c5037681cd4dfe9da8589602437f707c8","modified":1503206871000},{"_id":"source/_posts/POJ-3468-A-Simple-Problem-with-Integers（线段树区间更新-模板）.md","hash":"90abe92f769cb32ca6c05fdb1e31caad940ddfea","modified":1500781067000},{"_id":"source/_posts/POJ1015-Jury-Compromise（DP-计算顺序）.md","hash":"68f75eb91b28fa10a474e98474ee4bdade57ba74","modified":1500774233000},{"_id":"source/_posts/POJ1904-King-s-Quest-HDU4685-Prince-and-Princess（强连通-二分图匹配）.md","hash":"a330c76dab32db6bc5b4cda3e84fdf634ddfe16b","modified":1503111007000},{"_id":"source/_posts/POJ1182-食物链（带权并查集）.md","hash":"b4bf3861b55dea1caddd549ddb86f0d4ed681bd9","modified":1500777211000},{"_id":"source/_posts/POJ2155-Matrix-（二维树状数组）.md","hash":"f24c947f7d2cc0e91524325c3cd35647cf108f67","modified":1500777700000},{"_id":"source/_posts/POJ2135-Farm-Tour（最小费用流-模板-SPFA-Dijstra）.md","hash":"d67376e6b5efb8a16aa277ef53b7418e84f59595","modified":1500776805000},{"_id":"source/_posts/POJ2195-Going-Home（最小费用流-模板）.md","hash":"b294a352657d710aba2d8c919b967c427ed2499c","modified":1501121218000},{"_id":"source/_posts/POJ2411-Mondriaan-s-Dream-（状压DP-轮廓线DP）.md","hash":"953f2a3ded231b1fa15b31826cf2af60d52a0e83","modified":1500777089000},{"_id":"source/_posts/POJ3259-Wormholes（连通图判断负环）.md","hash":"40765a9ab5201f06756f5a0c373d052b988b3e63","modified":1500775700000},{"_id":"source/_posts/POJ3169-Layout-（差分约束）.md","hash":"a6fb9290e650bbf909ab6e705dac0cc896a867dc","modified":1500777145000},{"_id":"source/_posts/POJ3281-Dining（EK最大流-模板）.md","hash":"a2a33dc789a1a31903875b6092f0e3c0b56010bc","modified":1501039197000},{"_id":"source/_posts/Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪-）.md","hash":"8b1021987e4fb9cff83cab3e819e489e411117a7","modified":1500782564000},{"_id":"source/_posts/POJ3494-Largest-Submatrix-of-All-1’s-（单调栈）.md","hash":"59340e27291ba3cdbe4e1e12d201d7f87bb1c6cc","modified":1500777633000},{"_id":"source/_posts/POJ3694-Network（强连通-LCA）.md","hash":"b6b9109d1f3cbe20853b9d0e2b4393d8b3741df4","modified":1502421481000},{"_id":"source/_posts/Python爬虫基础细节（urllib-cookielib-BeautifulSoup）.md","hash":"c05d2e42d1d661608c3353c7cbf89fccf9c294e4","modified":1500782664000},{"_id":"source/_posts/SDUT-2622-最短路径（SPFA-二维）.md","hash":"8c187fc3bc13fd1cfd928d747e896e59ae1a02a3","modified":1500779219000},{"_id":"source/_posts/SDUT-Problem-5-二哥的狗（水题）.md","hash":"1e74fee13943c3ccbd5f6f49c1386e29acffd7f3","modified":1500782744000},{"_id":"source/_posts/SDUTOJ-2781-二分练习（二分）.md","hash":"6dc3858a64020ed9681a0498a9af728e90235a4a","modified":1500777588000},{"_id":"source/_posts/STL在使用算法竞赛中的使用方法-（教程-未完成）.md","hash":"dcd4ed21f35992f7f75e0a9d23daf48d18ac928d","modified":1500778088000},{"_id":"source/_posts/SDUTOJ-LCS问题-DP.md","hash":"508f9e123512450259c180314fd4d2e8e0fde25d","modified":1500783275000},{"_id":"source/_posts/ShadowSocks配置（Linux）.md","hash":"fdf9081b747267e7ef342f7a2d8b2851a7d00d57","modified":1500782410000},{"_id":"source/_posts/SDUTOJ3475-最后の汤圆.md","hash":"929224c76aa503699dc9822a533215fe728a8c80","modified":1500941846000},{"_id":"source/_posts/URAL1167-Bicolored-Horses（DP）.md","hash":"a14838f299ad274bc58e3528989724864f0cb700","modified":1507771644791},{"_id":"source/_posts/URAL1183-Brackets-Sequence（区间DP）.md","hash":"86bc021792db4657ed4a3eb7a855be56ccde8dc0","modified":1508116285914},{"_id":"source/_posts/URAL1260-Nudnik-Photographer（DP-递推）.md","hash":"42ce565dd944d3ba79f5dfb1e10762c593a31639","modified":1507698048944},{"_id":"source/_posts/UVA-10603-Fill（dijkstra-状态图）.md","hash":"fe4c4b4abb12f3f20f97e7b3bb660abf0e6d972e","modified":1500778698000},{"_id":"source/_posts/UVA-11212-Editing-a-Book（迭代加深搜索-IDA-模板）.md","hash":"8640c17e8aa49f9cd97337fc01126bb50c1a9ae7","modified":1500778553000},{"_id":"source/_posts/UVA-1606-Amphiphilic-Carbon-Molecules（极角排序-扫描法-计算几何）.md","hash":"07e6a174cf0c315587174a7bb8871e71c1bfa389","modified":1500777907000},{"_id":"source/_posts/UVA10129-Play-on-Words（欧拉道路）.md","hash":"9a85a8848a40719d24c5f104e4850ce010150fcf","modified":1500782812000},{"_id":"source/_posts/UVA12511-Virus（DP-最长公共上升子序列）.md","hash":"191423d095f35f76807a0e718948c618177008e8","modified":1500775972000},{"_id":"source/_posts/UVA11235-Frequent-values（游程编码-线段树）.md","hash":"a8e9384ec6d1625100d249f2941b92a2891d6cdf","modified":1500774575000},{"_id":"source/_posts/UVA140-Bandwidth-（暴力dfs-排列-剪枝）.md","hash":"e5a0753a69d4dfb0d75f0b18cc0beed247f2bdc4","modified":1500781112000},{"_id":"source/_posts/UVA506-System-Dependencies（模拟）.md","hash":"2364565b1a1896db7c7c1dacec9d5ae497953d64","modified":1500781600000},{"_id":"source/_posts/UVa-11426-GCD-Extreme-II.md","hash":"894fa5fed651cf24f1de0b9c93a1afdd9d5bedf9","modified":1503630212000},{"_id":"source/_posts/UVa-12166-Equilibrium-Mobile（二叉树-递归处理括号匹配-模板）.md","hash":"a97a7cb0a2aa31866617ed4b33547705468a6b93","modified":1500781314000},{"_id":"source/_posts/UVa-1354-Mobile-Computing（二叉树-DFS）.md","hash":"b2561687774888fa0462f5ec255f9e59e0f30d61","modified":1500778641000},{"_id":"source/_posts/Uva-806-Spatial-Structures（四分树-模板）.md","hash":"e15fcdf4d74935342f421f5ecb87109e7e6ac90c","modified":1502160304000},{"_id":"source/_posts/ZOJ3777-Problem-Arrangement（状压DP）.md","hash":"7cf98e525e8b0913b96d61f56139dcb503bb34f6","modified":1500777268000},{"_id":"source/_posts/ZOJ3385-Hanami-Party-（贪心）.md","hash":"2a837f2e65e909dea9071aef22a1b09e7b160f00","modified":1500774846000},{"_id":"source/_posts/webpy服务器（Linux-Web-HTML）.md","hash":"2dd0f5fb29c479a12bdec25065e93b96ee1c85e4","modified":1500779034000},{"_id":"source/_posts/ZOJ3781-Paint-the-Grid-Reloaded（缩点-最短路）.md","hash":"2b141379c1f65b53daac95983c75de947b3e96f0","modified":1500775389000},{"_id":"source/_posts/主席树（模板）.md","hash":"295276c7358c15ccba3ad20af321db3b6437e37d","modified":1507539269639},{"_id":"source/_posts/使用OpenMP实现并行归并排序（Report）.md","hash":"b25112e663729c39f0f4eded588303c7af31eab0","modified":1500776513000},{"_id":"source/_posts/常见错误清单（长期更新）.md","hash":"4585ac84fae32201a6f03d540363794eb15416bd","modified":1500776717000},{"_id":"source/_posts/数位DP（模板）.md","hash":"0e67c16c24f000a202cfdb6440a4ba310ee30e48","modified":1500777544000},{"_id":"source/_posts/口琴用简谱简易教程.md","hash":"d69b9510357ce3a46d1f73de2522abe6a520e4ce","modified":1507472453319},{"_id":"source/_posts/最长上升子序列（DP-模板）.md","hash":"69415d14ba72dd5f1a8b0aca24525bd8e76dc69e","modified":1500777859000},{"_id":"source/_posts/持续正反馈的任务清单计划.md","hash":"151c5a374369348163f2ea7898cb7961b301403b","modified":1504439203000},{"_id":"source/_posts/匹配、覆盖、独立集、二分图与网络流.md","hash":"bd273aaab90f72a16f9cd00cd3b5d6d4079d2dba","modified":1500775312000},{"_id":"source/_posts/矩阵快速幂小结.md","hash":"1f8f85ea6d1bd319da33b8deaf54bdecf76c45c2","modified":1503630056000},{"_id":"source/_posts/第八届acm山东省赛总结.md","hash":"e491165e68d8f4b6cbdae3fec0394f058e3cec34","modified":1500777335000},{"_id":"source/_posts/线段树小结.md","hash":"11290e61973f598830ee7996e824b97cf2fc2240","modified":1500775242000},{"_id":"source/_posts/社交网络图中结点的“重要性“计算（Dijkstra-SPFA-Floyd-模板）.md","hash":"55feea5e0901aea716cb040ba1c779bfbe0a50b8","modified":1500777975000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1507362681470},{"_id":"themes/next/.git/config","hash":"91b6a53b2a7f929b698734717a38d4ac169f0c1f","modified":1507362681474},{"_id":"source/_posts/计算行列式（高斯消元？-Java-工具）.md","hash":"9a7a1930531496e8815cf72761ebb9a8f64e5741","modified":1500778426000},{"_id":"themes/next/.git/index","hash":"002c7a2363654d59d0e03c7b7d306a5f572e60f9","modified":1508376887090},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1507362675190},{"_id":"source/_posts/自动走迷宫（DFS）.md","hash":"387582178c87cea41a208180d01c874a1302d264","modified":1500782947000},{"_id":"source/_posts/数独问题（工具）.md","hash":"d52743026268b974676885943ae67ae0f7e06867","modified":1500783066000},{"_id":"themes/next/.git/packed-refs","hash":"44c2da7f4c8a5fba74b51526d8c8d57ffff9e1d2","modified":1507362681470},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1507362681494},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1507362681494},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1507362681494},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1507362681494},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1507362681498},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1507362681498},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1507362681498},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1507362681498},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1507362681498},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1507362681498},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1507362681498},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1507362681498},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1507362681498},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1507362681498},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1507362681498},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1507362681498},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1507362681498},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1507362681498},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1507362681506},{"_id":"themes/next/layout/_layout.swig","hash":"26bd9be87576eaab53aaf178b5ddd84d8bb4cabf","modified":1507362681498},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1507362681506},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1507362681506},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1507362681506},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1507362681506},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1507362681506},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1507362681506},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1507362681506},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1507362681506},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1507362681538},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1507362681538},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1507362681538},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681514},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1507362675190},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1507362675186},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1507362675190},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1507362675190},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1507362675186},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1507362675186},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1507362675186},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1507362675190},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1507362675190},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1507362675190},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1507362675190},{"_id":"themes/next/.git/logs/HEAD","hash":"c649b455ca8fbc8d32b82c756fc0b8ea9b4a8faf","modified":1507362681470},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1507362681498},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1507362681498},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1507362681498},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1507362681498},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1507362681498},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1507362681502},{"_id":"themes/next/layout/_macro/post.swig","hash":"7a64914a0a3c893c1aaa8b5349b85898f95af314","modified":1507362681498},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1507362681502},{"_id":"themes/next/layout/_partials/comments.swig","hash":"044bc872d7b59655e46f6fb1cf14f767e31a4dfa","modified":1507362681502},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1507362681502},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1507362681502},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1507362681502},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1507362681502},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1507362681502},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1507362681502},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1507362681502},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1507362681506},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1507362681502},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1507362681502},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1507362681506},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1507362681506},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1507362681506},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1507362681506},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1507362681506},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1507362681506},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1507362681506},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1507362681506},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1507362681506},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1507362681506},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1507362681506},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1507362681506},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1507362681506},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1507362681510},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1507362681506},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1507362681506},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1507362681514},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1507362681514},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1507362681514},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1507362681514},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1507362681514},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1507362681514},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1507362681514},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1507362681514},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1507362681514},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1507362681514},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1507362681514},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1507362681514},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1507362681514},{"_id":"themes/next/source/images/favicon32.png","hash":"387e074ae6ca71bcf8b1806283478249be2d58b5","modified":1507387518758},{"_id":"themes/next/source/images/favicon16.png","hash":"eec6d3b10bcd573dab8640b9ace41fd6a8012368","modified":1507387689130},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1507362681514},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1507362681514},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1507362681514},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1507362681514},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1507362681514},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681502},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681502},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681510},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681510},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681510},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681510},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507362681510},{"_id":"themes/next/.git/refs/heads/master","hash":"5b9d4d4fefce055a1dace7d05b2f9e39dc4da00f","modified":1507362681470},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1507362681502},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1507362681502},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1507362681502},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1507362681502},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1507362681502},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1507362681502},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1507362681502},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1507362681502},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1507362681502},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1507362681502},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1507362681502},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1507362681502},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1507362681502},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1507362681502},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1507362681502},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1507362681502},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"1649bec66519e6d5d88b5a762ac2c001fc6fe01a","modified":1507362681506},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1507362681506},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1507362681506},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1507362681506},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"9f4ed36c73e890909b8ebbe601fb60e13d048288","modified":1507362681506},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1507362681506},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1507362681506},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1507362681506},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1507362681506},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1507362681510},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1507362681510},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1507362681510},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1507362681510},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1507362681510},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1507362681510},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1507362681510},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1507362681510},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1507362681514},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1507362681514},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1507362681514},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1507362681514},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1507362681514},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1507362681514},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1507362681514},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1507362681514},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1507362681514},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1507362681514},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1507362681514},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1507362681518},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1507362681518},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1507362681518},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1507362681518},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1507362681518},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1507362681518},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1507362681522},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1507362681518},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1507362681522},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1507362681530},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1507362681530},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1507362681530},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1507362681530},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1507362681530},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1507362681530},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1507362681534},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1507362681534},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1507362681534},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1507362681534},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1507362681534},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1507362681538},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1507362681538},{"_id":"themes/next/source/uploads/avatar.gif","hash":"3af3280fcd4589a5a1603b808233f875d55c932b","modified":1507364071140},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1507362681538},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1507362681506},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1507362681530},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c649b455ca8fbc8d32b82c756fc0b8ea9b4a8faf","modified":1507362681470},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1507362681470},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1507362681506},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1507362681506},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1507362681510},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1507362681510},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1507362681514},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1507362681510},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1507362681514},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1507362681510},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1507362681514},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1507362681514},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1507362681522},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1507362681518},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1507362681522},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1507362681518},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1507362681522},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1507362681534},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1507362681534},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1507362681510},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1507362681514},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1507362681530},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1507362681530},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1507362681538},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c649b455ca8fbc8d32b82c756fc0b8ea9b4a8faf","modified":1507362681470},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1507362681510},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1507362681510},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1507362681514},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1507362681514},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1507362681514},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1507362681514},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1507362681514},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1507362681518},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1507362681518},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1507362681522},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1507362681526},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1507362681530},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1507362681506},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1507362681510},{"_id":"themes/next/.git/objects/pack/pack-4ff4aa24e77c53c2e046803853e372ce7f06cb7f.idx","hash":"642cb9bb3e61e4d33251b85b3956ff2760ed6bbd","modified":1507362681398},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1507362681510},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1507362681510},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1507362681518},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1507362681534},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1507362681526},{"_id":"themes/next/.git/objects/pack/pack-4ff4aa24e77c53c2e046803853e372ce7f06cb7f.pack","hash":"bc3c8425ae5bc74aaaefdd99adfa95ccedf08940","modified":1507362681394},{"_id":"public/rss.xml","hash":"cee316e5e7ca5fded2f4d0c56afbde77fed5b501","modified":1509100037931},{"_id":"public/archives/2017/page/11/index.html","hash":"201a00fb2f4bd7ec5076f70d6425dc54811b6fcf","modified":1509100038395},{"_id":"public/archives/2017/01/index.html","hash":"adbbd292c786bf4cf70246fc7ab52ba477d3d823","modified":1509100038397},{"_id":"public/archives/2017/02/page/2/index.html","hash":"652c33899e534f2c8e23bc81fd9409705c9a342c","modified":1509100038397},{"_id":"public/archives/2017/05/page/2/index.html","hash":"e4e3a629a4d3118f7721b4ed223d2cee92e6e0ad","modified":1509100038397},{"_id":"public/archives/2017/07/page/2/index.html","hash":"3c6cde531774d5469bd11a2894587e32945f5521","modified":1509100038397},{"_id":"public/archives/2017/09/index.html","hash":"4030519a8fcfdba2a3885e67e3ae18c23b4f19b6","modified":1509100038397},{"_id":"public/archives/2017/10/page/2/index.html","hash":"1a991988de1b2783d8008619b99137e050bdb782","modified":1509100038397},{"_id":"public/categories/历程/index.html","hash":"5d62ec34e4c67c8b124df27274c24efd6aa949f0","modified":1509100038397},{"_id":"public/categories/游戏/index.html","hash":"877a99e1a0a8d76c8bacea40a1d3a01fbc367a76","modified":1509100038398},{"_id":"public/categories/ACM/搜索/page/2/index.html","hash":"27d0b2eae5d69fd2f17547e98bd44b595308ac5d","modified":1509100038398},{"_id":"public/categories/ACM/图论/page/3/index.html","hash":"5656c6baba632fcf0e81a1ea308ee7e9aad065ad","modified":1509100038398},{"_id":"public/categories/ACM/字符串/index.html","hash":"872dcfcc20562c3f9a883b9f85273c8275ec1190","modified":1509100038398},{"_id":"public/categories/ACM/DP/page/3/index.html","hash":"440c90fcea3d029fda7d0fb407a0f4196bfd2dab","modified":1509100038398},{"_id":"public/categories/ACM/搜索/BFS/index.html","hash":"c7219547603db542f236d7d533f01dd550bd9b65","modified":1509100038398},{"_id":"public/categories/ACM/二分/index.html","hash":"eb21b05371df3dbe9e54109b1280129372a1d76c","modified":1509100038398},{"_id":"public/categories/ACM/二进制/index.html","hash":"3615467b3a75fd4cec94fd570c31c54c5e13247a","modified":1509100038399},{"_id":"public/categories/ACM/图论/2-SAT/index.html","hash":"4d3032aa44789f5c0274a0a9642a218b4f4955a5","modified":1509100038399},{"_id":"public/categories/ACM/数据结构/Splay/index.html","hash":"885da29abac5f453b1cbcea731d097abcda3689f","modified":1509100038399},{"_id":"public/categories/ACM/字符串/AC自动机/index.html","hash":"ca1503987be6cfdeaa2a2b67d86c039f37703381","modified":1509100038399},{"_id":"public/categories/ACM/DP/树型DP/index.html","hash":"7db63897180d1289d30c834aa315e0d903bbe1bd","modified":1509100038399},{"_id":"public/categories/ACM/图论/匹配/index.html","hash":"c53862de36186c53f00c4a635f311a7dd2fc045c","modified":1509100038399},{"_id":"public/categories/ACM/数据结构/树链剖分/index.html","hash":"c80f0d03fa49476228c42376f9991b1fd8f06080","modified":1509100038399},{"_id":"public/categories/ACM/图论/最短路/index.html","hash":"bb5c0f09bf544e67f8389e639f89085fc1b4516c","modified":1509100038399},{"_id":"public/categories/ACM/贪心/index.html","hash":"42db392dc79c9763de4654d3479a758f5dc801ff","modified":1509100038400},{"_id":"public/categories/ACM/DP/状压DP/index.html","hash":"3e0e812bb83fe20215fe3588fc349d96f5ccbc17","modified":1509100038400},{"_id":"public/categories/ACM/DP/数位DP/index.html","hash":"e848e94a1e5be0e32d5e9171c7308ba510d1e3f5","modified":1509100038400},{"_id":"public/categories/ACM/数据结构/并查集/index.html","hash":"499f68e8ec087e0920d35d05a11c4206a7ce8e7c","modified":1509100038400},{"_id":"public/categories/ACM/图论/差分约束/index.html","hash":"094ceae746b455b40e6935787c0152324dd5f982","modified":1509100038400},{"_id":"public/categories/爬虫-数据处理/index.html","hash":"8d25fca7f7ee68b1d293ad592696a4b8a36d34f5","modified":1509100038400},{"_id":"public/categories/ACM/数据结构/栈/index.html","hash":"93cef20877ee2bbbe22f4aa1ac46e11fa35a9c29","modified":1509100038400},{"_id":"public/categories/编程语言/index.html","hash":"23337a6a9d21d188f8f0d8e7a12ce37201f5e75c","modified":1509100038400},{"_id":"public/categories/ACM/DP/区间DP/index.html","hash":"53d6c522052dcfffea1adf0a5bb5258b383192e1","modified":1509100038400},{"_id":"public/categories/ACM/计算几何/index.html","hash":"4b19276ea5f03fff7a27b203d61fbf20a27ff8a8","modified":1509100038401},{"_id":"public/categories/ACM/模拟/index.html","hash":"bce28520bc70593d1a49008f27b82ac9194a3d99","modified":1509100038401},{"_id":"public/categories/网页设计/index.html","hash":"70590ee6e12b43ba3ba5a53861c4fbbc239feb5c","modified":1509100038401},{"_id":"public/categories/ACM/数据结构/主席树/index.html","hash":"bbbd4e0f65bb2c058dba782ea4773ccd30867228","modified":1509100038401},{"_id":"public/categories/CS课程/index.html","hash":"f6fd2457770a98eea6d9ab190dab0ce02e6edebb","modified":1509100038401},{"_id":"public/categories/ACM/知识小结/index.html","hash":"01c3f432ffa2cc974e3c3111c9cd75fe512be023","modified":1509100038401},{"_id":"public/categories/音乐/index.html","hash":"c29bf406eb8d0b59df9cdc35332d1c0593d55513","modified":1509100038401},{"_id":"public/categories/想法/index.html","hash":"c800d96bb0020e63979fe3893a500d6e965b2ad4","modified":1509100038402},{"_id":"public/categories/ACM/数学/数论/index.html","hash":"46bf59b7f34f8d437c65f71cf490dfd6428edd31","modified":1509100038402},{"_id":"public/categories/编程语言/C/index.html","hash":"b51d636cf11a18c42a02c6403a377e7386abf3b1","modified":1509100038402},{"_id":"public/categories/网页设计/Web服务器/index.html","hash":"d37e8e5ead01d2353eb0025df7c9c684563d8ec6","modified":1509100038402},{"_id":"public/categories/音乐/乐理/index.html","hash":"5ba0889b006e4e67539946c2979e00d94e625d96","modified":1509100038402},{"_id":"public/categories/ACM/数学/矩阵快速幂/index.html","hash":"f6aac89e4098f990cca6cd752d9a8e5849a11769","modified":1509100038402},{"_id":"public/categories/编程语言/Java/index.html","hash":"b1dfef52688a33d9a00443e2f75afbfc67b388bc","modified":1509100038402},{"_id":"public/categories/index.html","hash":"a6acf654f7df123eafee3f08285de56870600ad6","modified":1509100038402},{"_id":"public/2017/10/24/CCPC2017哈理工比赛总结/index.html","hash":"d209751ad743ec8dfd2409421ec9f036445c65a4","modified":1509100038402},{"_id":"public/2017/10/18/2-SAT问题（模板）/index.html","hash":"58e865320249c3a582953986bda315fd1edeb01d","modified":1509100038402},{"_id":"public/2017/10/16/URAL1183-Brackets-Sequence（区间DP）/index.html","hash":"e968115504f709f237c9adb38c12591a9b67717a","modified":1509100038402},{"_id":"public/2017/10/16/HihoCoder1424-Asa-s-Chess-Problem（有上下流量限制的费用流）/index.html","hash":"4a9597e96990d92dcc6b3eebd60573c74a15560e","modified":1509100038402},{"_id":"public/2017/10/15/CodeForces732F-Tourist-Reform（边双连通-DFS）/index.html","hash":"ccec05c378e49ea6f82990005d8c000a9448c256","modified":1509100038402},{"_id":"public/2017/10/12/URAL1167-Bicolored-Horses（DP）/index.html","hash":"16fbed631fc26d789fd671cba0c25de5f2ea887d","modified":1509100038403},{"_id":"public/2017/10/11/URAL1260-Nudnik-Photographer（DP-递推）/index.html","hash":"ef2e2245652091046dad84255c63581b3728475e","modified":1509100038403},{"_id":"public/2017/10/10/BZOJ1500-维修数列-Splay/index.html","hash":"6eb7c617fd9cb12e4af66382460de8da7db38eba","modified":1509100038403},{"_id":"public/2017/10/09/HDU3487-Play-with-Chain-Splay-模板详解/index.html","hash":"0dc10cf17e6df94f3c67177450c5464e906d7d88","modified":1509100038403},{"_id":"public/2017/10/09/CodeForces868C-Qualification-Rounds-思维-二进制/index.html","hash":"169fa8afbe614d0859edd9796c4a019b2081c416","modified":1509100038403},{"_id":"public/2017/10/08/口琴用简谱简易教程/index.html","hash":"61f741d12956055bc68c98dab80eea1bb522e0b8","modified":1509100038403},{"_id":"public/2017/09/25/主席树（模板）/index.html","hash":"3e2764f4fcd0313e45f8a0ee906942c3db8b537f","modified":1509100038403},{"_id":"public/2017/09/25/AC自动机（模板）/index.html","hash":"f87596e7b2c9692d1b880a6a552ef7c40169c0b2","modified":1509100038403},{"_id":"public/2017/09/03/持续正反馈的任务清单计划/index.html","hash":"eca365d35c6060421c393512529b292e7739c8f2","modified":1509100038403},{"_id":"public/2017/08/28/2017年暑假集训/index.html","hash":"1f2a46a2e1d341faa0080dbf881640cb23375104","modified":1509100038403},{"_id":"public/2017/08/25/HDU6156-Palindrome-Function（数位DP）/index.html","hash":"1b9ca1b0ead60f3b9abe600f68daf93e87351236","modified":1509100038403},{"_id":"public/2017/08/21/Gym-100917J-Judgement-背包DP-bitset/index.html","hash":"520ddfd45aa0025e97ef57476ca944d1f5d16412","modified":1509100038403},{"_id":"public/2017/08/20/矩阵快速幂小结/index.html","hash":"1c0ba591f26034eaa640698d95c1c85da2618a04","modified":1509100038403},{"_id":"public/2017/08/19/CodeForces748E-Santa-Claus-and-Tangerines-递推-二分DP/index.html","hash":"29ea37a4820292a8ac859adfc0dd188e04a8ea2f","modified":1509100038403},{"_id":"public/2017/08/18/CodeForces744B-Hongcow-s-Game（交互-二进制）/index.html","hash":"3ec9e901991e1e8ff665f34d157d65a5ca67d038","modified":1509100038404},{"_id":"public/2017/08/18/POJ1904-King-s-Quest-HDU4685-Prince-and-Princess（强连通-二分图匹配）/index.html","hash":"777991deaf081c43aa8e680601cb0386638f0af2","modified":1509100038404},{"_id":"public/2017/08/18/HDU3829-Cat-VS-Dog（二分图匹配）/index.html","hash":"54c6209d7d598175f8d7c10c2472f1d32a8776cb","modified":1509100038404},{"_id":"public/2017/08/18/CodeForces743E-Vladik-and-cards（状压DP-二分）/index.html","hash":"4e9ae1129010f31b94842dbae6887d0b3029e089","modified":1509100038404},{"_id":"public/2017/08/16/CodeForces740D-Alyona-and-a-tree-二分-树上差分/index.html","hash":"aca3593cb847d32d3d11e7ecb6026ddd2d500065","modified":1509100038404},{"_id":"public/2017/08/11/POJ3694-Network（强连通-LCA）/index.html","hash":"b3d079060972da35ee4f68660613bd4b52cd6563","modified":1509100038404},{"_id":"public/2017/08/09/HDU3966-Aragorn-s-Story（树链剖分-模板）/index.html","hash":"8700a6a17331bbbcbf9b84bfde20aa120a3d3e8d","modified":1509100038404},{"_id":"public/2017/08/08/HDU4289-Control（最大流最小割）/index.html","hash":"22851e7375016af490ddcbb013989c3268cc5fa2","modified":1509100038404},{"_id":"public/2017/08/08/HDU4288-Coder（线段树）/index.html","hash":"e3673b4ef5f53c5c14164b48e02b134cf844e7f8","modified":1509100038404},{"_id":"public/2017/08/04/HDU6070-Dirt-Ratio（线段树-二分答案）/index.html","hash":"4b25471f6ef750d76dd4caf830ea8b96f7127934","modified":1509100038404},{"_id":"public/2017/08/03/HDU2242-考研路茫茫——空调教室（边双连通-树型DP）/index.html","hash":"762a9faccdb4173eea682d8bec074bdf557a32a0","modified":1509100038404},{"_id":"public/2017/08/03/HDU3639-Hawk-and-Chicken（强连通-缩点）/index.html","hash":"f017e45f85d5106498fbac3b588a4177279dd93d","modified":1509100038404},{"_id":"public/2017/08/02/HDU3861-The-King’s-Problem（强连通-缩点-匈牙利）/index.html","hash":"875e25ff7a4c4bf03fa86fb933ddcf02065ac186","modified":1509100038404},{"_id":"public/2017/08/02/HDU1827-Summer-Holiday-强连通-缩点/index.html","hash":"8e65438a4a86fd2130ab1c87aee666f8f045dbef","modified":1509100038405},{"_id":"public/2017/08/02/HDU1269-迷宫城堡-强连通/index.html","hash":"f24cedde70af4107550d3ad6d0e665ec77f2de6d","modified":1509100038405},{"_id":"public/2017/07/27/POJ2195-Going-Home（最小费用流-模板）/index.html","hash":"f26dfbbff71ee5a21ed55b4272c2291b40ce2bad","modified":1509100038405},{"_id":"public/2017/07/27/HDU4280-Island-Transport（最大流-Dinic模板）/index.html","hash":"e7b6a0664b1782491d0bd460b0b75a969cb5a277","modified":1509100038405},{"_id":"public/2017/07/26/POJ3281-Dining（EK最大流-模板）/index.html","hash":"2786eb3266c8da6da9be11b59cdd8befaa031157","modified":1509100038405},{"_id":"public/2017/07/25/UVa-11426-GCD-Extreme-II/index.html","hash":"2fbec28da97c7629165bd7f32a7c3ac08693a906","modified":1509100038405},{"_id":"public/2017/07/24/SDUTOJ3475-最后の汤圆/index.html","hash":"8580a0f5c41bb1a46858985b182be1672e499d51","modified":1509100038405},{"_id":"public/2017/07/21/LightOJ1197-Help-Hanzo（区间素数筛-模板）/index.html","hash":"68599f9ea481a9a9c2a3a66daee1c8695e4e5e3c","modified":1509100038405},{"_id":"public/2017/07/21/LightOJ1214-Large-Division（高精度取模-模板）/index.html","hash":"35ea662c0bf35d09c1dda9bdab401db57d16c5a6","modified":1509100038405},{"_id":"public/2017/07/21/LightOJ1236-Pairs-Forming-LCM（LCM-唯一分解定理）/index.html","hash":"eaa57e7299aae4acc43a75ebe6d27714cda932db","modified":1509100038405},{"_id":"public/2017/07/20/LightOJ1282-Leading-and-Trailing（快速幂-数学）/index.html","hash":"c0121b31167dea098dc485e2cb0d302917f21e43","modified":1509100038405},{"_id":"public/2017/07/20/LightOJ1370-Bi-shoe-and-Phi-shoe（欧拉函数-打表）/index.html","hash":"6732add443db5511a31979fee7835d033513d022","modified":1509100038406},{"_id":"public/2017/07/02/POJ1015-Jury-Compromise（DP-计算顺序）/index.html","hash":"a1904f3fd9bd5cfc1f3b161525270143c0e30f3a","modified":1509100038406},{"_id":"public/2017/06/30/HDU1024-Max-Sum-Plus-Plus（DP-降维优化）/index.html","hash":"9d87e33b9bf1198cbffb02c42df1b43bddc69119","modified":1509100038406},{"_id":"public/2017/06/28/HDU2196-Computer（树的直径-DP）/index.html","hash":"92f9f7f71ad14d9429c00210eb3fe3c018958c5f","modified":1509100038406},{"_id":"public/2017/06/28/UVA11235-Frequent-values（游程编码-线段树）/index.html","hash":"b4bb71473c87d31400dbe20ed93a74798fc71481","modified":1509100038406},{"_id":"public/2017/06/27/CodeForces743D-Chloe-and-pleasant-prizes（树型DP）/index.html","hash":"29b3d47b6369a796237c34dd02c6b9dd09e1fadc","modified":1509100038406},{"_id":"public/2017/06/27/CodeForces734E-Anton-and-Tree（缩点-树的直径）/index.html","hash":"c436637f5f9c6544f43cf4c76bf876f40f9e7b2a","modified":1509100038406},{"_id":"public/2017/06/26/HackerRank-pairs-again（暴力-预处理）/index.html","hash":"0d9f2855de2c6103cd04fbf4d805de2fc3c6b3cf","modified":1509100038406},{"_id":"public/2017/06/25/ZOJ3385-Hanami-Party-（贪心）/index.html","hash":"e154d175b43fad8ede0ac3cb628b5f6505cf217b","modified":1509100038406},{"_id":"public/2017/06/25/HDU5527-Too-Rich（贪心）/index.html","hash":"70b5ecb67c2e036f3ff1c958cfb94b8902dd3b3a","modified":1509100038406},{"_id":"public/2017/06/25/CodeChef-MOU2H-Mountain-Holidays-2-（DP）/index.html","hash":"ba7fc3047d218a3a52ac24e7f041c0a0a573b75f","modified":1509100038406},{"_id":"public/2017/06/21/HDU4027-Can-you-answer-these-queries-（线段树）/index.html","hash":"caa86741488fcf363049f5936412a640c8b0f7e0","modified":1509100038406},{"_id":"public/2017/06/21/HDU1394-Minimum-Inversion-Number（线段树）/index.html","hash":"beea63cee6e5e5391f27a2693bdd8deacc876b9b","modified":1509100038406},{"_id":"public/2017/06/19/线段树小结/index.html","hash":"68f83bc1be9ab0d366de677d0ed603343ddfee02","modified":1509100038406},{"_id":"public/2017/06/14/匹配、覆盖、独立集、二分图与网络流/index.html","hash":"1003a941cb67dd67037d5632da03c685cd3d0685","modified":1509100038406},{"_id":"public/2017/06/13/ZOJ3781-Paint-the-Grid-Reloaded（缩点-最短路）/index.html","hash":"bdd7b59ea848335e32fa2c2d503cac233ced8055","modified":1509100038407},{"_id":"public/2017/06/13/POJ3259-Wormholes（连通图判断负环）/index.html","hash":"17174e7507cd2b5d607dff9f5ae9d6c9a49728f9","modified":1509100038407},{"_id":"public/2017/06/11/UVA12511-Virus（DP-最长公共上升子序列）/index.html","hash":"6fc5220318f2be72f303d241e9ce648155344a23","modified":1509100038407},{"_id":"public/2017/06/05/使用OpenMP实现并行归并排序（Report）/index.html","hash":"ae6fdc3a1423231e231e63a0873da61a19172b19","modified":1509100038407},{"_id":"public/2017/05/31/HDU3085-Nightmare-Ⅱ（双向BFS）/index.html","hash":"474d2c698ee8ddb7602b46fc9b4ce544b389cebe","modified":1509100038407},{"_id":"public/2017/05/22/常见错误清单（长期更新）/index.html","hash":"5d1b009af2e57e6c2d0c322baf9dd239a462a6fb","modified":1509100038407},{"_id":"public/2017/05/22/POJ2135-Farm-Tour（最小费用流-模板-SPFA-Dijstra）/index.html","hash":"dae502dc7e611b131d615a1b2f8fbd1a71ed5d59","modified":1509100038407},{"_id":"public/2017/05/22/HDU4725-The-Shortest-Path-in-Nya-Graph-（Dijstra-建图）/index.html","hash":"47556ff5489b1a8391f59c7a5c5a732243cbc4dc","modified":1509100038407},{"_id":"public/2017/05/21/HDU5550-Game-room-（DP）/index.html","hash":"716960970a73bc19632bc0999163e6282e34980e","modified":1509100038407},{"_id":"public/2017/05/19/HDUOJ3549-Flow-Problem（网络流-最大流最小割-模板）/index.html","hash":"641008300c33ea453e6034b723ec81b8dfa975b5","modified":1509100038407},{"_id":"public/2017/05/18/POJ2411-Mondriaan-s-Dream-（状压DP-轮廓线DP）/index.html","hash":"aa37acfad54ecc965479c1968b848ab2a5c11fc2","modified":1509100038407},{"_id":"public/2017/05/15/POJ3169-Layout-（差分约束）/index.html","hash":"9bf911ba53f2baf39bd69e2c1a8d7899fa5a2a2e","modified":1509100038407},{"_id":"public/2017/05/13/POJ1182-食物链（带权并查集）/index.html","hash":"f821555a725c771c6a6d0fae0be5b56b29e47196","modified":1509100038407},{"_id":"public/2017/05/12/ZOJ3777-Problem-Arrangement（状压DP）/index.html","hash":"9555f9bfc1278b905fde7cce3fb015a15cccef03","modified":1509100038407},{"_id":"public/2017/05/09/第八届acm山东省赛总结/index.html","hash":"5f9dd0db305d082eec8f1897299e367df5c96214","modified":1509100038408},{"_id":"public/2017/05/04/FZU-2112-Tickets-（欧拉回路-联通块判断）/index.html","hash":"911119694fca299b0fa1c5b16a0c42dcb6d4c08c","modified":1509100038408},{"_id":"public/2017/04/26/DAG上的动态规划/index.html","hash":"540a2ed089226b6e5e7a8fecbd8900961ea7b960","modified":1509100038408},{"_id":"public/2017/04/24/数位DP（模板）/index.html","hash":"09454c633562ccd7fd19edf40c87802d96501b59","modified":1509100038408},{"_id":"public/2017/04/17/SDUTOJ-2781-二分练习（二分）/index.html","hash":"2017a6c58516dddcb6667ac6e9fadbbfd05e9cc8","modified":1509100038408},{"_id":"public/2017/04/09/POJ3494-Largest-Submatrix-of-All-1’s-（单调栈）/index.html","hash":"a2cf30014f35088cdd7a9a8a79e84af2a7f1d91e","modified":1509100038408},{"_id":"public/2017/04/09/POJ2155-Matrix-（二维树状数组）/index.html","hash":"f4e2ccca645b5f0aacc7807631c56f982048339b","modified":1509100038408},{"_id":"public/2017/04/09/最长上升子序列（DP-模板）/index.html","hash":"8c5c96dd3ce6ce8d8d7cd9545ad2d911bd8c62f5","modified":1509100038408},{"_id":"public/2017/04/03/UVA-1606-Amphiphilic-Carbon-Molecules（极角排序-扫描法-计算几何）/index.html","hash":"c8eb3302405d3ed24f9fac0a7d1ab60bc001c358","modified":1509100038408},{"_id":"public/2017/03/20/社交网络图中结点的“重要性“计算（Dijkstra-SPFA-Floyd-模板）/index.html","hash":"92b2734a08aaffcb9dead81e5ac43634817c6a0e","modified":1509100038408},{"_id":"public/2017/03/17/STL在使用算法竞赛中的使用方法-（教程-未完成）/index.html","hash":"5c6c5f9e570e8ccb9d37ba68ce9b098253e9336d","modified":1509100038408},{"_id":"public/2017/03/16/12558-Egyptian-Fractions-HARD-version-（IDA-剪枝）/index.html","hash":"105f839fedeadc2574ca07f1bab58019b55edf69","modified":1509100038408},{"_id":"public/2017/03/15/690-Pipeline-Scheduling-DFS-状态压缩-剪枝/index.html","hash":"d15a6a4c5ec8d80b6ee60deeb273f6fa4759978a","modified":1509100038408},{"_id":"public/2017/03/14/818-Cutting-Chains-（枚举子集-状态压缩）/index.html","hash":"36468d0ab10ad629993fec3989657ff22cca22cb","modified":1509100038410},{"_id":"public/2017/03/09/计算行列式（高斯消元？-Java-工具）/index.html","hash":"127d3231b5ab5c41b48f8fe9c2825481be69f672","modified":1509100038410},{"_id":"public/2017/02/26/2016年寒假集训/index.html","hash":"3c2003ea556e76c60e91c4b7677e8f292c3aa181","modified":1509100038410},{"_id":"public/2017/02/21/UVA-11212-Editing-a-Book（迭代加深搜索-IDA-模板）/index.html","hash":"8a3ca4bb61539b5e2465871d4ce9cfaab6ddab4a","modified":1509100038410},{"_id":"public/2017/02/18/UVa-1354-Mobile-Computing（二叉树-DFS）/index.html","hash":"4fa897fa141b976a257671fe2569e8cf3cf17705","modified":1509100038410},{"_id":"public/2017/02/18/UVA-10603-Fill（dijkstra-状态图）/index.html","hash":"0181d5ab0dc8e5a258f6f5271593987b99e8993f","modified":1509100038411},{"_id":"public/2017/02/16/SDUT-2622-最短路径（SPFA-二维）/index.html","hash":"c62a127e1a29e48c25acf5c98eed3470283751aa","modified":1509100038411},{"_id":"public/2017/02/17/webpy服务器（Linux-Web-HTML）/index.html","hash":"7c9d9ecbc96fbeea3ce89c3451000f82eb7ad596","modified":1509100038411},{"_id":"public/2017/02/15/UVA140-Bandwidth-（暴力dfs-排列-剪枝）/index.html","hash":"8cda670c99f7525b351763426fa63cf28b041396","modified":1509100038411},{"_id":"public/2017/02/13/CF-766C-Mahmoud-and-a-Message-（DP-字符串）/index.html","hash":"36b325b4478e4fce38404ab7add33279f3c2b074","modified":1509100038411},{"_id":"public/2017/02/10/POJ-3468-A-Simple-Problem-with-Integers（线段树区间更新-模板）/index.html","hash":"167112f42eb19993bffebbf1e4e9b622b261dcfc","modified":1509100038411},{"_id":"public/2017/02/09/Uva-806-Spatial-Structures（四分树-模板）/index.html","hash":"622452b24f2ece059256c093fcb39d36c66b436c","modified":1509100038411},{"_id":"public/2017/02/08/UVa-12166-Equilibrium-Mobile（二叉树-递归处理括号匹配-模板）/index.html","hash":"6216e3d2688d44604530336c1740f3cf9d86c502","modified":1509100038411},{"_id":"public/2017/02/07/UVA506-System-Dependencies（模拟）/index.html","hash":"6b19f2e87792dfa1be6bd28dba8bfb24ae721b3a","modified":1509100038411},{"_id":"public/2017/02/03/ShadowSocks配置（Linux）/index.html","hash":"bec33e79f4498ee0bf92dc65d58363cfabfde157","modified":1509100038412},{"_id":"public/2017/01/03/Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪-）/index.html","hash":"96eb442039f3ab724a421fd2a4f98cde6665226b","modified":1509100038412},{"_id":"public/2017/01/03/Python爬虫基础细节（urllib-cookielib-BeautifulSoup）/index.html","hash":"a10316f0a1fed6c4aa892148edb9cb9ee6a46dad","modified":1509100038412},{"_id":"public/2016/12/26/SDUT-Problem-5-二哥的狗（水题）/index.html","hash":"a34f38f3bd2c9c4a3458d4d80ce8b6da416aa328","modified":1509100038412},{"_id":"public/2016/12/15/UVA10129-Play-on-Words（欧拉道路）/index.html","hash":"0f343a4acd286599ba057c0ea8edf308a26af631","modified":1509100038412},{"_id":"public/2016/12/05/2048（游戏）/index.html","hash":"1f149b0317fc6614f00ee89c281eb90dd08a176a","modified":1509100038412},{"_id":"public/2016/12/05/自动走迷宫（DFS）/index.html","hash":"72452b7aacfb8a61f38d24ac4ed419c0abffa0da","modified":1509100038412},{"_id":"public/2016/12/05/数独问题（工具）/index.html","hash":"b514a347565a87f7b0b5ae88a7e180d3d3fe4a59","modified":1509100038412},{"_id":"public/2016/12/05/HDOJ1176-免费馅饼-（DP）/index.html","hash":"ef7671b4de329744cedb33d2b7eef9e407ba8fcd","modified":1509100038413},{"_id":"public/2016/12/05/CodeForces-255C-Almost-Arithmetical-Progression-DP/index.html","hash":"00cf42d414272f99f020e12cd75df6a445c143c8","modified":1509100038413},{"_id":"public/2016/12/05/SDUTOJ-LCS问题-DP/index.html","hash":"3be1d83ad510a5db1baa9b09e7e4c255b6886ea0","modified":1509100038413},{"_id":"public/archives/index.html","hash":"6a50e0cd247b5a2d0d314ecb3d917037e2bc9ec0","modified":1509100038413},{"_id":"public/archives/page/2/index.html","hash":"2ed8fd3bd57156d5d2c7b30cce405447d0b514c1","modified":1509100038413},{"_id":"public/archives/page/3/index.html","hash":"577d2229fe45219752f178da6a694b4d9f414b85","modified":1509100038413},{"_id":"public/archives/page/4/index.html","hash":"390639013527a388a8c2be1c7d816343e06d4ae7","modified":1509100038413},{"_id":"public/archives/page/5/index.html","hash":"52b0726c47d06dda5ba6d922e0115619d0deaccb","modified":1509100038413},{"_id":"public/archives/page/6/index.html","hash":"2d767d5d1ac901df976b8e8de5a13013870ae272","modified":1509100038413},{"_id":"public/archives/page/7/index.html","hash":"4aaa121f297b805bc9aac19c3a8e2ea5b9e14faa","modified":1509100038414},{"_id":"public/archives/page/8/index.html","hash":"f29c1ec0383657625a96da68490191d991aa6331","modified":1509100038414},{"_id":"public/archives/page/9/index.html","hash":"36ed52c525da3c927d49ad2296beeb86e542f4b3","modified":1509100038414},{"_id":"public/archives/page/10/index.html","hash":"c06b1e905291397fd6d7d8a70017821c63c6124f","modified":1509100038414},{"_id":"public/archives/page/11/index.html","hash":"be5e0e95d459e330feed8fdbf1d0aaa1e020508c","modified":1509100038414},{"_id":"public/archives/2016/index.html","hash":"f13faa0cdda54f81f24111539b77bd0cd10a1495","modified":1509100038414},{"_id":"public/archives/2016/12/index.html","hash":"c581eb456b900c69a826057d5cf831f12f24c63e","modified":1509100038414},{"_id":"public/archives/2017/index.html","hash":"2a3e00b0d10db632a89f4b767b611034a2e1511a","modified":1509100038414},{"_id":"public/archives/2017/page/2/index.html","hash":"6633ff6af21f024d9ed82842c86bb5bb284fc46a","modified":1509100038415},{"_id":"public/archives/2017/page/3/index.html","hash":"2d22fd4032b5d17abd228157129f099067bb1b82","modified":1509100038415},{"_id":"public/archives/2017/page/4/index.html","hash":"6ed4c21ac475dbe112a0c18ef077ad0b0d2a7c65","modified":1509100038415},{"_id":"public/archives/2017/page/5/index.html","hash":"2189084f24f5439ff884c34e55b710176f8bd080","modified":1509100038415},{"_id":"public/archives/2017/page/6/index.html","hash":"0bb08e29527727c895bf2d8013c661c877418aff","modified":1509100038415},{"_id":"public/archives/2017/page/7/index.html","hash":"db338a88cc3e1ddd933a43d7670eb7fa797b6b8e","modified":1509100038415},{"_id":"public/archives/2017/page/8/index.html","hash":"efdb23d41d38fa28393d5a6b7b2dc489d38811dd","modified":1509100038415},{"_id":"public/archives/2017/page/9/index.html","hash":"15a209df46b85864facb82c17556b6bd7fd35fe6","modified":1509100038415},{"_id":"public/archives/2017/page/10/index.html","hash":"321ac4826d65b0fb1d2902ce1863f3686b8ba8ac","modified":1509100038415},{"_id":"public/archives/2017/02/index.html","hash":"9a19476d3153b706ba1d8e731dba227ad9ea1a82","modified":1509100038415},{"_id":"public/archives/2017/03/index.html","hash":"c59a17658b3a0065f5f2cd26277f48b1920cc56d","modified":1509100038415},{"_id":"public/archives/2017/04/index.html","hash":"1252e27d3eda8dcf37285b9e1e8e876a0539094d","modified":1509100038416},{"_id":"public/archives/2017/05/index.html","hash":"0d8720142953a0d0735bc8816ef9ac290c8dace0","modified":1509100038416},{"_id":"public/archives/2017/06/index.html","hash":"d64ab70b09fb8ac91f9d5fc3198ffef170cf6bff","modified":1509100038416},{"_id":"public/archives/2017/06/page/2/index.html","hash":"14f7e4972ca289e2118c45ad4534e59ee789d4ae","modified":1509100038416},{"_id":"public/archives/2017/07/index.html","hash":"3c254a54151aa853176356225282b5a98d884f56","modified":1509100038416},{"_id":"public/archives/2017/08/index.html","hash":"5b427031a5068f0d88f0410582b1445008212c97","modified":1509100038416},{"_id":"public/archives/2017/08/page/2/index.html","hash":"6ca58253bd575d4e3689952d5a805c1e5216668a","modified":1509100038416},{"_id":"public/archives/2017/10/index.html","hash":"cb0ffc16952e9bd8a7bce3a3890d918204ddec1d","modified":1509100038416},{"_id":"public/categories/ACM/index.html","hash":"8ea61f8a9fb837a33c9c4b65e6ff84930b063d83","modified":1509100038416},{"_id":"public/categories/ACM/page/2/index.html","hash":"650489a80aeb26e58120a3a3d67825e85ba0570e","modified":1509100038417},{"_id":"public/categories/ACM/page/3/index.html","hash":"36f610bcec20cbf9d82605828b2a123cd842ab63","modified":1509100038417},{"_id":"public/categories/ACM/page/4/index.html","hash":"f29f0e544449b6c58146d83391930d56116f1826","modified":1509100038417},{"_id":"public/categories/ACM/page/5/index.html","hash":"828a4bed3f7b36c078ecd4a1c3363fed4d41d731","modified":1509100038417},{"_id":"public/categories/ACM/page/6/index.html","hash":"b3fe1305c16ddceae829ded3f867933cca04155c","modified":1509100038417},{"_id":"public/categories/ACM/page/7/index.html","hash":"d7ab671c9fcd878dee863532bdf251f775a788e3","modified":1509100038417},{"_id":"public/categories/ACM/page/8/index.html","hash":"78171cd16b087aed5ad7b9efed9399c8bc0bdfcd","modified":1509100038417},{"_id":"public/categories/ACM/page/9/index.html","hash":"9864e31b676e66897ae37242975ce576e5bcb3f8","modified":1509100038418},{"_id":"public/categories/ACM/page/10/index.html","hash":"b0f9206f3fdb5db80f2a7f714f69807afab9372c","modified":1509100038418},{"_id":"public/categories/ACM/搜索/index.html","hash":"5dc2b05b349f41e51f68dcdfc42a4bfb0f2f802a","modified":1509100038418},{"_id":"public/categories/ACM/图论/index.html","hash":"079e879b9531dc8a36be019572c8fbc89595526e","modified":1509100038418},{"_id":"public/categories/ACM/图论/page/2/index.html","hash":"b4555b65e003868078c02178d42ae5aae849af62","modified":1509100038418},{"_id":"public/categories/ACM/数据结构/index.html","hash":"202a077fa9c07953c50a54b23d2f7d4a1c3e485a","modified":1509100038418},{"_id":"public/categories/ACM/数据结构/page/2/index.html","hash":"b13ed466421c0027e5c47fa0be551fe24a58c650","modified":1509100038418},{"_id":"public/categories/ACM/DP/index.html","hash":"3f21c3d9fd3612f75831266bac508d67b793e952","modified":1509100038418},{"_id":"public/categories/ACM/DP/page/2/index.html","hash":"27dc51acd2e6d17fb4ae37c1dd1ff8619f2679e7","modified":1509100038418},{"_id":"public/categories/ACM/图论/连通性/index.html","hash":"f73fc9cf518245fad56c4de6f191c3f8249b8b6a","modified":1509100038419},{"_id":"public/categories/ACM/数据结构/线段树/index.html","hash":"b62f25722e4200b09e6ab95ffa26da230b304758","modified":1509100038419},{"_id":"public/categories/ACM/图论/网络流/index.html","hash":"75d56eaafcf0778f7454e3a3f1e17601c09b4608","modified":1509100038419},{"_id":"public/categories/ACM/数学/index.html","hash":"e899dafaa3552babf4612f8ec333e7cd74315c6f","modified":1509100038419},{"_id":"public/index.html","hash":"0b1c708eb825281333b67ec5aaf4a7c171af89bb","modified":1509100038419},{"_id":"public/page/2/index.html","hash":"b96fb42a5057c0efeedf96a97dd60a37eafb4926","modified":1509100038419},{"_id":"public/page/3/index.html","hash":"3d84924a77126747a62018c0f6c0ee3de5d659d2","modified":1509100038419},{"_id":"public/page/4/index.html","hash":"7b85ebb9ee549758a52a4fb457ea7b381832e309","modified":1509100038419},{"_id":"public/page/5/index.html","hash":"f1c1c1fc87671245505585eff2fac87c2f2c488d","modified":1509100038420},{"_id":"public/page/6/index.html","hash":"3b37bb706e1eaf184066fdb2f14d319c78228cd6","modified":1509100038420},{"_id":"public/page/7/index.html","hash":"cd35a92b723a709d62fb58d7f072173f334987db","modified":1509100038420},{"_id":"public/page/8/index.html","hash":"21d8e58aac3df39e93755d9368670d8b3e6489ac","modified":1509100038420},{"_id":"public/page/9/index.html","hash":"c55f1147a9874593e5ed30232dc4c3412fae1df3","modified":1509100038420},{"_id":"public/page/10/index.html","hash":"cd4d705192e4cf83e2b8b831e8016d0e00b4bec4","modified":1509100038420},{"_id":"public/page/11/index.html","hash":"15f3696fb63f901edb1a5378c1d8b239498cd210","modified":1509100038420},{"_id":"public/archives/page/12/index.html","hash":"2f962f7ff0b79e28b89e187bf6f3a850949125f3","modified":1509100038436},{"_id":"public/2017/10/27/HDU4819-Mosaic（二维线段树-单点更新区间查询-模板）/index.html","hash":"1150d1180adc28bb46b45b0ffceff17aeb81b07f","modified":1509100038436},{"_id":"public/page/12/index.html","hash":"41cc628a85b2a3e3113fd41a8259d584351e9dd3","modified":1509100038436},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1509100038449},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1509100038450},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1509100038450},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1509100038450},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1509100038450},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1509100038450},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1509100038450},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1509100038450},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1509100038450},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1509100038450},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1509100038451},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1509100038451},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1509100038451},{"_id":"public/images/favicon32.png","hash":"387e074ae6ca71bcf8b1806283478249be2d58b5","modified":1509100038451},{"_id":"public/images/favicon16.png","hash":"eec6d3b10bcd573dab8640b9ace41fd6a8012368","modified":1509100038451},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1509100038451},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1509100038451},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1509100038451},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1509100038451},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1509100038451},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1509100038452},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1509100038452},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1509100038452},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1509100038452},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1509100038452},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1509100038452},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1509100038452},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1509100038452},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1509100038453},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1509100038453},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1509100038453},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1509100038453},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1509100038453},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1509100038453},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1509100038453},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1509100039608},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1509100039615},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1509100039654},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1509100039654},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1509100039654},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1509100039654},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1509100039654},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1509100039654},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1509100039654},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1509100039654},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1509100039654},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1509100039654},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1509100039655},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1509100039655},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1509100039655},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1509100039655},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1509100039655},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1509100039655},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1509100039655},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1509100039655},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1509100039655},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1509100039655},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1509100039655},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1509100039655},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1509100039655},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1509100039655},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1509100039655},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1509100039655},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1509100039655},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1509100039656},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1509100039656},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1509100039656},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1509100039656},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1509100039656},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1509100039656},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1509100039656},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1509100039656},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1509100039656},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1509100039656},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1509100039656},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1509100039657},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1509100039657},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1509100039657},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1509100039657},{"_id":"public/css/main.css","hash":"e0efca644518f23a2ced6522af6f6af4db7719f2","modified":1509100039657},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1509100039657},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1509100039657},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1509100039657},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1509100039657},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1509100039657},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1509100039657},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1509100039657},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1509100039657},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1509100039657},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1509100039658},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1509100039658},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1509100039658},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1509100039658},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1509100039658},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1509100039658},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1509100039658},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1509100039658},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1509100039658},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1509100039658},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1509100039658},{"_id":"public/uploads/avatar.gif","hash":"3af3280fcd4589a5a1603b808233f875d55c932b","modified":1509100039658},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1509100039659},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1509100039659},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1509100039659},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1509100039676}],"Category":[{"name":"ACM","_id":"cj99r6n8f0003y9id4llaw5t8"},{"name":"历程","_id":"cj99r6n93000ay9idwfeyqy1t"},{"name":"游戏","_id":"cj99r6n96000dy9idj5gehqu3"},{"name":"搜索","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6n9c000hy9ide1wu1nae"},{"name":"图论","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6n9s000uy9idamys5was"},{"name":"数据结构","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6naa0017y9ide3bncvb3"},{"name":"字符串","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nae001cy9idboobswv2"},{"name":"DP","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6naj001hy9id0amduhe9"},{"name":"BFS","parent":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nax001ty9idt5fpw4no"},{"name":"二分","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nb70024y9idut313vzl"},{"name":"二进制","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nbq002hy9idqaqsepd2"},{"name":"2-SAT","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nbv002ky9ido3d0yqwk"},{"name":"Splay","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nch0039y9idqmygw8tq"},{"name":"连通性","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ncs003ly9idj0unhudg"},{"name":"AC自动机","parent":"cj99r6nae001cy9idboobswv2","_id":"cj99r6ncy003qy9idrbrrrrp6"},{"name":"线段树","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nd4003vy9idgm464xg2"},{"name":"树型DP","parent":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nde0045y9idsvcsfnxh"},{"name":"匹配","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ne1004wy9idpo46sqok"},{"name":"树链剖分","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6neb0056y9idwp79bhc1"},{"name":"网络流","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nem005ly9id56i7kl0u"},{"name":"最短路","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nf5006ay9idhlkbcf5q"},{"name":"贪心","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfa006hy9idgpspepk2"},{"name":"状压DP","parent":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nfd006my9idxb5t7ese"},{"name":"数位DP","parent":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nfi006ry9idvxhuli20"},{"name":"数学","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfl006wy9idwz8ldprj"},{"name":"并查集","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nfv007sy9idanaz2hs6"},{"name":"差分约束","parent":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ng3008ay9idec7md0cr"},{"name":"爬虫&数据处理","_id":"cj99r6ng5008gy9idqg6lcf3u"},{"name":"栈","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng6008jy9id6b6el40j"},{"name":"编程语言","_id":"cj99r6ngb008ty9iduw0rly9k"},{"name":"区间DP","parent":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ngc008wy9idsl48c8uy"},{"name":"计算几何","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nge0092y9idzxpkcgdi"},{"name":"模拟","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngf0095y9iddsh0ukcj"},{"name":"网页设计","_id":"cj99r6ngk009iy9idzf97bzw3"},{"name":"主席树","parent":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ngl009ly9idgk8xjlcc"},{"name":"CS课程","_id":"cj99r6ngm009oy9ido1fcmmjm"},{"name":"知识小结","parent":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngn009ry9idsuqz2sis"},{"name":"音乐","_id":"cj99r6ngp009yy9id22h9iozw"},{"name":"想法","_id":"cj99r6ngq00a1y9id7tfgotxg"},{"name":"数论","parent":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6ngy00agy9idgcl1ot34"},{"name":"C++","parent":"cj99r6ngb008ty9iduw0rly9k","_id":"cj99r6nh300apy9idm9syz6xh"},{"name":"Web服务器","parent":"cj99r6ngk009iy9idzf97bzw3","_id":"cj99r6nh700awy9idkm6ul9fz"},{"name":"乐理","parent":"cj99r6ngp009yy9id22h9iozw","_id":"cj99r6nh800azy9ide5lfkhic"},{"name":"矩阵快速幂","parent":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nh900b2y9id8tfbf5wl"},{"name":"Java","parent":"cj99r6ngb008ty9iduw0rly9k","_id":"cj99r6nha00b5y9idq6m77a8x"}],"Data":[],"Page":[{"title":"categories","date":"2017-10-07T08:04:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-10-07 16:04:06\ntype: \"categories\"\n---\n","updated":"2017-10-07T08:07:37.880Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj99r6n7y0000y9id4w6f1kzr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"12558 - Egyptian Fractions (HARD version) （IDA* + 剪枝）","date":"2017-03-16T13:55:23.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4003\n# 题目大意\n------------------\n埃及分数问题，给定一个分数，用几个不相同的分数表示，有多个表示的话，用的分数越少越好，还是多解的话，最小的分数越大越好，然后第二小的分数越大越好……一直到最大的分数越大越好。\n# 解题过程\n--------------\n见紫书分析\n# 题目分析\n------------------\n见紫书分析\n代码已加入注释\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nLL ans[11234567], tans[11234567];\n\n//book用来标记不可用作分母的数字，题目说小于1000，下面代码用到book的地方都是判断分母是否可用\nbool book[11234];\n\n//得到一个结果后，如果比ans更优，那么更新\nbool better(int d) {\n    for (int i = d; i >= 0; i--) {\n        if (ans[i] != tans[i])\n            return ans[i] == -1 || tans[i] < ans[i];\n    }\n}\n\n//获得下一个比 a/b 小的 1/c\nLL get_next(LL a, LL b) {\n    for (LL i = 1; ; i++) {\n        if (i <= 10000 && book[i])\n            continue;\n        if (b <= a * i)\n            return i;\n    }\n}\n\nbool dfs(int max_deep, LL from, LL aa, LL bb, int deep) {\n    //如果到达最大深度，那么需要判断下，然后return\n    if (deep == max_deep) {\n        //判断最后的状态是否为 1/c 的形式，如果不算，那么当前状态不可表示原分数\n        if (bb % aa)\n            return false;\n        if (bb <= 10000 && book[bb/aa])\n            return false;\n        tans[deep] = bb/aa;\n        //如果当前解更优，那么更新ans\n        if (better(deep))\n            memcpy(ans, tans, sizeof(LL) * (deep+1));\n        return true;\n    }\n\n    bool ok = false;\n\n    //得到的 1/c 中 c 至少比上一次的分母大才可以 from 即是上一次的分母加一\n    from = max(from, get_next(aa, bb));\n    for (int i = from; ; i++) {\n        if (i <= 10000 && book[i])\n            continue;\n\n        //如果剩下的递归次数，都是用 1/i 还小于 aa/bb 的话，那么当前 i 和比 i 大的数字不能用来做分母\n        if (bb * (max_deep+1-deep) <= i * aa)\n            break;\n        tans[deep] = i;\n\n        //计算 aa/bb - 1/i，gcd 用来约分\n        LL b2 = bb*i;\n        LL a2 = aa*i - bb;\n        LL g = __gcd(a2, b2);\n        if (dfs(max_deep, i+1, a2/g, b2/g, deep+1))\n            ok = true;\n    }\n    return ok;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int cases = 1; cases <= n; cases++) {\n        memset(book, 0, sizeof(book));\n        LL a, b, k;\n        scanf(\"%lld %lld %lld\", &a, &b, &k);\n        for (int i = 0; i < k; i++) {\n            LL t;\n            scanf(\"%d\", &t);\n            book[t] = true;\n        }\n\n        for (int i = 0; ; i++) {\n            memset(ans, -1, sizeof(ans));\n            if (dfs(i,get_next(a, b), a, b, 0))\n                break;\n        }\n\n        printf(\"Case %d: %lld/%lld=\", cases, a, b);\n        for (int i = 0; ans[i] != -1; i++) {\n            if (i)\n                putchar('+');\n            printf(\"1/%lld\", ans[i]);\n        }\n        putchar('\\n');\n    }\n}\n\n```","source":"_posts/12558-Egyptian-Fractions-HARD-version-（IDA-剪枝）.md","raw":"---\ntitle: 12558 - Egyptian Fractions (HARD version) （IDA* + 剪枝）\ndate: 2017-03-16 21:55:23\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4003\n# 题目大意\n------------------\n埃及分数问题，给定一个分数，用几个不相同的分数表示，有多个表示的话，用的分数越少越好，还是多解的话，最小的分数越大越好，然后第二小的分数越大越好……一直到最大的分数越大越好。\n# 解题过程\n--------------\n见紫书分析\n# 题目分析\n------------------\n见紫书分析\n代码已加入注释\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nLL ans[11234567], tans[11234567];\n\n//book用来标记不可用作分母的数字，题目说小于1000，下面代码用到book的地方都是判断分母是否可用\nbool book[11234];\n\n//得到一个结果后，如果比ans更优，那么更新\nbool better(int d) {\n    for (int i = d; i >= 0; i--) {\n        if (ans[i] != tans[i])\n            return ans[i] == -1 || tans[i] < ans[i];\n    }\n}\n\n//获得下一个比 a/b 小的 1/c\nLL get_next(LL a, LL b) {\n    for (LL i = 1; ; i++) {\n        if (i <= 10000 && book[i])\n            continue;\n        if (b <= a * i)\n            return i;\n    }\n}\n\nbool dfs(int max_deep, LL from, LL aa, LL bb, int deep) {\n    //如果到达最大深度，那么需要判断下，然后return\n    if (deep == max_deep) {\n        //判断最后的状态是否为 1/c 的形式，如果不算，那么当前状态不可表示原分数\n        if (bb % aa)\n            return false;\n        if (bb <= 10000 && book[bb/aa])\n            return false;\n        tans[deep] = bb/aa;\n        //如果当前解更优，那么更新ans\n        if (better(deep))\n            memcpy(ans, tans, sizeof(LL) * (deep+1));\n        return true;\n    }\n\n    bool ok = false;\n\n    //得到的 1/c 中 c 至少比上一次的分母大才可以 from 即是上一次的分母加一\n    from = max(from, get_next(aa, bb));\n    for (int i = from; ; i++) {\n        if (i <= 10000 && book[i])\n            continue;\n\n        //如果剩下的递归次数，都是用 1/i 还小于 aa/bb 的话，那么当前 i 和比 i 大的数字不能用来做分母\n        if (bb * (max_deep+1-deep) <= i * aa)\n            break;\n        tans[deep] = i;\n\n        //计算 aa/bb - 1/i，gcd 用来约分\n        LL b2 = bb*i;\n        LL a2 = aa*i - bb;\n        LL g = __gcd(a2, b2);\n        if (dfs(max_deep, i+1, a2/g, b2/g, deep+1))\n            ok = true;\n    }\n    return ok;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int cases = 1; cases <= n; cases++) {\n        memset(book, 0, sizeof(book));\n        LL a, b, k;\n        scanf(\"%lld %lld %lld\", &a, &b, &k);\n        for (int i = 0; i < k; i++) {\n            LL t;\n            scanf(\"%d\", &t);\n            book[t] = true;\n        }\n\n        for (int i = 0; ; i++) {\n            memset(ans, -1, sizeof(ans));\n            if (dfs(i,get_next(a, b), a, b, 0))\n                break;\n        }\n\n        printf(\"Case %d: %lld/%lld=\", cases, a, b);\n        for (int i = 0; ans[i] != -1; i++) {\n            if (i)\n                putchar('+');\n            printf(\"1/%lld\", ans[i]);\n        }\n        putchar('\\n');\n    }\n}\n\n```","slug":"12558-Egyptian-Fractions-HARD-version-（IDA-剪枝）","published":1,"updated":"2017-07-23T02:49:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n810001y9idx8oqqzfl","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4003\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4003</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>埃及分数问题，给定一个分数，用几个不相同的分数表示，有多个表示的话，用的分数越少越好，还是多解的话，最小的分数越大越好，然后第二小的分数越大越好……一直到最大的分数越大越好。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>见紫书分析</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<p>见紫书分析<br>代码已加入注释</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"></div><div class=\"line\">LL ans[<span class=\"number\">11234567</span>], tans[<span class=\"number\">11234567</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//book用来标记不可用作分母的数字，题目说小于1000，下面代码用到book的地方都是判断分母是否可用</span></div><div class=\"line\"><span class=\"keyword\">bool</span> book[<span class=\"number\">11234</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到一个结果后，如果比ans更优，那么更新</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">better</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = d; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[i] != tans[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> ans[i] == <span class=\"number\">-1</span> || tans[i] &lt; ans[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得下一个比 a/b 小的 1/c</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">get_next</span><span class=\"params\">(LL a, LL b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; ; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">10000</span> &amp;&amp; book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (b &lt;= a * i)</div><div class=\"line\">            <span class=\"keyword\">return</span> i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> max_deep, LL from, LL aa, LL bb, <span class=\"keyword\">int</span> deep)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果到达最大深度，那么需要判断下，然后return</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (deep == max_deep) &#123;</div><div class=\"line\">        <span class=\"comment\">//判断最后的状态是否为 1/c 的形式，如果不算，那么当前状态不可表示原分数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb % aa)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (bb &lt;= <span class=\"number\">10000</span> &amp;&amp; book[bb/aa])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        tans[deep] = bb/aa;</div><div class=\"line\">        <span class=\"comment\">//如果当前解更优，那么更新ans</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (better(deep))</div><div class=\"line\">            <span class=\"built_in\">memcpy</span>(ans, tans, <span class=\"keyword\">sizeof</span>(LL) * (deep+<span class=\"number\">1</span>));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">bool</span> ok = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//得到的 1/c 中 c 至少比上一次的分母大才可以 from 即是上一次的分母加一</span></div><div class=\"line\">    from = max(from, get_next(aa, bb));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = from; ; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">10000</span> &amp;&amp; book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果剩下的递归次数，都是用 1/i 还小于 aa/bb 的话，那么当前 i 和比 i 大的数字不能用来做分母</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb * (max_deep+<span class=\"number\">1</span>-deep) &lt;= i * aa)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        tans[deep] = i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算 aa/bb - 1/i，gcd 用来约分</span></div><div class=\"line\">        LL b2 = bb*i;</div><div class=\"line\">        LL a2 = aa*i - bb;</div><div class=\"line\">        LL g = __gcd(a2, b2);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dfs(max_deep, i+<span class=\"number\">1</span>, a2/g, b2/g, deep+<span class=\"number\">1</span>))</div><div class=\"line\">            ok = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ok;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= n; cases++) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        LL a, b, k;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld %lld\"</span>, &amp;a, &amp;b, &amp;k);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</div><div class=\"line\">            LL t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            book[t] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(ans, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i,get_next(a, b), a, b, <span class=\"number\">0</span>))</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld/%lld=\"</span>, cases, a, b);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ans[i] != <span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i)</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'+'</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"1/%lld\"</span>, ans[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4003\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4003</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>埃及分数问题，给定一个分数，用几个不相同的分数表示，有多个表示的话，用的分数越少越好，还是多解的话，最小的分数越大越好，然后第二小的分数越大越好……一直到最大的分数越大越好。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>见紫书分析</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<p>见紫书分析<br>代码已加入注释</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"></div><div class=\"line\">LL ans[<span class=\"number\">11234567</span>], tans[<span class=\"number\">11234567</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//book用来标记不可用作分母的数字，题目说小于1000，下面代码用到book的地方都是判断分母是否可用</span></div><div class=\"line\"><span class=\"keyword\">bool</span> book[<span class=\"number\">11234</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到一个结果后，如果比ans更优，那么更新</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">better</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = d; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[i] != tans[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> ans[i] == <span class=\"number\">-1</span> || tans[i] &lt; ans[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得下一个比 a/b 小的 1/c</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">get_next</span><span class=\"params\">(LL a, LL b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; ; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">10000</span> &amp;&amp; book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (b &lt;= a * i)</div><div class=\"line\">            <span class=\"keyword\">return</span> i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> max_deep, LL from, LL aa, LL bb, <span class=\"keyword\">int</span> deep)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果到达最大深度，那么需要判断下，然后return</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (deep == max_deep) &#123;</div><div class=\"line\">        <span class=\"comment\">//判断最后的状态是否为 1/c 的形式，如果不算，那么当前状态不可表示原分数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb % aa)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (bb &lt;= <span class=\"number\">10000</span> &amp;&amp; book[bb/aa])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        tans[deep] = bb/aa;</div><div class=\"line\">        <span class=\"comment\">//如果当前解更优，那么更新ans</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (better(deep))</div><div class=\"line\">            <span class=\"built_in\">memcpy</span>(ans, tans, <span class=\"keyword\">sizeof</span>(LL) * (deep+<span class=\"number\">1</span>));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">bool</span> ok = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//得到的 1/c 中 c 至少比上一次的分母大才可以 from 即是上一次的分母加一</span></div><div class=\"line\">    from = max(from, get_next(aa, bb));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = from; ; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">10000</span> &amp;&amp; book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果剩下的递归次数，都是用 1/i 还小于 aa/bb 的话，那么当前 i 和比 i 大的数字不能用来做分母</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb * (max_deep+<span class=\"number\">1</span>-deep) &lt;= i * aa)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        tans[deep] = i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算 aa/bb - 1/i，gcd 用来约分</span></div><div class=\"line\">        LL b2 = bb*i;</div><div class=\"line\">        LL a2 = aa*i - bb;</div><div class=\"line\">        LL g = __gcd(a2, b2);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dfs(max_deep, i+<span class=\"number\">1</span>, a2/g, b2/g, deep+<span class=\"number\">1</span>))</div><div class=\"line\">            ok = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ok;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= n; cases++) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        LL a, b, k;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld %lld\"</span>, &amp;a, &amp;b, &amp;k);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</div><div class=\"line\">            LL t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            book[t] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(ans, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i,get_next(a, b), a, b, <span class=\"number\">0</span>))</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld/%lld=\"</span>, cases, a, b);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ans[i] != <span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i)</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'+'</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"1/%lld\"</span>, ans[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"2-SAT问题（模板）","date":"2017-10-18T01:32:46.000Z","_content":"# 简介\n\n2-SAT （[2-satisfiability](https://en.wikipedia.org/wiki/2-satisfiability)）是描述一个这样的问题，有 n 个 bool 变量 $x_i$，并且有 m 个需要满足的条件，比如： \"$x_1$为真或$x_2$为假\"，“ $x_1$ 为真或$x_2$为真”之类的条件，这里”或“是指两个条件中至少有一个为真。SAT的问题是确定这 n 个变量的值，使得满足所有的条件。\n\n# 解法\n\n以下主要参考[Sengxian's Blog](https://blog.sengxian.com/algorithms/2-sat)和刘汝佳的白书。\n\n有一个比较容易理解的解法，首先将每一个变量当成两个图中的顶点，比如 $x_i$ 拆成 $2i$ 和 $2i + 1$ 两个节点，分表表示 $x_i$ 为假和真。比如标记了 $2i + 1$ 这个节点表示 $x_i$ 这个变量为真，如果标记了 $2i $ 则表示 $x_i$ 为假。\n\n对于 \"$x_i$ 为真或 $x_j$ 为假\"这个条件，我们添加一条 $2i$ 到 $2j$ 的边，表示如果 $x_i$ 为假的话，那么要使得条件成立 $x_j$ 一定要为假。另外同理也要添加一条 $2j + 1$ 到 $2i + 1$的边。注意上面的都是有向边，这里的边可以当做逻辑上的推导出的意思。\n\n这样根据上面建完图后，接下来逐一考虑没有标记的变量，设为 $x_i$。我们先假定它为假，然后标记节点 $2i$，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量所对应的两个节点都被标记了，则 \" $x_i$ 为假\" 这个假定不成立，需要改成 \" $x_i$ 为真\"，然后退回到标记 \" $x_i$ 为假\" 之前的状态，重新操作。注意，如果当前考虑的变量不管是真是假都会引起矛盾，可以证明整个 2-SAT 问题无解（即使调整以前赋值的其他变量都没用），所以这个算法是没有回溯过程的，这样最差的复杂度是 $O(N \\cdot M)$。\n\n其实对于 2-SAT 问题还 $O(M)$ 的算法，不过对于 2-SAT 问题一般是考的建图方式，不卡时间，这里给出几个链接：\n\n+  [http://blog.csdn.net/hqd_acm/article/details/5881655](http://blog.csdn.net/hqd_acm/article/details/5881655)\n+ [http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html](http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html)\n\n\n\n```cpp\nstruct TwoSat {\n    static const int MAX_NODE = 1000;\n    vector<int> G[MAX_NODE];\n    int n, stk[MAX_NODE], sz;\n    bool mark[MAX_NODE];\n\n    void init(int _n) {\n        n = _n;\n        for (int i = 0; i < n * 2; ++i) G[i].clear();\n        memset(mark, 0, sizeof(mark));\n    }\n\n    void addClause(int x, int xVal, int y, int yVal) {\n        x = x * 2 + xVal, y = y * 2 + yVal;\n        G[x ^ 1].push_back(y);\n        G[y ^ 1].push_back(x);\n    }\n\n    bool dfs(int x) {\n        if (mark[x ^ 1]) return false;\n        if (mark[x]) return true;\n        stk[sz++] = x;\n        mark[x] = true;\n        for (int i = 0; i < (int)G[x].size(); ++i)\n            if (!dfs(G[x][i])) return false;\n        return true;\n    }\n\n    bool solve() {\n        for (int i = 0; i < n * 2; i += 2)\n            if (!mark[i] && !mark[i ^ 1]) {\n                sz = 0;\n                if (!dfs(i)) {\n                    while (sz > 0) mark[stk[--sz]] = false;\n                    if (!dfs(i ^ 1)) return false;\n                }\n            }\n\n        return true;\n    }\n};\n```\n\n# 扩展\n\n上面描述的条件都只是 “或”，即是两个之中有一个成立，这里可以通过多个“或”条件的组合产生其他的逻辑条件。\n\n\n\n| 条件              | 转化                                       | 实现                                       |\n| --------------- | ---------------------------------------- | ---------------------------------------- |\n| $a=b$           | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  $ | add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n| $a \\neq b$      | $a \\vee b \\bigwedge \\lnot a \\vee \\lnot b$ | add_clause(a, 0, b, 0); add_clause(a, 1, b, 1); |\n| $a = b = true$  | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge a \\vee b$ | add_clause(a, 1, b, 1); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n| $a = b = false$ | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge \\lnot a \\vee  \\lnot b$ | add_clause(a, 0, b, 0); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n","source":"_posts/2-SAT问题（模板）.md","raw":"---\ntitle: 2-SAT问题（模板）\ndate: 2017-10-18 09:32:46\ncategories: [ACM, 图论, 2-SAT]\ntags:\n---\n# 简介\n\n2-SAT （[2-satisfiability](https://en.wikipedia.org/wiki/2-satisfiability)）是描述一个这样的问题，有 n 个 bool 变量 $x_i$，并且有 m 个需要满足的条件，比如： \"$x_1$为真或$x_2$为假\"，“ $x_1$ 为真或$x_2$为真”之类的条件，这里”或“是指两个条件中至少有一个为真。SAT的问题是确定这 n 个变量的值，使得满足所有的条件。\n\n# 解法\n\n以下主要参考[Sengxian's Blog](https://blog.sengxian.com/algorithms/2-sat)和刘汝佳的白书。\n\n有一个比较容易理解的解法，首先将每一个变量当成两个图中的顶点，比如 $x_i$ 拆成 $2i$ 和 $2i + 1$ 两个节点，分表表示 $x_i$ 为假和真。比如标记了 $2i + 1$ 这个节点表示 $x_i$ 这个变量为真，如果标记了 $2i $ 则表示 $x_i$ 为假。\n\n对于 \"$x_i$ 为真或 $x_j$ 为假\"这个条件，我们添加一条 $2i$ 到 $2j$ 的边，表示如果 $x_i$ 为假的话，那么要使得条件成立 $x_j$ 一定要为假。另外同理也要添加一条 $2j + 1$ 到 $2i + 1$的边。注意上面的都是有向边，这里的边可以当做逻辑上的推导出的意思。\n\n这样根据上面建完图后，接下来逐一考虑没有标记的变量，设为 $x_i$。我们先假定它为假，然后标记节点 $2i$，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量所对应的两个节点都被标记了，则 \" $x_i$ 为假\" 这个假定不成立，需要改成 \" $x_i$ 为真\"，然后退回到标记 \" $x_i$ 为假\" 之前的状态，重新操作。注意，如果当前考虑的变量不管是真是假都会引起矛盾，可以证明整个 2-SAT 问题无解（即使调整以前赋值的其他变量都没用），所以这个算法是没有回溯过程的，这样最差的复杂度是 $O(N \\cdot M)$。\n\n其实对于 2-SAT 问题还 $O(M)$ 的算法，不过对于 2-SAT 问题一般是考的建图方式，不卡时间，这里给出几个链接：\n\n+  [http://blog.csdn.net/hqd_acm/article/details/5881655](http://blog.csdn.net/hqd_acm/article/details/5881655)\n+ [http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html](http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html)\n\n\n\n```cpp\nstruct TwoSat {\n    static const int MAX_NODE = 1000;\n    vector<int> G[MAX_NODE];\n    int n, stk[MAX_NODE], sz;\n    bool mark[MAX_NODE];\n\n    void init(int _n) {\n        n = _n;\n        for (int i = 0; i < n * 2; ++i) G[i].clear();\n        memset(mark, 0, sizeof(mark));\n    }\n\n    void addClause(int x, int xVal, int y, int yVal) {\n        x = x * 2 + xVal, y = y * 2 + yVal;\n        G[x ^ 1].push_back(y);\n        G[y ^ 1].push_back(x);\n    }\n\n    bool dfs(int x) {\n        if (mark[x ^ 1]) return false;\n        if (mark[x]) return true;\n        stk[sz++] = x;\n        mark[x] = true;\n        for (int i = 0; i < (int)G[x].size(); ++i)\n            if (!dfs(G[x][i])) return false;\n        return true;\n    }\n\n    bool solve() {\n        for (int i = 0; i < n * 2; i += 2)\n            if (!mark[i] && !mark[i ^ 1]) {\n                sz = 0;\n                if (!dfs(i)) {\n                    while (sz > 0) mark[stk[--sz]] = false;\n                    if (!dfs(i ^ 1)) return false;\n                }\n            }\n\n        return true;\n    }\n};\n```\n\n# 扩展\n\n上面描述的条件都只是 “或”，即是两个之中有一个成立，这里可以通过多个“或”条件的组合产生其他的逻辑条件。\n\n\n\n| 条件              | 转化                                       | 实现                                       |\n| --------------- | ---------------------------------------- | ---------------------------------------- |\n| $a=b$           | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  $ | add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n| $a \\neq b$      | $a \\vee b \\bigwedge \\lnot a \\vee \\lnot b$ | add_clause(a, 0, b, 0); add_clause(a, 1, b, 1); |\n| $a = b = true$  | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge a \\vee b$ | add_clause(a, 1, b, 1); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n| $a = b = false$ | $a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge \\lnot a \\vee  \\lnot b$ | add_clause(a, 0, b, 0); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1); |\n","slug":"2-SAT问题（模板）","published":1,"updated":"2017-10-18T02:57:20.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n890002y9idtsby9075","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>2-SAT （<a href=\"https://en.wikipedia.org/wiki/2-satisfiability\" target=\"_blank\" rel=\"external\">2-satisfiability</a>）是描述一个这样的问题，有 n 个 bool 变量 $x_i$，并且有 m 个需要满足的条件，比如： “$x_1$为真或$x_2$为假”，“ $x_1$ 为真或$x_2$为真”之类的条件，这里”或“是指两个条件中至少有一个为真。SAT的问题是确定这 n 个变量的值，使得满足所有的条件。</p>\n<h1 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h1><p>以下主要参考<a href=\"https://blog.sengxian.com/algorithms/2-sat\" target=\"_blank\" rel=\"external\">Sengxian’s Blog</a>和刘汝佳的白书。</p>\n<p>有一个比较容易理解的解法，首先将每一个变量当成两个图中的顶点，比如 $x_i$ 拆成 $2i$ 和 $2i + 1$ 两个节点，分表表示 $x_i$ 为假和真。比如标记了 $2i + 1$ 这个节点表示 $x_i$ 这个变量为真，如果标记了 $2i $ 则表示 $x_i$ 为假。</p>\n<p>对于 “$x_i$ 为真或 $x_j$ 为假”这个条件，我们添加一条 $2i$ 到 $2j$ 的边，表示如果 $x_i$ 为假的话，那么要使得条件成立 $x_j$ 一定要为假。另外同理也要添加一条 $2j + 1$ 到 $2i + 1$的边。注意上面的都是有向边，这里的边可以当做逻辑上的推导出的意思。</p>\n<p>这样根据上面建完图后，接下来逐一考虑没有标记的变量，设为 $x_i$。我们先假定它为假，然后标记节点 $2i$，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量所对应的两个节点都被标记了，则 “ $x_i$ 为假” 这个假定不成立，需要改成 “ $x_i$ 为真”，然后退回到标记 “ $x_i$ 为假” 之前的状态，重新操作。注意，如果当前考虑的变量不管是真是假都会引起矛盾，可以证明整个 2-SAT 问题无解（即使调整以前赋值的其他变量都没用），所以这个算法是没有回溯过程的，这样最差的复杂度是 $O(N \\cdot M)$。</p>\n<p>其实对于 2-SAT 问题还 $O(M)$ 的算法，不过对于 2-SAT 问题一般是考的建图方式，不卡时间，这里给出几个链接：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/hqd_acm/article/details/5881655\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hqd_acm/article/details/5881655</a></li>\n<li><a href=\"http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html</a></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoSat</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_NODE = <span class=\"number\">1000</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX_NODE];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, stk[MAX_NODE], sz;</div><div class=\"line\">    <span class=\"keyword\">bool</span> mark[MAX_NODE];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span> </span>&#123;</div><div class=\"line\">        n = _n;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n * <span class=\"number\">2</span>; ++i) G[i].clear();</div><div class=\"line\">        <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addClause</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> xVal, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> yVal)</span> </span>&#123;</div><div class=\"line\">        x = x * <span class=\"number\">2</span> + xVal, y = y * <span class=\"number\">2</span> + yVal;</div><div class=\"line\">        G[x ^ <span class=\"number\">1</span>].push_back(y);</div><div class=\"line\">        G[y ^ <span class=\"number\">1</span>].push_back(x);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[x ^ <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[x]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        stk[sz++] = x;</div><div class=\"line\">        mark[x] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"keyword\">int</span>)G[x].size(); ++i)</div><div class=\"line\">            <span class=\"keyword\">if</span> (!dfs(G[x][i])) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n * <span class=\"number\">2</span>; i += <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">if</span> (!mark[i] &amp;&amp; !mark[i ^ <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                sz = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!dfs(i)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">while</span> (sz &gt; <span class=\"number\">0</span>) mark[stk[--sz]] = <span class=\"literal\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!dfs(i ^ <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><p>上面描述的条件都只是 “或”，即是两个之中有一个成立，这里可以通过多个“或”条件的组合产生其他的逻辑条件。</p>\n<table>\n<thead>\n<tr>\n<th>条件</th>\n<th>转化</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$a=b$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  $</td>\n<td>add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n<tr>\n<td>$a \\neq b$</td>\n<td>$a \\vee b \\bigwedge \\lnot a \\vee \\lnot b$</td>\n<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 1);</td>\n</tr>\n<tr>\n<td>$a = b = true$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge a \\vee b$</td>\n<td>add_clause(a, 1, b, 1); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n<tr>\n<td>$a = b = false$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge \\lnot a \\vee  \\lnot b$</td>\n<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>2-SAT （<a href=\"https://en.wikipedia.org/wiki/2-satisfiability\" target=\"_blank\" rel=\"external\">2-satisfiability</a>）是描述一个这样的问题，有 n 个 bool 变量 $x_i$，并且有 m 个需要满足的条件，比如： “$x_1$为真或$x_2$为假”，“ $x_1$ 为真或$x_2$为真”之类的条件，这里”或“是指两个条件中至少有一个为真。SAT的问题是确定这 n 个变量的值，使得满足所有的条件。</p>\n<h1 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h1><p>以下主要参考<a href=\"https://blog.sengxian.com/algorithms/2-sat\" target=\"_blank\" rel=\"external\">Sengxian’s Blog</a>和刘汝佳的白书。</p>\n<p>有一个比较容易理解的解法，首先将每一个变量当成两个图中的顶点，比如 $x_i$ 拆成 $2i$ 和 $2i + 1$ 两个节点，分表表示 $x_i$ 为假和真。比如标记了 $2i + 1$ 这个节点表示 $x_i$ 这个变量为真，如果标记了 $2i $ 则表示 $x_i$ 为假。</p>\n<p>对于 “$x_i$ 为真或 $x_j$ 为假”这个条件，我们添加一条 $2i$ 到 $2j$ 的边，表示如果 $x_i$ 为假的话，那么要使得条件成立 $x_j$ 一定要为假。另外同理也要添加一条 $2j + 1$ 到 $2i + 1$的边。注意上面的都是有向边，这里的边可以当做逻辑上的推导出的意思。</p>\n<p>这样根据上面建完图后，接下来逐一考虑没有标记的变量，设为 $x_i$。我们先假定它为假，然后标记节点 $2i$，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量所对应的两个节点都被标记了，则 “ $x_i$ 为假” 这个假定不成立，需要改成 “ $x_i$ 为真”，然后退回到标记 “ $x_i$ 为假” 之前的状态，重新操作。注意，如果当前考虑的变量不管是真是假都会引起矛盾，可以证明整个 2-SAT 问题无解（即使调整以前赋值的其他变量都没用），所以这个算法是没有回溯过程的，这样最差的复杂度是 $O(N \\cdot M)$。</p>\n<p>其实对于 2-SAT 问题还 $O(M)$ 的算法，不过对于 2-SAT 问题一般是考的建图方式，不卡时间，这里给出几个链接：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/hqd_acm/article/details/5881655\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hqd_acm/article/details/5881655</a></li>\n<li><a href=\"http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html</a></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TwoSat</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_NODE = <span class=\"number\">1000</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX_NODE];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, stk[MAX_NODE], sz;</div><div class=\"line\">    <span class=\"keyword\">bool</span> mark[MAX_NODE];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span> </span>&#123;</div><div class=\"line\">        n = _n;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n * <span class=\"number\">2</span>; ++i) G[i].clear();</div><div class=\"line\">        <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addClause</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> xVal, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> yVal)</span> </span>&#123;</div><div class=\"line\">        x = x * <span class=\"number\">2</span> + xVal, y = y * <span class=\"number\">2</span> + yVal;</div><div class=\"line\">        G[x ^ <span class=\"number\">1</span>].push_back(y);</div><div class=\"line\">        G[y ^ <span class=\"number\">1</span>].push_back(x);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[x ^ <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[x]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        stk[sz++] = x;</div><div class=\"line\">        mark[x] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"keyword\">int</span>)G[x].size(); ++i)</div><div class=\"line\">            <span class=\"keyword\">if</span> (!dfs(G[x][i])) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n * <span class=\"number\">2</span>; i += <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">if</span> (!mark[i] &amp;&amp; !mark[i ^ <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                sz = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!dfs(i)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">while</span> (sz &gt; <span class=\"number\">0</span>) mark[stk[--sz]] = <span class=\"literal\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!dfs(i ^ <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><p>上面描述的条件都只是 “或”，即是两个之中有一个成立，这里可以通过多个“或”条件的组合产生其他的逻辑条件。</p>\n<table>\n<thead>\n<tr>\n<th>条件</th>\n<th>转化</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$a=b$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  $</td>\n<td>add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n<tr>\n<td>$a \\neq b$</td>\n<td>$a \\vee b \\bigwedge \\lnot a \\vee \\lnot b$</td>\n<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 1);</td>\n</tr>\n<tr>\n<td>$a = b = true$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge a \\vee b$</td>\n<td>add_clause(a, 1, b, 1); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n<tr>\n<td>$a = b = false$</td>\n<td>$a \\vee \\lnot b \\bigwedge \\lnot a \\vee b  \\bigwedge \\lnot a \\vee  \\lnot b$</td>\n<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"2016年寒假集训","date":"2017-02-26T10:30:55.000Z","_content":"# 一、时间内容\n2017年寒假，在学校ACM集训队开始了为期一个月的集训，感觉收获颇多，于是写这篇文章以来记录。\n\n在这四周里，每周都有训练计划，每天周一至周六，从早上8:00至晚上21:30，差不多整天面对屏幕了，虽然坐在实验室看了一天屏幕，累的腰酸眼疼，但是得到收获让我感觉这些付出都值得。每周末都有一次测试赛，还有为了缓解同学们的压力而开展的集体活动。总的来说这个寒假在集训队里的生活是充实愉快的。\n\n# 二、体验与经历\n接下来写下在集训中的具体体会和经历好了，由于我是中外专业的，结束考试比较早，于是集训早开始三四天，由于考试完整个人太怠惰了，结果集训第一天的时候就迟到了，正好还赶上是分组赛，感觉非常可惜，浪费了一次比赛的机会，并且在一开始就没有跟上集训的步伐。\n\n于是主动和老师道了歉，下午就去实验室和同学一起正常参加集训了，正好在昨天在实验室里同学找到了一个有意思的题，于是下午就在研究这个。刚开始用深度优先搜索推，于是超时，后来改用动态规划，结果推不出来状态转移方程，后来又想了想才发现是一个简单的广度优先搜索。于是就去敲了代码去交一遍试试，一次Accepted，于是就去告诉了同学思路，成就感满满。\n\n然后OJ开了集训的训练专题，之前在《算法竞赛入门经典》里刷过了数据结构和C++的STL，于是刷起来很顺利，一天大概就刷了一半的水题，结果正式集训之前，就差不多完成了所有的题目，然后集训的时候，每天自己只是在补一两道题，于是整个训练都很轻松。在这里我也差不多算是找到了适合自己的学习方法，就是在正式学习，听老师讲课和做题训练，直接先把内容过一遍，因为发现自己更适合直接找一本合适的教材去看书。之前上高数的时候也印证了这一点，每次上课如果没自己看书的话，完全不知道老师所云，之后由于没听懂老师的讲课，于是自己去刷了一遍高数书，结果用了一两个小时过完了老师三四节课的内容，顺便预习了以后的一点内容，然后又上课的时候，发现老师讲的内容就很简单了，最是遇到不太懂的地方补一下就好了。\n\n于是利用这个集训中找到的适合直接的方法去用到下一个学期，在上课和集训之前把内容都自己过一遍。\n\n之后正式开始集训后就进行了分组赛，所幸成绩不错，比赛也算是获得成就感和动力的一个地方了，最后实验室的位置安排和旁边的两个巨巨一组。于是正式的集训就开始了，因为之前刷完了所有的题目，于是只是在刷《算法竞赛入门经典》这一本书，据说是比较难（自己也深有体会TAT），自己也算是从开始到现在坚持下来刷紫书了，收获真的是非常大，书中的一道题，作者就讲了许多的做法，比如一道状态搜索的题，通常做法是暴力广度优先搜索，正好在训练迭代加深搜索，作者也给出了这个的思路，另外还提及了双向广度优先搜索和A*算法。另外就是书中的题好多都是经典题，这里引用一下某位dalao的“刷题哲学”：所谓的经典题就那些，刷完一道少一道。有种很人动力的感觉。由于是经典题网上可以收到很多blog，直接敲完一遍代码后再去翻blog，能学到不少的新知识，之前一道题我暴力模拟写了200行代码，结果搜了下blog，别人开数组映射了一下，代码量直接缩到了100行，顿时感觉非常惊艳，于是赶快对着敲了一遍学习了一下。总的来说这本书真的是一本好书，最近一个月的新知识感觉并不是通过集训，而且自己刷这本书得到的。可能是我比较适合自己去看书刷题吧。\n\n另外不只是算法，由于实验室的学习氛围非常好，自己空闲的时间也学了一些其他的东西，诸如HTML、TCP/IP，Python爬虫之类的，大体上向着互联网的方向上学习的，并且自己开了一台服务器，用Python写了个Web程序，放在服务器上搭了个网页。另外越来越习惯Linux的环境了，现在电脑也是双系统，主要使用Linux，除了用些Linux平台没有的软件，基本上只是在用Linux了。另外由于下学期有Java外教课，直接过了一遍Java的课程，大概把面向对象的知识简单过了一遍。\n\n后来的许多天都是日复一日的训练了，虽说每天的收获都非常多，但是想了想并没有什么值得写的，感觉记忆深刻点的还是比赛吧，最后一场的测试赛现在还是记忆犹新。\n\n原本只是一场普通的测试赛来着，老师突然要求改成组队赛，为了适应不久就要到来的天梯赛（这里以后讲一下），于是就按之前比赛的排名平均权重随机分配了一下。结果运气好匹配到的两个队友也比较给力，出来分配名单后就和他们讨论了一下，讨论下如何分配任务。最后结果是我负责敲代码，另一个队友负责想思路，和帮我一起看代码，另外一个专门负责翻译英文题，没办法讨论的时候发现我们英语都不是很好2333。\n\n比赛第一题是一道英文题，于是直接跳过，让队友去翻译了。然后我和另一个队友去看了第B题，我看了许久没思路，感觉负责敲代码的不能闲着，要一直有思路敲代码才行，于是让队友继续去看这道题，我去看了下C题。看了下是很简单的水题，于是敲了下来，幸好没有立即交上，叫来了队友看了下，结果有一个坑点，判断下左右边界，于是交上去AC了。这时翻译英文题的队友过来了，告诉我了下A题的题意，但是我还是纠结B题于是没打算敲A题。但是这时B题还是没思路，于是我把翻译英文题的队友叫来，一起敲完了A题，两个人检查了一遍，一次AC。无奈这时B题还是没思路，刚开始我的思路是直接暴力嵌套循环的，算了下时间复杂度果断超时，但是可以打一下表，于是打表出来让两个队友去找规律了。这时队友告诉我D题是一个暴力DFS的题，让我去敲，我看了下，刚好之前刷紫书做到过，于是照着敲了下来，过了几组数据一次AC。这时两个队友突然发现B题的递推规律，果断敲了代码，对比了下之前暴力打表的数据，完全符合，交上去，一次AC。这时我也看了下E题，是一个博弈题，看了下没思路，于是让两个队友都去看了，这时我发现F题就是一个无向图的最短路，于是很快就敲了出来，测了下样例交上去一次AC。然后两个给力的队友找到E题的规律了，就是一个if语句就可以解决的题，写了没几行的代码交上去A掉了。这时只剩下H题一个英文题和G题，这时队友已经把所有的题翻译完了。我看了下G题没思路，于是让队友告诉我了下H题的题意，发现是一个麻烦的模拟题，于是让他们去看G题，我去敲H题的代码，大概敲了半个小时，只是一个处理起来麻烦的题，思路不难想，然后敲完过了下样例，没想到交上去居然AC掉了。这时回过头来三个人一起想G题，刚开始我觉得是贪心，后来感觉是动态规划，最后觉得可能是二分递归分治，最后按分治敲了下代码，样例还没过比赛就结束了。\n\n剩下值得记录的就是结训了，最后结训赛，自己已经放弃治疗了，没想到还能水到一个奖品，最后老师讲了下自己寒假的经历，做了下总结，学长（长者）们也上台给我们讲（传授）了下学习方法（人生经验），总的来说过程是非常欢快的，QAQ巨是真的萌，最后要每个专业自荐一个代表讲讲话，然后某学长叫了我的名字2333，于是大概推荐了下紫书，和自己上面所说的学习方法，最后大家一起合影，寒假集训愉快的结束了～\n\n# 三、一些感悟\n之前刘老师也单独找过我谈过话，我当时说过，我当初上小学的时候，只喜欢打游戏，学习只是感兴趣学一下数学，实在是不想继续上初中了。然后是初中，每天浑浑噩噩的学习只是学一下感兴趣的课程，考试得到点成就感，根本没想着继续去上高中。直到后来开设化学和物理，发现原来世界上还有这么有意思的东西，感觉自己如果不了解的话多可惜啊。于是当初中考也只是考了个比较差的民办高中。在高中时追随初中的想法，读了一些物理科普书和名著小说，于是愈加的想要一个更高的平台，去了解更多这样有趣的知识。\n\n然后大学我想继续追随这个想法，开学之前自己其实就搜索了许多ACM相关的资料，于是加入了ACM。\n\n确实ACM这个平台也没辜负我的期望，让我见到了许许多多的dalao，在这个算是不大的圈子里，可以直接和整个中国最优秀的ACMer交流，可以把他们当做自己追赶的目标。另外算法也满足了我对知识的欲望，每次学到一个新算法都是成就感满满，当自己刚学会DFS解决数独问题和迷宫问题时，当自己和队友一起AC掉题时真心感到快乐。\n\n这里借用一下某个ACMer的话：我并不了解人生，也不愿去臆测未来，我只知道一道题WA很久之后突然Accepted的感觉简直妙不可言！\n\n\n\n\n\n# 尾巴\n\n其实这时当时写的寒假的社会实践，挺有纪念意义的，以后的也一起放出来好了。","source":"_posts/2016年寒假集训.md","raw":"---\ntitle: 2016年寒假集训\ndate: 2017-02-26 18:30:55\ncategories: [历程]\ntags:\n---\n# 一、时间内容\n2017年寒假，在学校ACM集训队开始了为期一个月的集训，感觉收获颇多，于是写这篇文章以来记录。\n\n在这四周里，每周都有训练计划，每天周一至周六，从早上8:00至晚上21:30，差不多整天面对屏幕了，虽然坐在实验室看了一天屏幕，累的腰酸眼疼，但是得到收获让我感觉这些付出都值得。每周末都有一次测试赛，还有为了缓解同学们的压力而开展的集体活动。总的来说这个寒假在集训队里的生活是充实愉快的。\n\n# 二、体验与经历\n接下来写下在集训中的具体体会和经历好了，由于我是中外专业的，结束考试比较早，于是集训早开始三四天，由于考试完整个人太怠惰了，结果集训第一天的时候就迟到了，正好还赶上是分组赛，感觉非常可惜，浪费了一次比赛的机会，并且在一开始就没有跟上集训的步伐。\n\n于是主动和老师道了歉，下午就去实验室和同学一起正常参加集训了，正好在昨天在实验室里同学找到了一个有意思的题，于是下午就在研究这个。刚开始用深度优先搜索推，于是超时，后来改用动态规划，结果推不出来状态转移方程，后来又想了想才发现是一个简单的广度优先搜索。于是就去敲了代码去交一遍试试，一次Accepted，于是就去告诉了同学思路，成就感满满。\n\n然后OJ开了集训的训练专题，之前在《算法竞赛入门经典》里刷过了数据结构和C++的STL，于是刷起来很顺利，一天大概就刷了一半的水题，结果正式集训之前，就差不多完成了所有的题目，然后集训的时候，每天自己只是在补一两道题，于是整个训练都很轻松。在这里我也差不多算是找到了适合自己的学习方法，就是在正式学习，听老师讲课和做题训练，直接先把内容过一遍，因为发现自己更适合直接找一本合适的教材去看书。之前上高数的时候也印证了这一点，每次上课如果没自己看书的话，完全不知道老师所云，之后由于没听懂老师的讲课，于是自己去刷了一遍高数书，结果用了一两个小时过完了老师三四节课的内容，顺便预习了以后的一点内容，然后又上课的时候，发现老师讲的内容就很简单了，最是遇到不太懂的地方补一下就好了。\n\n于是利用这个集训中找到的适合直接的方法去用到下一个学期，在上课和集训之前把内容都自己过一遍。\n\n之后正式开始集训后就进行了分组赛，所幸成绩不错，比赛也算是获得成就感和动力的一个地方了，最后实验室的位置安排和旁边的两个巨巨一组。于是正式的集训就开始了，因为之前刷完了所有的题目，于是只是在刷《算法竞赛入门经典》这一本书，据说是比较难（自己也深有体会TAT），自己也算是从开始到现在坚持下来刷紫书了，收获真的是非常大，书中的一道题，作者就讲了许多的做法，比如一道状态搜索的题，通常做法是暴力广度优先搜索，正好在训练迭代加深搜索，作者也给出了这个的思路，另外还提及了双向广度优先搜索和A*算法。另外就是书中的题好多都是经典题，这里引用一下某位dalao的“刷题哲学”：所谓的经典题就那些，刷完一道少一道。有种很人动力的感觉。由于是经典题网上可以收到很多blog，直接敲完一遍代码后再去翻blog，能学到不少的新知识，之前一道题我暴力模拟写了200行代码，结果搜了下blog，别人开数组映射了一下，代码量直接缩到了100行，顿时感觉非常惊艳，于是赶快对着敲了一遍学习了一下。总的来说这本书真的是一本好书，最近一个月的新知识感觉并不是通过集训，而且自己刷这本书得到的。可能是我比较适合自己去看书刷题吧。\n\n另外不只是算法，由于实验室的学习氛围非常好，自己空闲的时间也学了一些其他的东西，诸如HTML、TCP/IP，Python爬虫之类的，大体上向着互联网的方向上学习的，并且自己开了一台服务器，用Python写了个Web程序，放在服务器上搭了个网页。另外越来越习惯Linux的环境了，现在电脑也是双系统，主要使用Linux，除了用些Linux平台没有的软件，基本上只是在用Linux了。另外由于下学期有Java外教课，直接过了一遍Java的课程，大概把面向对象的知识简单过了一遍。\n\n后来的许多天都是日复一日的训练了，虽说每天的收获都非常多，但是想了想并没有什么值得写的，感觉记忆深刻点的还是比赛吧，最后一场的测试赛现在还是记忆犹新。\n\n原本只是一场普通的测试赛来着，老师突然要求改成组队赛，为了适应不久就要到来的天梯赛（这里以后讲一下），于是就按之前比赛的排名平均权重随机分配了一下。结果运气好匹配到的两个队友也比较给力，出来分配名单后就和他们讨论了一下，讨论下如何分配任务。最后结果是我负责敲代码，另一个队友负责想思路，和帮我一起看代码，另外一个专门负责翻译英文题，没办法讨论的时候发现我们英语都不是很好2333。\n\n比赛第一题是一道英文题，于是直接跳过，让队友去翻译了。然后我和另一个队友去看了第B题，我看了许久没思路，感觉负责敲代码的不能闲着，要一直有思路敲代码才行，于是让队友继续去看这道题，我去看了下C题。看了下是很简单的水题，于是敲了下来，幸好没有立即交上，叫来了队友看了下，结果有一个坑点，判断下左右边界，于是交上去AC了。这时翻译英文题的队友过来了，告诉我了下A题的题意，但是我还是纠结B题于是没打算敲A题。但是这时B题还是没思路，于是我把翻译英文题的队友叫来，一起敲完了A题，两个人检查了一遍，一次AC。无奈这时B题还是没思路，刚开始我的思路是直接暴力嵌套循环的，算了下时间复杂度果断超时，但是可以打一下表，于是打表出来让两个队友去找规律了。这时队友告诉我D题是一个暴力DFS的题，让我去敲，我看了下，刚好之前刷紫书做到过，于是照着敲了下来，过了几组数据一次AC。这时两个队友突然发现B题的递推规律，果断敲了代码，对比了下之前暴力打表的数据，完全符合，交上去，一次AC。这时我也看了下E题，是一个博弈题，看了下没思路，于是让两个队友都去看了，这时我发现F题就是一个无向图的最短路，于是很快就敲了出来，测了下样例交上去一次AC。然后两个给力的队友找到E题的规律了，就是一个if语句就可以解决的题，写了没几行的代码交上去A掉了。这时只剩下H题一个英文题和G题，这时队友已经把所有的题翻译完了。我看了下G题没思路，于是让队友告诉我了下H题的题意，发现是一个麻烦的模拟题，于是让他们去看G题，我去敲H题的代码，大概敲了半个小时，只是一个处理起来麻烦的题，思路不难想，然后敲完过了下样例，没想到交上去居然AC掉了。这时回过头来三个人一起想G题，刚开始我觉得是贪心，后来感觉是动态规划，最后觉得可能是二分递归分治，最后按分治敲了下代码，样例还没过比赛就结束了。\n\n剩下值得记录的就是结训了，最后结训赛，自己已经放弃治疗了，没想到还能水到一个奖品，最后老师讲了下自己寒假的经历，做了下总结，学长（长者）们也上台给我们讲（传授）了下学习方法（人生经验），总的来说过程是非常欢快的，QAQ巨是真的萌，最后要每个专业自荐一个代表讲讲话，然后某学长叫了我的名字2333，于是大概推荐了下紫书，和自己上面所说的学习方法，最后大家一起合影，寒假集训愉快的结束了～\n\n# 三、一些感悟\n之前刘老师也单独找过我谈过话，我当时说过，我当初上小学的时候，只喜欢打游戏，学习只是感兴趣学一下数学，实在是不想继续上初中了。然后是初中，每天浑浑噩噩的学习只是学一下感兴趣的课程，考试得到点成就感，根本没想着继续去上高中。直到后来开设化学和物理，发现原来世界上还有这么有意思的东西，感觉自己如果不了解的话多可惜啊。于是当初中考也只是考了个比较差的民办高中。在高中时追随初中的想法，读了一些物理科普书和名著小说，于是愈加的想要一个更高的平台，去了解更多这样有趣的知识。\n\n然后大学我想继续追随这个想法，开学之前自己其实就搜索了许多ACM相关的资料，于是加入了ACM。\n\n确实ACM这个平台也没辜负我的期望，让我见到了许许多多的dalao，在这个算是不大的圈子里，可以直接和整个中国最优秀的ACMer交流，可以把他们当做自己追赶的目标。另外算法也满足了我对知识的欲望，每次学到一个新算法都是成就感满满，当自己刚学会DFS解决数独问题和迷宫问题时，当自己和队友一起AC掉题时真心感到快乐。\n\n这里借用一下某个ACMer的话：我并不了解人生，也不愿去臆测未来，我只知道一道题WA很久之后突然Accepted的感觉简直妙不可言！\n\n\n\n\n\n# 尾巴\n\n其实这时当时写的寒假的社会实践，挺有纪念意义的，以后的也一起放出来好了。","slug":"2016年寒假集训","published":1,"updated":"2017-08-28T10:35:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n8m0004y9idfef4afut","content":"<h1 id=\"一、时间内容\"><a href=\"#一、时间内容\" class=\"headerlink\" title=\"一、时间内容\"></a>一、时间内容</h1><p>2017年寒假，在学校ACM集训队开始了为期一个月的集训，感觉收获颇多，于是写这篇文章以来记录。</p>\n<p>在这四周里，每周都有训练计划，每天周一至周六，从早上8:00至晚上21:30，差不多整天面对屏幕了，虽然坐在实验室看了一天屏幕，累的腰酸眼疼，但是得到收获让我感觉这些付出都值得。每周末都有一次测试赛，还有为了缓解同学们的压力而开展的集体活动。总的来说这个寒假在集训队里的生活是充实愉快的。</p>\n<h1 id=\"二、体验与经历\"><a href=\"#二、体验与经历\" class=\"headerlink\" title=\"二、体验与经历\"></a>二、体验与经历</h1><p>接下来写下在集训中的具体体会和经历好了，由于我是中外专业的，结束考试比较早，于是集训早开始三四天，由于考试完整个人太怠惰了，结果集训第一天的时候就迟到了，正好还赶上是分组赛，感觉非常可惜，浪费了一次比赛的机会，并且在一开始就没有跟上集训的步伐。</p>\n<p>于是主动和老师道了歉，下午就去实验室和同学一起正常参加集训了，正好在昨天在实验室里同学找到了一个有意思的题，于是下午就在研究这个。刚开始用深度优先搜索推，于是超时，后来改用动态规划，结果推不出来状态转移方程，后来又想了想才发现是一个简单的广度优先搜索。于是就去敲了代码去交一遍试试，一次Accepted，于是就去告诉了同学思路，成就感满满。</p>\n<p>然后OJ开了集训的训练专题，之前在《算法竞赛入门经典》里刷过了数据结构和C++的STL，于是刷起来很顺利，一天大概就刷了一半的水题，结果正式集训之前，就差不多完成了所有的题目，然后集训的时候，每天自己只是在补一两道题，于是整个训练都很轻松。在这里我也差不多算是找到了适合自己的学习方法，就是在正式学习，听老师讲课和做题训练，直接先把内容过一遍，因为发现自己更适合直接找一本合适的教材去看书。之前上高数的时候也印证了这一点，每次上课如果没自己看书的话，完全不知道老师所云，之后由于没听懂老师的讲课，于是自己去刷了一遍高数书，结果用了一两个小时过完了老师三四节课的内容，顺便预习了以后的一点内容，然后又上课的时候，发现老师讲的内容就很简单了，最是遇到不太懂的地方补一下就好了。</p>\n<p>于是利用这个集训中找到的适合直接的方法去用到下一个学期，在上课和集训之前把内容都自己过一遍。</p>\n<p>之后正式开始集训后就进行了分组赛，所幸成绩不错，比赛也算是获得成就感和动力的一个地方了，最后实验室的位置安排和旁边的两个巨巨一组。于是正式的集训就开始了，因为之前刷完了所有的题目，于是只是在刷《算法竞赛入门经典》这一本书，据说是比较难（自己也深有体会TAT），自己也算是从开始到现在坚持下来刷紫书了，收获真的是非常大，书中的一道题，作者就讲了许多的做法，比如一道状态搜索的题，通常做法是暴力广度优先搜索，正好在训练迭代加深搜索，作者也给出了这个的思路，另外还提及了双向广度优先搜索和A*算法。另外就是书中的题好多都是经典题，这里引用一下某位dalao的“刷题哲学”：所谓的经典题就那些，刷完一道少一道。有种很人动力的感觉。由于是经典题网上可以收到很多blog，直接敲完一遍代码后再去翻blog，能学到不少的新知识，之前一道题我暴力模拟写了200行代码，结果搜了下blog，别人开数组映射了一下，代码量直接缩到了100行，顿时感觉非常惊艳，于是赶快对着敲了一遍学习了一下。总的来说这本书真的是一本好书，最近一个月的新知识感觉并不是通过集训，而且自己刷这本书得到的。可能是我比较适合自己去看书刷题吧。</p>\n<p>另外不只是算法，由于实验室的学习氛围非常好，自己空闲的时间也学了一些其他的东西，诸如HTML、TCP/IP，Python爬虫之类的，大体上向着互联网的方向上学习的，并且自己开了一台服务器，用Python写了个Web程序，放在服务器上搭了个网页。另外越来越习惯Linux的环境了，现在电脑也是双系统，主要使用Linux，除了用些Linux平台没有的软件，基本上只是在用Linux了。另外由于下学期有Java外教课，直接过了一遍Java的课程，大概把面向对象的知识简单过了一遍。</p>\n<p>后来的许多天都是日复一日的训练了，虽说每天的收获都非常多，但是想了想并没有什么值得写的，感觉记忆深刻点的还是比赛吧，最后一场的测试赛现在还是记忆犹新。</p>\n<p>原本只是一场普通的测试赛来着，老师突然要求改成组队赛，为了适应不久就要到来的天梯赛（这里以后讲一下），于是就按之前比赛的排名平均权重随机分配了一下。结果运气好匹配到的两个队友也比较给力，出来分配名单后就和他们讨论了一下，讨论下如何分配任务。最后结果是我负责敲代码，另一个队友负责想思路，和帮我一起看代码，另外一个专门负责翻译英文题，没办法讨论的时候发现我们英语都不是很好2333。</p>\n<p>比赛第一题是一道英文题，于是直接跳过，让队友去翻译了。然后我和另一个队友去看了第B题，我看了许久没思路，感觉负责敲代码的不能闲着，要一直有思路敲代码才行，于是让队友继续去看这道题，我去看了下C题。看了下是很简单的水题，于是敲了下来，幸好没有立即交上，叫来了队友看了下，结果有一个坑点，判断下左右边界，于是交上去AC了。这时翻译英文题的队友过来了，告诉我了下A题的题意，但是我还是纠结B题于是没打算敲A题。但是这时B题还是没思路，于是我把翻译英文题的队友叫来，一起敲完了A题，两个人检查了一遍，一次AC。无奈这时B题还是没思路，刚开始我的思路是直接暴力嵌套循环的，算了下时间复杂度果断超时，但是可以打一下表，于是打表出来让两个队友去找规律了。这时队友告诉我D题是一个暴力DFS的题，让我去敲，我看了下，刚好之前刷紫书做到过，于是照着敲了下来，过了几组数据一次AC。这时两个队友突然发现B题的递推规律，果断敲了代码，对比了下之前暴力打表的数据，完全符合，交上去，一次AC。这时我也看了下E题，是一个博弈题，看了下没思路，于是让两个队友都去看了，这时我发现F题就是一个无向图的最短路，于是很快就敲了出来，测了下样例交上去一次AC。然后两个给力的队友找到E题的规律了，就是一个if语句就可以解决的题，写了没几行的代码交上去A掉了。这时只剩下H题一个英文题和G题，这时队友已经把所有的题翻译完了。我看了下G题没思路，于是让队友告诉我了下H题的题意，发现是一个麻烦的模拟题，于是让他们去看G题，我去敲H题的代码，大概敲了半个小时，只是一个处理起来麻烦的题，思路不难想，然后敲完过了下样例，没想到交上去居然AC掉了。这时回过头来三个人一起想G题，刚开始我觉得是贪心，后来感觉是动态规划，最后觉得可能是二分递归分治，最后按分治敲了下代码，样例还没过比赛就结束了。</p>\n<p>剩下值得记录的就是结训了，最后结训赛，自己已经放弃治疗了，没想到还能水到一个奖品，最后老师讲了下自己寒假的经历，做了下总结，学长（长者）们也上台给我们讲（传授）了下学习方法（人生经验），总的来说过程是非常欢快的，QAQ巨是真的萌，最后要每个专业自荐一个代表讲讲话，然后某学长叫了我的名字2333，于是大概推荐了下紫书，和自己上面所说的学习方法，最后大家一起合影，寒假集训愉快的结束了～</p>\n<h1 id=\"三、一些感悟\"><a href=\"#三、一些感悟\" class=\"headerlink\" title=\"三、一些感悟\"></a>三、一些感悟</h1><p>之前刘老师也单独找过我谈过话，我当时说过，我当初上小学的时候，只喜欢打游戏，学习只是感兴趣学一下数学，实在是不想继续上初中了。然后是初中，每天浑浑噩噩的学习只是学一下感兴趣的课程，考试得到点成就感，根本没想着继续去上高中。直到后来开设化学和物理，发现原来世界上还有这么有意思的东西，感觉自己如果不了解的话多可惜啊。于是当初中考也只是考了个比较差的民办高中。在高中时追随初中的想法，读了一些物理科普书和名著小说，于是愈加的想要一个更高的平台，去了解更多这样有趣的知识。</p>\n<p>然后大学我想继续追随这个想法，开学之前自己其实就搜索了许多ACM相关的资料，于是加入了ACM。</p>\n<p>确实ACM这个平台也没辜负我的期望，让我见到了许许多多的dalao，在这个算是不大的圈子里，可以直接和整个中国最优秀的ACMer交流，可以把他们当做自己追赶的目标。另外算法也满足了我对知识的欲望，每次学到一个新算法都是成就感满满，当自己刚学会DFS解决数独问题和迷宫问题时，当自己和队友一起AC掉题时真心感到快乐。</p>\n<p>这里借用一下某个ACMer的话：我并不了解人生，也不愿去臆测未来，我只知道一道题WA很久之后突然Accepted的感觉简直妙不可言！</p>\n<h1 id=\"尾巴\"><a href=\"#尾巴\" class=\"headerlink\" title=\"尾巴\"></a>尾巴</h1><p>其实这时当时写的寒假的社会实践，挺有纪念意义的，以后的也一起放出来好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、时间内容\"><a href=\"#一、时间内容\" class=\"headerlink\" title=\"一、时间内容\"></a>一、时间内容</h1><p>2017年寒假，在学校ACM集训队开始了为期一个月的集训，感觉收获颇多，于是写这篇文章以来记录。</p>\n<p>在这四周里，每周都有训练计划，每天周一至周六，从早上8:00至晚上21:30，差不多整天面对屏幕了，虽然坐在实验室看了一天屏幕，累的腰酸眼疼，但是得到收获让我感觉这些付出都值得。每周末都有一次测试赛，还有为了缓解同学们的压力而开展的集体活动。总的来说这个寒假在集训队里的生活是充实愉快的。</p>\n<h1 id=\"二、体验与经历\"><a href=\"#二、体验与经历\" class=\"headerlink\" title=\"二、体验与经历\"></a>二、体验与经历</h1><p>接下来写下在集训中的具体体会和经历好了，由于我是中外专业的，结束考试比较早，于是集训早开始三四天，由于考试完整个人太怠惰了，结果集训第一天的时候就迟到了，正好还赶上是分组赛，感觉非常可惜，浪费了一次比赛的机会，并且在一开始就没有跟上集训的步伐。</p>\n<p>于是主动和老师道了歉，下午就去实验室和同学一起正常参加集训了，正好在昨天在实验室里同学找到了一个有意思的题，于是下午就在研究这个。刚开始用深度优先搜索推，于是超时，后来改用动态规划，结果推不出来状态转移方程，后来又想了想才发现是一个简单的广度优先搜索。于是就去敲了代码去交一遍试试，一次Accepted，于是就去告诉了同学思路，成就感满满。</p>\n<p>然后OJ开了集训的训练专题，之前在《算法竞赛入门经典》里刷过了数据结构和C++的STL，于是刷起来很顺利，一天大概就刷了一半的水题，结果正式集训之前，就差不多完成了所有的题目，然后集训的时候，每天自己只是在补一两道题，于是整个训练都很轻松。在这里我也差不多算是找到了适合自己的学习方法，就是在正式学习，听老师讲课和做题训练，直接先把内容过一遍，因为发现自己更适合直接找一本合适的教材去看书。之前上高数的时候也印证了这一点，每次上课如果没自己看书的话，完全不知道老师所云，之后由于没听懂老师的讲课，于是自己去刷了一遍高数书，结果用了一两个小时过完了老师三四节课的内容，顺便预习了以后的一点内容，然后又上课的时候，发现老师讲的内容就很简单了，最是遇到不太懂的地方补一下就好了。</p>\n<p>于是利用这个集训中找到的适合直接的方法去用到下一个学期，在上课和集训之前把内容都自己过一遍。</p>\n<p>之后正式开始集训后就进行了分组赛，所幸成绩不错，比赛也算是获得成就感和动力的一个地方了，最后实验室的位置安排和旁边的两个巨巨一组。于是正式的集训就开始了，因为之前刷完了所有的题目，于是只是在刷《算法竞赛入门经典》这一本书，据说是比较难（自己也深有体会TAT），自己也算是从开始到现在坚持下来刷紫书了，收获真的是非常大，书中的一道题，作者就讲了许多的做法，比如一道状态搜索的题，通常做法是暴力广度优先搜索，正好在训练迭代加深搜索，作者也给出了这个的思路，另外还提及了双向广度优先搜索和A*算法。另外就是书中的题好多都是经典题，这里引用一下某位dalao的“刷题哲学”：所谓的经典题就那些，刷完一道少一道。有种很人动力的感觉。由于是经典题网上可以收到很多blog，直接敲完一遍代码后再去翻blog，能学到不少的新知识，之前一道题我暴力模拟写了200行代码，结果搜了下blog，别人开数组映射了一下，代码量直接缩到了100行，顿时感觉非常惊艳，于是赶快对着敲了一遍学习了一下。总的来说这本书真的是一本好书，最近一个月的新知识感觉并不是通过集训，而且自己刷这本书得到的。可能是我比较适合自己去看书刷题吧。</p>\n<p>另外不只是算法，由于实验室的学习氛围非常好，自己空闲的时间也学了一些其他的东西，诸如HTML、TCP/IP，Python爬虫之类的，大体上向着互联网的方向上学习的，并且自己开了一台服务器，用Python写了个Web程序，放在服务器上搭了个网页。另外越来越习惯Linux的环境了，现在电脑也是双系统，主要使用Linux，除了用些Linux平台没有的软件，基本上只是在用Linux了。另外由于下学期有Java外教课，直接过了一遍Java的课程，大概把面向对象的知识简单过了一遍。</p>\n<p>后来的许多天都是日复一日的训练了，虽说每天的收获都非常多，但是想了想并没有什么值得写的，感觉记忆深刻点的还是比赛吧，最后一场的测试赛现在还是记忆犹新。</p>\n<p>原本只是一场普通的测试赛来着，老师突然要求改成组队赛，为了适应不久就要到来的天梯赛（这里以后讲一下），于是就按之前比赛的排名平均权重随机分配了一下。结果运气好匹配到的两个队友也比较给力，出来分配名单后就和他们讨论了一下，讨论下如何分配任务。最后结果是我负责敲代码，另一个队友负责想思路，和帮我一起看代码，另外一个专门负责翻译英文题，没办法讨论的时候发现我们英语都不是很好2333。</p>\n<p>比赛第一题是一道英文题，于是直接跳过，让队友去翻译了。然后我和另一个队友去看了第B题，我看了许久没思路，感觉负责敲代码的不能闲着，要一直有思路敲代码才行，于是让队友继续去看这道题，我去看了下C题。看了下是很简单的水题，于是敲了下来，幸好没有立即交上，叫来了队友看了下，结果有一个坑点，判断下左右边界，于是交上去AC了。这时翻译英文题的队友过来了，告诉我了下A题的题意，但是我还是纠结B题于是没打算敲A题。但是这时B题还是没思路，于是我把翻译英文题的队友叫来，一起敲完了A题，两个人检查了一遍，一次AC。无奈这时B题还是没思路，刚开始我的思路是直接暴力嵌套循环的，算了下时间复杂度果断超时，但是可以打一下表，于是打表出来让两个队友去找规律了。这时队友告诉我D题是一个暴力DFS的题，让我去敲，我看了下，刚好之前刷紫书做到过，于是照着敲了下来，过了几组数据一次AC。这时两个队友突然发现B题的递推规律，果断敲了代码，对比了下之前暴力打表的数据，完全符合，交上去，一次AC。这时我也看了下E题，是一个博弈题，看了下没思路，于是让两个队友都去看了，这时我发现F题就是一个无向图的最短路，于是很快就敲了出来，测了下样例交上去一次AC。然后两个给力的队友找到E题的规律了，就是一个if语句就可以解决的题，写了没几行的代码交上去A掉了。这时只剩下H题一个英文题和G题，这时队友已经把所有的题翻译完了。我看了下G题没思路，于是让队友告诉我了下H题的题意，发现是一个麻烦的模拟题，于是让他们去看G题，我去敲H题的代码，大概敲了半个小时，只是一个处理起来麻烦的题，思路不难想，然后敲完过了下样例，没想到交上去居然AC掉了。这时回过头来三个人一起想G题，刚开始我觉得是贪心，后来感觉是动态规划，最后觉得可能是二分递归分治，最后按分治敲了下代码，样例还没过比赛就结束了。</p>\n<p>剩下值得记录的就是结训了，最后结训赛，自己已经放弃治疗了，没想到还能水到一个奖品，最后老师讲了下自己寒假的经历，做了下总结，学长（长者）们也上台给我们讲（传授）了下学习方法（人生经验），总的来说过程是非常欢快的，QAQ巨是真的萌，最后要每个专业自荐一个代表讲讲话，然后某学长叫了我的名字2333，于是大概推荐了下紫书，和自己上面所说的学习方法，最后大家一起合影，寒假集训愉快的结束了～</p>\n<h1 id=\"三、一些感悟\"><a href=\"#三、一些感悟\" class=\"headerlink\" title=\"三、一些感悟\"></a>三、一些感悟</h1><p>之前刘老师也单独找过我谈过话，我当时说过，我当初上小学的时候，只喜欢打游戏，学习只是感兴趣学一下数学，实在是不想继续上初中了。然后是初中，每天浑浑噩噩的学习只是学一下感兴趣的课程，考试得到点成就感，根本没想着继续去上高中。直到后来开设化学和物理，发现原来世界上还有这么有意思的东西，感觉自己如果不了解的话多可惜啊。于是当初中考也只是考了个比较差的民办高中。在高中时追随初中的想法，读了一些物理科普书和名著小说，于是愈加的想要一个更高的平台，去了解更多这样有趣的知识。</p>\n<p>然后大学我想继续追随这个想法，开学之前自己其实就搜索了许多ACM相关的资料，于是加入了ACM。</p>\n<p>确实ACM这个平台也没辜负我的期望，让我见到了许许多多的dalao，在这个算是不大的圈子里，可以直接和整个中国最优秀的ACMer交流，可以把他们当做自己追赶的目标。另外算法也满足了我对知识的欲望，每次学到一个新算法都是成就感满满，当自己刚学会DFS解决数独问题和迷宫问题时，当自己和队友一起AC掉题时真心感到快乐。</p>\n<p>这里借用一下某个ACMer的话：我并不了解人生，也不愿去臆测未来，我只知道一道题WA很久之后突然Accepted的感觉简直妙不可言！</p>\n<h1 id=\"尾巴\"><a href=\"#尾巴\" class=\"headerlink\" title=\"尾巴\"></a>尾巴</h1><p>其实这时当时写的寒假的社会实践，挺有纪念意义的，以后的也一起放出来好了。</p>\n"},{"title":"2048（游戏）","date":"2016-12-05T15:26:26.000Z","_content":"# 玩法：\n即模仿市场上的2048游戏。\n\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205231601726)\n![这里写图片描述](http://img.blog.csdn.net/20161205231624882)\n![这里写图片描述](http://img.blog.csdn.net/20161205232051310)\n\n\n----------\n# 实现原理：\n\n - 就当是一个非常复杂的模拟题，整理好思路，搭好大体结构不难写。\n - 重点是如何判断方块是否合并那里，还有检测是否游戏结束。\n - 分数用一个全局变量储存，每次更新出性方块时加分。\n - 为方块分数加了个等比例增加的#号，要不玩起来难受的要死。\n -\n\n\n----------\n# 源代码：\n\n```cpp\n#include<stdio.h>\n#include<time.h>\n#include<stdlib.h>\n#include<conio.h>\n\nint a[4][4], SCORE = 0, prt;\n\nint num()\n{\n    return rand()%4;\n}\n\nint scan()\n{\n    int i, j, t = 0;\n    for(i = 0; i < 4; i++)\n    {\n        for(j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n            {\n                return 1;\n            }\n        }\n\n    }\n    return 0;\n}\n\nvoid crt()\n{\n    SCORE += 2;\n    int i,j;\n    for(;1;)\n    {\n        i = num();\n        j = num();\n        printf(\"%d %d\", i, j);\n        if (a[i][j] == 0)\n        {\n            a[i][j] = 2;\n            break;\n        }\n    }\n}\n\nvoid frmt()\n{\n    int i, d;\n    for (i = 0; i < 4; i++)\n    {\n        for (d = 0; d < 4; d++)\n        {\n            a[i][d] = 0;\n        }\n    }\n}\n\nvoid put()\n{\n    int i,d;\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\tScode: \\t%d\\n\\n\\t\\t\\t┌──────┬──────┬──────┬──────┐\\n\\t\\t\\t\", SCORE);\n    for (i = 0; i < 4; i++)\n    {\n\n        for (d = 0; d < 4; d++)\n        {\n            if (a[i][d] == 2048)\n                printf(\"│##########%d \", a[i][d]);\n            else if (a[i][d] == 1024)\n                printf(\"│#########%2d \", a[i][d]);\n            else if (a[i][d] == 512)\n                printf(\"│########%3d \", a[i][d]);\n            else if (a[i][d] == 256)\n                printf(\"│#######%4d \", a[i][d]);\n            else if (a[i][d] == 128)\n                printf(\"│######%5d \", a[i][d]);\n            else if (a[i][d] == 64)\n                printf(\"│#####%6d \", a[i][d]);\n            else if (a[i][d] == 32)\n                printf(\"│####%7d \", a[i][d]);\n            else if (a[i][d] == 16)\n                printf(\"│###%8d \", a[i][d]);\n            else if (a[i][d] == 8)\n                printf(\"│##%9d \", a[i][d]);\n            else if (a[i][d] == 4)\n                printf(\"│#%10d \", a[i][d]);\n            else if (a[i][d] == 2)\n                printf(\"│%11d \", a[i][d]);\n            else\n            printf(\"│            \", a[i][d]);\n        }\n        printf(\"│\");\n\n        if (i != 3)\n        {\n            printf(\"\\n\\t\\t\\t├──────┼──────┼──────┼──────┤\\n\\t\\t\\t\");\n        }\n    }\n    printf(\"\\n\\t\\t\\t└──────┴──────┴──────┴──────┘\\n\\n\\n\");\n}\n\n\nvoid A_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n                continue;\n            else\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (t != 0 && a[i][t] == a[i][j])\n                    {\n                        prt=1;\n                        a[i][j] *= 2;\n                        a[i][t] = 0;\n                    }\n                    else if (t != 0 && a[i][t] != a[i][j])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (a[i][t] != 0)\n                    {\n                        prt=1;\n                        a[i][j] = a[i][t];\n                        a[i][t] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid D_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[i][j] == 0)\n                continue;\n            else\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (t != 0 && a[i][t] == a[i][j])\n                    {\n                        prt=1;\n                        a[i][j] *= 2;\n                        a[i][t] = 0;\n                    }\n                    else if (t != 0 && a[i][t] != a[i][j])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[i][j] == 0)\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (a[i][t] != 0)\n                    {\n                        prt=1;\n                        a[i][j] = a[i][t];\n                        a[i][t] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid S_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[j][i] == 0)\n                continue;\n            else\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (t != 0 && a[j][i] == a[t][i])\n                    {\n                        prt=1;\n                        a[j][i] *= 2;\n                        a[t][i] = 0;\n                    }\n                    else if (t != 0 && a[t][i] != a[j][i])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[j][i] == 0)\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (a[t][i] != 0)\n                    {\n                        prt=1;\n                        a[j][i] = a[t][i];\n                        a[t][i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid W_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[j][i] == 0)\n                continue;\n            else\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (t != 0 && a[j][i] == a[t][i])\n                    {\n                        prt=1;\n                        a[j][i] *= 2;\n                        a[t][i] = 0;\n                    }\n                    else if (t != 0 && a[t][i] != a[j][i])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[j][i] == 0)\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (a[t][i] != 0)\n                    {\n                        prt=1;\n                        a[j][i] = a[t][i];\n                        a[t][i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int judge;\n    char ch;\n    srand((unsigned) time(NULL));\n\n    printf(\"\\n\\n\\n\\n\\n\\n\\t\\t\\tW S A D Control direction\\n\\n\\n\\n\\t\\t\\tPress any key to start the game...\\n\");\n    getch();\n\n    frmt();\n    crt();\n    put();\n\n    for (;1;)\n    {\n        prt = 0;\n        for (;1;)\n        {\n            printf(\"\\n\\n\\n\\n\\n\\n\\n\\nPlease enter: \");\n            ch = getch();\n            putchar(ch);\n            if(ch >= 'a' && ch <= 'z')\n                ch -= 32;\n            if(ch == 'W' || ch == 'A' || ch == 'D' || ch == 'S')\n                break;\n        }\n\n        if (ch == 'A')\n            A_();\n\n        if (ch == 'D')\n            D_();\n\n        if (ch == 'S')\n            S_();\n\n        if (ch == 'W')\n            W_();\n\n        if (scan())\n        {\n            if (prt)\n                crt();\n            put();\n        }\n        else\n        {\n            printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\tGame Over\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n            break;\n        }\n    }\n    getchar();\n}\n\n```\n# PS：\n印象中好像是十月一刚开学时，非常无聊写的，当作是锻炼代码能力了，也是图个好玩，成就感也是有的，毕竟是第一个有点可玩性的游戏，有时候真的停不下来233。","source":"_posts/2048（游戏）.md","raw":"---\ntitle: 2048（游戏）\ndate: 2016-12-05 23:26:26\ncategories: [游戏]\ntags:\n---\n# 玩法：\n即模仿市场上的2048游戏。\n\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205231601726)\n![这里写图片描述](http://img.blog.csdn.net/20161205231624882)\n![这里写图片描述](http://img.blog.csdn.net/20161205232051310)\n\n\n----------\n# 实现原理：\n\n - 就当是一个非常复杂的模拟题，整理好思路，搭好大体结构不难写。\n - 重点是如何判断方块是否合并那里，还有检测是否游戏结束。\n - 分数用一个全局变量储存，每次更新出性方块时加分。\n - 为方块分数加了个等比例增加的#号，要不玩起来难受的要死。\n -\n\n\n----------\n# 源代码：\n\n```cpp\n#include<stdio.h>\n#include<time.h>\n#include<stdlib.h>\n#include<conio.h>\n\nint a[4][4], SCORE = 0, prt;\n\nint num()\n{\n    return rand()%4;\n}\n\nint scan()\n{\n    int i, j, t = 0;\n    for(i = 0; i < 4; i++)\n    {\n        for(j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n            {\n                return 1;\n            }\n        }\n\n    }\n    return 0;\n}\n\nvoid crt()\n{\n    SCORE += 2;\n    int i,j;\n    for(;1;)\n    {\n        i = num();\n        j = num();\n        printf(\"%d %d\", i, j);\n        if (a[i][j] == 0)\n        {\n            a[i][j] = 2;\n            break;\n        }\n    }\n}\n\nvoid frmt()\n{\n    int i, d;\n    for (i = 0; i < 4; i++)\n    {\n        for (d = 0; d < 4; d++)\n        {\n            a[i][d] = 0;\n        }\n    }\n}\n\nvoid put()\n{\n    int i,d;\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\tScode: \\t%d\\n\\n\\t\\t\\t┌──────┬──────┬──────┬──────┐\\n\\t\\t\\t\", SCORE);\n    for (i = 0; i < 4; i++)\n    {\n\n        for (d = 0; d < 4; d++)\n        {\n            if (a[i][d] == 2048)\n                printf(\"│##########%d \", a[i][d]);\n            else if (a[i][d] == 1024)\n                printf(\"│#########%2d \", a[i][d]);\n            else if (a[i][d] == 512)\n                printf(\"│########%3d \", a[i][d]);\n            else if (a[i][d] == 256)\n                printf(\"│#######%4d \", a[i][d]);\n            else if (a[i][d] == 128)\n                printf(\"│######%5d \", a[i][d]);\n            else if (a[i][d] == 64)\n                printf(\"│#####%6d \", a[i][d]);\n            else if (a[i][d] == 32)\n                printf(\"│####%7d \", a[i][d]);\n            else if (a[i][d] == 16)\n                printf(\"│###%8d \", a[i][d]);\n            else if (a[i][d] == 8)\n                printf(\"│##%9d \", a[i][d]);\n            else if (a[i][d] == 4)\n                printf(\"│#%10d \", a[i][d]);\n            else if (a[i][d] == 2)\n                printf(\"│%11d \", a[i][d]);\n            else\n            printf(\"│            \", a[i][d]);\n        }\n        printf(\"│\");\n\n        if (i != 3)\n        {\n            printf(\"\\n\\t\\t\\t├──────┼──────┼──────┼──────┤\\n\\t\\t\\t\");\n        }\n    }\n    printf(\"\\n\\t\\t\\t└──────┴──────┴──────┴──────┘\\n\\n\\n\");\n}\n\n\nvoid A_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n                continue;\n            else\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (t != 0 && a[i][t] == a[i][j])\n                    {\n                        prt=1;\n                        a[i][j] *= 2;\n                        a[i][t] = 0;\n                    }\n                    else if (t != 0 && a[i][t] != a[i][j])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[i][j] == 0)\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (a[i][t] != 0)\n                    {\n                        prt=1;\n                        a[i][j] = a[i][t];\n                        a[i][t] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid D_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[i][j] == 0)\n                continue;\n            else\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (t != 0 && a[i][t] == a[i][j])\n                    {\n                        prt=1;\n                        a[i][j] *= 2;\n                        a[i][t] = 0;\n                    }\n                    else if (t != 0 && a[i][t] != a[i][j])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[i][j] == 0)\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (a[i][t] != 0)\n                    {\n                        prt=1;\n                        a[i][j] = a[i][t];\n                        a[i][t] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid S_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[j][i] == 0)\n                continue;\n            else\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (t != 0 && a[j][i] == a[t][i])\n                    {\n                        prt=1;\n                        a[j][i] *= 2;\n                        a[t][i] = 0;\n                    }\n                    else if (t != 0 && a[t][i] != a[j][i])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 3; j >= 0; j--)\n        {\n            if (a[j][i] == 0)\n            {\n                for (t = j - 1; t >= 0; t--)\n                {\n                    if (a[t][i] != 0)\n                    {\n                        prt=1;\n                        a[j][i] = a[t][i];\n                        a[t][i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid W_()\n{\n    int i, j, t;\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[j][i] == 0)\n                continue;\n            else\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (t != 0 && a[j][i] == a[t][i])\n                    {\n                        prt=1;\n                        a[j][i] *= 2;\n                        a[t][i] = 0;\n                    }\n                    else if (t != 0 && a[t][i] != a[j][i])\n                        break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            if (a[j][i] == 0)\n            {\n                for (t = j + 1; t < 4; t++)\n                {\n                    if (a[t][i] != 0)\n                    {\n                        prt=1;\n                        a[j][i] = a[t][i];\n                        a[t][i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int judge;\n    char ch;\n    srand((unsigned) time(NULL));\n\n    printf(\"\\n\\n\\n\\n\\n\\n\\t\\t\\tW S A D Control direction\\n\\n\\n\\n\\t\\t\\tPress any key to start the game...\\n\");\n    getch();\n\n    frmt();\n    crt();\n    put();\n\n    for (;1;)\n    {\n        prt = 0;\n        for (;1;)\n        {\n            printf(\"\\n\\n\\n\\n\\n\\n\\n\\nPlease enter: \");\n            ch = getch();\n            putchar(ch);\n            if(ch >= 'a' && ch <= 'z')\n                ch -= 32;\n            if(ch == 'W' || ch == 'A' || ch == 'D' || ch == 'S')\n                break;\n        }\n\n        if (ch == 'A')\n            A_();\n\n        if (ch == 'D')\n            D_();\n\n        if (ch == 'S')\n            S_();\n\n        if (ch == 'W')\n            W_();\n\n        if (scan())\n        {\n            if (prt)\n                crt();\n            put();\n        }\n        else\n        {\n            printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\tGame Over\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n            break;\n        }\n    }\n    getchar();\n}\n\n```\n# PS：\n印象中好像是十月一刚开学时，非常无聊写的，当作是锻炼代码能力了，也是图个好玩，成就感也是有的，毕竟是第一个有点可玩性的游戏，有时候真的停不下来233。","slug":"2048（游戏）","published":1,"updated":"2017-07-23T04:08:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n8q0005y9ids4efdlkv","content":"<h1 id=\"玩法：\"><a href=\"#玩法：\" class=\"headerlink\" title=\"玩法：\"></a>玩法：</h1><p>即模仿市场上的2048游戏。</p>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205231601726\" alt=\"这里写图片描述\"><br><img src=\"http://img.blog.csdn.net/20161205231624882\" alt=\"这里写图片描述\"><br><img src=\"http://img.blog.csdn.net/20161205232051310\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>就当是一个非常复杂的模拟题，整理好思路，搭好大体结构不难写。</li>\n<li>重点是如何判断方块是否合并那里，还有检测是否游戏结束。</li>\n<li>分数用一个全局变量储存，每次更新出性方块时加分。</li>\n<li>为方块分数加了个等比例增加的#号，要不玩起来难受的要死。<br>-</li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;conio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>][<span class=\"number\">4</span>], SCORE = <span class=\"number\">0</span>, prt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">num</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> rand()%<span class=\"number\">4</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">scan</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">crt</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    SCORE += <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i,j;</div><div class=\"line\">    <span class=\"keyword\">for</span>(;<span class=\"number\">1</span>;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        i = num();</div><div class=\"line\">        j = num();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>, i, j);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            a[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">frmt</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; d++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            a[i][d] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i,d;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\tScode: \\t%d\\n\\n\\t\\t\\t┌──────┬──────┬──────┬──────┐\\n\\t\\t\\t\"</span>, SCORE);</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; d++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">2048</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│##########%d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">1024</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#########%2d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">512</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│########%3d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">256</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#######%4d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">128</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│######%5d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">64</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#####%6d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">32</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│####%7d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">16</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│###%8d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">8</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│##%9d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">4</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#%10d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">2</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│%11d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"│            \"</span>, a[i][d]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"│\"</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">3</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\t\\t\\t├──────┼──────┼──────┼──────┤\\n\\t\\t\\t\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\t\\t\\t└──────┴──────┴──────┴──────┘\\n\\n\\n\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">A_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] == a[i][j])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] != a[i][j])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[i][t] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] = a[i][t];</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">D_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] == a[i][j])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] != a[i][j])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[i][t] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] = a[i][t];</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">S_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[j][i] == a[t][i])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[t][i] != a[j][i])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[t][i] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] = a[t][i];</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">W_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[j][i] == a[t][i])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[t][i] != a[j][i])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[t][i] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] = a[t][i];</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> judge;</div><div class=\"line\">    <span class=\"keyword\">char</span> ch;</div><div class=\"line\">    srand((<span class=\"keyword\">unsigned</span>) time(<span class=\"literal\">NULL</span>));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\t\\t\\tW S A D Control direction\\n\\n\\n\\n\\t\\t\\tPress any key to start the game...\\n\"</span>);</div><div class=\"line\">    getch();</div><div class=\"line\"></div><div class=\"line\">    frmt();</div><div class=\"line\">    crt();</div><div class=\"line\">    put();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;<span class=\"number\">1</span>;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        prt = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;<span class=\"number\">1</span>;)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\nPlease enter: \"</span>);</div><div class=\"line\">            ch = getch();</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(ch);</div><div class=\"line\">            <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'a'</span> &amp;&amp; ch &lt;= <span class=\"string\">'z'</span>)</div><div class=\"line\">                ch -= <span class=\"number\">32</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ch == <span class=\"string\">'W'</span> || ch == <span class=\"string\">'A'</span> || ch == <span class=\"string\">'D'</span> || ch == <span class=\"string\">'S'</span>)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'A'</span>)</div><div class=\"line\">            A_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'D'</span>)</div><div class=\"line\">            D_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'S'</span>)</div><div class=\"line\">            S_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'W'</span>)</div><div class=\"line\">            W_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (scan())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (prt)</div><div class=\"line\">                crt();</div><div class=\"line\">            put();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\tGame Over\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    getchar();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a>PS：</h1><p>印象中好像是十月一刚开学时，非常无聊写的，当作是锻炼代码能力了，也是图个好玩，成就感也是有的，毕竟是第一个有点可玩性的游戏，有时候真的停不下来233。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"玩法：\"><a href=\"#玩法：\" class=\"headerlink\" title=\"玩法：\"></a>玩法：</h1><p>即模仿市场上的2048游戏。</p>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205231601726\" alt=\"这里写图片描述\"><br><img src=\"http://img.blog.csdn.net/20161205231624882\" alt=\"这里写图片描述\"><br><img src=\"http://img.blog.csdn.net/20161205232051310\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>就当是一个非常复杂的模拟题，整理好思路，搭好大体结构不难写。</li>\n<li>重点是如何判断方块是否合并那里，还有检测是否游戏结束。</li>\n<li>分数用一个全局变量储存，每次更新出性方块时加分。</li>\n<li>为方块分数加了个等比例增加的#号，要不玩起来难受的要死。<br>-</li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;conio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>][<span class=\"number\">4</span>], SCORE = <span class=\"number\">0</span>, prt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">num</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> rand()%<span class=\"number\">4</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">scan</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">crt</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    SCORE += <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i,j;</div><div class=\"line\">    <span class=\"keyword\">for</span>(;<span class=\"number\">1</span>;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        i = num();</div><div class=\"line\">        j = num();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>, i, j);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            a[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">frmt</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; d++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            a[i][d] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i,d;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\tScode: \\t%d\\n\\n\\t\\t\\t┌──────┬──────┬──────┬──────┐\\n\\t\\t\\t\"</span>, SCORE);</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; d++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">2048</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│##########%d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">1024</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#########%2d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">512</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│########%3d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">256</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#######%4d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">128</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│######%5d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">64</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#####%6d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">32</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│####%7d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">16</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│###%8d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">8</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│##%9d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">4</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│#%10d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i][d] == <span class=\"number\">2</span>)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"│%11d \"</span>, a[i][d]);</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"│            \"</span>, a[i][d]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"│\"</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">3</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\t\\t\\t├──────┼──────┼──────┼──────┤\\n\\t\\t\\t\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\t\\t\\t└──────┴──────┴──────┴──────┘\\n\\n\\n\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">A_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] == a[i][j])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] != a[i][j])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[i][t] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] = a[i][t];</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">D_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] == a[i][j])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[i][t] != a[i][j])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[i][t] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[i][j] = a[i][t];</div><div class=\"line\">                        a[i][t] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">S_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[j][i] == a[t][i])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[t][i] != a[j][i])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">3</span>; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j - <span class=\"number\">1</span>; t &gt;= <span class=\"number\">0</span>; t--)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[t][i] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] = a[t][i];</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">W_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[j][i] == a[t][i])</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] *= <span class=\"number\">2</span>;</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t != <span class=\"number\">0</span> &amp;&amp; a[t][i] != a[j][i])</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[j][i] == <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (t = j + <span class=\"number\">1</span>; t &lt; <span class=\"number\">4</span>; t++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (a[t][i] != <span class=\"number\">0</span>)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        prt=<span class=\"number\">1</span>;</div><div class=\"line\">                        a[j][i] = a[t][i];</div><div class=\"line\">                        a[t][i] = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> judge;</div><div class=\"line\">    <span class=\"keyword\">char</span> ch;</div><div class=\"line\">    srand((<span class=\"keyword\">unsigned</span>) time(<span class=\"literal\">NULL</span>));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\t\\t\\tW S A D Control direction\\n\\n\\n\\n\\t\\t\\tPress any key to start the game...\\n\"</span>);</div><div class=\"line\">    getch();</div><div class=\"line\"></div><div class=\"line\">    frmt();</div><div class=\"line\">    crt();</div><div class=\"line\">    put();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;<span class=\"number\">1</span>;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        prt = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;<span class=\"number\">1</span>;)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\nPlease enter: \"</span>);</div><div class=\"line\">            ch = getch();</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(ch);</div><div class=\"line\">            <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'a'</span> &amp;&amp; ch &lt;= <span class=\"string\">'z'</span>)</div><div class=\"line\">                ch -= <span class=\"number\">32</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ch == <span class=\"string\">'W'</span> || ch == <span class=\"string\">'A'</span> || ch == <span class=\"string\">'D'</span> || ch == <span class=\"string\">'S'</span>)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'A'</span>)</div><div class=\"line\">            A_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'D'</span>)</div><div class=\"line\">            D_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'S'</span>)</div><div class=\"line\">            S_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ch == <span class=\"string\">'W'</span>)</div><div class=\"line\">            W_();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (scan())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (prt)</div><div class=\"line\">                crt();</div><div class=\"line\">            put();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\tGame Over\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    getchar();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a>PS：</h1><p>印象中好像是十月一刚开学时，非常无聊写的，当作是锻炼代码能力了，也是图个好玩，成就感也是有的，毕竟是第一个有点可玩性的游戏，有时候真的停不下来233。</p>\n"},{"title":"690 - Pipeline Scheduling (DFS + 状态压缩 + 剪枝)","date":"2017-03-15T10:07:24.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=631\n\n# 题目大意\n------------------\n有 5 个不同的工作单元，10 个相同的程序，每个程序需要运行 n 个时间段，每个时间段需要一个工作单元工作。现在问至少需要多少时间，才可以执行完全部的程序。\n\n# 解题过程\n--------------\n大体思路就是暴力模拟，显然可以状态压缩用位运算，然后就是剪枝的问题了。\n\n最开始想的是最暴力的模拟，从移一位开始试，如果可以移动了就 break 掉，这样找的每一步都是最短的，但总体上不是最优的。\n\n然后就去删掉了 break ，循环到移动 n 位。\n\n最后还是超时，又加了如果当前长度加上后面的最少长度大于答案就剪掉，还是超时，不过这里到是用的 IDA* 换了直接 DFS 还是超时。\n\n于是去找了博客……\n\n# 题目分析\n------------------\n#### 以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。\n\n+ 有两次剪枝\n\t+ 一是开始就初始化一下，仅有两个任务的情况每次可以移动的步长。这样比直接暴力移动省了不少时间。\n\t+ 二是如果当前还需要运行的程序个数乘最短步长后，如果大于当前的结果，那么剪掉。\n+ 每次的状态用一个一位数组储存，每个工作单元用状态压缩一个整数表示。\n+ 每次检测好移动用位运算。\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 30;\n\nchar rawData[6][MAX];\nint data[MAX], n, ans, jump[MAX], cnt;\n\nbool judge(int A[], int k) {\n    for (int i = 0; i < 5; i++) {\n        if ((A[i]>>k)&data[i])\n            return false;\n    }\n    return true;\n}\n\nvoid codingData(int n) {\n    ans = n*10, cnt = 0;\n    memset(data, 0, sizeof(data));\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%s\", rawData[i]);\n        for (int j = 0; j < n; j++) {\n            if (rawData[i][j] == 'X') {\n                data[i] |= (1<<j);\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        if (judge(data, i))\n            jump[cnt++] = i;\n    }\n}\n\nvoid attempt(int dep, int A[], int pos) {\n    if (pos + (10 - dep) * jump[0] > ans)\n        return;\n    if (dep == 10) {\n        ans = min(pos, ans);\n        return;\n    }\n    for (int i = 0; i < cnt; i++) {\n        if (judge(A, jump[i])) {\n            int B[MAX] = {};\n            for (int j = 0; j < 5; j++) {\n                B[j] = (A[j]>>jump[i]) | data[j];\n            }\n            attempt(dep+1, B, pos + jump[i]);\n        }\n    }\n}\n\nint main() {\n    while (~scanf(\"%d\", &n) && n) {\n        codingData(n);\n        attempt(1, data, n);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```","source":"_posts/690-Pipeline-Scheduling-DFS-状态压缩-剪枝.md","raw":"---\ntitle: 690 - Pipeline Scheduling (DFS + 状态压缩 + 剪枝)\ndate: 2017-03-15 18:07:24\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=631\n\n# 题目大意\n------------------\n有 5 个不同的工作单元，10 个相同的程序，每个程序需要运行 n 个时间段，每个时间段需要一个工作单元工作。现在问至少需要多少时间，才可以执行完全部的程序。\n\n# 解题过程\n--------------\n大体思路就是暴力模拟，显然可以状态压缩用位运算，然后就是剪枝的问题了。\n\n最开始想的是最暴力的模拟，从移一位开始试，如果可以移动了就 break 掉，这样找的每一步都是最短的，但总体上不是最优的。\n\n然后就去删掉了 break ，循环到移动 n 位。\n\n最后还是超时，又加了如果当前长度加上后面的最少长度大于答案就剪掉，还是超时，不过这里到是用的 IDA* 换了直接 DFS 还是超时。\n\n于是去找了博客……\n\n# 题目分析\n------------------\n#### 以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。\n\n+ 有两次剪枝\n\t+ 一是开始就初始化一下，仅有两个任务的情况每次可以移动的步长。这样比直接暴力移动省了不少时间。\n\t+ 二是如果当前还需要运行的程序个数乘最短步长后，如果大于当前的结果，那么剪掉。\n+ 每次的状态用一个一位数组储存，每个工作单元用状态压缩一个整数表示。\n+ 每次检测好移动用位运算。\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 30;\n\nchar rawData[6][MAX];\nint data[MAX], n, ans, jump[MAX], cnt;\n\nbool judge(int A[], int k) {\n    for (int i = 0; i < 5; i++) {\n        if ((A[i]>>k)&data[i])\n            return false;\n    }\n    return true;\n}\n\nvoid codingData(int n) {\n    ans = n*10, cnt = 0;\n    memset(data, 0, sizeof(data));\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%s\", rawData[i]);\n        for (int j = 0; j < n; j++) {\n            if (rawData[i][j] == 'X') {\n                data[i] |= (1<<j);\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        if (judge(data, i))\n            jump[cnt++] = i;\n    }\n}\n\nvoid attempt(int dep, int A[], int pos) {\n    if (pos + (10 - dep) * jump[0] > ans)\n        return;\n    if (dep == 10) {\n        ans = min(pos, ans);\n        return;\n    }\n    for (int i = 0; i < cnt; i++) {\n        if (judge(A, jump[i])) {\n            int B[MAX] = {};\n            for (int j = 0; j < 5; j++) {\n                B[j] = (A[j]>>jump[i]) | data[j];\n            }\n            attempt(dep+1, B, pos + jump[i]);\n        }\n    }\n}\n\nint main() {\n    while (~scanf(\"%d\", &n) && n) {\n        codingData(n);\n        attempt(1, data, n);\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```","slug":"690-Pipeline-Scheduling-DFS-状态压缩-剪枝","published":1,"updated":"2017-07-23T02:49:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n8t0006y9idb9ri866t","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=631\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=631</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有 5 个不同的工作单元，10 个相同的程序，每个程序需要运行 n 个时间段，每个时间段需要一个工作单元工作。现在问至少需要多少时间，才可以执行完全部的程序。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>大体思路就是暴力模拟，显然可以状态压缩用位运算，然后就是剪枝的问题了。</p>\n<p>最开始想的是最暴力的模拟，从移一位开始试，如果可以移动了就 break 掉，这样找的每一步都是最短的，但总体上不是最优的。</p>\n<p>然后就去删掉了 break ，循环到移动 n 位。</p>\n<p>最后还是超时，又加了如果当前长度加上后面的最少长度大于答案就剪掉，还是超时，不过这里到是用的 IDA* 换了直接 DFS 还是超时。</p>\n<p>于是去找了博客……</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<h4 id=\"以后做题的时候要考虑下，暴力-dfs-时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似-KMP-先预处理可以走的步长，避免以后很多次的判断。\"><a href=\"#以后做题的时候要考虑下，暴力-dfs-时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似-KMP-先预处理可以走的步长，避免以后很多次的判断。\" class=\"headerlink\" title=\"以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。\"></a>以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。</h4><ul>\n<li>有两次剪枝<ul>\n<li>一是开始就初始化一下，仅有两个任务的情况每次可以移动的步长。这样比直接暴力移动省了不少时间。</li>\n<li>二是如果当前还需要运行的程序个数乘最短步长后，如果大于当前的结果，那么剪掉。</li>\n</ul>\n</li>\n<li>每次的状态用一个一位数组储存，每个工作单元用状态压缩一个整数表示。</li>\n<li>每次检测好移动用位运算。<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1></li>\n</ul>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">30</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> rawData[<span class=\"number\">6</span>][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], n, ans, jump[MAX], cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((A[i]&gt;&gt;k)&amp;data[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">codingData</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    ans = n*<span class=\"number\">10</span>, cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, rawData[i]);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (rawData[i][j] == <span class=\"string\">'X'</span>) &#123;</div><div class=\"line\">                data[i] |= (<span class=\"number\">1</span>&lt;&lt;j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge(data, i))</div><div class=\"line\">            jump[cnt++] = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt</span><span class=\"params\">(<span class=\"keyword\">int</span> dep, <span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos + (<span class=\"number\">10</span> - dep) * jump[<span class=\"number\">0</span>] &gt; ans)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dep == <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        ans = min(pos, ans);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge(A, jump[i])) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> B[MAX] = &#123;&#125;;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</div><div class=\"line\">                B[j] = (A[j]&gt;&gt;jump[i]) | data[j];</div><div class=\"line\">            &#125;</div><div class=\"line\">            attempt(dep+<span class=\"number\">1</span>, B, pos + jump[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        codingData(n);</div><div class=\"line\">        attempt(<span class=\"number\">1</span>, data, n);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=631\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=631</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有 5 个不同的工作单元，10 个相同的程序，每个程序需要运行 n 个时间段，每个时间段需要一个工作单元工作。现在问至少需要多少时间，才可以执行完全部的程序。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>大体思路就是暴力模拟，显然可以状态压缩用位运算，然后就是剪枝的问题了。</p>\n<p>最开始想的是最暴力的模拟，从移一位开始试，如果可以移动了就 break 掉，这样找的每一步都是最短的，但总体上不是最优的。</p>\n<p>然后就去删掉了 break ，循环到移动 n 位。</p>\n<p>最后还是超时，又加了如果当前长度加上后面的最少长度大于答案就剪掉，还是超时，不过这里到是用的 IDA* 换了直接 DFS 还是超时。</p>\n<p>于是去找了博客……</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<h4 id=\"以后做题的时候要考虑下，暴力-dfs-时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似-KMP-先预处理可以走的步长，避免以后很多次的判断。\"><a href=\"#以后做题的时候要考虑下，暴力-dfs-时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似-KMP-先预处理可以走的步长，避免以后很多次的判断。\" class=\"headerlink\" title=\"以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。\"></a>以后做题的时候要考虑下，暴力 dfs 时候，每一个状态到下一个状态的路径个数，可不可以优化，感觉这题的思想类似 KMP 先预处理可以走的步长，避免以后很多次的判断。</h4><ul>\n<li>有两次剪枝<ul>\n<li>一是开始就初始化一下，仅有两个任务的情况每次可以移动的步长。这样比直接暴力移动省了不少时间。</li>\n<li>二是如果当前还需要运行的程序个数乘最短步长后，如果大于当前的结果，那么剪掉。</li>\n</ul>\n</li>\n<li>每次的状态用一个一位数组储存，每个工作单元用状态压缩一个整数表示。</li>\n<li>每次检测好移动用位运算。<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1></li>\n</ul>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">30</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> rawData[<span class=\"number\">6</span>][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], n, ans, jump[MAX], cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((A[i]&gt;&gt;k)&amp;data[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">codingData</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    ans = n*<span class=\"number\">10</span>, cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, rawData[i]);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (rawData[i][j] == <span class=\"string\">'X'</span>) &#123;</div><div class=\"line\">                data[i] |= (<span class=\"number\">1</span>&lt;&lt;j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge(data, i))</div><div class=\"line\">            jump[cnt++] = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt</span><span class=\"params\">(<span class=\"keyword\">int</span> dep, <span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos + (<span class=\"number\">10</span> - dep) * jump[<span class=\"number\">0</span>] &gt; ans)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dep == <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        ans = min(pos, ans);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge(A, jump[i])) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> B[MAX] = &#123;&#125;;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</div><div class=\"line\">                B[j] = (A[j]&gt;&gt;jump[i]) | data[j];</div><div class=\"line\">            &#125;</div><div class=\"line\">            attempt(dep+<span class=\"number\">1</span>, B, pos + jump[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        codingData(n);</div><div class=\"line\">        attempt(<span class=\"number\">1</span>, data, n);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"2017年暑假集训","date":"2017-08-28T10:38:40.000Z","_content":"# 一、时间内容\n\n2017年暑假，学校 ACM 算法实验室。对一个月集训的总结，也算是应付一下学校的社会实践作业。时间为7月24日至8月26日，总共五周34天。\n\n时间差不多是早上8点就得到实验室，不过这次不像寒假集训那样每天要签到，结果日常迟到，刚开始几天还好，之后都是迟到个10几分钟...\n\n老师对集训的安排是周一至周六全天训练，周日休息一天，除周二以外每天上午自己去刷专题学习算法，下午就进行组队赛，周三是一天都是学习算法和补题。周六是上午+下午两场个人赛，一周下来总共六场比赛，除去个人赛三个小时外，每场比赛都是5小时，训练强度可以说是挺高的了。\n\n\n\n# 二、体验与经历\n\n这里就以时间为顺序写一下集训的趣事和重要经历好了。\n\n我是在集训开始前几天就来学校刷了一会专题，搞了搞数论，算是弄懂了逆元、中国剩余定理、扩展欧几里得算法...对于基本的数论题算是没问题了，然后对数论不像之前那么怕了，讲道理我到时非常想仔细研究一下数论来着，毕竟算是数学中的皇后、最纯粹的数学了，然而图论真的是太有意思了～\n\n然后过了几天就开始正式集训了，刘老师首先开始讲话，看参加集训的人数，大概有个100+人，看刘老师说是分算法组和数据结构组两部分，算法组的基本上就是面向比赛的集训队队员了，数据结构组，看刘老师的意思是想要把我们学校整体的水平提高上来，整个计院差不多700人，这样相当于有个1/6人都在大一结束的时候就完成了数据结构的学习，如果进展的好的话，可以说是非常恐怖了。\n\n对于数据结构组我不太清楚，刘老师说了一下对算法组的安排，就是上面说的那样了，然后张老师在 VJ 上抓了 kuangbin 的专题，算是我们学习的大纲了。\n\n接下来防不胜防的，刘老师说要开一场个人赛，算是让我们找到状态，当时就整个人就方了。\n\n然后第二天上午就开始比赛了，由于过去一个多月了，记得也不是太清楚了，反正刚开始就是一堆的水题，唯一用到数据结构也就是单调栈和线段树，当时状态还不错，不过单调栈看了紫书才敲出来 ORZ 。最后 A 完7题后，就在看一个类似约瑟夫环的题，刚开始还以为是一个纯数学题，不过之前刷了很多的线段树的题，然后用朴素的思想想了一下，维护下标这个信息，突然发现用线段树可以搞，于是最后半个小时就非常开心的敲起了线段树，不得不说金桔的线段树的板子真的好用，然后自信的交上去，给了一个 Wrong Answer，然后比赛还有不到十分钟，本来没怎么有希望了，然后又去查了一下代码，区间更新 lazy 标记直接覆盖掉了，没累加，改掉之后交上去居然 A 了，非常开心，这时候也就五分钟了，于是和后面机位的 xuanhuang 聊了起来。开始第一场比赛 AK 可以说是非常开心了。\n\n比赛结束后，就是日常的训练了，不过刚开始我们队比赛状态并不怎么好，经常前两个小时 A 完题，就咸鱼了，三个人坐着没事干。\n\n然后就是每周的个人赛了，第一周的搜索算是非常开心，自己本身刷紫书的题的时候做了不少的搜索题，底子算是还可以，然后印象比较深的时候是一个题从 TLE 加剪枝优化，慢慢调成了 AC，非常开心，两次排名都是 Rank1。\n\n组队赛的时候，非常幸运可以参加多校赛，也算是去见识下区域赛的题型，发现数学题居多，上来就是莫比乌斯反演、矩阵快速幂、快速傅里叶变换、卷积...刚开始打的一脸懵逼，感觉也就是做前几到简单题就尽力。然后感觉对于区域赛，感觉也只能思维活跃一点，把直接力所能及的题，做出来就好了。然后区域赛尽可能去拿一个铜牌甚至是银牌，如果是银牌的话，那就非常稳了，整个大二就可以平稳的去刷金牌题和知识点了（幻想ing）。\n\n之后几个周都是一样的安排，整天不是刷题就是比赛，非常单调，值得一提的是最短路的测试赛又体验了一下 AK 的感觉，感觉自己对最短路理解也算是比较深了。\n\n集训前几天一直在搞图论，先去学了下网络流，裸的 FF 算法， EK 算法， Dinic 算法都看了一下，网络流专题也算是刷了一半。感觉网络流算是图论里面一个比较重要的知识点了，之前区域赛的网络赛中经常有网络流的题。刷网络流的时候顺便去看了一下二分图匹配的问题，感觉匹配这个东西有点神奇，好多看起来和图论无关的问题，都可以转化到二分图的模型上，然后跑最大匹配就能解决好多问题。\n\n之后因为实验室要开算法讲堂，然后就被叫去讲强连通缩点，于是用了一个星期咸鱼突刺了一下，算是弄清了强连通、边-双连通、点-双连通，然后就开始填算法讲堂的模板了，反反复复修正了得一两天，最后填的也不怎么样，等学离散数学的时候，一定要好好在图论上扩展一下！\n\n最后只能就这样将强连通了，感觉讲的算是比较失败的了，没学过的估计没听懂，学过的也基本上不用听的。对比之前学长讲的树链剖分，当时我只看卿学姐的视频学了一下概念，然后听学长讲的居然听懂了，然后拿着板子去切了几个题，也算是会基本的树链剖分了，其实树链剖分实质上就是一种映射，目的是将一条链上的点映射到若干段连续的区间上，然后对于链上的修改，就对这几段连续的区间进行修改，对于连续的区间修改可以用线段树进行维护。于是这样树链剖分的题重点还算是在线段树上。\n\n其他有意思的事情就是被派去辅导数据结构组的刷题了，然后发现他们是在做的 CCCC 的题，之前天梯赛训练的时候刷过的，然后给一个同学讲了一下树的同构的判断，发现直接好久没写过的指针了，我本以为给他写一个指针的比较好理解来着，最后写起来发现数组的好些太多了。另外一个就是看了一下目录树，之前在白书上面看到过，上面说的是静态排错，手写一个简单 shell ，也算是一个大模拟题了。看起来还是比较容易，记得天梯赛的时候，这个题曾经水过了20+分。\n\n最后就是结训赛了，其实也都是比较水的题，大家都当做娱乐来做的，其实也挺娱乐的，最开心的是做出来了一道区域赛的 DP 题，感觉还可以，最后罚时有点多Rank2，还可以。\n\n# 三、一些感悟\n\n一个多月以来，基本上都是自学算法，学习新算法也是自己去百度找资料、翻书，比起之前集训都是学长来讲内容，感觉自己的自学能力算是提高了不少。学习能力也是提高了不少，比如匈牙利算法，当初只用了一上午不到，就学完并刷了好多例题了。\n\n另外一个重要的提升是，最近比赛的时候不再像之前那样，每次前两三个小时做出来题，之后就没事干了，现在基本上五个小时都在看题，尤其是最近一场比赛，前三个半小时都是爆零，知道三个半小时后才切掉了第一题，之后半小时又切了一题，最后十分钟队友又切了一道 KMP 的题，顿时咸鱼翻身。\n\n之后也是打算继续搞算法竞赛，目测会打到大三吧。","source":"_posts/2017年暑假集训.md","raw":"---\ntitle: 2017年暑假集训\ndate: 2017-08-28 18:38:40\ncategories: [历程]\ntags:\n---\n# 一、时间内容\n\n2017年暑假，学校 ACM 算法实验室。对一个月集训的总结，也算是应付一下学校的社会实践作业。时间为7月24日至8月26日，总共五周34天。\n\n时间差不多是早上8点就得到实验室，不过这次不像寒假集训那样每天要签到，结果日常迟到，刚开始几天还好，之后都是迟到个10几分钟...\n\n老师对集训的安排是周一至周六全天训练，周日休息一天，除周二以外每天上午自己去刷专题学习算法，下午就进行组队赛，周三是一天都是学习算法和补题。周六是上午+下午两场个人赛，一周下来总共六场比赛，除去个人赛三个小时外，每场比赛都是5小时，训练强度可以说是挺高的了。\n\n\n\n# 二、体验与经历\n\n这里就以时间为顺序写一下集训的趣事和重要经历好了。\n\n我是在集训开始前几天就来学校刷了一会专题，搞了搞数论，算是弄懂了逆元、中国剩余定理、扩展欧几里得算法...对于基本的数论题算是没问题了，然后对数论不像之前那么怕了，讲道理我到时非常想仔细研究一下数论来着，毕竟算是数学中的皇后、最纯粹的数学了，然而图论真的是太有意思了～\n\n然后过了几天就开始正式集训了，刘老师首先开始讲话，看参加集训的人数，大概有个100+人，看刘老师说是分算法组和数据结构组两部分，算法组的基本上就是面向比赛的集训队队员了，数据结构组，看刘老师的意思是想要把我们学校整体的水平提高上来，整个计院差不多700人，这样相当于有个1/6人都在大一结束的时候就完成了数据结构的学习，如果进展的好的话，可以说是非常恐怖了。\n\n对于数据结构组我不太清楚，刘老师说了一下对算法组的安排，就是上面说的那样了，然后张老师在 VJ 上抓了 kuangbin 的专题，算是我们学习的大纲了。\n\n接下来防不胜防的，刘老师说要开一场个人赛，算是让我们找到状态，当时就整个人就方了。\n\n然后第二天上午就开始比赛了，由于过去一个多月了，记得也不是太清楚了，反正刚开始就是一堆的水题，唯一用到数据结构也就是单调栈和线段树，当时状态还不错，不过单调栈看了紫书才敲出来 ORZ 。最后 A 完7题后，就在看一个类似约瑟夫环的题，刚开始还以为是一个纯数学题，不过之前刷了很多的线段树的题，然后用朴素的思想想了一下，维护下标这个信息，突然发现用线段树可以搞，于是最后半个小时就非常开心的敲起了线段树，不得不说金桔的线段树的板子真的好用，然后自信的交上去，给了一个 Wrong Answer，然后比赛还有不到十分钟，本来没怎么有希望了，然后又去查了一下代码，区间更新 lazy 标记直接覆盖掉了，没累加，改掉之后交上去居然 A 了，非常开心，这时候也就五分钟了，于是和后面机位的 xuanhuang 聊了起来。开始第一场比赛 AK 可以说是非常开心了。\n\n比赛结束后，就是日常的训练了，不过刚开始我们队比赛状态并不怎么好，经常前两个小时 A 完题，就咸鱼了，三个人坐着没事干。\n\n然后就是每周的个人赛了，第一周的搜索算是非常开心，自己本身刷紫书的题的时候做了不少的搜索题，底子算是还可以，然后印象比较深的时候是一个题从 TLE 加剪枝优化，慢慢调成了 AC，非常开心，两次排名都是 Rank1。\n\n组队赛的时候，非常幸运可以参加多校赛，也算是去见识下区域赛的题型，发现数学题居多，上来就是莫比乌斯反演、矩阵快速幂、快速傅里叶变换、卷积...刚开始打的一脸懵逼，感觉也就是做前几到简单题就尽力。然后感觉对于区域赛，感觉也只能思维活跃一点，把直接力所能及的题，做出来就好了。然后区域赛尽可能去拿一个铜牌甚至是银牌，如果是银牌的话，那就非常稳了，整个大二就可以平稳的去刷金牌题和知识点了（幻想ing）。\n\n之后几个周都是一样的安排，整天不是刷题就是比赛，非常单调，值得一提的是最短路的测试赛又体验了一下 AK 的感觉，感觉自己对最短路理解也算是比较深了。\n\n集训前几天一直在搞图论，先去学了下网络流，裸的 FF 算法， EK 算法， Dinic 算法都看了一下，网络流专题也算是刷了一半。感觉网络流算是图论里面一个比较重要的知识点了，之前区域赛的网络赛中经常有网络流的题。刷网络流的时候顺便去看了一下二分图匹配的问题，感觉匹配这个东西有点神奇，好多看起来和图论无关的问题，都可以转化到二分图的模型上，然后跑最大匹配就能解决好多问题。\n\n之后因为实验室要开算法讲堂，然后就被叫去讲强连通缩点，于是用了一个星期咸鱼突刺了一下，算是弄清了强连通、边-双连通、点-双连通，然后就开始填算法讲堂的模板了，反反复复修正了得一两天，最后填的也不怎么样，等学离散数学的时候，一定要好好在图论上扩展一下！\n\n最后只能就这样将强连通了，感觉讲的算是比较失败的了，没学过的估计没听懂，学过的也基本上不用听的。对比之前学长讲的树链剖分，当时我只看卿学姐的视频学了一下概念，然后听学长讲的居然听懂了，然后拿着板子去切了几个题，也算是会基本的树链剖分了，其实树链剖分实质上就是一种映射，目的是将一条链上的点映射到若干段连续的区间上，然后对于链上的修改，就对这几段连续的区间进行修改，对于连续的区间修改可以用线段树进行维护。于是这样树链剖分的题重点还算是在线段树上。\n\n其他有意思的事情就是被派去辅导数据结构组的刷题了，然后发现他们是在做的 CCCC 的题，之前天梯赛训练的时候刷过的，然后给一个同学讲了一下树的同构的判断，发现直接好久没写过的指针了，我本以为给他写一个指针的比较好理解来着，最后写起来发现数组的好些太多了。另外一个就是看了一下目录树，之前在白书上面看到过，上面说的是静态排错，手写一个简单 shell ，也算是一个大模拟题了。看起来还是比较容易，记得天梯赛的时候，这个题曾经水过了20+分。\n\n最后就是结训赛了，其实也都是比较水的题，大家都当做娱乐来做的，其实也挺娱乐的，最开心的是做出来了一道区域赛的 DP 题，感觉还可以，最后罚时有点多Rank2，还可以。\n\n# 三、一些感悟\n\n一个多月以来，基本上都是自学算法，学习新算法也是自己去百度找资料、翻书，比起之前集训都是学长来讲内容，感觉自己的自学能力算是提高了不少。学习能力也是提高了不少，比如匈牙利算法，当初只用了一上午不到，就学完并刷了好多例题了。\n\n另外一个重要的提升是，最近比赛的时候不再像之前那样，每次前两三个小时做出来题，之后就没事干了，现在基本上五个小时都在看题，尤其是最近一场比赛，前三个半小时都是爆零，知道三个半小时后才切掉了第一题，之后半小时又切了一题，最后十分钟队友又切了一道 KMP 的题，顿时咸鱼翻身。\n\n之后也是打算继续搞算法竞赛，目测会打到大三吧。","slug":"2017年暑假集训","published":1,"updated":"2017-08-28T12:42:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n8x0008y9id1wt65bzk","content":"<h1 id=\"一、时间内容\"><a href=\"#一、时间内容\" class=\"headerlink\" title=\"一、时间内容\"></a>一、时间内容</h1><p>2017年暑假，学校 ACM 算法实验室。对一个月集训的总结，也算是应付一下学校的社会实践作业。时间为7月24日至8月26日，总共五周34天。</p>\n<p>时间差不多是早上8点就得到实验室，不过这次不像寒假集训那样每天要签到，结果日常迟到，刚开始几天还好，之后都是迟到个10几分钟…</p>\n<p>老师对集训的安排是周一至周六全天训练，周日休息一天，除周二以外每天上午自己去刷专题学习算法，下午就进行组队赛，周三是一天都是学习算法和补题。周六是上午+下午两场个人赛，一周下来总共六场比赛，除去个人赛三个小时外，每场比赛都是5小时，训练强度可以说是挺高的了。</p>\n<h1 id=\"二、体验与经历\"><a href=\"#二、体验与经历\" class=\"headerlink\" title=\"二、体验与经历\"></a>二、体验与经历</h1><p>这里就以时间为顺序写一下集训的趣事和重要经历好了。</p>\n<p>我是在集训开始前几天就来学校刷了一会专题，搞了搞数论，算是弄懂了逆元、中国剩余定理、扩展欧几里得算法…对于基本的数论题算是没问题了，然后对数论不像之前那么怕了，讲道理我到时非常想仔细研究一下数论来着，毕竟算是数学中的皇后、最纯粹的数学了，然而图论真的是太有意思了～</p>\n<p>然后过了几天就开始正式集训了，刘老师首先开始讲话，看参加集训的人数，大概有个100+人，看刘老师说是分算法组和数据结构组两部分，算法组的基本上就是面向比赛的集训队队员了，数据结构组，看刘老师的意思是想要把我们学校整体的水平提高上来，整个计院差不多700人，这样相当于有个1/6人都在大一结束的时候就完成了数据结构的学习，如果进展的好的话，可以说是非常恐怖了。</p>\n<p>对于数据结构组我不太清楚，刘老师说了一下对算法组的安排，就是上面说的那样了，然后张老师在 VJ 上抓了 kuangbin 的专题，算是我们学习的大纲了。</p>\n<p>接下来防不胜防的，刘老师说要开一场个人赛，算是让我们找到状态，当时就整个人就方了。</p>\n<p>然后第二天上午就开始比赛了，由于过去一个多月了，记得也不是太清楚了，反正刚开始就是一堆的水题，唯一用到数据结构也就是单调栈和线段树，当时状态还不错，不过单调栈看了紫书才敲出来 ORZ 。最后 A 完7题后，就在看一个类似约瑟夫环的题，刚开始还以为是一个纯数学题，不过之前刷了很多的线段树的题，然后用朴素的思想想了一下，维护下标这个信息，突然发现用线段树可以搞，于是最后半个小时就非常开心的敲起了线段树，不得不说金桔的线段树的板子真的好用，然后自信的交上去，给了一个 Wrong Answer，然后比赛还有不到十分钟，本来没怎么有希望了，然后又去查了一下代码，区间更新 lazy 标记直接覆盖掉了，没累加，改掉之后交上去居然 A 了，非常开心，这时候也就五分钟了，于是和后面机位的 xuanhuang 聊了起来。开始第一场比赛 AK 可以说是非常开心了。</p>\n<p>比赛结束后，就是日常的训练了，不过刚开始我们队比赛状态并不怎么好，经常前两个小时 A 完题，就咸鱼了，三个人坐着没事干。</p>\n<p>然后就是每周的个人赛了，第一周的搜索算是非常开心，自己本身刷紫书的题的时候做了不少的搜索题，底子算是还可以，然后印象比较深的时候是一个题从 TLE 加剪枝优化，慢慢调成了 AC，非常开心，两次排名都是 Rank1。</p>\n<p>组队赛的时候，非常幸运可以参加多校赛，也算是去见识下区域赛的题型，发现数学题居多，上来就是莫比乌斯反演、矩阵快速幂、快速傅里叶变换、卷积…刚开始打的一脸懵逼，感觉也就是做前几到简单题就尽力。然后感觉对于区域赛，感觉也只能思维活跃一点，把直接力所能及的题，做出来就好了。然后区域赛尽可能去拿一个铜牌甚至是银牌，如果是银牌的话，那就非常稳了，整个大二就可以平稳的去刷金牌题和知识点了（幻想ing）。</p>\n<p>之后几个周都是一样的安排，整天不是刷题就是比赛，非常单调，值得一提的是最短路的测试赛又体验了一下 AK 的感觉，感觉自己对最短路理解也算是比较深了。</p>\n<p>集训前几天一直在搞图论，先去学了下网络流，裸的 FF 算法， EK 算法， Dinic 算法都看了一下，网络流专题也算是刷了一半。感觉网络流算是图论里面一个比较重要的知识点了，之前区域赛的网络赛中经常有网络流的题。刷网络流的时候顺便去看了一下二分图匹配的问题，感觉匹配这个东西有点神奇，好多看起来和图论无关的问题，都可以转化到二分图的模型上，然后跑最大匹配就能解决好多问题。</p>\n<p>之后因为实验室要开算法讲堂，然后就被叫去讲强连通缩点，于是用了一个星期咸鱼突刺了一下，算是弄清了强连通、边-双连通、点-双连通，然后就开始填算法讲堂的模板了，反反复复修正了得一两天，最后填的也不怎么样，等学离散数学的时候，一定要好好在图论上扩展一下！</p>\n<p>最后只能就这样将强连通了，感觉讲的算是比较失败的了，没学过的估计没听懂，学过的也基本上不用听的。对比之前学长讲的树链剖分，当时我只看卿学姐的视频学了一下概念，然后听学长讲的居然听懂了，然后拿着板子去切了几个题，也算是会基本的树链剖分了，其实树链剖分实质上就是一种映射，目的是将一条链上的点映射到若干段连续的区间上，然后对于链上的修改，就对这几段连续的区间进行修改，对于连续的区间修改可以用线段树进行维护。于是这样树链剖分的题重点还算是在线段树上。</p>\n<p>其他有意思的事情就是被派去辅导数据结构组的刷题了，然后发现他们是在做的 CCCC 的题，之前天梯赛训练的时候刷过的，然后给一个同学讲了一下树的同构的判断，发现直接好久没写过的指针了，我本以为给他写一个指针的比较好理解来着，最后写起来发现数组的好些太多了。另外一个就是看了一下目录树，之前在白书上面看到过，上面说的是静态排错，手写一个简单 shell ，也算是一个大模拟题了。看起来还是比较容易，记得天梯赛的时候，这个题曾经水过了20+分。</p>\n<p>最后就是结训赛了，其实也都是比较水的题，大家都当做娱乐来做的，其实也挺娱乐的，最开心的是做出来了一道区域赛的 DP 题，感觉还可以，最后罚时有点多Rank2，还可以。</p>\n<h1 id=\"三、一些感悟\"><a href=\"#三、一些感悟\" class=\"headerlink\" title=\"三、一些感悟\"></a>三、一些感悟</h1><p>一个多月以来，基本上都是自学算法，学习新算法也是自己去百度找资料、翻书，比起之前集训都是学长来讲内容，感觉自己的自学能力算是提高了不少。学习能力也是提高了不少，比如匈牙利算法，当初只用了一上午不到，就学完并刷了好多例题了。</p>\n<p>另外一个重要的提升是，最近比赛的时候不再像之前那样，每次前两三个小时做出来题，之后就没事干了，现在基本上五个小时都在看题，尤其是最近一场比赛，前三个半小时都是爆零，知道三个半小时后才切掉了第一题，之后半小时又切了一题，最后十分钟队友又切了一道 KMP 的题，顿时咸鱼翻身。</p>\n<p>之后也是打算继续搞算法竞赛，目测会打到大三吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、时间内容\"><a href=\"#一、时间内容\" class=\"headerlink\" title=\"一、时间内容\"></a>一、时间内容</h1><p>2017年暑假，学校 ACM 算法实验室。对一个月集训的总结，也算是应付一下学校的社会实践作业。时间为7月24日至8月26日，总共五周34天。</p>\n<p>时间差不多是早上8点就得到实验室，不过这次不像寒假集训那样每天要签到，结果日常迟到，刚开始几天还好，之后都是迟到个10几分钟…</p>\n<p>老师对集训的安排是周一至周六全天训练，周日休息一天，除周二以外每天上午自己去刷专题学习算法，下午就进行组队赛，周三是一天都是学习算法和补题。周六是上午+下午两场个人赛，一周下来总共六场比赛，除去个人赛三个小时外，每场比赛都是5小时，训练强度可以说是挺高的了。</p>\n<h1 id=\"二、体验与经历\"><a href=\"#二、体验与经历\" class=\"headerlink\" title=\"二、体验与经历\"></a>二、体验与经历</h1><p>这里就以时间为顺序写一下集训的趣事和重要经历好了。</p>\n<p>我是在集训开始前几天就来学校刷了一会专题，搞了搞数论，算是弄懂了逆元、中国剩余定理、扩展欧几里得算法…对于基本的数论题算是没问题了，然后对数论不像之前那么怕了，讲道理我到时非常想仔细研究一下数论来着，毕竟算是数学中的皇后、最纯粹的数学了，然而图论真的是太有意思了～</p>\n<p>然后过了几天就开始正式集训了，刘老师首先开始讲话，看参加集训的人数，大概有个100+人，看刘老师说是分算法组和数据结构组两部分，算法组的基本上就是面向比赛的集训队队员了，数据结构组，看刘老师的意思是想要把我们学校整体的水平提高上来，整个计院差不多700人，这样相当于有个1/6人都在大一结束的时候就完成了数据结构的学习，如果进展的好的话，可以说是非常恐怖了。</p>\n<p>对于数据结构组我不太清楚，刘老师说了一下对算法组的安排，就是上面说的那样了，然后张老师在 VJ 上抓了 kuangbin 的专题，算是我们学习的大纲了。</p>\n<p>接下来防不胜防的，刘老师说要开一场个人赛，算是让我们找到状态，当时就整个人就方了。</p>\n<p>然后第二天上午就开始比赛了，由于过去一个多月了，记得也不是太清楚了，反正刚开始就是一堆的水题，唯一用到数据结构也就是单调栈和线段树，当时状态还不错，不过单调栈看了紫书才敲出来 ORZ 。最后 A 完7题后，就在看一个类似约瑟夫环的题，刚开始还以为是一个纯数学题，不过之前刷了很多的线段树的题，然后用朴素的思想想了一下，维护下标这个信息，突然发现用线段树可以搞，于是最后半个小时就非常开心的敲起了线段树，不得不说金桔的线段树的板子真的好用，然后自信的交上去，给了一个 Wrong Answer，然后比赛还有不到十分钟，本来没怎么有希望了，然后又去查了一下代码，区间更新 lazy 标记直接覆盖掉了，没累加，改掉之后交上去居然 A 了，非常开心，这时候也就五分钟了，于是和后面机位的 xuanhuang 聊了起来。开始第一场比赛 AK 可以说是非常开心了。</p>\n<p>比赛结束后，就是日常的训练了，不过刚开始我们队比赛状态并不怎么好，经常前两个小时 A 完题，就咸鱼了，三个人坐着没事干。</p>\n<p>然后就是每周的个人赛了，第一周的搜索算是非常开心，自己本身刷紫书的题的时候做了不少的搜索题，底子算是还可以，然后印象比较深的时候是一个题从 TLE 加剪枝优化，慢慢调成了 AC，非常开心，两次排名都是 Rank1。</p>\n<p>组队赛的时候，非常幸运可以参加多校赛，也算是去见识下区域赛的题型，发现数学题居多，上来就是莫比乌斯反演、矩阵快速幂、快速傅里叶变换、卷积…刚开始打的一脸懵逼，感觉也就是做前几到简单题就尽力。然后感觉对于区域赛，感觉也只能思维活跃一点，把直接力所能及的题，做出来就好了。然后区域赛尽可能去拿一个铜牌甚至是银牌，如果是银牌的话，那就非常稳了，整个大二就可以平稳的去刷金牌题和知识点了（幻想ing）。</p>\n<p>之后几个周都是一样的安排，整天不是刷题就是比赛，非常单调，值得一提的是最短路的测试赛又体验了一下 AK 的感觉，感觉自己对最短路理解也算是比较深了。</p>\n<p>集训前几天一直在搞图论，先去学了下网络流，裸的 FF 算法， EK 算法， Dinic 算法都看了一下，网络流专题也算是刷了一半。感觉网络流算是图论里面一个比较重要的知识点了，之前区域赛的网络赛中经常有网络流的题。刷网络流的时候顺便去看了一下二分图匹配的问题，感觉匹配这个东西有点神奇，好多看起来和图论无关的问题，都可以转化到二分图的模型上，然后跑最大匹配就能解决好多问题。</p>\n<p>之后因为实验室要开算法讲堂，然后就被叫去讲强连通缩点，于是用了一个星期咸鱼突刺了一下，算是弄清了强连通、边-双连通、点-双连通，然后就开始填算法讲堂的模板了，反反复复修正了得一两天，最后填的也不怎么样，等学离散数学的时候，一定要好好在图论上扩展一下！</p>\n<p>最后只能就这样将强连通了，感觉讲的算是比较失败的了，没学过的估计没听懂，学过的也基本上不用听的。对比之前学长讲的树链剖分，当时我只看卿学姐的视频学了一下概念，然后听学长讲的居然听懂了，然后拿着板子去切了几个题，也算是会基本的树链剖分了，其实树链剖分实质上就是一种映射，目的是将一条链上的点映射到若干段连续的区间上，然后对于链上的修改，就对这几段连续的区间进行修改，对于连续的区间修改可以用线段树进行维护。于是这样树链剖分的题重点还算是在线段树上。</p>\n<p>其他有意思的事情就是被派去辅导数据结构组的刷题了，然后发现他们是在做的 CCCC 的题，之前天梯赛训练的时候刷过的，然后给一个同学讲了一下树的同构的判断，发现直接好久没写过的指针了，我本以为给他写一个指针的比较好理解来着，最后写起来发现数组的好些太多了。另外一个就是看了一下目录树，之前在白书上面看到过，上面说的是静态排错，手写一个简单 shell ，也算是一个大模拟题了。看起来还是比较容易，记得天梯赛的时候，这个题曾经水过了20+分。</p>\n<p>最后就是结训赛了，其实也都是比较水的题，大家都当做娱乐来做的，其实也挺娱乐的，最开心的是做出来了一道区域赛的 DP 题，感觉还可以，最后罚时有点多Rank2，还可以。</p>\n<h1 id=\"三、一些感悟\"><a href=\"#三、一些感悟\" class=\"headerlink\" title=\"三、一些感悟\"></a>三、一些感悟</h1><p>一个多月以来，基本上都是自学算法，学习新算法也是自己去百度找资料、翻书，比起之前集训都是学长来讲内容，感觉自己的自学能力算是提高了不少。学习能力也是提高了不少，比如匈牙利算法，当初只用了一上午不到，就学完并刷了好多例题了。</p>\n<p>另外一个重要的提升是，最近比赛的时候不再像之前那样，每次前两三个小时做出来题，之后就没事干了，现在基本上五个小时都在看题，尤其是最近一场比赛，前三个半小时都是爆零，知道三个半小时后才切掉了第一题，之后半小时又切了一题，最后十分钟队友又切了一道 KMP 的题，顿时咸鱼翻身。</p>\n<p>之后也是打算继续搞算法竞赛，目测会打到大三吧。</p>\n"},{"title":"CCPC2017哈理工比赛总结","date":"2017-10-24T12:54:18.000Z","_content":"# 前言\n\n算是第一次参加的区域赛，老师又让写一份总结，于是凑一块写在这里好了。\n\n\n\n# 经历\n\n出发前准备的算是挺充分，当时还一直纠结着哈尔滨冷不冷，要带多厚的衣服过去，最后就随便带了几件，然后出发当天去超市买了一堆的东西，给手机缓存了几部动漫（路人女主，末日时，来自深渊，笨女孩...）。得出经验，只需要提前半小时能够到达火车站就好了。\n\n在火车上一晚上看完了笨女孩，然后白天的路上看完了末日时。期间还有打打王者荣耀和斗地主，感觉好颓啊，最逗的是一个别的队的傻子，和我们斗地主积分输成负的时候，就要清理下手机的数据，重新变成1000分。路上还算是挺好的，不过一天三顿吃泡面有点绝望，发现买的零食都不怎么好吃。另外值得一提的就是路上遇到了一个别人家的熊孩子，特别烦。\n\n到了哈尔滨刚下车也不算太冷，在火车站刚下车就见识到了东北的民风彪悍，门卫大爷开玩笑都是 “你过来，看我不揍你！”。然后晚上就搭车去旅馆了，还算是顺利。（不过我们的房间厕所没有门是几个意思啊？！）\n\n晚上一起去吃了夜宵（算是？），没好吃的然后回宿舍订了外卖，发现外卖能直接送到酒店的房间里，体验贼好！\n\n第二天睡到了九点半（晚上终末少女的旅行更新了，然后看了一集），发现步行只需要半小时就到学校了，报名领取发票也挺顺利的，然后在门外的牌子前面合影就去吃饭了。伙食感觉还行，至少有不少肉，能吃饱...米饭给的是有点少。\n\n下午就是一个关于游戏开发的演讲，然后不知不觉的睡着了...\n\n回去的时候就没什么意思了，因为时间问题结果没去成中央大街，只买了点超市里散卖的红肠。\n\n\n\n# 比赛\n\n热身赛的时候前两题出的是比较顺的，我强行要攒人品，然后全场第一发的WA是我交的，然后测了测Java后，把所有题都WA了一发。然后就开始认真出题了，第一题就是个暴力，然后另一个是猜结论，我还强行打了一个表，最后没出B题有点可惜，赛后我还以为是要用线段树进行区间加，后来看大佬们的解释，发现改一下递推的方式就可以用前缀和优化掉了。\n\n之后是正式赛，第一题，一个平时随手切的水题，比赛的时候居然卡了接近半小时，然后第二题也不算太难，卡了两个小时，最后吃午饭的时候讨论了下才A出来，可以说是相当绝望了，排名一直在100左右，觉得已经凉了，最后两个小时也没有出题。\n\n不过最后的时候，居然能有铜牌，当时就很开心了，觉得打的这么差居然还有个牌子...\n\n\n\n# 反思\n\n可能是第一次参加区域赛，状态不是很好，比赛也缺乏一些讨论，好多题型没见过，比如热身赛的DP用前缀和优化，之前没见过...\n\n还有好多题都是没用到复杂的数据结构算法，都是需要一些思维和技巧的题，感觉之后还是要加大点刷题量，多学一点套路和技巧，多打打CF。","source":"_posts/CCPC2017哈理工比赛总结.md","raw":"---\ntitle: CCPC2017哈理工比赛总结\ndate: 2017-10-24 20:54:18\ncategories: [历程]\ntags:\n---\n# 前言\n\n算是第一次参加的区域赛，老师又让写一份总结，于是凑一块写在这里好了。\n\n\n\n# 经历\n\n出发前准备的算是挺充分，当时还一直纠结着哈尔滨冷不冷，要带多厚的衣服过去，最后就随便带了几件，然后出发当天去超市买了一堆的东西，给手机缓存了几部动漫（路人女主，末日时，来自深渊，笨女孩...）。得出经验，只需要提前半小时能够到达火车站就好了。\n\n在火车上一晚上看完了笨女孩，然后白天的路上看完了末日时。期间还有打打王者荣耀和斗地主，感觉好颓啊，最逗的是一个别的队的傻子，和我们斗地主积分输成负的时候，就要清理下手机的数据，重新变成1000分。路上还算是挺好的，不过一天三顿吃泡面有点绝望，发现买的零食都不怎么好吃。另外值得一提的就是路上遇到了一个别人家的熊孩子，特别烦。\n\n到了哈尔滨刚下车也不算太冷，在火车站刚下车就见识到了东北的民风彪悍，门卫大爷开玩笑都是 “你过来，看我不揍你！”。然后晚上就搭车去旅馆了，还算是顺利。（不过我们的房间厕所没有门是几个意思啊？！）\n\n晚上一起去吃了夜宵（算是？），没好吃的然后回宿舍订了外卖，发现外卖能直接送到酒店的房间里，体验贼好！\n\n第二天睡到了九点半（晚上终末少女的旅行更新了，然后看了一集），发现步行只需要半小时就到学校了，报名领取发票也挺顺利的，然后在门外的牌子前面合影就去吃饭了。伙食感觉还行，至少有不少肉，能吃饱...米饭给的是有点少。\n\n下午就是一个关于游戏开发的演讲，然后不知不觉的睡着了...\n\n回去的时候就没什么意思了，因为时间问题结果没去成中央大街，只买了点超市里散卖的红肠。\n\n\n\n# 比赛\n\n热身赛的时候前两题出的是比较顺的，我强行要攒人品，然后全场第一发的WA是我交的，然后测了测Java后，把所有题都WA了一发。然后就开始认真出题了，第一题就是个暴力，然后另一个是猜结论，我还强行打了一个表，最后没出B题有点可惜，赛后我还以为是要用线段树进行区间加，后来看大佬们的解释，发现改一下递推的方式就可以用前缀和优化掉了。\n\n之后是正式赛，第一题，一个平时随手切的水题，比赛的时候居然卡了接近半小时，然后第二题也不算太难，卡了两个小时，最后吃午饭的时候讨论了下才A出来，可以说是相当绝望了，排名一直在100左右，觉得已经凉了，最后两个小时也没有出题。\n\n不过最后的时候，居然能有铜牌，当时就很开心了，觉得打的这么差居然还有个牌子...\n\n\n\n# 反思\n\n可能是第一次参加区域赛，状态不是很好，比赛也缺乏一些讨论，好多题型没见过，比如热身赛的DP用前缀和优化，之前没见过...\n\n还有好多题都是没用到复杂的数据结构算法，都是需要一些思维和技巧的题，感觉之后还是要加大点刷题量，多学一点套路和技巧，多打打CF。","slug":"CCPC2017哈理工比赛总结","published":1,"updated":"2017-10-25T11:16:53.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n920009y9id9qkbp4yk","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>算是第一次参加的区域赛，老师又让写一份总结，于是凑一块写在这里好了。</p>\n<h1 id=\"经历\"><a href=\"#经历\" class=\"headerlink\" title=\"经历\"></a>经历</h1><p>出发前准备的算是挺充分，当时还一直纠结着哈尔滨冷不冷，要带多厚的衣服过去，最后就随便带了几件，然后出发当天去超市买了一堆的东西，给手机缓存了几部动漫（路人女主，末日时，来自深渊，笨女孩…）。得出经验，只需要提前半小时能够到达火车站就好了。</p>\n<p>在火车上一晚上看完了笨女孩，然后白天的路上看完了末日时。期间还有打打王者荣耀和斗地主，感觉好颓啊，最逗的是一个别的队的傻子，和我们斗地主积分输成负的时候，就要清理下手机的数据，重新变成1000分。路上还算是挺好的，不过一天三顿吃泡面有点绝望，发现买的零食都不怎么好吃。另外值得一提的就是路上遇到了一个别人家的熊孩子，特别烦。</p>\n<p>到了哈尔滨刚下车也不算太冷，在火车站刚下车就见识到了东北的民风彪悍，门卫大爷开玩笑都是 “你过来，看我不揍你！”。然后晚上就搭车去旅馆了，还算是顺利。（不过我们的房间厕所没有门是几个意思啊？！）</p>\n<p>晚上一起去吃了夜宵（算是？），没好吃的然后回宿舍订了外卖，发现外卖能直接送到酒店的房间里，体验贼好！</p>\n<p>第二天睡到了九点半（晚上终末少女的旅行更新了，然后看了一集），发现步行只需要半小时就到学校了，报名领取发票也挺顺利的，然后在门外的牌子前面合影就去吃饭了。伙食感觉还行，至少有不少肉，能吃饱…米饭给的是有点少。</p>\n<p>下午就是一个关于游戏开发的演讲，然后不知不觉的睡着了…</p>\n<p>回去的时候就没什么意思了，因为时间问题结果没去成中央大街，只买了点超市里散卖的红肠。</p>\n<h1 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h1><p>热身赛的时候前两题出的是比较顺的，我强行要攒人品，然后全场第一发的WA是我交的，然后测了测Java后，把所有题都WA了一发。然后就开始认真出题了，第一题就是个暴力，然后另一个是猜结论，我还强行打了一个表，最后没出B题有点可惜，赛后我还以为是要用线段树进行区间加，后来看大佬们的解释，发现改一下递推的方式就可以用前缀和优化掉了。</p>\n<p>之后是正式赛，第一题，一个平时随手切的水题，比赛的时候居然卡了接近半小时，然后第二题也不算太难，卡了两个小时，最后吃午饭的时候讨论了下才A出来，可以说是相当绝望了，排名一直在100左右，觉得已经凉了，最后两个小时也没有出题。</p>\n<p>不过最后的时候，居然能有铜牌，当时就很开心了，觉得打的这么差居然还有个牌子…</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>可能是第一次参加区域赛，状态不是很好，比赛也缺乏一些讨论，好多题型没见过，比如热身赛的DP用前缀和优化，之前没见过…</p>\n<p>还有好多题都是没用到复杂的数据结构算法，都是需要一些思维和技巧的题，感觉之后还是要加大点刷题量，多学一点套路和技巧，多打打CF。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>算是第一次参加的区域赛，老师又让写一份总结，于是凑一块写在这里好了。</p>\n<h1 id=\"经历\"><a href=\"#经历\" class=\"headerlink\" title=\"经历\"></a>经历</h1><p>出发前准备的算是挺充分，当时还一直纠结着哈尔滨冷不冷，要带多厚的衣服过去，最后就随便带了几件，然后出发当天去超市买了一堆的东西，给手机缓存了几部动漫（路人女主，末日时，来自深渊，笨女孩…）。得出经验，只需要提前半小时能够到达火车站就好了。</p>\n<p>在火车上一晚上看完了笨女孩，然后白天的路上看完了末日时。期间还有打打王者荣耀和斗地主，感觉好颓啊，最逗的是一个别的队的傻子，和我们斗地主积分输成负的时候，就要清理下手机的数据，重新变成1000分。路上还算是挺好的，不过一天三顿吃泡面有点绝望，发现买的零食都不怎么好吃。另外值得一提的就是路上遇到了一个别人家的熊孩子，特别烦。</p>\n<p>到了哈尔滨刚下车也不算太冷，在火车站刚下车就见识到了东北的民风彪悍，门卫大爷开玩笑都是 “你过来，看我不揍你！”。然后晚上就搭车去旅馆了，还算是顺利。（不过我们的房间厕所没有门是几个意思啊？！）</p>\n<p>晚上一起去吃了夜宵（算是？），没好吃的然后回宿舍订了外卖，发现外卖能直接送到酒店的房间里，体验贼好！</p>\n<p>第二天睡到了九点半（晚上终末少女的旅行更新了，然后看了一集），发现步行只需要半小时就到学校了，报名领取发票也挺顺利的，然后在门外的牌子前面合影就去吃饭了。伙食感觉还行，至少有不少肉，能吃饱…米饭给的是有点少。</p>\n<p>下午就是一个关于游戏开发的演讲，然后不知不觉的睡着了…</p>\n<p>回去的时候就没什么意思了，因为时间问题结果没去成中央大街，只买了点超市里散卖的红肠。</p>\n<h1 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h1><p>热身赛的时候前两题出的是比较顺的，我强行要攒人品，然后全场第一发的WA是我交的，然后测了测Java后，把所有题都WA了一发。然后就开始认真出题了，第一题就是个暴力，然后另一个是猜结论，我还强行打了一个表，最后没出B题有点可惜，赛后我还以为是要用线段树进行区间加，后来看大佬们的解释，发现改一下递推的方式就可以用前缀和优化掉了。</p>\n<p>之后是正式赛，第一题，一个平时随手切的水题，比赛的时候居然卡了接近半小时，然后第二题也不算太难，卡了两个小时，最后吃午饭的时候讨论了下才A出来，可以说是相当绝望了，排名一直在100左右，觉得已经凉了，最后两个小时也没有出题。</p>\n<p>不过最后的时候，居然能有铜牌，当时就很开心了，觉得打的这么差居然还有个牌子…</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>可能是第一次参加区域赛，状态不是很好，比赛也缺乏一些讨论，好多题型没见过，比如热身赛的DP用前缀和优化，之前没见过…</p>\n<p>还有好多题都是没用到复杂的数据结构算法，都是需要一些思维和技巧的题，感觉之后还是要加大点刷题量，多学一点套路和技巧，多打打CF。</p>\n"},{"title":"818 - Cutting Chains （枚举子集 + 状态压缩）","date":"2017-03-14T11:13:13.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=759\n# 题目大意\n------------------\n给定n个环，其中有些环可以扣在一起，一个环可以和多个环扣在一起。\n现在需要求最少打开多少个环才能使这些环构成一条链。（当然打开了环还需要扣上，打开扣上算一次操作）\n# 解题过程\n--------------\n 既然是暴力里面的题，自然应该是暴力解决的。然后思路是枚举每一个环，枚举他的所有删边增边情况。大体用 IDA* 搞一搞。\n然后超时了，跑到第四层就要好长时间，第五层直接走不动了。\n然后就去翻了翻博客，原来是位运算枚举子集。\n# 题目分析\n------------------\n+ 用集合表示每一个环打不打开的情况，首先所有的环至多打开一次。\n+ 然后用二进制枚举枚举子集。\n+ 统计下每个环的度，如果度大于 2，那么一定构不成链。\n+ dfs 一下删除打开的环后，剩下的连通块有没有构成环。\n+ 最后以打开的环当做边，看看能否把这些独立的链连起来。如果打开的环数大于等于独立的链的条数减一，即可连起来。\n\n\n# __builtin_popcount() 函数使用\n```cpp\nint n;\n__builtin_popcount(n);\n```\n\n函数返回 n 的二进制表示中 1 的个数。\n用二进制枚举子集的时候可以用来统计 1 的个数。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint g[16][16], gmask[16];\nint visited[16];\n\nint dfs(int u, int p, int open, int n) {\n    visited[u] = 1;\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        if (g[u][i] == 0 || i == p)\n            continue;\n        if (visited[i] || dfs(i, u, open, n))\n            return 1;\n    }\n    return 0;\n}\n\nint checkChain(int open, int n) {\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        int t = gmask[i]^(gmask[i]&open);\n        int degree = __builtin_popcount(t);\n        if (degree > 2)\n            return 0;\n    }\n\n    int op = __builtin_popcount(open);\n    int comp = 0;\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        if (visited[i])\n            continue;\n        if (dfs(i, -1, open, n))\n            return 0;\n        comp++;\n    }\n    return op >= comp - 1;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n) && n) {\n        memset(g, 0, sizeof(g));\n        memset(gmask, 0, sizeof(gmask));\n        while (true) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            if (a == -1 && b == -1)\n                break;\n            a--, b--;\n            g[a][b] = g[b][a] = 1;\n            gmask[a] |= 1<<b, gmask[b] |= 1<<a;\n        }\n\n        int ret = 0x3f3f3f3f;\n        for (int i = 0; i < (1<<n); i++) {\n            int op = __builtin_popcount(i);\n            if (op >= ret)\n                continue;\n            if (checkChain(i, n))\n                ret = min(ret, op);\n        }\n        printf(\"Set %d: Minimum links to open is %d\\n\", ++cases, ret);\n    }\n}\n\n```","source":"_posts/818-Cutting-Chains-（枚举子集-状态压缩）.md","raw":"---\ntitle: 818 - Cutting Chains （枚举子集 + 状态压缩）\ndate: 2017-03-14 19:13:13\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=759\n# 题目大意\n------------------\n给定n个环，其中有些环可以扣在一起，一个环可以和多个环扣在一起。\n现在需要求最少打开多少个环才能使这些环构成一条链。（当然打开了环还需要扣上，打开扣上算一次操作）\n# 解题过程\n--------------\n 既然是暴力里面的题，自然应该是暴力解决的。然后思路是枚举每一个环，枚举他的所有删边增边情况。大体用 IDA* 搞一搞。\n然后超时了，跑到第四层就要好长时间，第五层直接走不动了。\n然后就去翻了翻博客，原来是位运算枚举子集。\n# 题目分析\n------------------\n+ 用集合表示每一个环打不打开的情况，首先所有的环至多打开一次。\n+ 然后用二进制枚举枚举子集。\n+ 统计下每个环的度，如果度大于 2，那么一定构不成链。\n+ dfs 一下删除打开的环后，剩下的连通块有没有构成环。\n+ 最后以打开的环当做边，看看能否把这些独立的链连起来。如果打开的环数大于等于独立的链的条数减一，即可连起来。\n\n\n# __builtin_popcount() 函数使用\n```cpp\nint n;\n__builtin_popcount(n);\n```\n\n函数返回 n 的二进制表示中 1 的个数。\n用二进制枚举子集的时候可以用来统计 1 的个数。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint g[16][16], gmask[16];\nint visited[16];\n\nint dfs(int u, int p, int open, int n) {\n    visited[u] = 1;\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        if (g[u][i] == 0 || i == p)\n            continue;\n        if (visited[i] || dfs(i, u, open, n))\n            return 1;\n    }\n    return 0;\n}\n\nint checkChain(int open, int n) {\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        int t = gmask[i]^(gmask[i]&open);\n        int degree = __builtin_popcount(t);\n        if (degree > 2)\n            return 0;\n    }\n\n    int op = __builtin_popcount(open);\n    int comp = 0;\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < n; i++) {\n        if ((open>>i)&1)\n            continue;\n        if (visited[i])\n            continue;\n        if (dfs(i, -1, open, n))\n            return 0;\n        comp++;\n    }\n    return op >= comp - 1;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n) && n) {\n        memset(g, 0, sizeof(g));\n        memset(gmask, 0, sizeof(gmask));\n        while (true) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            if (a == -1 && b == -1)\n                break;\n            a--, b--;\n            g[a][b] = g[b][a] = 1;\n            gmask[a] |= 1<<b, gmask[b] |= 1<<a;\n        }\n\n        int ret = 0x3f3f3f3f;\n        for (int i = 0; i < (1<<n); i++) {\n            int op = __builtin_popcount(i);\n            if (op >= ret)\n                continue;\n            if (checkChain(i, n))\n                ret = min(ret, op);\n        }\n        printf(\"Set %d: Minimum links to open is %d\\n\", ++cases, ret);\n    }\n}\n\n```","slug":"818-Cutting-Chains-（枚举子集-状态压缩）","published":1,"updated":"2017-07-23T02:51:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n93000by9id3al0un2y","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=759\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=759</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定n个环，其中有些环可以扣在一起，一个环可以和多个环扣在一起。<br>现在需要求最少打开多少个环才能使这些环构成一条链。（当然打开了环还需要扣上，打开扣上算一次操作）</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p> 既然是暴力里面的题，自然应该是暴力解决的。然后思路是枚举每一个环，枚举他的所有删边增边情况。大体用 IDA* 搞一搞。<br>然后超时了，跑到第四层就要好长时间，第五层直接走不动了。<br>然后就去翻了翻博客，原来是位运算枚举子集。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li>用集合表示每一个环打不打开的情况，首先所有的环至多打开一次。</li>\n<li>然后用二进制枚举枚举子集。</li>\n<li>统计下每个环的度，如果度大于 2，那么一定构不成链。</li>\n<li>dfs 一下删除打开的环后，剩下的连通块有没有构成环。</li>\n<li>最后以打开的环当做边，看看能否把这些独立的链连起来。如果打开的环数大于等于独立的链的条数减一，即可连起来。</li>\n</ul>\n<h1 id=\"builtin-popcount-函数使用\"><a href=\"#builtin-popcount-函数使用\" class=\"headerlink\" title=\"__builtin_popcount() 函数使用\"></a>__builtin_popcount() 函数使用</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\">__builtin_popcount(n);</div></pre></td></tr></table></figure>\n<p>函数返回 n 的二进制表示中 1 的个数。<br>用二进制枚举子集的时候可以用来统计 1 的个数。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> g[<span class=\"number\">16</span>][<span class=\"number\">16</span>], gmask[<span class=\"number\">16</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> visited[<span class=\"number\">16</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    visited[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (g[u][i] == <span class=\"number\">0</span> || i == p)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (visited[i] || dfs(i, u, open, n))</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">checkChain</span><span class=\"params\">(<span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> t = gmask[i]^(gmask[i]&amp;open);</div><div class=\"line\">        <span class=\"keyword\">int</span> degree = __builtin_popcount(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (degree &gt; <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> op = __builtin_popcount(open);</div><div class=\"line\">    <span class=\"keyword\">int</span> comp = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visited));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (visited[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dfs(i, <span class=\"number\">-1</span>, open, n))</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        comp++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> op &gt;= comp - <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(g, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(g));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(gmask, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(gmask));</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> a, b;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;a, &amp;b);</div><div class=\"line\">            <span class=\"keyword\">if</span> (a == <span class=\"number\">-1</span> &amp;&amp; b == <span class=\"number\">-1</span>)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            a--, b--;</div><div class=\"line\">            g[a][b] = g[b][a] = <span class=\"number\">1</span>;</div><div class=\"line\">            gmask[a] |= <span class=\"number\">1</span>&lt;&lt;b, gmask[b] |= <span class=\"number\">1</span>&lt;&lt;a;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span>&lt;&lt;n); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> op = __builtin_popcount(i);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op &gt;= ret)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (checkChain(i, n))</div><div class=\"line\">                ret = min(ret, op);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Set %d: Minimum links to open is %d\\n\"</span>, ++cases, ret);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=759\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=759</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定n个环，其中有些环可以扣在一起，一个环可以和多个环扣在一起。<br>现在需要求最少打开多少个环才能使这些环构成一条链。（当然打开了环还需要扣上，打开扣上算一次操作）</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p> 既然是暴力里面的题，自然应该是暴力解决的。然后思路是枚举每一个环，枚举他的所有删边增边情况。大体用 IDA* 搞一搞。<br>然后超时了，跑到第四层就要好长时间，第五层直接走不动了。<br>然后就去翻了翻博客，原来是位运算枚举子集。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li>用集合表示每一个环打不打开的情况，首先所有的环至多打开一次。</li>\n<li>然后用二进制枚举枚举子集。</li>\n<li>统计下每个环的度，如果度大于 2，那么一定构不成链。</li>\n<li>dfs 一下删除打开的环后，剩下的连通块有没有构成环。</li>\n<li>最后以打开的环当做边，看看能否把这些独立的链连起来。如果打开的环数大于等于独立的链的条数减一，即可连起来。</li>\n</ul>\n<h1 id=\"builtin-popcount-函数使用\"><a href=\"#builtin-popcount-函数使用\" class=\"headerlink\" title=\"__builtin_popcount() 函数使用\"></a>__builtin_popcount() 函数使用</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\">__builtin_popcount(n);</div></pre></td></tr></table></figure>\n<p>函数返回 n 的二进制表示中 1 的个数。<br>用二进制枚举子集的时候可以用来统计 1 的个数。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> g[<span class=\"number\">16</span>][<span class=\"number\">16</span>], gmask[<span class=\"number\">16</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> visited[<span class=\"number\">16</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    visited[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (g[u][i] == <span class=\"number\">0</span> || i == p)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (visited[i] || dfs(i, u, open, n))</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">checkChain</span><span class=\"params\">(<span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> t = gmask[i]^(gmask[i]&amp;open);</div><div class=\"line\">        <span class=\"keyword\">int</span> degree = __builtin_popcount(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (degree &gt; <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> op = __builtin_popcount(open);</div><div class=\"line\">    <span class=\"keyword\">int</span> comp = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(visited));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((open&gt;&gt;i)&amp;<span class=\"number\">1</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (visited[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dfs(i, <span class=\"number\">-1</span>, open, n))</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        comp++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> op &gt;= comp - <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(g, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(g));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(gmask, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(gmask));</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> a, b;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;a, &amp;b);</div><div class=\"line\">            <span class=\"keyword\">if</span> (a == <span class=\"number\">-1</span> &amp;&amp; b == <span class=\"number\">-1</span>)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            a--, b--;</div><div class=\"line\">            g[a][b] = g[b][a] = <span class=\"number\">1</span>;</div><div class=\"line\">            gmask[a] |= <span class=\"number\">1</span>&lt;&lt;b, gmask[b] |= <span class=\"number\">1</span>&lt;&lt;a;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span>&lt;&lt;n); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> op = __builtin_popcount(i);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op &gt;= ret)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (checkChain(i, n))</div><div class=\"line\">                ret = min(ret, op);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Set %d: Minimum links to open is %d\\n\"</span>, ++cases, ret);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"BZOJ1500 - 维修数列(Splay)","date":"2017-10-10T13:45:44.000Z","_content":"# 题目链接：\n\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=1500\n\n# 题目大意：\n\n给出 N 个数字和 M 次操作。\n\n分为下面六种操作：\n\n![](http://www.lydsy.com/JudgeOnline/images/1500_1.jpg)\n\n$M \\le 2\\times 10^4$，保证序列中的数字不会超过 $5 \\times 10^5$，并且插入数字的总数不超过$4 \\times 10^6$\n\n# 解题过程：\n\n调了一晚上才 A 掉，最后还是对照[金桔的代码](http://blog.csdn.net/a1s4z5/article/details/51890310)改的。\n\n# 题目分析：\n\n裸的 Splay 题，Splay的操作基本上都用上了，但是有好多坑点，下面列举一下：\n\n- GET-SUM 有可能 y = 0，这是计算区间时有可能右区间大于左区间。\n- 总共可能用到 $4 \\times 10^6$ 个节点，这样会超内存，但是同时在序列的节点最多只有$5 \\times 10^5$，所以要自己写内存回收。\n- 求最大子列和需要维护的信息是不对称的，当节点翻转时，对应维护的信息也需要翻转。\n- 当进行插入和删除操作的时候，需要维护一下根节点和插入到的父亲节点，主要是为了维护 size 这个值，因为 getid 需要用这个值二分，否则会 TLE。\n- 区间修改时需要两个变量，一个是 lazy 值，另一个是判断是否进行了修改。\n\n\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int maxn = 552345 + 10;\n\nint n, m;\n\nstruct Info {\n    int size;\n    ll sum;\n    ll lma, rma, tma;\n\n    Info(ll v = 0) {\n        size = 1;\n        sum = v;\n        lma = rma = tma = v;\n    }\n\n    void addIt(ll v) {\n        sum = v * size;\n        lma = rma = tma = max(sum, v);\n    }\n\n    //翻转区间信息\n    void revIt() {\n        swap(lma, rma);\n    }\n};\n\n//进行区间信息合并\nInfo operator+(const struct Info &a, const struct Info &b) {\n    Info rst(a.sum + b.sum);\n    rst.size = a.size + b.size;\n\n    rst.lma = max(a.lma, a.sum + b.lma);\n    rst.rma = max(b.rma, b.sum + a.rma);\n    rst.tma = max(max(a.tma, b.tma), a.rma + b.lma);\n\n    return rst;\n}\n\nstruct Node {\n    int son[2], fa;\n    ll val, lazy;\n    Info info;\n    bool change;\n    bool flip;\n\n    int &l() { return son[0]; }\n\n    int &r() { return son[1]; }\n\n    Node(ll v = 0) {\n        l() = r() = fa = -1;\n        val = v;\n        change = false;\n        info = Info(v);\n        lazy = 0;\n        flip = false;\n    }\n\n    void maintain();\n\n    void push_down();\n\n    //翻转和修改操作\n    void addIt(ll v) {\n        val = v;\n        lazy = v;\n        change = true;\n        info.addIt(v);\n    }\n\n    void revIt() {\n        flip ^= 1;\n        swap(l(), r());\n        info.revIt();\n    }\n} node[maxn];\n\nvoid Node::push_down() {\n    if (change) {\n        if (l() != -1) node[l()].addIt(lazy);\n        if (r() != -1) node[r()].addIt(lazy);\n        lazy = 0;\n        change = false;\n    }\n    if (flip) {\n        if (l() != -1) node[l()].revIt();\n        if (r() != -1) node[r()].revIt();\n        flip = false;\n    }\n}\n\nvoid Node::maintain() {\n    info = Info(val);\n    if (l() != -1) info = node[l()].info + info;\n    if (r() != -1) info = info + node[r()].info;\n}\n\nint ori(int st) {\n    int fa = node[st].fa;\n    if (fa == -1) return -1;\n    return st == node[fa].r();\n}\n\nvoid setc(int st, int sn, int d) {\n    if (st != -1) {\n        node[st].son[d] = sn;\n        node[st].maintain();\n    }\n    if (sn != -1) node[sn].fa = st;\n}\n\nvoid zg(int x) {\n    int st = node[x].fa, p = -1;\n\n    node[st].push_down();\n    node[x].push_down();\n\n    int d = ori(x), dst = ori(st);\n    if (st != -1) p = node[st].fa;\n    setc(st, node[x].son[d ^ 1], d);\n    setc(x, st, d ^ 1);\n    setc(p, x, dst);\n}\n\nint root;\n\n#define f(x) (node[x].fa)\n\nvoid splay(int x, int fa = -1) {\n    while (f(x) != fa) {\n        if (f(f(x)) == fa) zg(x);\n        else {\n            if (ori(x) == ori(f(x))) zg(f(x));\n            else zg(x);\n            zg(x);\n        }\n    }\n    if (fa == -1) root = x;\n}\n\nint getid(int v, int st) {\n    node[st].push_down();\n    int l = node[st].l();\n    int lsize = 1 + (l == -1 ? 0 : node[l].info.size);\n    if (v == lsize) return st;\n    int d = v > lsize;\n    if (d) v -= lsize;\n    return getid(v, node[st].son[d]);\n}\n\nint getseg(int l, int r) {\n    l--, r++;\n    l = getid(l + 1, root), r = getid(r + 1, root);\n    splay(r);\n    splay(l, r);\n    return node[l].r();\n}\n\n\n//进行插入和删除操作需要维护一下根节点和根节点的左儿子的区间信息\nvoid segMaintain() {\n    node[node[root].l()].maintain();\n    node[root].maintain();\n}\n\n//进行内存回收\nint head, tail;\nint value[maxn], nxt[maxn];\n\nint new_node(int v) {\n    int rst = head;\n    head = nxt[head];\n    node[rst] = Node(v);\n    return rst;\n}\n\nvoid recycle(int st) {\n    if (st == -1) return;\n    recycle(node[st].l());\n    recycle(node[st].r());\n    nxt[tail] = st;\n    tail = st;\n}\n\nvoid del(int l, int r) {\n    int pos = getseg(l, r);\n    setc(node[pos].fa, -1, 1);\n    recycle(pos);\n    segMaintain();\n}\n\nint build(int l, int r) {\n    int m = (l + r) >> 1;\n    int st = new_node(value[m]);\n\n    if (l < m) setc(st, build(l, m - 1), 0);\n    if (m < r) setc(st, build(m + 1, r), 1);\n    return st;\n}\n\n//初始化Splay\nint build(int n) {\n    head = 0;\n    for (int i = 0; i < maxn; i++) {\n        nxt[i] = i + 1;\n    }\n    tail = maxn - 1;\n    nxt[tail] = -1;\n    return build(0, n + 1);\n}\n\nvoid add(int l, int r, int v) {\n    int pos = getseg(l, r);\n    node[pos].addIt(v);\n}\n\nvoid insert(int pos, int p) {\n    int l = pos;\n    int r = pos + 1;\n    l = getid(l + 1, root);\n    r = getid(r + 1, root);\n    splay(r);\n    splay(l, r);\n    setc(l, p, 1);\n    segMaintain();\n}\n\nInfo query(int l, int r) {\n    return node[getseg(l, r)].info;\n}\n\nvoid flip(int l, int r) {\n    int pos = getseg(l, r);\n    node[pos].revIt();\n}\n\nint main() {\n    char op[11];\n    while (~scanf(\"%d %d\", &n, &m)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", value + i);\n        }\n        value[n + 1] = 0;\n        root = build(n);\n        while (m--) {\n            int x, y, z;\n            scanf(\"%s\", op);\n            if (strcmp(op, \"GET-SUM\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) {\n                    puts(\"0\");\n                    continue;\n                }\n                printf(\"%lld\\n\", query(x, x + y - 1).sum);\n            } else if (strcmp(op, \"MAX-SUM\") == 0) {\n                //因为插入了两个虚拟节点，所以要减二才是总共的节点数\n                printf(\"%lld\\n\", query(1, node[root].info.size - 2).tma);\n            } else if (strcmp(op, \"INSERT\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                for (int i = 1; i <= y; i++) {\n                    scanf(\"%d\", value + i);\n                }\n                //用 build 根据刚刚输入的值生成一个 Splay 再与主 Splay 合并\n                insert(x, build(1, y));\n            } else if (strcmp(op, \"DELETE\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                del(x, x + y - 1);\n            } else if (strcmp(op, \"REVERSE\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                flip(x, x + y - 1);\n            } else if (strcmp(op, \"MAKE-SAME\") == 0) {\n                scanf(\"%d %d %d\", &x, &y, &z);\n                if (y == 0) continue;\n                add(x, x + y - 1, z);\n            }\n        }\n    }\n}\n```","source":"_posts/BZOJ1500-维修数列-Splay.md","raw":"---\ntitle: BZOJ1500 - 维修数列(Splay)\ndate: 2017-10-10 21:45:44\ncategories: [ACM, 数据结构, Splay]\ntags:\n---\n# 题目链接：\n\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=1500\n\n# 题目大意：\n\n给出 N 个数字和 M 次操作。\n\n分为下面六种操作：\n\n![](http://www.lydsy.com/JudgeOnline/images/1500_1.jpg)\n\n$M \\le 2\\times 10^4$，保证序列中的数字不会超过 $5 \\times 10^5$，并且插入数字的总数不超过$4 \\times 10^6$\n\n# 解题过程：\n\n调了一晚上才 A 掉，最后还是对照[金桔的代码](http://blog.csdn.net/a1s4z5/article/details/51890310)改的。\n\n# 题目分析：\n\n裸的 Splay 题，Splay的操作基本上都用上了，但是有好多坑点，下面列举一下：\n\n- GET-SUM 有可能 y = 0，这是计算区间时有可能右区间大于左区间。\n- 总共可能用到 $4 \\times 10^6$ 个节点，这样会超内存，但是同时在序列的节点最多只有$5 \\times 10^5$，所以要自己写内存回收。\n- 求最大子列和需要维护的信息是不对称的，当节点翻转时，对应维护的信息也需要翻转。\n- 当进行插入和删除操作的时候，需要维护一下根节点和插入到的父亲节点，主要是为了维护 size 这个值，因为 getid 需要用这个值二分，否则会 TLE。\n- 区间修改时需要两个变量，一个是 lazy 值，另一个是判断是否进行了修改。\n\n\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int maxn = 552345 + 10;\n\nint n, m;\n\nstruct Info {\n    int size;\n    ll sum;\n    ll lma, rma, tma;\n\n    Info(ll v = 0) {\n        size = 1;\n        sum = v;\n        lma = rma = tma = v;\n    }\n\n    void addIt(ll v) {\n        sum = v * size;\n        lma = rma = tma = max(sum, v);\n    }\n\n    //翻转区间信息\n    void revIt() {\n        swap(lma, rma);\n    }\n};\n\n//进行区间信息合并\nInfo operator+(const struct Info &a, const struct Info &b) {\n    Info rst(a.sum + b.sum);\n    rst.size = a.size + b.size;\n\n    rst.lma = max(a.lma, a.sum + b.lma);\n    rst.rma = max(b.rma, b.sum + a.rma);\n    rst.tma = max(max(a.tma, b.tma), a.rma + b.lma);\n\n    return rst;\n}\n\nstruct Node {\n    int son[2], fa;\n    ll val, lazy;\n    Info info;\n    bool change;\n    bool flip;\n\n    int &l() { return son[0]; }\n\n    int &r() { return son[1]; }\n\n    Node(ll v = 0) {\n        l() = r() = fa = -1;\n        val = v;\n        change = false;\n        info = Info(v);\n        lazy = 0;\n        flip = false;\n    }\n\n    void maintain();\n\n    void push_down();\n\n    //翻转和修改操作\n    void addIt(ll v) {\n        val = v;\n        lazy = v;\n        change = true;\n        info.addIt(v);\n    }\n\n    void revIt() {\n        flip ^= 1;\n        swap(l(), r());\n        info.revIt();\n    }\n} node[maxn];\n\nvoid Node::push_down() {\n    if (change) {\n        if (l() != -1) node[l()].addIt(lazy);\n        if (r() != -1) node[r()].addIt(lazy);\n        lazy = 0;\n        change = false;\n    }\n    if (flip) {\n        if (l() != -1) node[l()].revIt();\n        if (r() != -1) node[r()].revIt();\n        flip = false;\n    }\n}\n\nvoid Node::maintain() {\n    info = Info(val);\n    if (l() != -1) info = node[l()].info + info;\n    if (r() != -1) info = info + node[r()].info;\n}\n\nint ori(int st) {\n    int fa = node[st].fa;\n    if (fa == -1) return -1;\n    return st == node[fa].r();\n}\n\nvoid setc(int st, int sn, int d) {\n    if (st != -1) {\n        node[st].son[d] = sn;\n        node[st].maintain();\n    }\n    if (sn != -1) node[sn].fa = st;\n}\n\nvoid zg(int x) {\n    int st = node[x].fa, p = -1;\n\n    node[st].push_down();\n    node[x].push_down();\n\n    int d = ori(x), dst = ori(st);\n    if (st != -1) p = node[st].fa;\n    setc(st, node[x].son[d ^ 1], d);\n    setc(x, st, d ^ 1);\n    setc(p, x, dst);\n}\n\nint root;\n\n#define f(x) (node[x].fa)\n\nvoid splay(int x, int fa = -1) {\n    while (f(x) != fa) {\n        if (f(f(x)) == fa) zg(x);\n        else {\n            if (ori(x) == ori(f(x))) zg(f(x));\n            else zg(x);\n            zg(x);\n        }\n    }\n    if (fa == -1) root = x;\n}\n\nint getid(int v, int st) {\n    node[st].push_down();\n    int l = node[st].l();\n    int lsize = 1 + (l == -1 ? 0 : node[l].info.size);\n    if (v == lsize) return st;\n    int d = v > lsize;\n    if (d) v -= lsize;\n    return getid(v, node[st].son[d]);\n}\n\nint getseg(int l, int r) {\n    l--, r++;\n    l = getid(l + 1, root), r = getid(r + 1, root);\n    splay(r);\n    splay(l, r);\n    return node[l].r();\n}\n\n\n//进行插入和删除操作需要维护一下根节点和根节点的左儿子的区间信息\nvoid segMaintain() {\n    node[node[root].l()].maintain();\n    node[root].maintain();\n}\n\n//进行内存回收\nint head, tail;\nint value[maxn], nxt[maxn];\n\nint new_node(int v) {\n    int rst = head;\n    head = nxt[head];\n    node[rst] = Node(v);\n    return rst;\n}\n\nvoid recycle(int st) {\n    if (st == -1) return;\n    recycle(node[st].l());\n    recycle(node[st].r());\n    nxt[tail] = st;\n    tail = st;\n}\n\nvoid del(int l, int r) {\n    int pos = getseg(l, r);\n    setc(node[pos].fa, -1, 1);\n    recycle(pos);\n    segMaintain();\n}\n\nint build(int l, int r) {\n    int m = (l + r) >> 1;\n    int st = new_node(value[m]);\n\n    if (l < m) setc(st, build(l, m - 1), 0);\n    if (m < r) setc(st, build(m + 1, r), 1);\n    return st;\n}\n\n//初始化Splay\nint build(int n) {\n    head = 0;\n    for (int i = 0; i < maxn; i++) {\n        nxt[i] = i + 1;\n    }\n    tail = maxn - 1;\n    nxt[tail] = -1;\n    return build(0, n + 1);\n}\n\nvoid add(int l, int r, int v) {\n    int pos = getseg(l, r);\n    node[pos].addIt(v);\n}\n\nvoid insert(int pos, int p) {\n    int l = pos;\n    int r = pos + 1;\n    l = getid(l + 1, root);\n    r = getid(r + 1, root);\n    splay(r);\n    splay(l, r);\n    setc(l, p, 1);\n    segMaintain();\n}\n\nInfo query(int l, int r) {\n    return node[getseg(l, r)].info;\n}\n\nvoid flip(int l, int r) {\n    int pos = getseg(l, r);\n    node[pos].revIt();\n}\n\nint main() {\n    char op[11];\n    while (~scanf(\"%d %d\", &n, &m)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", value + i);\n        }\n        value[n + 1] = 0;\n        root = build(n);\n        while (m--) {\n            int x, y, z;\n            scanf(\"%s\", op);\n            if (strcmp(op, \"GET-SUM\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) {\n                    puts(\"0\");\n                    continue;\n                }\n                printf(\"%lld\\n\", query(x, x + y - 1).sum);\n            } else if (strcmp(op, \"MAX-SUM\") == 0) {\n                //因为插入了两个虚拟节点，所以要减二才是总共的节点数\n                printf(\"%lld\\n\", query(1, node[root].info.size - 2).tma);\n            } else if (strcmp(op, \"INSERT\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                for (int i = 1; i <= y; i++) {\n                    scanf(\"%d\", value + i);\n                }\n                //用 build 根据刚刚输入的值生成一个 Splay 再与主 Splay 合并\n                insert(x, build(1, y));\n            } else if (strcmp(op, \"DELETE\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                del(x, x + y - 1);\n            } else if (strcmp(op, \"REVERSE\") == 0) {\n                scanf(\"%d %d\", &x, &y);\n                if (y == 0) continue;\n                flip(x, x + y - 1);\n            } else if (strcmp(op, \"MAKE-SAME\") == 0) {\n                scanf(\"%d %d %d\", &x, &y, &z);\n                if (y == 0) continue;\n                add(x, x + y - 1, z);\n            }\n        }\n    }\n}\n```","slug":"BZOJ1500-维修数列-Splay","published":1,"updated":"2017-10-10T14:07:33.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n95000cy9id2tyd3mpp","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1500\" target=\"_blank\" rel=\"external\">http://www.lydsy.com/JudgeOnline/problem.php?id=1500</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 N 个数字和 M 次操作。</p>\n<p>分为下面六种操作：</p>\n<p><img src=\"http://www.lydsy.com/JudgeOnline/images/1500_1.jpg\" alt=\"\"></p>\n<p>$M \\le 2\\times 10^4$，保证序列中的数字不会超过 $5 \\times 10^5$，并且插入数字的总数不超过$4 \\times 10^6$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>调了一晚上才 A 掉，最后还是对照<a href=\"http://blog.csdn.net/a1s4z5/article/details/51890310\" target=\"_blank\" rel=\"external\">金桔的代码</a>改的。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>裸的 Splay 题，Splay的操作基本上都用上了，但是有好多坑点，下面列举一下：</p>\n<ul>\n<li>GET-SUM 有可能 y = 0，这是计算区间时有可能右区间大于左区间。</li>\n<li>总共可能用到 $4 \\times 10^6$ 个节点，这样会超内存，但是同时在序列的节点最多只有$5 \\times 10^5$，所以要自己写内存回收。</li>\n<li>求最大子列和需要维护的信息是不对称的，当节点翻转时，对应维护的信息也需要翻转。</li>\n<li>当进行插入和删除操作的时候，需要维护一下根节点和插入到的父亲节点，主要是为了维护 size 这个值，因为 getid 需要用这个值二分，否则会 TLE。</li>\n<li>区间修改时需要两个变量，一个是 lazy 值，另一个是判断是否进行了修改。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">552345</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> size;</div><div class=\"line\">    ll sum;</div><div class=\"line\">    ll lma, rma, tma;</div><div class=\"line\"></div><div class=\"line\">    Info(ll v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        size = <span class=\"number\">1</span>;</div><div class=\"line\">        sum = v;</div><div class=\"line\">        lma = rma = tma = v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(ll v)</span> </span>&#123;</div><div class=\"line\">        sum = v * size;</div><div class=\"line\">        lma = rma = tma = max(sum, v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//翻转区间信息</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revIt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        swap(lma, rma);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行区间信息合并</span></div><div class=\"line\">Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> struct Info &amp;a, <span class=\"keyword\">const</span> struct Info &amp;b) &#123;</div><div class=\"line\">    <span class=\"function\">Info <span class=\"title\">rst</span><span class=\"params\">(a.sum + b.sum)</span></span>;</div><div class=\"line\">    rst.size = a.size + b.size;</div><div class=\"line\"></div><div class=\"line\">    rst.lma = max(a.lma, a.sum + b.lma);</div><div class=\"line\">    rst.rma = max(b.rma, b.sum + a.rma);</div><div class=\"line\">    rst.tma = max(max(a.tma, b.tma), a.rma + b.lma);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> son[<span class=\"number\">2</span>], fa;</div><div class=\"line\">    ll val, lazy;</div><div class=\"line\">    Info info;</div><div class=\"line\">    <span class=\"keyword\">bool</span> change;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flip;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">l</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">r</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    Node(ll v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        l() = r() = fa = <span class=\"number\">-1</span>;</div><div class=\"line\">        val = v;</div><div class=\"line\">        change = <span class=\"literal\">false</span>;</div><div class=\"line\">        info = Info(v);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        flip = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//翻转和修改操作</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(ll v)</span> </span>&#123;</div><div class=\"line\">        val = v;</div><div class=\"line\">        lazy = v;</div><div class=\"line\">        change = <span class=\"literal\">true</span>;</div><div class=\"line\">        info.addIt(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revIt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        flip ^= <span class=\"number\">1</span>;</div><div class=\"line\">        swap(l(), r());</div><div class=\"line\">        info.revIt();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; node[maxn];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> Node::push_down() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (change) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].addIt(lazy);</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].addIt(lazy);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        change = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flip) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].revIt();</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].revIt();</div><div class=\"line\">        flip = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> Node::maintain() &#123;</div><div class=\"line\">    info = Info(val);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) info = node[l()].info + info;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) info = info + node[r()].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ori</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = node[st].fa;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> st == node[fa].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setc</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> sn, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        node[st].son[d] = sn;</div><div class=\"line\">        node[st].maintain();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sn != <span class=\"number\">-1</span>) node[sn].fa = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zg</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = node[x].fa, p = <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    node[x].push_down();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> d = ori(x), dst = ori(st);</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) p = node[st].fa;</div><div class=\"line\">    setc(st, node[x].son[d ^ <span class=\"number\">1</span>], d);</div><div class=\"line\">    setc(x, st, d ^ <span class=\"number\">1</span>);</div><div class=\"line\">    setc(p, x, dst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f(x) (node[x].fa)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> fa = <span class=\"number\">-1</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (f(x) != fa) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (f(f(x)) == fa) zg(x);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ori(x) == ori(f(x))) zg(f(x));</div><div class=\"line\">            <span class=\"keyword\">else</span> zg(x);</div><div class=\"line\">            zg(x);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) root = x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getid</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = node[st].l();</div><div class=\"line\">    <span class=\"keyword\">int</span> lsize = <span class=\"number\">1</span> + (l == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : node[l].info.size);</div><div class=\"line\">    <span class=\"keyword\">if</span> (v == lsize) <span class=\"keyword\">return</span> st;</div><div class=\"line\">    <span class=\"keyword\">int</span> d = v &gt; lsize;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d) v -= lsize;</div><div class=\"line\">    <span class=\"keyword\">return</span> getid(v, node[st].son[d]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getseg</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    l--, r++;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root), r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    <span class=\"keyword\">return</span> node[l].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行插入和删除操作需要维护一下根节点和根节点的左儿子的区间信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">segMaintain</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    node[node[root].l()].maintain();</div><div class=\"line\">    node[root].maintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行内存回收</span></div><div class=\"line\"><span class=\"keyword\">int</span> head, tail;</div><div class=\"line\"><span class=\"keyword\">int</span> value[maxn], nxt[maxn];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">new_node</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = head;</div><div class=\"line\">    head = nxt[head];</div><div class=\"line\">    node[rst] = Node(v);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycle</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    recycle(node[st].l());</div><div class=\"line\">    recycle(node[st].r());</div><div class=\"line\">    nxt[tail] = st;</div><div class=\"line\">    tail = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    setc(node[pos].fa, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    recycle(pos);</div><div class=\"line\">    segMaintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = new_node(value[m]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt; m) setc(st, build(l, m - <span class=\"number\">1</span>), <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m &lt; r) setc(st, build(m + <span class=\"number\">1</span>, r), <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//初始化Splay</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    head = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxn; i++) &#123;</div><div class=\"line\">        nxt[i] = i + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    tail = maxn - <span class=\"number\">1</span>;</div><div class=\"line\">    nxt[tail] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].addIt(v);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> p)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> l = pos;</div><div class=\"line\">    <span class=\"keyword\">int</span> r = pos + <span class=\"number\">1</span>;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root);</div><div class=\"line\">    r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    setc(l, p, <span class=\"number\">1</span>);</div><div class=\"line\">    segMaintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> node[getseg(l, r)].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flip</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].revIt();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">11</span>];</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, value + i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        value[n + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        root = build(n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y, z;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, op);</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"GET-SUM\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"0\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(x, x + y - <span class=\"number\">1</span>).sum);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"MAX-SUM\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//因为插入了两个虚拟节点，所以要减二才是总共的节点数</span></div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, node[root].info.size - <span class=\"number\">2</span>).tma);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"INSERT\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= y; i++) &#123;</div><div class=\"line\">                    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, value + i);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//用 build 根据刚刚输入的值生成一个 Splay 再与主 Splay 合并</span></div><div class=\"line\">                insert(x, build(<span class=\"number\">1</span>, y));</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"DELETE\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                del(x, x + y - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"REVERSE\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                flip(x, x + y - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"MAKE-SAME\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;z);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                add(x, x + y - <span class=\"number\">1</span>, z);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1500\" target=\"_blank\" rel=\"external\">http://www.lydsy.com/JudgeOnline/problem.php?id=1500</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 N 个数字和 M 次操作。</p>\n<p>分为下面六种操作：</p>\n<p><img src=\"http://www.lydsy.com/JudgeOnline/images/1500_1.jpg\" alt=\"\"></p>\n<p>$M \\le 2\\times 10^4$，保证序列中的数字不会超过 $5 \\times 10^5$，并且插入数字的总数不超过$4 \\times 10^6$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>调了一晚上才 A 掉，最后还是对照<a href=\"http://blog.csdn.net/a1s4z5/article/details/51890310\" target=\"_blank\" rel=\"external\">金桔的代码</a>改的。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>裸的 Splay 题，Splay的操作基本上都用上了，但是有好多坑点，下面列举一下：</p>\n<ul>\n<li>GET-SUM 有可能 y = 0，这是计算区间时有可能右区间大于左区间。</li>\n<li>总共可能用到 $4 \\times 10^6$ 个节点，这样会超内存，但是同时在序列的节点最多只有$5 \\times 10^5$，所以要自己写内存回收。</li>\n<li>求最大子列和需要维护的信息是不对称的，当节点翻转时，对应维护的信息也需要翻转。</li>\n<li>当进行插入和删除操作的时候，需要维护一下根节点和插入到的父亲节点，主要是为了维护 size 这个值，因为 getid 需要用这个值二分，否则会 TLE。</li>\n<li>区间修改时需要两个变量，一个是 lazy 值，另一个是判断是否进行了修改。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">552345</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> size;</div><div class=\"line\">    ll sum;</div><div class=\"line\">    ll lma, rma, tma;</div><div class=\"line\"></div><div class=\"line\">    Info(ll v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        size = <span class=\"number\">1</span>;</div><div class=\"line\">        sum = v;</div><div class=\"line\">        lma = rma = tma = v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(ll v)</span> </span>&#123;</div><div class=\"line\">        sum = v * size;</div><div class=\"line\">        lma = rma = tma = max(sum, v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//翻转区间信息</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revIt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        swap(lma, rma);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行区间信息合并</span></div><div class=\"line\">Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> struct Info &amp;a, <span class=\"keyword\">const</span> struct Info &amp;b) &#123;</div><div class=\"line\">    <span class=\"function\">Info <span class=\"title\">rst</span><span class=\"params\">(a.sum + b.sum)</span></span>;</div><div class=\"line\">    rst.size = a.size + b.size;</div><div class=\"line\"></div><div class=\"line\">    rst.lma = max(a.lma, a.sum + b.lma);</div><div class=\"line\">    rst.rma = max(b.rma, b.sum + a.rma);</div><div class=\"line\">    rst.tma = max(max(a.tma, b.tma), a.rma + b.lma);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> son[<span class=\"number\">2</span>], fa;</div><div class=\"line\">    ll val, lazy;</div><div class=\"line\">    Info info;</div><div class=\"line\">    <span class=\"keyword\">bool</span> change;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flip;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">l</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">r</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    Node(ll v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        l() = r() = fa = <span class=\"number\">-1</span>;</div><div class=\"line\">        val = v;</div><div class=\"line\">        change = <span class=\"literal\">false</span>;</div><div class=\"line\">        info = Info(v);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        flip = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//翻转和修改操作</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(ll v)</span> </span>&#123;</div><div class=\"line\">        val = v;</div><div class=\"line\">        lazy = v;</div><div class=\"line\">        change = <span class=\"literal\">true</span>;</div><div class=\"line\">        info.addIt(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revIt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        flip ^= <span class=\"number\">1</span>;</div><div class=\"line\">        swap(l(), r());</div><div class=\"line\">        info.revIt();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; node[maxn];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> Node::push_down() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (change) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].addIt(lazy);</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].addIt(lazy);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        change = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flip) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].revIt();</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].revIt();</div><div class=\"line\">        flip = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> Node::maintain() &#123;</div><div class=\"line\">    info = Info(val);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) info = node[l()].info + info;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) info = info + node[r()].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ori</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = node[st].fa;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> st == node[fa].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setc</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> sn, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        node[st].son[d] = sn;</div><div class=\"line\">        node[st].maintain();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sn != <span class=\"number\">-1</span>) node[sn].fa = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zg</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = node[x].fa, p = <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    node[x].push_down();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> d = ori(x), dst = ori(st);</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) p = node[st].fa;</div><div class=\"line\">    setc(st, node[x].son[d ^ <span class=\"number\">1</span>], d);</div><div class=\"line\">    setc(x, st, d ^ <span class=\"number\">1</span>);</div><div class=\"line\">    setc(p, x, dst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f(x) (node[x].fa)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> fa = <span class=\"number\">-1</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (f(x) != fa) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (f(f(x)) == fa) zg(x);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ori(x) == ori(f(x))) zg(f(x));</div><div class=\"line\">            <span class=\"keyword\">else</span> zg(x);</div><div class=\"line\">            zg(x);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) root = x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getid</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = node[st].l();</div><div class=\"line\">    <span class=\"keyword\">int</span> lsize = <span class=\"number\">1</span> + (l == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : node[l].info.size);</div><div class=\"line\">    <span class=\"keyword\">if</span> (v == lsize) <span class=\"keyword\">return</span> st;</div><div class=\"line\">    <span class=\"keyword\">int</span> d = v &gt; lsize;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d) v -= lsize;</div><div class=\"line\">    <span class=\"keyword\">return</span> getid(v, node[st].son[d]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getseg</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    l--, r++;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root), r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    <span class=\"keyword\">return</span> node[l].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行插入和删除操作需要维护一下根节点和根节点的左儿子的区间信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">segMaintain</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    node[node[root].l()].maintain();</div><div class=\"line\">    node[root].maintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行内存回收</span></div><div class=\"line\"><span class=\"keyword\">int</span> head, tail;</div><div class=\"line\"><span class=\"keyword\">int</span> value[maxn], nxt[maxn];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">new_node</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = head;</div><div class=\"line\">    head = nxt[head];</div><div class=\"line\">    node[rst] = Node(v);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycle</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    recycle(node[st].l());</div><div class=\"line\">    recycle(node[st].r());</div><div class=\"line\">    nxt[tail] = st;</div><div class=\"line\">    tail = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    setc(node[pos].fa, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    recycle(pos);</div><div class=\"line\">    segMaintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = new_node(value[m]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt; m) setc(st, build(l, m - <span class=\"number\">1</span>), <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m &lt; r) setc(st, build(m + <span class=\"number\">1</span>, r), <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//初始化Splay</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    head = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxn; i++) &#123;</div><div class=\"line\">        nxt[i] = i + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    tail = maxn - <span class=\"number\">1</span>;</div><div class=\"line\">    nxt[tail] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].addIt(v);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> p)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> l = pos;</div><div class=\"line\">    <span class=\"keyword\">int</span> r = pos + <span class=\"number\">1</span>;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root);</div><div class=\"line\">    r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    setc(l, p, <span class=\"number\">1</span>);</div><div class=\"line\">    segMaintain();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> node[getseg(l, r)].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flip</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].revIt();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">11</span>];</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, value + i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        value[n + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        root = build(n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y, z;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, op);</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"GET-SUM\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"0\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(x, x + y - <span class=\"number\">1</span>).sum);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"MAX-SUM\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//因为插入了两个虚拟节点，所以要减二才是总共的节点数</span></div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, node[root].info.size - <span class=\"number\">2</span>).tma);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"INSERT\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= y; i++) &#123;</div><div class=\"line\">                    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, value + i);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//用 build 根据刚刚输入的值生成一个 Splay 再与主 Splay 合并</span></div><div class=\"line\">                insert(x, build(<span class=\"number\">1</span>, y));</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"DELETE\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                del(x, x + y - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"REVERSE\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                flip(x, x + y - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(op, <span class=\"string\">\"MAKE-SAME\"</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;z);</div><div class=\"line\">                <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                add(x, x + y - <span class=\"number\">1</span>, z);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"AC自动机（模板）","date":"2017-09-25T06:13:33.000Z","_content":"\n\n# 感谢&资料：\n\n主要参考紫书的写法，其他的写法都用到了指针，不太喜欢指针...\n\n因为紫书没有完整的代码，然后参考了一下 [dalao 的博客](http://www.acyume.com/archives/19)。\n\n\n\n# 简介：\n\nAC自动机主要解决的是字符串匹配问题，不同于 KMP 的是，AC 自动机可以进行多个模式串的匹配。KMP 的失配指针是一个线性的数组，但是 AC 自动机是多个模式串匹配，所以适配指针是一个树型的结构。\n\n\n\n# 代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//字典树的最大节点个数\nconst int MAX = 250001;\nconst int N = 1000010;\n//有多少个不同的字符\nconst int SIGMA_SIZE = 26;\n\n//字典树的节点\nint ch[MAX][SIGMA_SIZE];\n//当前节点是否为一个模式串的结尾， 当前节点的上一个模式串结尾， fail指针\nint val[MAX], last[MAX], f[MAX], sz;\nint ANS;\n\nvoid init() {\n    sz = 1;\n    memset(ch, 0, sizeof(ch));\n    memset(val, 0, sizeof(val));\n    memset(f, 0, sizeof(f));\n    memset(last, 0, sizeof(last));\n}\n\nint idx(char c) {\n    return c - 'a';\n}\n\n//更新答案\nvoid add(int u) {\n    while (u) {\n        ANS += val[u];\n        val[u] = 0;\n        u = last[u];\n    }\n}\n\n//添加模式串\nvoid Creat(char *s) {\n    int u = 0, len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        int c = idx(s[i]);\n        if (!ch[u][c]) ch[u][c] = sz++;\n        u = ch[u][c];\n    }\n    val[u]++;\n}\n\n\n//获得fail指针\nvoid getFail() {\n    queue<int> q;\n    for (int i = 0; i < SIGMA_SIZE; i++)\n        if (ch[0][i]) q.push(ch[0][i]);\n\n    while (!q.empty()) {\n        int r = q.front(); q.pop();\n        for (int c = 0; c < SIGMA_SIZE; c++) {\n            int u = ch[r][c];\n            if (!u) continue;\n            q.push(u);\n            int v = f[r];\n            //和kmp相似，和根据父亲的fail指针获得当前的\n            while (v && ch[v][c] == 0) v = f[v];\n            f[u] = ch[v][c];\n            //更新last\n            last[u] = val[f[u]] ? f[u] : last[f[u]];\n        }\n    }\n}\n\n//进行匹配\nvoid find(char * T) {\n    int len = strlen(T), j = 0;\n    for (int i = 0; i < len; i++) {\n        int c = idx(T[i]);\n        while (j && ch[j][c] == 0) j = f[j];\n        j = ch[j][c];\n        //如果当前是模式串的结尾，那么更新答案\n        //else if 里是处理一个模式串包含另一个模式串的情况\n        if (val[j]) add(j);\n        else if (last[j]) add(last[j]);\n    }\n}\n\nchar str[N];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        int n;\n        scanf(\"%d\", &n);\n        while (n--) {\n            scanf(\"%s\", str);\n            Creat(str);\n        }\n        getFail();\n        scanf(\"%s\", str);\n        ANS = 0;\n        find(str);\n        printf(\"%d\\n\", ANS);\n    }\n}\n```\n\n","source":"_posts/AC自动机（模板）.md","raw":"---\ntitle: AC自动机（模板）\ndate: 2017-09-25 14:13:33\ncategories: [ACM, 字符串, AC自动机]\ntags:\n---\n\n\n# 感谢&资料：\n\n主要参考紫书的写法，其他的写法都用到了指针，不太喜欢指针...\n\n因为紫书没有完整的代码，然后参考了一下 [dalao 的博客](http://www.acyume.com/archives/19)。\n\n\n\n# 简介：\n\nAC自动机主要解决的是字符串匹配问题，不同于 KMP 的是，AC 自动机可以进行多个模式串的匹配。KMP 的失配指针是一个线性的数组，但是 AC 自动机是多个模式串匹配，所以适配指针是一个树型的结构。\n\n\n\n# 代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//字典树的最大节点个数\nconst int MAX = 250001;\nconst int N = 1000010;\n//有多少个不同的字符\nconst int SIGMA_SIZE = 26;\n\n//字典树的节点\nint ch[MAX][SIGMA_SIZE];\n//当前节点是否为一个模式串的结尾， 当前节点的上一个模式串结尾， fail指针\nint val[MAX], last[MAX], f[MAX], sz;\nint ANS;\n\nvoid init() {\n    sz = 1;\n    memset(ch, 0, sizeof(ch));\n    memset(val, 0, sizeof(val));\n    memset(f, 0, sizeof(f));\n    memset(last, 0, sizeof(last));\n}\n\nint idx(char c) {\n    return c - 'a';\n}\n\n//更新答案\nvoid add(int u) {\n    while (u) {\n        ANS += val[u];\n        val[u] = 0;\n        u = last[u];\n    }\n}\n\n//添加模式串\nvoid Creat(char *s) {\n    int u = 0, len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        int c = idx(s[i]);\n        if (!ch[u][c]) ch[u][c] = sz++;\n        u = ch[u][c];\n    }\n    val[u]++;\n}\n\n\n//获得fail指针\nvoid getFail() {\n    queue<int> q;\n    for (int i = 0; i < SIGMA_SIZE; i++)\n        if (ch[0][i]) q.push(ch[0][i]);\n\n    while (!q.empty()) {\n        int r = q.front(); q.pop();\n        for (int c = 0; c < SIGMA_SIZE; c++) {\n            int u = ch[r][c];\n            if (!u) continue;\n            q.push(u);\n            int v = f[r];\n            //和kmp相似，和根据父亲的fail指针获得当前的\n            while (v && ch[v][c] == 0) v = f[v];\n            f[u] = ch[v][c];\n            //更新last\n            last[u] = val[f[u]] ? f[u] : last[f[u]];\n        }\n    }\n}\n\n//进行匹配\nvoid find(char * T) {\n    int len = strlen(T), j = 0;\n    for (int i = 0; i < len; i++) {\n        int c = idx(T[i]);\n        while (j && ch[j][c] == 0) j = f[j];\n        j = ch[j][c];\n        //如果当前是模式串的结尾，那么更新答案\n        //else if 里是处理一个模式串包含另一个模式串的情况\n        if (val[j]) add(j);\n        else if (last[j]) add(last[j]);\n    }\n}\n\nchar str[N];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        int n;\n        scanf(\"%d\", &n);\n        while (n--) {\n            scanf(\"%s\", str);\n            Creat(str);\n        }\n        getFail();\n        scanf(\"%s\", str);\n        ANS = 0;\n        find(str);\n        printf(\"%d\\n\", ANS);\n    }\n}\n```\n\n","slug":"AC自动机（模板）","published":1,"updated":"2017-09-25T06:46:06.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n98000ey9id64ansv0r","content":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>主要参考紫书的写法，其他的写法都用到了指针，不太喜欢指针…</p>\n<p>因为紫书没有完整的代码，然后参考了一下 <a href=\"http://www.acyume.com/archives/19\" target=\"_blank\" rel=\"external\">dalao 的博客</a>。</p>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>AC自动机主要解决的是字符串匹配问题，不同于 KMP 的是，AC 自动机可以进行多个模式串的匹配。KMP 的失配指针是一个线性的数组，但是 AC 自动机是多个模式串匹配，所以适配指针是一个树型的结构。</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典树的最大节点个数</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">250001</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1000010</span>;</div><div class=\"line\"><span class=\"comment\">//有多少个不同的字符</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIGMA_SIZE = <span class=\"number\">26</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典树的节点</span></div><div class=\"line\"><span class=\"keyword\">int</span> ch[MAX][SIGMA_SIZE];</div><div class=\"line\"><span class=\"comment\">//当前节点是否为一个模式串的结尾， 当前节点的上一个模式串结尾， fail指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> val[MAX], last[MAX], f[MAX], sz;</div><div class=\"line\"><span class=\"keyword\">int</span> ANS;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    sz = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ch, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ch));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(val, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(val));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(f, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(f));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(last, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(last));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">idx</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c - <span class=\"string\">'a'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新答案</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (u) &#123;</div><div class=\"line\">        ANS += val[u];</div><div class=\"line\">        val[u] = <span class=\"number\">0</span>;</div><div class=\"line\">        u = last[u];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加模式串</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Creat</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> u = <span class=\"number\">0</span>, len = <span class=\"built_in\">strlen</span>(s);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = idx(s[i]);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!ch[u][c]) ch[u][c] = sz++;</div><div class=\"line\">        u = ch[u][c];</div><div class=\"line\">    &#125;</div><div class=\"line\">    val[u]++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得fail指针</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getFail</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIGMA_SIZE; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (ch[<span class=\"number\">0</span>][i]) q.push(ch[<span class=\"number\">0</span>][i]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; SIGMA_SIZE; c++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = ch[r][c];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!u) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            q.push(u);</div><div class=\"line\">            <span class=\"keyword\">int</span> v = f[r];</div><div class=\"line\">            <span class=\"comment\">//和kmp相似，和根据父亲的fail指针获得当前的</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (v &amp;&amp; ch[v][c] == <span class=\"number\">0</span>) v = f[v];</div><div class=\"line\">            f[u] = ch[v][c];</div><div class=\"line\">            <span class=\"comment\">//更新last</span></div><div class=\"line\">            last[u] = val[f[u]] ? f[u] : last[f[u]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行匹配</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">char</span> * T)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(T), j = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = idx(T[i]);</div><div class=\"line\">        <span class=\"keyword\">while</span> (j &amp;&amp; ch[j][c] == <span class=\"number\">0</span>) j = f[j];</div><div class=\"line\">        j = ch[j][c];</div><div class=\"line\">        <span class=\"comment\">//如果当前是模式串的结尾，那么更新答案</span></div><div class=\"line\">        <span class=\"comment\">//else if 里是处理一个模式串包含另一个模式串的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (val[j]) add(j);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (last[j]) add(last[j]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> str[N];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">            Creat(str);</div><div class=\"line\">        &#125;</div><div class=\"line\">        getFail();</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">        ANS = <span class=\"number\">0</span>;</div><div class=\"line\">        find(str);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ANS);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>主要参考紫书的写法，其他的写法都用到了指针，不太喜欢指针…</p>\n<p>因为紫书没有完整的代码，然后参考了一下 <a href=\"http://www.acyume.com/archives/19\" target=\"_blank\" rel=\"external\">dalao 的博客</a>。</p>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>AC自动机主要解决的是字符串匹配问题，不同于 KMP 的是，AC 自动机可以进行多个模式串的匹配。KMP 的失配指针是一个线性的数组，但是 AC 自动机是多个模式串匹配，所以适配指针是一个树型的结构。</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典树的最大节点个数</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">250001</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1000010</span>;</div><div class=\"line\"><span class=\"comment\">//有多少个不同的字符</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIGMA_SIZE = <span class=\"number\">26</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典树的节点</span></div><div class=\"line\"><span class=\"keyword\">int</span> ch[MAX][SIGMA_SIZE];</div><div class=\"line\"><span class=\"comment\">//当前节点是否为一个模式串的结尾， 当前节点的上一个模式串结尾， fail指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> val[MAX], last[MAX], f[MAX], sz;</div><div class=\"line\"><span class=\"keyword\">int</span> ANS;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    sz = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ch, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ch));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(val, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(val));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(f, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(f));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(last, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(last));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">idx</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c - <span class=\"string\">'a'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新答案</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (u) &#123;</div><div class=\"line\">        ANS += val[u];</div><div class=\"line\">        val[u] = <span class=\"number\">0</span>;</div><div class=\"line\">        u = last[u];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加模式串</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Creat</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> u = <span class=\"number\">0</span>, len = <span class=\"built_in\">strlen</span>(s);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = idx(s[i]);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!ch[u][c]) ch[u][c] = sz++;</div><div class=\"line\">        u = ch[u][c];</div><div class=\"line\">    &#125;</div><div class=\"line\">    val[u]++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得fail指针</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getFail</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIGMA_SIZE; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (ch[<span class=\"number\">0</span>][i]) q.push(ch[<span class=\"number\">0</span>][i]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; SIGMA_SIZE; c++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = ch[r][c];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!u) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            q.push(u);</div><div class=\"line\">            <span class=\"keyword\">int</span> v = f[r];</div><div class=\"line\">            <span class=\"comment\">//和kmp相似，和根据父亲的fail指针获得当前的</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (v &amp;&amp; ch[v][c] == <span class=\"number\">0</span>) v = f[v];</div><div class=\"line\">            f[u] = ch[v][c];</div><div class=\"line\">            <span class=\"comment\">//更新last</span></div><div class=\"line\">            last[u] = val[f[u]] ? f[u] : last[f[u]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行匹配</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">char</span> * T)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(T), j = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = idx(T[i]);</div><div class=\"line\">        <span class=\"keyword\">while</span> (j &amp;&amp; ch[j][c] == <span class=\"number\">0</span>) j = f[j];</div><div class=\"line\">        j = ch[j][c];</div><div class=\"line\">        <span class=\"comment\">//如果当前是模式串的结尾，那么更新答案</span></div><div class=\"line\">        <span class=\"comment\">//else if 里是处理一个模式串包含另一个模式串的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (val[j]) add(j);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (last[j]) add(last[j]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> str[N];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">            Creat(str);</div><div class=\"line\">        &#125;</div><div class=\"line\">        getFail();</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">        ANS = <span class=\"number\">0</span>;</div><div class=\"line\">        find(str);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ANS);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"CF 766C - Mahmoud and a Message （DP+字符串）","date":"2017-02-13T13:10:16.000Z","_content":"# 题目链接：\n------------------\nhttp://codeforces.com/problemset/problem/766/C\n# 题目描述：\n-------------\n有一个只含小写字母的字符串，输入一个26个整数，用来限制每个字母所在字符串的最大长度，在保证符合限制的前提下。\n\n+ 输出分割字符串的方案数。\n+ 输出所有方案中，最少的分割次数。\n+ 输出所有方案中，最大的子串长度。\n# 结题过程：\n------------\n一开始打算放弃掉的，英文题，题目很长，看起来又比较麻烦。\n然后学长来讲了一下，感觉毕竟讲都讲了，不做下挺可惜的，倒是个好题。\n\n刚开始示例一直过不了，第二层循环字符串长度的时候出了问题，我用j表示到那一个字符了，后来发现用j代表分隔符的位置更好。\n\n# 题目分析：\n-----------\n+ 首先确定状态，很明显字符串处理经常用长度做状态，无后效性。\n+ 接下来是确定状态转移方程：\n\t+ 先说下第二层循环，这里j代表分隔符的所在位置，位于第j个字符的前方。\n\t用一个变量用来标记当前最小的长度限制，如果 **i - j + 1 > limit** 就跳出循环。\n\t最后虽然 **j = -1** 的时候退出循环，但是要给方案数加一，整个字符串可以不用分割。\n\t\n\t+ 方案次数：**dpNum[i] += dpNum[j-1] ,  0 < j <= i.**\n\t\n\t+ 最少子串数：**dpMinNum[i] = min(dpMinNum[j-1]+1, dpMinNum[i]).**\n\t+ 最长子串数，只需一直用 **j** 来更新最大长度 **ansLen** 就好了。\n\t\n+ 最后注意一下初始化。\n\n# AC代码：\n---------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1e9+7;\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    char data[1123];\n    int maxLen[30];\n    scanf(\"%s\", data);\n    long long dpNum[1123], dpMinNum[1123], ansLen = 1;\n    for (int i = 0; i < 26; i++)\n        scanf(\"%d\", maxLen+i);\n\n    dpMinNum[0] = 1;\n    dpNum[0] = 1;\n\n    for (int i = 1; i < n; i++)\n    {\n        dpMinNum[i] = n;\n        dpNum[i] = 0;\n        int limit = n;\n        int j;\n        for (j = i; j >= 0; j--)\n        {\n            limit = min(maxLen[data[j]-'a'], limit);\n            if (i-j+1 > limit)\n                break;\n\n            if (!i)\n                continue;\n\n            dpMinNum[i] =  min(dpMinNum[j-1]+1, dpMinNum[i]);\n            ansLen = max(ansLen, (long long)i-j+1);\n            dpNum[i] = (dpNum[i]%MOD + dpNum[j-1]%MOD)%MOD;\n        }\n        if (j == -1)\n            dpNum[i]+=1;\n    }\n    printf(\"%lld\\n%lld\\n%lld\\n\", dpNum[n-1], ansLen, dpMinNum[n-1]);\n}\n\n```","source":"_posts/CF-766C-Mahmoud-and-a-Message-（DP-字符串）.md","raw":"---\ntitle: CF 766C - Mahmoud and a Message （DP+字符串）\ndate: 2017-02-13 21:10:16\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n------------------\nhttp://codeforces.com/problemset/problem/766/C\n# 题目描述：\n-------------\n有一个只含小写字母的字符串，输入一个26个整数，用来限制每个字母所在字符串的最大长度，在保证符合限制的前提下。\n\n+ 输出分割字符串的方案数。\n+ 输出所有方案中，最少的分割次数。\n+ 输出所有方案中，最大的子串长度。\n# 结题过程：\n------------\n一开始打算放弃掉的，英文题，题目很长，看起来又比较麻烦。\n然后学长来讲了一下，感觉毕竟讲都讲了，不做下挺可惜的，倒是个好题。\n\n刚开始示例一直过不了，第二层循环字符串长度的时候出了问题，我用j表示到那一个字符了，后来发现用j代表分隔符的位置更好。\n\n# 题目分析：\n-----------\n+ 首先确定状态，很明显字符串处理经常用长度做状态，无后效性。\n+ 接下来是确定状态转移方程：\n\t+ 先说下第二层循环，这里j代表分隔符的所在位置，位于第j个字符的前方。\n\t用一个变量用来标记当前最小的长度限制，如果 **i - j + 1 > limit** 就跳出循环。\n\t最后虽然 **j = -1** 的时候退出循环，但是要给方案数加一，整个字符串可以不用分割。\n\t\n\t+ 方案次数：**dpNum[i] += dpNum[j-1] ,  0 < j <= i.**\n\t\n\t+ 最少子串数：**dpMinNum[i] = min(dpMinNum[j-1]+1, dpMinNum[i]).**\n\t+ 最长子串数，只需一直用 **j** 来更新最大长度 **ansLen** 就好了。\n\t\n+ 最后注意一下初始化。\n\n# AC代码：\n---------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1e9+7;\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    char data[1123];\n    int maxLen[30];\n    scanf(\"%s\", data);\n    long long dpNum[1123], dpMinNum[1123], ansLen = 1;\n    for (int i = 0; i < 26; i++)\n        scanf(\"%d\", maxLen+i);\n\n    dpMinNum[0] = 1;\n    dpNum[0] = 1;\n\n    for (int i = 1; i < n; i++)\n    {\n        dpMinNum[i] = n;\n        dpNum[i] = 0;\n        int limit = n;\n        int j;\n        for (j = i; j >= 0; j--)\n        {\n            limit = min(maxLen[data[j]-'a'], limit);\n            if (i-j+1 > limit)\n                break;\n\n            if (!i)\n                continue;\n\n            dpMinNum[i] =  min(dpMinNum[j-1]+1, dpMinNum[i]);\n            ansLen = max(ansLen, (long long)i-j+1);\n            dpNum[i] = (dpNum[i]%MOD + dpNum[j-1]%MOD)%MOD;\n        }\n        if (j == -1)\n            dpNum[i]+=1;\n    }\n    printf(\"%lld\\n%lld\\n%lld\\n\", dpNum[n-1], ansLen, dpMinNum[n-1]);\n}\n\n```","slug":"CF-766C-Mahmoud-and-a-Message-（DP-字符串）","published":1,"updated":"2017-07-23T03:11:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9a000fy9idnvp04dus","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://codeforces.com/problemset/problem/766/C\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/766/C</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>有一个只含小写字母的字符串，输入一个26个整数，用来限制每个字母所在字符串的最大长度，在保证符合限制的前提下。</p>\n<ul>\n<li>输出分割字符串的方案数。</li>\n<li>输出所有方案中，最少的分割次数。</li>\n<li>输出所有方案中，最大的子串长度。<h1 id=\"结题过程：\"><a href=\"#结题过程：\" class=\"headerlink\" title=\"结题过程：\"></a>结题过程：</h1></li>\n</ul>\n<hr>\n<p>一开始打算放弃掉的，英文题，题目很长，看起来又比较麻烦。<br>然后学长来讲了一下，感觉毕竟讲都讲了，不做下挺可惜的，倒是个好题。</p>\n<p>刚开始示例一直过不了，第二层循环字符串长度的时候出了问题，我用j表示到那一个字符了，后来发现用j代表分隔符的位置更好。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>首先确定状态，很明显字符串处理经常用长度做状态，无后效性。</li>\n<li><p>接下来是确定状态转移方程：</p>\n<ul>\n<li><p>先说下第二层循环，这里j代表分隔符的所在位置，位于第j个字符的前方。<br>用一个变量用来标记当前最小的长度限制，如果 <strong>i - j + 1 &gt; limit</strong> 就跳出循环。<br>最后虽然 <strong>j = -1</strong> 的时候退出循环，但是要给方案数加一，整个字符串可以不用分割。</p>\n</li>\n<li><p>方案次数：<strong>dpNum[i] += dpNum[j-1] ,  0 &lt; j &lt;= i.</strong></p>\n</li>\n<li><p>最少子串数：<strong>dpMinNum[i] = min(dpMinNum[j-1]+1, dpMinNum[i]).</strong></p>\n</li>\n<li>最长子串数，只需一直用 <strong>j</strong> 来更新最大长度 <strong>ansLen</strong> 就好了。</li>\n</ul>\n</li>\n<li><p>最后注意一下初始化。</p>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">char</span> data[<span class=\"number\">1123</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> maxLen[<span class=\"number\">30</span>];</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data);</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dpNum[<span class=\"number\">1123</span>], dpMinNum[<span class=\"number\">1123</span>], ansLen = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, maxLen+i);</div><div class=\"line\"></div><div class=\"line\">    dpMinNum[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dpNum[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        dpMinNum[i] = n;</div><div class=\"line\">        dpNum[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> limit = n;</div><div class=\"line\">        <span class=\"keyword\">int</span> j;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = i; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            limit = min(maxLen[data[j]-<span class=\"string\">'a'</span>], limit);</div><div class=\"line\">            <span class=\"keyword\">if</span> (i-j+<span class=\"number\">1</span> &gt; limit)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (!i)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            dpMinNum[i] =  min(dpMinNum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>, dpMinNum[i]);</div><div class=\"line\">            ansLen = max(ansLen, (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)i-j+<span class=\"number\">1</span>);</div><div class=\"line\">            dpNum[i] = (dpNum[i]%MOD + dpNum[j<span class=\"number\">-1</span>]%MOD)%MOD;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span>)</div><div class=\"line\">            dpNum[i]+=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n%lld\\n%lld\\n\"</span>, dpNum[n<span class=\"number\">-1</span>], ansLen, dpMinNum[n<span class=\"number\">-1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://codeforces.com/problemset/problem/766/C\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/766/C</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>有一个只含小写字母的字符串，输入一个26个整数，用来限制每个字母所在字符串的最大长度，在保证符合限制的前提下。</p>\n<ul>\n<li>输出分割字符串的方案数。</li>\n<li>输出所有方案中，最少的分割次数。</li>\n<li>输出所有方案中，最大的子串长度。<h1 id=\"结题过程：\"><a href=\"#结题过程：\" class=\"headerlink\" title=\"结题过程：\"></a>结题过程：</h1></li>\n</ul>\n<hr>\n<p>一开始打算放弃掉的，英文题，题目很长，看起来又比较麻烦。<br>然后学长来讲了一下，感觉毕竟讲都讲了，不做下挺可惜的，倒是个好题。</p>\n<p>刚开始示例一直过不了，第二层循环字符串长度的时候出了问题，我用j表示到那一个字符了，后来发现用j代表分隔符的位置更好。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>首先确定状态，很明显字符串处理经常用长度做状态，无后效性。</li>\n<li><p>接下来是确定状态转移方程：</p>\n<ul>\n<li><p>先说下第二层循环，这里j代表分隔符的所在位置，位于第j个字符的前方。<br>用一个变量用来标记当前最小的长度限制，如果 <strong>i - j + 1 &gt; limit</strong> 就跳出循环。<br>最后虽然 <strong>j = -1</strong> 的时候退出循环，但是要给方案数加一，整个字符串可以不用分割。</p>\n</li>\n<li><p>方案次数：<strong>dpNum[i] += dpNum[j-1] ,  0 &lt; j &lt;= i.</strong></p>\n</li>\n<li><p>最少子串数：<strong>dpMinNum[i] = min(dpMinNum[j-1]+1, dpMinNum[i]).</strong></p>\n</li>\n<li>最长子串数，只需一直用 <strong>j</strong> 来更新最大长度 <strong>ansLen</strong> 就好了。</li>\n</ul>\n</li>\n<li><p>最后注意一下初始化。</p>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">char</span> data[<span class=\"number\">1123</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> maxLen[<span class=\"number\">30</span>];</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data);</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dpNum[<span class=\"number\">1123</span>], dpMinNum[<span class=\"number\">1123</span>], ansLen = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, maxLen+i);</div><div class=\"line\"></div><div class=\"line\">    dpMinNum[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dpNum[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        dpMinNum[i] = n;</div><div class=\"line\">        dpNum[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> limit = n;</div><div class=\"line\">        <span class=\"keyword\">int</span> j;</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = i; j &gt;= <span class=\"number\">0</span>; j--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            limit = min(maxLen[data[j]-<span class=\"string\">'a'</span>], limit);</div><div class=\"line\">            <span class=\"keyword\">if</span> (i-j+<span class=\"number\">1</span> &gt; limit)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (!i)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            dpMinNum[i] =  min(dpMinNum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>, dpMinNum[i]);</div><div class=\"line\">            ansLen = max(ansLen, (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)i-j+<span class=\"number\">1</span>);</div><div class=\"line\">            dpNum[i] = (dpNum[i]%MOD + dpNum[j<span class=\"number\">-1</span>]%MOD)%MOD;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span>)</div><div class=\"line\">            dpNum[i]+=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n%lld\\n%lld\\n\"</span>, dpNum[n<span class=\"number\">-1</span>], ansLen, dpMinNum[n<span class=\"number\">-1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeChef MOU2H - Mountain Holidays 2 （DP）","date":"2017-06-25T03:09:59.000Z","_content":"# 题目链接：\nhttps://www.codechef.com/problems/MOU2H\n\n-------------------------\n# 题目大意：\n理解题意后就是求一个序列中有多少个不同的子序列。\n\n---------------------------\n# 解题过程：\n\n刚开始看错了题意，样例过不去，后来去翻了博客，才看懂题意，看懂题意后就好做了，就是一个简单的动态规划。\n\n---------------------\n# 题目分析：\n因为要求不同子序列的个数。\n\n定义状态$dp[i]$为前[i]个数中，不同子序列的个数。那么对于dp[i]可以由已下方式转移而来，记$pre[A[i]]$为A$[i]$这个数字上次出现的下标，如果未出现为$-1$。\n\n定义$dp[0]$为$1$代表一个空串。\n\n那么dp[i]可由以下状态转移而来：\n\n$$\ndp[i] = \t\n\\begin{cases}\ndp[i-1]\\times 2 , &pre[A[i]] = -1 \\\\\ndp[i-1] \\times 2 - dp[pre[A[i]]-1], &pre[A[i]] \\neq -1\n\\end{cases}\n$$\n\n\n如果前i-1个数的不同子串个数为N，那么加上第i个数之后，对于前i个不同的子串加上第i个数后都构成了一个新的串，那么对于前i个数的不同子串为，前i-1的不同子串个数+新构成的子串个数。\n\n不过如果第i个数曾经出现过的话，需要去重处理，如果3这个数字，在$5$和$9$这个位置都出现过的话，那么前$4$个数的子串后面加上第$5$个数和加上第$9$个数，构成的子串相同，这里需要减去最近出现的前一个位置的不同子串个数。\n这里需要仔细理解下，$dp[i]$代表的是前$i$个元素构成的不同子串的个数，不是以元素$i$结尾的最大子串个数。\n\n\n\n\n这里介绍一个骚操作，数组的下标可以为负数，对于下面代码。\n```cpp\nint a[3] = {1, 2, 3};\nint *p = a+1;\ncout << p[-1] << endl;\n```\n输出的结果为`1`\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\nconst int INF = MAX<<2;\nconst int MOD = 1000000009;\n\nint H[MAX];\nint reserve[MAX*10], *pre = reserve+INF;\nint dp[MAX];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", H+i);\n        }\n        for (int i = 1; i < n; i++) {\n            H[i] = H[i+1] - H[i];\n            pre[H[i]] = -1;\n        }\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i] = (dp[i-1]<<1)%MOD;\n            if (pre[H[i]] != -1) {\n                dp[i] = (dp[i] - dp[pre[H[i]]-1] + MOD)%MOD;\n            }\n            pre[H[i]] = i;\n        }\n        printf(\"%d\\n\", (dp[n-1]-1+MOD)%MOD);\n    }\n}\n\n\n```","source":"_posts/CodeChef-MOU2H-Mountain-Holidays-2-（DP）.md","raw":"---\ntitle: CodeChef MOU2H - Mountain Holidays 2 （DP）\ndate: 2017-06-25 11:09:59\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\nhttps://www.codechef.com/problems/MOU2H\n\n-------------------------\n# 题目大意：\n理解题意后就是求一个序列中有多少个不同的子序列。\n\n---------------------------\n# 解题过程：\n\n刚开始看错了题意，样例过不去，后来去翻了博客，才看懂题意，看懂题意后就好做了，就是一个简单的动态规划。\n\n---------------------\n# 题目分析：\n因为要求不同子序列的个数。\n\n定义状态$dp[i]$为前[i]个数中，不同子序列的个数。那么对于dp[i]可以由已下方式转移而来，记$pre[A[i]]$为A$[i]$这个数字上次出现的下标，如果未出现为$-1$。\n\n定义$dp[0]$为$1$代表一个空串。\n\n那么dp[i]可由以下状态转移而来：\n\n$$\ndp[i] = \t\n\\begin{cases}\ndp[i-1]\\times 2 , &pre[A[i]] = -1 \\\\\ndp[i-1] \\times 2 - dp[pre[A[i]]-1], &pre[A[i]] \\neq -1\n\\end{cases}\n$$\n\n\n如果前i-1个数的不同子串个数为N，那么加上第i个数之后，对于前i个不同的子串加上第i个数后都构成了一个新的串，那么对于前i个数的不同子串为，前i-1的不同子串个数+新构成的子串个数。\n\n不过如果第i个数曾经出现过的话，需要去重处理，如果3这个数字，在$5$和$9$这个位置都出现过的话，那么前$4$个数的子串后面加上第$5$个数和加上第$9$个数，构成的子串相同，这里需要减去最近出现的前一个位置的不同子串个数。\n这里需要仔细理解下，$dp[i]$代表的是前$i$个元素构成的不同子串的个数，不是以元素$i$结尾的最大子串个数。\n\n\n\n\n这里介绍一个骚操作，数组的下标可以为负数，对于下面代码。\n```cpp\nint a[3] = {1, 2, 3};\nint *p = a+1;\ncout << p[-1] << endl;\n```\n输出的结果为`1`\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\nconst int INF = MAX<<2;\nconst int MOD = 1000000009;\n\nint H[MAX];\nint reserve[MAX*10], *pre = reserve+INF;\nint dp[MAX];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", H+i);\n        }\n        for (int i = 1; i < n; i++) {\n            H[i] = H[i+1] - H[i];\n            pre[H[i]] = -1;\n        }\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i] = (dp[i-1]<<1)%MOD;\n            if (pre[H[i]] != -1) {\n                dp[i] = (dp[i] - dp[pre[H[i]]-1] + MOD)%MOD;\n            }\n            pre[H[i]] = i;\n        }\n        printf(\"%d\\n\", (dp[n-1]-1+MOD)%MOD);\n    }\n}\n\n\n```","slug":"CodeChef-MOU2H-Mountain-Holidays-2-（DP）","published":1,"updated":"2017-07-23T01:56:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9e000iy9id6iu10wpm","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://www.codechef.com/problems/MOU2H\" target=\"_blank\" rel=\"external\">https://www.codechef.com/problems/MOU2H</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>理解题意后就是求一个序列中有多少个不同的子序列。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始看错了题意，样例过不去，后来去翻了博客，才看懂题意，看懂题意后就好做了，就是一个简单的动态规划。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为要求不同子序列的个数。</p>\n<p>定义状态$dp[i]$为前[i]个数中，不同子序列的个数。那么对于dp[i]可以由已下方式转移而来，记$pre[A[i]]$为A$[i]$这个数字上次出现的下标，如果未出现为$-1$。</p>\n<p>定义$dp[0]$为$1$代表一个空串。</p>\n<p>那么dp[i]可由以下状态转移而来：</p>\n<p>$$<br>dp[i] =<br>\\begin{cases}<br>dp[i-1]\\times 2 , &amp;pre[A[i]] = -1 \\<br>dp[i-1] \\times 2 - dp[pre[A[i]]-1], &amp;pre[A[i]] \\neq -1<br>\\end{cases}<br>$$</p>\n<p>如果前i-1个数的不同子串个数为N，那么加上第i个数之后，对于前i个不同的子串加上第i个数后都构成了一个新的串，那么对于前i个数的不同子串为，前i-1的不同子串个数+新构成的子串个数。</p>\n<p>不过如果第i个数曾经出现过的话，需要去重处理，如果3这个数字，在$5$和$9$这个位置都出现过的话，那么前$4$个数的子串后面加上第$5$个数和加上第$9$个数，构成的子串相同，这里需要减去最近出现的前一个位置的不同子串个数。<br>这里需要仔细理解下，$dp[i]$代表的是前$i$个元素构成的不同子串的个数，不是以元素$i$结尾的最大子串个数。</p>\n<p>这里介绍一个骚操作，数组的下标可以为负数，对于下面代码。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = a+<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; p[<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为<code>1</code></p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = MAX&lt;&lt;<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1000000009</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> H[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> reserve[MAX*<span class=\"number\">10</span>], *pre = reserve+INF;</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, H+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            H[i] = H[i+<span class=\"number\">1</span>] - H[i];</div><div class=\"line\">            pre[H[i]] = <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            dp[i] = (dp[i<span class=\"number\">-1</span>]&lt;&lt;<span class=\"number\">1</span>)%MOD;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pre[H[i]] != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                dp[i] = (dp[i] - dp[pre[H[i]]<span class=\"number\">-1</span>] + MOD)%MOD;</div><div class=\"line\">            &#125;</div><div class=\"line\">            pre[H[i]] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, (dp[n<span class=\"number\">-1</span>]<span class=\"number\">-1</span>+MOD)%MOD);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://www.codechef.com/problems/MOU2H\" target=\"_blank\" rel=\"external\">https://www.codechef.com/problems/MOU2H</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>理解题意后就是求一个序列中有多少个不同的子序列。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始看错了题意，样例过不去，后来去翻了博客，才看懂题意，看懂题意后就好做了，就是一个简单的动态规划。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为要求不同子序列的个数。</p>\n<p>定义状态$dp[i]$为前[i]个数中，不同子序列的个数。那么对于dp[i]可以由已下方式转移而来，记$pre[A[i]]$为A$[i]$这个数字上次出现的下标，如果未出现为$-1$。</p>\n<p>定义$dp[0]$为$1$代表一个空串。</p>\n<p>那么dp[i]可由以下状态转移而来：</p>\n<p>$$<br>dp[i] =<br>\\begin{cases}<br>dp[i-1]\\times 2 , &amp;pre[A[i]] = -1 \\<br>dp[i-1] \\times 2 - dp[pre[A[i]]-1], &amp;pre[A[i]] \\neq -1<br>\\end{cases}<br>$$</p>\n<p>如果前i-1个数的不同子串个数为N，那么加上第i个数之后，对于前i个不同的子串加上第i个数后都构成了一个新的串，那么对于前i个数的不同子串为，前i-1的不同子串个数+新构成的子串个数。</p>\n<p>不过如果第i个数曾经出现过的话，需要去重处理，如果3这个数字，在$5$和$9$这个位置都出现过的话，那么前$4$个数的子串后面加上第$5$个数和加上第$9$个数，构成的子串相同，这里需要减去最近出现的前一个位置的不同子串个数。<br>这里需要仔细理解下，$dp[i]$代表的是前$i$个元素构成的不同子串的个数，不是以元素$i$结尾的最大子串个数。</p>\n<p>这里介绍一个骚操作，数组的下标可以为负数，对于下面代码。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = a+<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; p[<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>输出的结果为<code>1</code></p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = MAX&lt;&lt;<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1000000009</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> H[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> reserve[MAX*<span class=\"number\">10</span>], *pre = reserve+INF;</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, H+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            H[i] = H[i+<span class=\"number\">1</span>] - H[i];</div><div class=\"line\">            pre[H[i]] = <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            dp[i] = (dp[i<span class=\"number\">-1</span>]&lt;&lt;<span class=\"number\">1</span>)%MOD;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pre[H[i]] != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                dp[i] = (dp[i] - dp[pre[H[i]]<span class=\"number\">-1</span>] + MOD)%MOD;</div><div class=\"line\">            &#125;</div><div class=\"line\">            pre[H[i]] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, (dp[n<span class=\"number\">-1</span>]<span class=\"number\">-1</span>+MOD)%MOD);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces 255C. Almost Arithmetical Progression (DP)","date":"2016-12-05T09:50:28.000Z","_content":"# 题目链接：\n\n[CodeForces255C.](http://codeforces.com/contest/255/problem/C)\n\n\n----------\n# 题目大意：\n看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.\n数据小于4000.\n\n\n----------\n# 解题过程：\n\n - 看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。\n \n - 比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。\n错误的状态转移方程：\t\t\t\t ***a[i] = a[j] + 1 (a[i] == b[i])***\n  显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。\n  \n - 于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：[题解](http://blog.csdn.net/qq_24451605/article/details/48659235)\n 可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……\n\n\n----------\n# 分析过程：\n\n - 用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。\n - 状态转移方程：***dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])***\n - 看巨巨的题解K在状态转移的过程中就可以找到了。\n\n----------\n# AC代码：\n\n```cpp\n#include <iostream>\n#define MAX 4123\nusing namespace std;\n\nint data[MAX];\nint dp[MAX][MAX];\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> data[i];\n    }\n\n    int ans = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = -1;\n        for (int j = 1; j < i; j++)\n        {\n            if (k == -1)\n                dp[i][j] = 2;\n            else\n                dp[i][j] = dp[j][k] + 1;\n            if (data[i] == data[j])\n                k = j;\n            if (ans < dp[i][j])\n                ans = dp[i][j];\n        }\n    }\n    cout << ans;\n}\n```\n# 暴力遍历代码：\n看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nset<int> check;\nvector<int> store;\nint data[41234];\nint n;\n\nint scan(int a, int b)\n{\n    int judge = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (judge == 0 && (data[i] == a || data[i] == b) || data[i] == judge)\n        {\n            if (data[i] == a)\n            {\n                judge = b;\n            }\n            if (data[i] == b)\n            {\n                judge = a;\n            }\n            sum++;\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> data[i];\n        if (check.count(data[i]) == 0)\n        {\n            check.insert(data[i]);\n            store.push_back(data[i]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < store.size(); i++)\n    {\n        for (int j = i; j < store.size(); j++)\n        {\n            int t = scan(data[i], data[j]);\n            ans = ans > t? ans:t;\n        }\n    }\n    cout << ans;\n}\n```","source":"_posts/CodeForces-255C-Almost-Arithmetical-Progression-DP.md","raw":"---\ntitle: CodeForces 255C. Almost Arithmetical Progression (DP)\ndate: 2016-12-05 17:50:28\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\n[CodeForces255C.](http://codeforces.com/contest/255/problem/C)\n\n\n----------\n# 题目大意：\n看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.\n数据小于4000.\n\n\n----------\n# 解题过程：\n\n - 看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。\n \n - 比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。\n错误的状态转移方程：\t\t\t\t ***a[i] = a[j] + 1 (a[i] == b[i])***\n  显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。\n  \n - 于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：[题解](http://blog.csdn.net/qq_24451605/article/details/48659235)\n 可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……\n\n\n----------\n# 分析过程：\n\n - 用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。\n - 状态转移方程：***dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])***\n - 看巨巨的题解K在状态转移的过程中就可以找到了。\n\n----------\n# AC代码：\n\n```cpp\n#include <iostream>\n#define MAX 4123\nusing namespace std;\n\nint data[MAX];\nint dp[MAX][MAX];\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> data[i];\n    }\n\n    int ans = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = -1;\n        for (int j = 1; j < i; j++)\n        {\n            if (k == -1)\n                dp[i][j] = 2;\n            else\n                dp[i][j] = dp[j][k] + 1;\n            if (data[i] == data[j])\n                k = j;\n            if (ans < dp[i][j])\n                ans = dp[i][j];\n        }\n    }\n    cout << ans;\n}\n```\n# 暴力遍历代码：\n看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nset<int> check;\nvector<int> store;\nint data[41234];\nint n;\n\nint scan(int a, int b)\n{\n    int judge = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (judge == 0 && (data[i] == a || data[i] == b) || data[i] == judge)\n        {\n            if (data[i] == a)\n            {\n                judge = b;\n            }\n            if (data[i] == b)\n            {\n                judge = a;\n            }\n            sum++;\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> data[i];\n        if (check.count(data[i]) == 0)\n        {\n            check.insert(data[i]);\n            store.push_back(data[i]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < store.size(); i++)\n    {\n        for (int j = i; j < store.size(); j++)\n        {\n            int t = scan(data[i], data[j]);\n            ans = ans > t? ans:t;\n        }\n    }\n    cout << ans;\n}\n```","slug":"CodeForces-255C-Almost-Arithmetical-Progression-DP","published":1,"updated":"2017-07-23T04:16:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9g000jy9idetwzd4y2","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/255/problem/C\" target=\"_blank\" rel=\"external\">CodeForces255C.</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.<br>数据小于4000.</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li><p>看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。</p>\n</li>\n<li><p>比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。<br>错误的状态转移方程：                 <strong><em>a[i] = a[j] + 1 (a[i] == b[i])</em></strong><br>显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。</p>\n</li>\n<li><p>于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：<a href=\"http://blog.csdn.net/qq_24451605/article/details/48659235\" target=\"_blank\" rel=\"external\">题解</a><br>可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h1><ul>\n<li>用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。</li>\n<li>状态转移方程：<strong><em>dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])</em></strong></li>\n<li>看巨巨的题解K在状态转移的过程中就可以找到了。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 4123</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">-1</span>)</div><div class=\"line\">                dp[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[i][j] = dp[j][k] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == data[j])</div><div class=\"line\">                k = j;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans &lt; dp[i][j])</div><div class=\"line\">                ans = dp[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"暴力遍历代码：\"><a href=\"#暴力遍历代码：\" class=\"headerlink\" title=\"暴力遍历代码：\"></a>暴力遍历代码：</h1><p>看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; check;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; store;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">41234</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">scan</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> judge = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge == <span class=\"number\">0</span> &amp;&amp; (data[i] == a || data[i] == b) || data[i] == judge)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == a)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = b;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == b)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = a;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (check.count(data[i]) == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            check.insert(data[i]);</div><div class=\"line\">            store.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; store.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; store.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = scan(data[i], data[j]);</div><div class=\"line\">            ans = ans &gt; t? ans:t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/255/problem/C\" target=\"_blank\" rel=\"external\">CodeForces255C.</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.<br>数据小于4000.</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li><p>看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。</p>\n</li>\n<li><p>比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。<br>错误的状态转移方程：                 <strong><em>a[i] = a[j] + 1 (a[i] == b[i])</em></strong><br>显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。</p>\n</li>\n<li><p>于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：<a href=\"http://blog.csdn.net/qq_24451605/article/details/48659235\" target=\"_blank\" rel=\"external\">题解</a><br>可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h1><ul>\n<li>用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。</li>\n<li>状态转移方程：<strong><em>dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])</em></strong></li>\n<li>看巨巨的题解K在状态转移的过程中就可以找到了。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 4123</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">-1</span>)</div><div class=\"line\">                dp[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[i][j] = dp[j][k] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == data[j])</div><div class=\"line\">                k = j;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans &lt; dp[i][j])</div><div class=\"line\">                ans = dp[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"暴力遍历代码：\"><a href=\"#暴力遍历代码：\" class=\"headerlink\" title=\"暴力遍历代码：\"></a>暴力遍历代码：</h1><p>看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; check;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; store;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">41234</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">scan</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> judge = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (judge == <span class=\"number\">0</span> &amp;&amp; (data[i] == a || data[i] == b) || data[i] == judge)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == a)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = b;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == b)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = a;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (check.count(data[i]) == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            check.insert(data[i]);</div><div class=\"line\">            store.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; store.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; store.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = scan(data[i], data[j]);</div><div class=\"line\">            ans = ans &gt; t? ans:t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces734E - Anton and Tree（缩点+树的直径）","date":"2017-06-27T02:17:47.000Z","_content":"# 题目链接：\nhttp://codeforces.com/problemset/problem/734/E\n\n------------------\n# 题目大意：\n给定一棵无根数，每个节点有黑白两种颜色，现在有一种涂色操作，一次可以将一块连通的同色区域涂为一个颜色，现在求最少操作几次可以将整棵树涂成黑色或白色。\n\n\n-------------------------\n# 解题过程：\n因为之前做过一个涂板子的题，进行的操作和这个一样，也是先缩点。不过那个数据范围比较小，枚举所有点BFS一次，求最长路即可，但是做过数据范围比较大，所以用到了树的某些性质。\n\n------------------------------\n# 题目分析：\n\n关于树的直径的介绍和BFS的求法，建议看这篇[博客](http://wattlebird.github.io/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/)，也有详细证明。\n\n如果之前做过[这道题](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781)的话，那么这个题的思路不难想，就是缩点然后再求一下树的直径就好了。\n\n树的直径有一个性质，以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整），因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。\n\n另外在树上缩点，构成的新的图也是一棵树。\n\n-------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 212345;\n\nint color[MAX], n, vis[MAX], top;\nvector<int> raw_edge[MAX], edge[MAX];\n\n//用DFS染色缩点\nvoid dfs(int u) {\n    vis[u] = top;\n    for (int i = 0; i < raw_edge[u].size(); i++) {\n        int v = raw_edge[u][i];\n        if (!vis[v] && color[u] == color[v]) {\n            //如果颜色相同，并且没访问过那么缩成一个点\n            dfs(v);\n        }\n        else if (vis[v] && color[u] != color[v]){\n            //如果颜色不同，并且访问过，那么就建边\n            edge[top].push_back(vis[v]);\n            edge[vis[v]].push_back(top);\n        }\n    }\n}\n\nvoid build() {\n    top = 1;\n    memset(vis, 0, sizeof(vis));\n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            top++;\n        }\n    }\n}\n\n//BFS求最长路\nint bfs(int u) {\n    memset(vis, 0, sizeof(vis));\n    queue<int> q;\n    q.push(u);\n    vis[u] = 1;\n    while (!q.empty()) {\n        u = q.front();\n        q.pop();\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i];\n            if (!vis[v]) {\n                vis[v] = vis[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    int pos = 1;\n    for (int i = 1; i < top; i++) {\n        if (vis[i] > vis[pos])\n            pos = i;\n    }\n    return pos;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        raw_edge[u].push_back(v);\n        raw_edge[v].push_back(u);\n    }\n    build();\n    //先确定直径的一个端点\n    int x = bfs(1);\n    //然后从端点跑最长路求出直径长度，这里距离求出来的是比实际距离大1，所以默认向上取整\n    printf(\"%d\\n\", vis[bfs(x)]/2);\n}\n```\n","source":"_posts/CodeForces734E-Anton-and-Tree（缩点-树的直径）.md","raw":"---\ntitle: CodeForces734E - Anton and Tree（缩点+树的直径）\ndate: 2017-06-27 10:17:47\ncategories: [ACM, 搜索, BFS]\ntags:\n---\n# 题目链接：\nhttp://codeforces.com/problemset/problem/734/E\n\n------------------\n# 题目大意：\n给定一棵无根数，每个节点有黑白两种颜色，现在有一种涂色操作，一次可以将一块连通的同色区域涂为一个颜色，现在求最少操作几次可以将整棵树涂成黑色或白色。\n\n\n-------------------------\n# 解题过程：\n因为之前做过一个涂板子的题，进行的操作和这个一样，也是先缩点。不过那个数据范围比较小，枚举所有点BFS一次，求最长路即可，但是做过数据范围比较大，所以用到了树的某些性质。\n\n------------------------------\n# 题目分析：\n\n关于树的直径的介绍和BFS的求法，建议看这篇[博客](http://wattlebird.github.io/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/)，也有详细证明。\n\n如果之前做过[这道题](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781)的话，那么这个题的思路不难想，就是缩点然后再求一下树的直径就好了。\n\n树的直径有一个性质，以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整），因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。\n\n另外在树上缩点，构成的新的图也是一棵树。\n\n-------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 212345;\n\nint color[MAX], n, vis[MAX], top;\nvector<int> raw_edge[MAX], edge[MAX];\n\n//用DFS染色缩点\nvoid dfs(int u) {\n    vis[u] = top;\n    for (int i = 0; i < raw_edge[u].size(); i++) {\n        int v = raw_edge[u][i];\n        if (!vis[v] && color[u] == color[v]) {\n            //如果颜色相同，并且没访问过那么缩成一个点\n            dfs(v);\n        }\n        else if (vis[v] && color[u] != color[v]){\n            //如果颜色不同，并且访问过，那么就建边\n            edge[top].push_back(vis[v]);\n            edge[vis[v]].push_back(top);\n        }\n    }\n}\n\nvoid build() {\n    top = 1;\n    memset(vis, 0, sizeof(vis));\n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            top++;\n        }\n    }\n}\n\n//BFS求最长路\nint bfs(int u) {\n    memset(vis, 0, sizeof(vis));\n    queue<int> q;\n    q.push(u);\n    vis[u] = 1;\n    while (!q.empty()) {\n        u = q.front();\n        q.pop();\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i];\n            if (!vis[v]) {\n                vis[v] = vis[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    int pos = 1;\n    for (int i = 1; i < top; i++) {\n        if (vis[i] > vis[pos])\n            pos = i;\n    }\n    return pos;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        raw_edge[u].push_back(v);\n        raw_edge[v].push_back(u);\n    }\n    build();\n    //先确定直径的一个端点\n    int x = bfs(1);\n    //然后从端点跑最长路求出直径长度，这里距离求出来的是比实际距离大1，所以默认向上取整\n    printf(\"%d\\n\", vis[bfs(x)]/2);\n}\n```\n","slug":"CodeForces734E-Anton-and-Tree（缩点-树的直径）","published":1,"updated":"2017-07-23T01:51:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9i000my9id8s2mv5o7","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/734/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/734/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一棵无根数，每个节点有黑白两种颜色，现在有一种涂色操作，一次可以将一块连通的同色区域涂为一个颜色，现在求最少操作几次可以将整棵树涂成黑色或白色。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>因为之前做过一个涂板子的题，进行的操作和这个一样，也是先缩点。不过那个数据范围比较小，枚举所有点BFS一次，求最长路即可，但是做过数据范围比较大，所以用到了树的某些性质。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>关于树的直径的介绍和BFS的求法，建议看这篇<a href=\"http://wattlebird.github.io/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/\" target=\"_blank\" rel=\"external\">博客</a>，也有详细证明。</p>\n<p>如果之前做过<a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\" target=\"_blank\" rel=\"external\">这道题</a>的话，那么这个题的思路不难想，就是缩点然后再求一下树的直径就好了。</p>\n<p>树的直径有一个性质，以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整），因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。</p>\n<p>另外在树上缩点，构成的新的图也是一棵树。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> color[MAX], n, vis[MAX], top;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; raw_edge[MAX], edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用DFS染色缩点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = top;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; raw_edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = raw_edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v] &amp;&amp; color[u] == color[v]) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果颜色相同，并且没访问过那么缩成一个点</span></div><div class=\"line\">            dfs(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vis[v] &amp;&amp; color[u] != color[v])&#123;</div><div class=\"line\">            <span class=\"comment\">//如果颜色不同，并且访问过，那么就建边</span></div><div class=\"line\">            edge[top].push_back(vis[v]);</div><div class=\"line\">            edge[vis[v]].push_back(top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    top = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[i]) &#123;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">            top++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//BFS求最长路</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(u);</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                vis[v] = vis[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; top; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i] &gt; vis[pos])</div><div class=\"line\">            pos = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> pos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; color[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        raw_edge[u].push_back(v);</div><div class=\"line\">        raw_edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    build();</div><div class=\"line\">    <span class=\"comment\">//先确定直径的一个端点</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x = bfs(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//然后从端点跑最长路求出直径长度，这里距离求出来的是比实际距离大1，所以默认向上取整</span></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, vis[bfs(x)]/<span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/734/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/734/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一棵无根数，每个节点有黑白两种颜色，现在有一种涂色操作，一次可以将一块连通的同色区域涂为一个颜色，现在求最少操作几次可以将整棵树涂成黑色或白色。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>因为之前做过一个涂板子的题，进行的操作和这个一样，也是先缩点。不过那个数据范围比较小，枚举所有点BFS一次，求最长路即可，但是做过数据范围比较大，所以用到了树的某些性质。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>关于树的直径的介绍和BFS的求法，建议看这篇<a href=\"http://wattlebird.github.io/2014/09/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/\" target=\"_blank\" rel=\"external\">博客</a>，也有详细证明。</p>\n<p>如果之前做过<a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\" target=\"_blank\" rel=\"external\">这道题</a>的话，那么这个题的思路不难想，就是缩点然后再求一下树的直径就好了。</p>\n<p>树的直径有一个性质，以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整），因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。</p>\n<p>另外在树上缩点，构成的新的图也是一棵树。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> color[MAX], n, vis[MAX], top;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; raw_edge[MAX], edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用DFS染色缩点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = top;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; raw_edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = raw_edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v] &amp;&amp; color[u] == color[v]) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果颜色相同，并且没访问过那么缩成一个点</span></div><div class=\"line\">            dfs(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vis[v] &amp;&amp; color[u] != color[v])&#123;</div><div class=\"line\">            <span class=\"comment\">//如果颜色不同，并且访问过，那么就建边</span></div><div class=\"line\">            edge[top].push_back(vis[v]);</div><div class=\"line\">            edge[vis[v]].push_back(top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    top = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[i]) &#123;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">            top++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//BFS求最长路</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(u);</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                vis[v] = vis[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; top; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i] &gt; vis[pos])</div><div class=\"line\">            pos = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> pos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; color[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        raw_edge[u].push_back(v);</div><div class=\"line\">        raw_edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    build();</div><div class=\"line\">    <span class=\"comment\">//先确定直径的一个端点</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x = bfs(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//然后从端点跑最长路求出直径长度，这里距离求出来的是比实际距离大1，所以默认向上取整</span></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, vis[bfs(x)]/<span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"CodeForces732F - Tourist Reform（边双连通 + DFS）","date":"2017-10-15T04:33:53.000Z","_content":"# 题目链接：\n\nhttp://codeforces.com/contest/732/problem/F\n\n\n\n# 题目大意：\n\n给出一张 n 个顶点， m 条边的无向图，保证图连通，没有重边，现在给每个边加上方向，记从点 i 出发可以访问到的点的数量为 $r_i$，求一种分配方向的方式，使得最小的 $r_i$ 尽量的大。\n\n$2 \\le n \\le 400000, 1 \\le m \\le 400000$\n\n# 题目分析：\n\n这里就引用下 [dalao的博客](https://blog.sengxian.com/solutions/cf-732f):\n\n> 我们考虑如何将边定向，定向成 DAG 肯定是极不好的，因为 DAG 里边存在没有出度的点，而这样的话，答案就必然为 1 了。也就是说，不能出去的点，最好要形成一个环，这样答案就是环的大小了。\n>\n> 将图分解为若干边-双连通分量，将每个边-双连通分量看作一个点，那么此时形成了一棵缩点树。对于每个边-双连通分量，我们可以将里边的边定向，使之成为强联通分量。再将缩点后的树边定向，成为一个边指向根的树形图，这样答案就是根代表的边-双连通分量的答案，由于任意点都可以做树形图的根，所以答案就是最大的边-双连通分量的大小。\n>\n> **定理：**答案就是是最大的边-双连通分量的大小。\n> **证明：**前面已经证明了，最大的边-双连通分量的大小是一个合法答案。现在只需证明，最大的答案不会大于最大的边-双连通分量的大小：考虑定向后的图，将其强联通缩点，答案就是没有出度的强联通分量中最小的那个，如果这个值比最大的边-双连通分量的大小更大，那么考虑将这个强联通分量中的边改为无向边，这就能形成一个边-双连通分量，而且比原图中最大的边-双连通分量的大小还要大，这就产生了矛盾。\n>\n> 考虑输出方案，树边是很好定向的，DFS 一下缩点树就行了。如何将边-双连通分量中的边定向，使得形成一个强联通分量呢？我们考虑直接使用 DFS 中第一次访问边的顺序，为什么？因为利用这个顺序，肯定能保证联通。我们再考虑 DFS 树，在 DFS 树中，每个点一定能通过 DFS 返祖边和非返祖边的结合，走到自己上方的点（否则存在桥，与边-双连通的定义违背），所以每个点都可以通过定向后的边走到根，自然证明这个原先的边-双连通分量通过这种定向方法后强联通。\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 4112345;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX << 1];\n\nint n, m;\n\nint head[MAX], ecnt;\n\nint dfs_clock, scc_cnt;\nint low[MAX], pre[MAX], mark[MAX];\nstack<int> S;\n\nint num[MAX], ans, id;\nint data[MAX][2];\n\nvoid add_edge(int u, int v) {\n    edge[ecnt].u = u;\n    edge[ecnt].v = v;\n    edge[ecnt].nxt = head[u];\n    head[u] = ecnt++;\n}\n\nvoid init() {\n    dfs_clock = scc_cnt = ecnt = 0;\n    memset(head, -1, sizeof(head));\n    memset(mark, 0, sizeof(mark));\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &data[i][0], &data[i][1]);\n        add_edge(data[i][0], data[i][1]);\n        add_edge(data[i][1], data[i][0]);\n    }\n}\n\nvoid tarjan(int u, int fa) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (v == fa) continue;\n        if (!pre[v]) {\n            tarjan(v, u);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (pre[u] == low[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n            num[scc_cnt]++;\n            if (num[scc_cnt] > ans) {\n                ans = num[scc_cnt];\n                id = u;\n            }\n        } while (x != u);\n    }\n}\n\nbool vis[MAX];\nint fa[MAX];\n\nvoid dfs1(int u) {\n    fa[u] = true;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (vis[i / 2]) continue;\n        if (mark[v] != mark[u]) continue;\n        vis[i / 2] = true;\n        data[i / 2][0] = u;\n        data[i / 2][1] = v;\n        if (fa[v]) continue;\n        dfs1(v);\n    }\n}\n\nvoid dfs2(int u) {\n    vis[u] = true;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        //这里类似 DFS 一棵树的过程，如果当前双连通分量已经访问过了，那么不应该通过其他强连通分量去访问了\n        if (mark[v] != mark[u]) {\n            if (fa[mark[v]] == 0 || fa[mark[v]] == mark[u]) {\n                fa[mark[v]] = mark[u];\n                data[i/2][0] = v;\n                data[i/2][1] = u;\n            }\n        }\n        if (vis[v]) continue;\n        dfs2(v);\n    }\n}\n\nvoid solve() {\n    tarjan(1, -1);\n\n    //第一次 DFS 为双连通分量里面的边分配方向\n    for (int i = 1; i <= n; i++) {\n        dfs1(i);\n    }\n\n    //第二次为连接不同的双连通分量的边分配方向\n    memset(vis, 0, sizeof(vis));\n    memset(fa, 0, sizeof(fa));\n    fa[mark[id]] = -1;\n    dfs2(id);\n\n    printf(\"%d\\n\", ans);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", data[i][0], data[i][1]);\n    }\n}\n\nint main() {\n    init();\n    solve();\n}\n```\n# 解题过程：\n\n这题卡了好久，主要是为缩点后的图重新建边后会爆内存，然后只能用第一次建的边去 DFS，然后就写的有点恶心了...","source":"_posts/CodeForces732F-Tourist-Reform（边双连通-DFS）.md","raw":"---\ntitle: CodeForces732F - Tourist Reform（边双连通 + DFS）\ndate: 2017-10-15 12:33:53\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\n\nhttp://codeforces.com/contest/732/problem/F\n\n\n\n# 题目大意：\n\n给出一张 n 个顶点， m 条边的无向图，保证图连通，没有重边，现在给每个边加上方向，记从点 i 出发可以访问到的点的数量为 $r_i$，求一种分配方向的方式，使得最小的 $r_i$ 尽量的大。\n\n$2 \\le n \\le 400000, 1 \\le m \\le 400000$\n\n# 题目分析：\n\n这里就引用下 [dalao的博客](https://blog.sengxian.com/solutions/cf-732f):\n\n> 我们考虑如何将边定向，定向成 DAG 肯定是极不好的，因为 DAG 里边存在没有出度的点，而这样的话，答案就必然为 1 了。也就是说，不能出去的点，最好要形成一个环，这样答案就是环的大小了。\n>\n> 将图分解为若干边-双连通分量，将每个边-双连通分量看作一个点，那么此时形成了一棵缩点树。对于每个边-双连通分量，我们可以将里边的边定向，使之成为强联通分量。再将缩点后的树边定向，成为一个边指向根的树形图，这样答案就是根代表的边-双连通分量的答案，由于任意点都可以做树形图的根，所以答案就是最大的边-双连通分量的大小。\n>\n> **定理：**答案就是是最大的边-双连通分量的大小。\n> **证明：**前面已经证明了，最大的边-双连通分量的大小是一个合法答案。现在只需证明，最大的答案不会大于最大的边-双连通分量的大小：考虑定向后的图，将其强联通缩点，答案就是没有出度的强联通分量中最小的那个，如果这个值比最大的边-双连通分量的大小更大，那么考虑将这个强联通分量中的边改为无向边，这就能形成一个边-双连通分量，而且比原图中最大的边-双连通分量的大小还要大，这就产生了矛盾。\n>\n> 考虑输出方案，树边是很好定向的，DFS 一下缩点树就行了。如何将边-双连通分量中的边定向，使得形成一个强联通分量呢？我们考虑直接使用 DFS 中第一次访问边的顺序，为什么？因为利用这个顺序，肯定能保证联通。我们再考虑 DFS 树，在 DFS 树中，每个点一定能通过 DFS 返祖边和非返祖边的结合，走到自己上方的点（否则存在桥，与边-双连通的定义违背），所以每个点都可以通过定向后的边走到根，自然证明这个原先的边-双连通分量通过这种定向方法后强联通。\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 4112345;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX << 1];\n\nint n, m;\n\nint head[MAX], ecnt;\n\nint dfs_clock, scc_cnt;\nint low[MAX], pre[MAX], mark[MAX];\nstack<int> S;\n\nint num[MAX], ans, id;\nint data[MAX][2];\n\nvoid add_edge(int u, int v) {\n    edge[ecnt].u = u;\n    edge[ecnt].v = v;\n    edge[ecnt].nxt = head[u];\n    head[u] = ecnt++;\n}\n\nvoid init() {\n    dfs_clock = scc_cnt = ecnt = 0;\n    memset(head, -1, sizeof(head));\n    memset(mark, 0, sizeof(mark));\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &data[i][0], &data[i][1]);\n        add_edge(data[i][0], data[i][1]);\n        add_edge(data[i][1], data[i][0]);\n    }\n}\n\nvoid tarjan(int u, int fa) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (v == fa) continue;\n        if (!pre[v]) {\n            tarjan(v, u);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (pre[u] == low[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n            num[scc_cnt]++;\n            if (num[scc_cnt] > ans) {\n                ans = num[scc_cnt];\n                id = u;\n            }\n        } while (x != u);\n    }\n}\n\nbool vis[MAX];\nint fa[MAX];\n\nvoid dfs1(int u) {\n    fa[u] = true;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (vis[i / 2]) continue;\n        if (mark[v] != mark[u]) continue;\n        vis[i / 2] = true;\n        data[i / 2][0] = u;\n        data[i / 2][1] = v;\n        if (fa[v]) continue;\n        dfs1(v);\n    }\n}\n\nvoid dfs2(int u) {\n    vis[u] = true;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        //这里类似 DFS 一棵树的过程，如果当前双连通分量已经访问过了，那么不应该通过其他强连通分量去访问了\n        if (mark[v] != mark[u]) {\n            if (fa[mark[v]] == 0 || fa[mark[v]] == mark[u]) {\n                fa[mark[v]] = mark[u];\n                data[i/2][0] = v;\n                data[i/2][1] = u;\n            }\n        }\n        if (vis[v]) continue;\n        dfs2(v);\n    }\n}\n\nvoid solve() {\n    tarjan(1, -1);\n\n    //第一次 DFS 为双连通分量里面的边分配方向\n    for (int i = 1; i <= n; i++) {\n        dfs1(i);\n    }\n\n    //第二次为连接不同的双连通分量的边分配方向\n    memset(vis, 0, sizeof(vis));\n    memset(fa, 0, sizeof(fa));\n    fa[mark[id]] = -1;\n    dfs2(id);\n\n    printf(\"%d\\n\", ans);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", data[i][0], data[i][1]);\n    }\n}\n\nint main() {\n    init();\n    solve();\n}\n```\n# 解题过程：\n\n这题卡了好久，主要是为缩点后的图重新建边后会爆内存，然后只能用第一次建的边去 DFS，然后就写的有点恶心了...","slug":"CodeForces732F-Tourist-Reform（边双连通-DFS）","published":1,"updated":"2017-10-19T01:16:56.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9m000ny9id5fwdxpy9","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/732/problem/F\" target=\"_blank\" rel=\"external\">http://codeforces.com/contest/732/problem/F</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一张 n 个顶点， m 条边的无向图，保证图连通，没有重边，现在给每个边加上方向，记从点 i 出发可以访问到的点的数量为 $r_i$，求一种分配方向的方式，使得最小的 $r_i$ 尽量的大。</p>\n<p>$2 \\le n \\le 400000, 1 \\le m \\le 400000$</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里就引用下 <a href=\"https://blog.sengxian.com/solutions/cf-732f\" target=\"_blank\" rel=\"external\">dalao的博客</a>:</p>\n<blockquote>\n<p>我们考虑如何将边定向，定向成 DAG 肯定是极不好的，因为 DAG 里边存在没有出度的点，而这样的话，答案就必然为 1 了。也就是说，不能出去的点，最好要形成一个环，这样答案就是环的大小了。</p>\n<p>将图分解为若干边-双连通分量，将每个边-双连通分量看作一个点，那么此时形成了一棵缩点树。对于每个边-双连通分量，我们可以将里边的边定向，使之成为强联通分量。再将缩点后的树边定向，成为一个边指向根的树形图，这样答案就是根代表的边-双连通分量的答案，由于任意点都可以做树形图的根，所以答案就是最大的边-双连通分量的大小。</p>\n<p><strong>定理：</strong>答案就是是最大的边-双连通分量的大小。<br><strong>证明：</strong>前面已经证明了，最大的边-双连通分量的大小是一个合法答案。现在只需证明，最大的答案不会大于最大的边-双连通分量的大小：考虑定向后的图，将其强联通缩点，答案就是没有出度的强联通分量中最小的那个，如果这个值比最大的边-双连通分量的大小更大，那么考虑将这个强联通分量中的边改为无向边，这就能形成一个边-双连通分量，而且比原图中最大的边-双连通分量的大小还要大，这就产生了矛盾。</p>\n<p>考虑输出方案，树边是很好定向的，DFS 一下缩点树就行了。如何将边-双连通分量中的边定向，使得形成一个强联通分量呢？我们考虑直接使用 DFS 中第一次访问边的顺序，为什么？因为利用这个顺序，肯定能保证联通。我们再考虑 DFS 树，在 DFS 树中，每个点一定能通过 DFS 返祖边和非返祖边的结合，走到自己上方的点（否则存在桥，与边-双连通的定义违背），所以每个点都可以通过定向后的边走到根，自然证明这个原先的边-双连通分量通过这种定向方法后强联通。</p>\n</blockquote>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], ecnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], pre[MAX], mark[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], ans, id;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[ecnt].u = u;</div><div class=\"line\">    edge[ecnt].v = v;</div><div class=\"line\">    edge[ecnt].nxt = head[u];</div><div class=\"line\">    head[u] = ecnt++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = ecnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;data[i][<span class=\"number\">0</span>], &amp;data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        add_edge(data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        add_edge(data[i][<span class=\"number\">1</span>], data[i][<span class=\"number\">0</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fa)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v, u);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pre[u] == low[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">            num[scc_cnt]++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (num[scc_cnt] &gt; ans) &#123;</div><div class=\"line\">                ans = num[scc_cnt];</div><div class=\"line\">                id = u;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> fa[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    fa[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i / <span class=\"number\">2</span>]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[v] != mark[u]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        vis[i / <span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\">        data[i / <span class=\"number\">2</span>][<span class=\"number\">0</span>] = u;</div><div class=\"line\">        data[i / <span class=\"number\">2</span>][<span class=\"number\">1</span>] = v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (fa[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs1(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"comment\">//这里类似 DFS 一棵树的过程，如果当前双连通分量已经访问过了，那么不应该通过其他强连通分量去访问了</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[v] != mark[u]) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fa[mark[v]] == <span class=\"number\">0</span> || fa[mark[v]] == mark[u]) &#123;</div><div class=\"line\">                fa[mark[v]] = mark[u];</div><div class=\"line\">                data[i/<span class=\"number\">2</span>][<span class=\"number\">0</span>] = v;</div><div class=\"line\">                data[i/<span class=\"number\">2</span>][<span class=\"number\">1</span>] = u;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs2(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    tarjan(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第一次 DFS 为双连通分量里面的边分配方向</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dfs1(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二次为连接不同的双连通分量的边分配方向</span></div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(fa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(fa));</div><div class=\"line\">    fa[mark[id]] = <span class=\"number\">-1</span>;</div><div class=\"line\">    dfs2(id);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    solve();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题卡了好久，主要是为缩点后的图重新建边后会爆内存，然后只能用第一次建的边去 DFS，然后就写的有点恶心了…</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/732/problem/F\" target=\"_blank\" rel=\"external\">http://codeforces.com/contest/732/problem/F</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一张 n 个顶点， m 条边的无向图，保证图连通，没有重边，现在给每个边加上方向，记从点 i 出发可以访问到的点的数量为 $r_i$，求一种分配方向的方式，使得最小的 $r_i$ 尽量的大。</p>\n<p>$2 \\le n \\le 400000, 1 \\le m \\le 400000$</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里就引用下 <a href=\"https://blog.sengxian.com/solutions/cf-732f\" target=\"_blank\" rel=\"external\">dalao的博客</a>:</p>\n<blockquote>\n<p>我们考虑如何将边定向，定向成 DAG 肯定是极不好的，因为 DAG 里边存在没有出度的点，而这样的话，答案就必然为 1 了。也就是说，不能出去的点，最好要形成一个环，这样答案就是环的大小了。</p>\n<p>将图分解为若干边-双连通分量，将每个边-双连通分量看作一个点，那么此时形成了一棵缩点树。对于每个边-双连通分量，我们可以将里边的边定向，使之成为强联通分量。再将缩点后的树边定向，成为一个边指向根的树形图，这样答案就是根代表的边-双连通分量的答案，由于任意点都可以做树形图的根，所以答案就是最大的边-双连通分量的大小。</p>\n<p><strong>定理：</strong>答案就是是最大的边-双连通分量的大小。<br><strong>证明：</strong>前面已经证明了，最大的边-双连通分量的大小是一个合法答案。现在只需证明，最大的答案不会大于最大的边-双连通分量的大小：考虑定向后的图，将其强联通缩点，答案就是没有出度的强联通分量中最小的那个，如果这个值比最大的边-双连通分量的大小更大，那么考虑将这个强联通分量中的边改为无向边，这就能形成一个边-双连通分量，而且比原图中最大的边-双连通分量的大小还要大，这就产生了矛盾。</p>\n<p>考虑输出方案，树边是很好定向的，DFS 一下缩点树就行了。如何将边-双连通分量中的边定向，使得形成一个强联通分量呢？我们考虑直接使用 DFS 中第一次访问边的顺序，为什么？因为利用这个顺序，肯定能保证联通。我们再考虑 DFS 树，在 DFS 树中，每个点一定能通过 DFS 返祖边和非返祖边的结合，走到自己上方的点（否则存在桥，与边-双连通的定义违背），所以每个点都可以通过定向后的边走到根，自然证明这个原先的边-双连通分量通过这种定向方法后强联通。</p>\n</blockquote>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], ecnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], pre[MAX], mark[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], ans, id;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[ecnt].u = u;</div><div class=\"line\">    edge[ecnt].v = v;</div><div class=\"line\">    edge[ecnt].nxt = head[u];</div><div class=\"line\">    head[u] = ecnt++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = ecnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;data[i][<span class=\"number\">0</span>], &amp;data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        add_edge(data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        add_edge(data[i][<span class=\"number\">1</span>], data[i][<span class=\"number\">0</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fa)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v, u);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pre[u] == low[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">            num[scc_cnt]++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (num[scc_cnt] &gt; ans) &#123;</div><div class=\"line\">                ans = num[scc_cnt];</div><div class=\"line\">                id = u;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> fa[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    fa[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i / <span class=\"number\">2</span>]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[v] != mark[u]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        vis[i / <span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\">        data[i / <span class=\"number\">2</span>][<span class=\"number\">0</span>] = u;</div><div class=\"line\">        data[i / <span class=\"number\">2</span>][<span class=\"number\">1</span>] = v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (fa[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs1(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"comment\">//这里类似 DFS 一棵树的过程，如果当前双连通分量已经访问过了，那么不应该通过其他强连通分量去访问了</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[v] != mark[u]) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fa[mark[v]] == <span class=\"number\">0</span> || fa[mark[v]] == mark[u]) &#123;</div><div class=\"line\">                fa[mark[v]] = mark[u];</div><div class=\"line\">                data[i/<span class=\"number\">2</span>][<span class=\"number\">0</span>] = v;</div><div class=\"line\">                data[i/<span class=\"number\">2</span>][<span class=\"number\">1</span>] = u;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs2(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    tarjan(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第一次 DFS 为双连通分量里面的边分配方向</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dfs1(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二次为连接不同的双连通分量的边分配方向</span></div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(fa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(fa));</div><div class=\"line\">    fa[mark[id]] = <span class=\"number\">-1</span>;</div><div class=\"line\">    dfs2(id);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    solve();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题卡了好久，主要是为缩点后的图重新建边后会爆内存，然后只能用第一次建的边去 DFS，然后就写的有点恶心了…</p>\n"},{"title":"CodeForces740D - Alyona and a tree (二分+树上差分)","date":"2017-08-16T14:11:26.000Z","_content":"# 题目链接：\n\nhttp://codeforces.com/problemset/problem/740/D\n\n\n\n--------------------\n# 题目大意：\n\n给出一颗有根树，每个点有点权$a_i$，每个边有边权，定义$dist(u, v)$为 u 到 v 的边权和，如果有两个节点符合，v 是 u 的子节点并且 $dist(u, v) \\le a_v$那么称 v 为 u 控制的节点。\n\n题目要求输出每个点控制的节点有多少个。\n\n\n\n-------------------\n# 解题过程：\n\n大体思路没错，推出来如果固定 v 的话，那么从 v 往上会有一段连续的祖先都可以控制 v，让他们控制的节点都加一就可以了，然后找这一段连续的祖先可以用二分去找。但是不知道该怎么让这一对祖先同时加一，于是想起来之前刚学的树链剖分，感觉 CF div2 的 D 题不至于上树剖...\n\n然后去翻了下博客，发现了居然还有树上差分这种东西！问了学长 + 翻了 standing 上的代码算是理解了。\n\n\n\n--------------------\n# 题目分析：\n\n首先我们设 $dep[u] $ 为根节点到节点 u 的权值和，对于原式 $dist(u, v) \\le a_v$ 可化为 $dep[v] - a_v \\le dep[u]$ ，这样我们在递归到 v 的时候，维护一个序列以深度的顺序记录 v 的所有祖先的 $dep$ 值，然后这个值肯定是递增的。\n\n这样对于每个节点 v 用二分在序列里找到满足上式最小的$dep[u]$，那么序列中 u 后面的节点都满足上式，让这些节点控制的节点数全加一即可。\n\n对于加一这个操作，我们让第一个祖先节点的父亲减一，当前节点的父亲加一，然后你会会发现，现在每个节点的所有子节点和他自身的和就是答案了。\n\n\n\n\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 212345;\n\nint n, idx[MAX], pcnt;\n//pre记录当前节点所有父亲节点的dep，并且是递增的\n//idx记录pre数组里每个位置对应的下标\n//d记录当前节点+1/-1操作了多少次\n//ans记录答案\nLL a[MAX], w[MAX], pre[MAX], d[MAX], ans[MAX];\n\nvector<int> G[MAX];\n\nvoid dfs(int u) {\n\t//找出第一个符合的祖先\n    int id = lower_bound(pre, pre + pcnt + 1, pre[pcnt] - a[u]) - pre;\n    //进行+1/-1操作\n    d[idx[id - 1]]--;\n    d[idx[pcnt - 1]]++;\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        //更新pre数组\n        pre[pcnt + 1] = pre[pcnt] + w[v];\n        idx[pcnt + 1] = v;\n        pcnt++;\n        dfs(v);\n        pcnt--;\n        //累加每个儿子的权值和\n        ans[u] += ans[v];\n    }\n    ans[u] += d[u];\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n    for (int v = 2; v <= n; v++) {\n        int u;\n        scanf(\"%d%lld\", &u, &w[v]);\n        G[u].push_back(v);\n    }\n    idx[0] = 1;\n    dfs(1);\n    for (int i = 1; i <= n; i++) printf(\"%lld \", ans[i]);\n}\n```","source":"_posts/CodeForces740D-Alyona-and-a-tree-二分-树上差分.md","raw":"---\ntitle: CodeForces740D - Alyona and a tree (二分+树上差分)\ndate: 2017-08-16 22:11:26\ncategories: [ACM, 二分]\ntags:\n---\n# 题目链接：\n\nhttp://codeforces.com/problemset/problem/740/D\n\n\n\n--------------------\n# 题目大意：\n\n给出一颗有根树，每个点有点权$a_i$，每个边有边权，定义$dist(u, v)$为 u 到 v 的边权和，如果有两个节点符合，v 是 u 的子节点并且 $dist(u, v) \\le a_v$那么称 v 为 u 控制的节点。\n\n题目要求输出每个点控制的节点有多少个。\n\n\n\n-------------------\n# 解题过程：\n\n大体思路没错，推出来如果固定 v 的话，那么从 v 往上会有一段连续的祖先都可以控制 v，让他们控制的节点都加一就可以了，然后找这一段连续的祖先可以用二分去找。但是不知道该怎么让这一对祖先同时加一，于是想起来之前刚学的树链剖分，感觉 CF div2 的 D 题不至于上树剖...\n\n然后去翻了下博客，发现了居然还有树上差分这种东西！问了学长 + 翻了 standing 上的代码算是理解了。\n\n\n\n--------------------\n# 题目分析：\n\n首先我们设 $dep[u] $ 为根节点到节点 u 的权值和，对于原式 $dist(u, v) \\le a_v$ 可化为 $dep[v] - a_v \\le dep[u]$ ，这样我们在递归到 v 的时候，维护一个序列以深度的顺序记录 v 的所有祖先的 $dep$ 值，然后这个值肯定是递增的。\n\n这样对于每个节点 v 用二分在序列里找到满足上式最小的$dep[u]$，那么序列中 u 后面的节点都满足上式，让这些节点控制的节点数全加一即可。\n\n对于加一这个操作，我们让第一个祖先节点的父亲减一，当前节点的父亲加一，然后你会会发现，现在每个节点的所有子节点和他自身的和就是答案了。\n\n\n\n\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 212345;\n\nint n, idx[MAX], pcnt;\n//pre记录当前节点所有父亲节点的dep，并且是递增的\n//idx记录pre数组里每个位置对应的下标\n//d记录当前节点+1/-1操作了多少次\n//ans记录答案\nLL a[MAX], w[MAX], pre[MAX], d[MAX], ans[MAX];\n\nvector<int> G[MAX];\n\nvoid dfs(int u) {\n\t//找出第一个符合的祖先\n    int id = lower_bound(pre, pre + pcnt + 1, pre[pcnt] - a[u]) - pre;\n    //进行+1/-1操作\n    d[idx[id - 1]]--;\n    d[idx[pcnt - 1]]++;\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        //更新pre数组\n        pre[pcnt + 1] = pre[pcnt] + w[v];\n        idx[pcnt + 1] = v;\n        pcnt++;\n        dfs(v);\n        pcnt--;\n        //累加每个儿子的权值和\n        ans[u] += ans[v];\n    }\n    ans[u] += d[u];\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n    for (int v = 2; v <= n; v++) {\n        int u;\n        scanf(\"%d%lld\", &u, &w[v]);\n        G[u].push_back(v);\n    }\n    idx[0] = 1;\n    dfs(1);\n    for (int i = 1; i <= n; i++) printf(\"%lld \", ans[i]);\n}\n```","slug":"CodeForces740D-Alyona-and-a-tree-二分-树上差分","published":1,"updated":"2017-08-17T00:32:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9p000qy9idqhjdciea","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/740/D\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/740/D</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一颗有根树，每个点有点权$a_i$，每个边有边权，定义$dist(u, v)$为 u 到 v 的边权和，如果有两个节点符合，v 是 u 的子节点并且 $dist(u, v) \\le a_v$那么称 v 为 u 控制的节点。</p>\n<p>题目要求输出每个点控制的节点有多少个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>大体思路没错，推出来如果固定 v 的话，那么从 v 往上会有一段连续的祖先都可以控制 v，让他们控制的节点都加一就可以了，然后找这一段连续的祖先可以用二分去找。但是不知道该怎么让这一对祖先同时加一，于是想起来之前刚学的树链剖分，感觉 CF div2 的 D 题不至于上树剖…</p>\n<p>然后去翻了下博客，发现了居然还有树上差分这种东西！问了学长 + 翻了 standing 上的代码算是理解了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先我们设 $dep[u] $ 为根节点到节点 u 的权值和，对于原式 $dist(u, v) \\le a_v$ 可化为 $dep[v] - a_v \\le dep[u]$ ，这样我们在递归到 v 的时候，维护一个序列以深度的顺序记录 v 的所有祖先的 $dep$ 值，然后这个值肯定是递增的。</p>\n<p>这样对于每个节点 v 用二分在序列里找到满足上式最小的$dep[u]$，那么序列中 u 后面的节点都满足上式，让这些节点控制的节点数全加一即可。</p>\n<p>对于加一这个操作，我们让第一个祖先节点的父亲减一，当前节点的父亲加一，然后你会会发现，现在每个节点的所有子节点和他自身的和就是答案了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, idx[MAX], pcnt;</div><div class=\"line\"><span class=\"comment\">//pre记录当前节点所有父亲节点的dep，并且是递增的</span></div><div class=\"line\"><span class=\"comment\">//idx记录pre数组里每个位置对应的下标</span></div><div class=\"line\"><span class=\"comment\">//d记录当前节点+1/-1操作了多少次</span></div><div class=\"line\"><span class=\"comment\">//ans记录答案</span></div><div class=\"line\">LL a[MAX], w[MAX], pre[MAX], d[MAX], ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//找出第一个符合的祖先</span></div><div class=\"line\">    <span class=\"keyword\">int</span> id = lower_bound(pre, pre + pcnt + <span class=\"number\">1</span>, pre[pcnt] - a[u]) - pre;</div><div class=\"line\">    <span class=\"comment\">//进行+1/-1操作</span></div><div class=\"line\">    d[idx[id - <span class=\"number\">1</span>]]--;</div><div class=\"line\">    d[idx[pcnt - <span class=\"number\">1</span>]]++;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">        <span class=\"comment\">//更新pre数组</span></div><div class=\"line\">        pre[pcnt + <span class=\"number\">1</span>] = pre[pcnt] + w[v];</div><div class=\"line\">        idx[pcnt + <span class=\"number\">1</span>] = v;</div><div class=\"line\">        pcnt++;</div><div class=\"line\">        dfs(v);</div><div class=\"line\">        pcnt--;</div><div class=\"line\">        <span class=\"comment\">//累加每个儿子的权值和</span></div><div class=\"line\">        ans[u] += ans[v];</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans[u] += d[u];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;a[i]);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v = <span class=\"number\">2</span>; v &lt;= n; v++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%lld\"</span>, &amp;u, &amp;w[v]);</div><div class=\"line\">        G[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">    idx[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dfs(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld \"</span>, ans[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/740/D\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/740/D</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一颗有根树，每个点有点权$a_i$，每个边有边权，定义$dist(u, v)$为 u 到 v 的边权和，如果有两个节点符合，v 是 u 的子节点并且 $dist(u, v) \\le a_v$那么称 v 为 u 控制的节点。</p>\n<p>题目要求输出每个点控制的节点有多少个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>大体思路没错，推出来如果固定 v 的话，那么从 v 往上会有一段连续的祖先都可以控制 v，让他们控制的节点都加一就可以了，然后找这一段连续的祖先可以用二分去找。但是不知道该怎么让这一对祖先同时加一，于是想起来之前刚学的树链剖分，感觉 CF div2 的 D 题不至于上树剖…</p>\n<p>然后去翻了下博客，发现了居然还有树上差分这种东西！问了学长 + 翻了 standing 上的代码算是理解了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先我们设 $dep[u] $ 为根节点到节点 u 的权值和，对于原式 $dist(u, v) \\le a_v$ 可化为 $dep[v] - a_v \\le dep[u]$ ，这样我们在递归到 v 的时候，维护一个序列以深度的顺序记录 v 的所有祖先的 $dep$ 值，然后这个值肯定是递增的。</p>\n<p>这样对于每个节点 v 用二分在序列里找到满足上式最小的$dep[u]$，那么序列中 u 后面的节点都满足上式，让这些节点控制的节点数全加一即可。</p>\n<p>对于加一这个操作，我们让第一个祖先节点的父亲减一，当前节点的父亲加一，然后你会会发现，现在每个节点的所有子节点和他自身的和就是答案了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, idx[MAX], pcnt;</div><div class=\"line\"><span class=\"comment\">//pre记录当前节点所有父亲节点的dep，并且是递增的</span></div><div class=\"line\"><span class=\"comment\">//idx记录pre数组里每个位置对应的下标</span></div><div class=\"line\"><span class=\"comment\">//d记录当前节点+1/-1操作了多少次</span></div><div class=\"line\"><span class=\"comment\">//ans记录答案</span></div><div class=\"line\">LL a[MAX], w[MAX], pre[MAX], d[MAX], ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//找出第一个符合的祖先</span></div><div class=\"line\">    <span class=\"keyword\">int</span> id = lower_bound(pre, pre + pcnt + <span class=\"number\">1</span>, pre[pcnt] - a[u]) - pre;</div><div class=\"line\">    <span class=\"comment\">//进行+1/-1操作</span></div><div class=\"line\">    d[idx[id - <span class=\"number\">1</span>]]--;</div><div class=\"line\">    d[idx[pcnt - <span class=\"number\">1</span>]]++;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">        <span class=\"comment\">//更新pre数组</span></div><div class=\"line\">        pre[pcnt + <span class=\"number\">1</span>] = pre[pcnt] + w[v];</div><div class=\"line\">        idx[pcnt + <span class=\"number\">1</span>] = v;</div><div class=\"line\">        pcnt++;</div><div class=\"line\">        dfs(v);</div><div class=\"line\">        pcnt--;</div><div class=\"line\">        <span class=\"comment\">//累加每个儿子的权值和</span></div><div class=\"line\">        ans[u] += ans[v];</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans[u] += d[u];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;a[i]);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v = <span class=\"number\">2</span>; v &lt;= n; v++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%lld\"</span>, &amp;u, &amp;w[v]);</div><div class=\"line\">        G[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">    idx[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dfs(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld \"</span>, ans[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces743D - Chloe and pleasant prizes（树型DP）","date":"2017-06-27T09:10:50.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/CodeForces-743D\n\n\n----------------------\n# 题目大意：\n给定一颗树，每个节点上有一个权值，求找出两颗不相交子树，使两颗子树的权值和最大。\n\n---------------------------------\n# 解题过程：\n好久好久好久之前CF比赛的题，当时好像是没读懂题意，虽然说现在也有点读不懂，最后看了下别人的博客才知道题意。看到下面的标签上有DFS和DP，于是往树型DP上想，不过没系统的学过，之前只写过一个求树的重心的，于是照着那个思路想，没想到还真的可以做。\n\n-------------------------------\n# 题目分析：\n定义状态$dp[u]$表示以节点$u$的所有子树（包括他自身）的最大权值和，$sum(u)$表示以$u$为根节点的树的权值和显然有：\n$dp[u] = max(dp[v], sum(u))$  \n这里的$v$是$u$的儿子节点。\n\n然后要求不相交的两个子树，对于一个节点，他的两个儿子构成的子树一定是不相交的，这样遍历一下所有的节点就好了。\n\n\n-----------------------------\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 212345;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nvector<int> edge[MAX];\nint data[MAX];\nbool vis[MAX];\n\nint fat[MAX];\nLL sum[MAX], dp[MAX];\n\n//DFS求出DP数组\nLL dfs(int u) {\n    vis[u] = true;\n    //sum记录以当前节点为根节点的权值和\n    LL & temp = sum[u];\n    temp += data[u];\n    //枚举所有的儿子节点，更新DP数组和计算当前树的权值和\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!vis[v]) {\n            fat[v] = u;\n            LL t = dfs(v);\n            temp += t;\n            dp[u] = max(dp[v], dp[u]);\n        }\n    }\n    //最后用当前树的权值和更新一下DP数组\n    dp[u] = max(dp[u], temp);\n    return temp;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = -INF;\n        cin >> data[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1);\n    LL ans = -INF;\n    for (int i = 1; i <= n; i++) {\n        if (edge[i].size() < 2)\n            continue;\n        LL a, b;\n        a = b = -INF;\n        //枚举每个节点，找出最大的两个儿子节点\n        for (int j = 0; j < edge[i].size(); j++) {\n            int v = edge[i][j];\n            if (fat[v] != i)\n                continue;\n            if (a < dp[v]) {\n                a = dp[v];\n                if (b < a)\n                    swap(a, b);\n            }\n        }\n        if (a == -INF || b == -INF)\n            continue;\n        ans = max(ans, a + b);\n    }\n\n    if (ans <= -INF)\n        printf(\"Impossible\\n\");\n    else\n        printf(\"%lld\\n\", ans);\n}\n```","source":"_posts/CodeForces743D-Chloe-and-pleasant-prizes（树型DP）.md","raw":"---\ntitle: CodeForces743D - Chloe and pleasant prizes（树型DP）\ndate: 2017-06-27 17:10:50\ncategories: [ACM, DP, 树型DP]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/CodeForces-743D\n\n\n----------------------\n# 题目大意：\n给定一颗树，每个节点上有一个权值，求找出两颗不相交子树，使两颗子树的权值和最大。\n\n---------------------------------\n# 解题过程：\n好久好久好久之前CF比赛的题，当时好像是没读懂题意，虽然说现在也有点读不懂，最后看了下别人的博客才知道题意。看到下面的标签上有DFS和DP，于是往树型DP上想，不过没系统的学过，之前只写过一个求树的重心的，于是照着那个思路想，没想到还真的可以做。\n\n-------------------------------\n# 题目分析：\n定义状态$dp[u]$表示以节点$u$的所有子树（包括他自身）的最大权值和，$sum(u)$表示以$u$为根节点的树的权值和显然有：\n$dp[u] = max(dp[v], sum(u))$  \n这里的$v$是$u$的儿子节点。\n\n然后要求不相交的两个子树，对于一个节点，他的两个儿子构成的子树一定是不相交的，这样遍历一下所有的节点就好了。\n\n\n-----------------------------\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 212345;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nvector<int> edge[MAX];\nint data[MAX];\nbool vis[MAX];\n\nint fat[MAX];\nLL sum[MAX], dp[MAX];\n\n//DFS求出DP数组\nLL dfs(int u) {\n    vis[u] = true;\n    //sum记录以当前节点为根节点的权值和\n    LL & temp = sum[u];\n    temp += data[u];\n    //枚举所有的儿子节点，更新DP数组和计算当前树的权值和\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!vis[v]) {\n            fat[v] = u;\n            LL t = dfs(v);\n            temp += t;\n            dp[u] = max(dp[v], dp[u]);\n        }\n    }\n    //最后用当前树的权值和更新一下DP数组\n    dp[u] = max(dp[u], temp);\n    return temp;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = -INF;\n        cin >> data[i];\n    }\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1);\n    LL ans = -INF;\n    for (int i = 1; i <= n; i++) {\n        if (edge[i].size() < 2)\n            continue;\n        LL a, b;\n        a = b = -INF;\n        //枚举每个节点，找出最大的两个儿子节点\n        for (int j = 0; j < edge[i].size(); j++) {\n            int v = edge[i][j];\n            if (fat[v] != i)\n                continue;\n            if (a < dp[v]) {\n                a = dp[v];\n                if (b < a)\n                    swap(a, b);\n            }\n        }\n        if (a == -INF || b == -INF)\n            continue;\n        ans = max(ans, a + b);\n    }\n\n    if (ans <= -INF)\n        printf(\"Impossible\\n\");\n    else\n        printf(\"%lld\\n\", ans);\n}\n```","slug":"CodeForces743D-Chloe-and-pleasant-prizes（树型DP）","published":1,"updated":"2017-07-23T01:50:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9r000sy9idb9blvq5l","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/CodeForces-743D\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/CodeForces-743D</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一颗树，每个节点上有一个权值，求找出两颗不相交子树，使两颗子树的权值和最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>好久好久好久之前CF比赛的题，当时好像是没读懂题意，虽然说现在也有点读不懂，最后看了下别人的博客才知道题意。看到下面的标签上有DFS和DP，于是往树型DP上想，不过没系统的学过，之前只写过一个求树的重心的，于是照着那个思路想，没想到还真的可以做。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态$dp[u]$表示以节点$u$的所有子树（包括他自身）的最大权值和，$sum(u)$表示以$u$为根节点的树的权值和显然有：<br>$dp[u] = max(dp[v], sum(u))$<br>这里的$v$是$u$的儿子节点。</p>\n<p>然后要求不相交的两个子树，对于一个节点，他的两个儿子构成的子树一定是不相交的，这样遍历一下所有的节点就好了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> fat[MAX];</div><div class=\"line\">LL sum[MAX], dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//DFS求出DP数组</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"comment\">//sum记录以当前节点为根节点的权值和</span></div><div class=\"line\">    LL &amp; temp = sum[u];</div><div class=\"line\">    temp += data[u];</div><div class=\"line\">    <span class=\"comment\">//枚举所有的儿子节点，更新DP数组和计算当前树的权值和</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">            fat[v] = u;</div><div class=\"line\">            LL t = dfs(v);</div><div class=\"line\">            temp += t;</div><div class=\"line\">            dp[u] = max(dp[v], dp[u]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//最后用当前树的权值和更新一下DP数组</span></div><div class=\"line\">    dp[u] = max(dp[u], temp);</div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i] = -INF;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</div><div class=\"line\">        edge[u].push_back(v);</div><div class=\"line\">        edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    dfs(<span class=\"number\">1</span>);</div><div class=\"line\">    LL ans = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i].size() &lt; <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        LL a, b;</div><div class=\"line\">        a = b = -INF;</div><div class=\"line\">        <span class=\"comment\">//枚举每个节点，找出最大的两个儿子节点</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edge[i].size(); j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i][j];</div><div class=\"line\">            <span class=\"keyword\">if</span> (fat[v] != i)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a &lt; dp[v]) &#123;</div><div class=\"line\">                a = dp[v];</div><div class=\"line\">                <span class=\"keyword\">if</span> (b &lt; a)</div><div class=\"line\">                    swap(a, b);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == -INF || b == -INF)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        ans = max(ans, a + b);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &lt;= -INF)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Impossible\\n\"</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/CodeForces-743D\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/CodeForces-743D</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一颗树，每个节点上有一个权值，求找出两颗不相交子树，使两颗子树的权值和最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>好久好久好久之前CF比赛的题，当时好像是没读懂题意，虽然说现在也有点读不懂，最后看了下别人的博客才知道题意。看到下面的标签上有DFS和DP，于是往树型DP上想，不过没系统的学过，之前只写过一个求树的重心的，于是照着那个思路想，没想到还真的可以做。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态$dp[u]$表示以节点$u$的所有子树（包括他自身）的最大权值和，$sum(u)$表示以$u$为根节点的树的权值和显然有：<br>$dp[u] = max(dp[v], sum(u))$<br>这里的$v$是$u$的儿子节点。</p>\n<p>然后要求不相交的两个子树，对于一个节点，他的两个儿子构成的子树一定是不相交的，这样遍历一下所有的节点就好了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">212345</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> fat[MAX];</div><div class=\"line\">LL sum[MAX], dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//DFS求出DP数组</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    vis[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"comment\">//sum记录以当前节点为根节点的权值和</span></div><div class=\"line\">    LL &amp; temp = sum[u];</div><div class=\"line\">    temp += data[u];</div><div class=\"line\">    <span class=\"comment\">//枚举所有的儿子节点，更新DP数组和计算当前树的权值和</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">            fat[v] = u;</div><div class=\"line\">            LL t = dfs(v);</div><div class=\"line\">            temp += t;</div><div class=\"line\">            dp[u] = max(dp[v], dp[u]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//最后用当前树的权值和更新一下DP数组</span></div><div class=\"line\">    dp[u] = max(dp[u], temp);</div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i] = -INF;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</div><div class=\"line\">        edge[u].push_back(v);</div><div class=\"line\">        edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    dfs(<span class=\"number\">1</span>);</div><div class=\"line\">    LL ans = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i].size() &lt; <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        LL a, b;</div><div class=\"line\">        a = b = -INF;</div><div class=\"line\">        <span class=\"comment\">//枚举每个节点，找出最大的两个儿子节点</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edge[i].size(); j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i][j];</div><div class=\"line\">            <span class=\"keyword\">if</span> (fat[v] != i)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a &lt; dp[v]) &#123;</div><div class=\"line\">                a = dp[v];</div><div class=\"line\">                <span class=\"keyword\">if</span> (b &lt; a)</div><div class=\"line\">                    swap(a, b);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == -INF || b == -INF)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        ans = max(ans, a + b);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &lt;= -INF)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Impossible\\n\"</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces743E - Vladik and cards（状压DP + 二分）","date":"2017-08-18T02:56:01.000Z","_content":"# 题目链接：\n\nhttp://codeforces.com/problemset/problem/743/E\n\n\n\n--------------------\n# 题目大意：\n\n给出一个只含数字 1~8 序列，找出一个符合下面条件的最长子序列。\n\n1. 选出的子序列，每种数字出现的次数差不能超过，没选视为出现 0 次。\n2. 选出的子序列中，相同数字出现的位置要连续。\n\n\n-------------------\n# 解题过程：\n\n补的好久之前的题，一开始题意都没看懂，然后去搜了下题意，顺便看到了二分+状压dp的标签，不过还是不会做。刚开始做的时候漏掉了第二个条件....\n\n最后翻到了两个博客：\n\n+ http://blog.csdn.net/mengxiang000000/article/details/53695321\n+ http://www.cnblogs.com/Saurus/p/6183721.html\n\n\n--------------------\n# 题目分析：\n\n首先因为每种序列的差最大不会超过 1，那么我们可以二分答案，枚举较长的连续数字长度 L 。\n\n然后用 DP 判断一个解是否可行，并且算出来最优的答案。\n\n假设我们现在限制最长的长度为 L，那么对于每种数字有 L 和 L-1 两种长度可选，显然选长度为 L 是比 L-1 更优的，现在我们要知道最多能选多少个长度为 L 的。\n\n首先用一个集合记录那些数已经选完，那些还没选，由于只有 8 个数字，所以可以用状态压缩。\n\n设二维的 DP 数组 $dp[i][j]$ 的含义是，只考虑序列里前 i 个数字，选取的状态为 j 的时，最多能选几个长度为 L 的连续数字。\n\n这时候有状态转移方程：\n\n$$dp[next(i, L-1)][s \\cup k] = max(itself, dp[i][s]) $$\n\n$$ dp[next(i, L)][s \\cup k] = max(itself, dp[i][s])$$\n\n$next(i, L)$ 表示从当前位置开始往后第 L 个数字 k 的位置，这个可以通过预处理获得。\n\n这样就得出了当最长的连续数字长度为 L 时可以选多少个长度为 L 的连续数字。\n\n设上面结果为 sum，那么 $sum \\cdot L + (8 - sum) \\cdot (L - 1)$ 就是原问题的答案。\n\n不过二分枚举 L 的时候 L 最小为 2，因为我们默认长度为 L-1 的连续数字是合法的。\n\n我们特殊处理一下 L = 1 的情况，判断下有多少个数字至少出现了一次即可。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1123;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> pos[10];\n\nint n, ans;\nint a[MAX], dp[MAX][1 << 8], cur[10];\n\nbool ok(int L) {\n    memset(cur, 0, sizeof(cur));\n    memset(dp, -1, sizeof(dp));\n    //初始合法的状态只有在字符串开始并且一个没放的情况\n    dp[1][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < (1 << 8); j++) {\n            if (dp[i][j] < 0) continue;\n            for (int k = 1; k <= 8; k++) {\n                //如果当前 dp 数组的值为负数，说明当前状态是不可到达的，不进行往后转移\n                if (j & (1 << (k - 1))) continue;\n                if (pos[k].size() - cur[k] < L - 1) continue;\n                dp[pos[k][cur[k] + L - 2]][j | (1 << (k - 1))] = max(dp[pos[k][cur[k] + L - 2]][j | (1 << (k - 1))],\n                                                                     dp[i][j]);\n                if (pos[k].size() - cur[k] < L) continue;\n                dp[pos[k][cur[k] + L - 1]][j | (1 << (k - 1))] = max(dp[pos[k][cur[k] + L - 1]][j | (1 << (k - 1))],\n                                                                     dp[i][j] + 1);\n            }\n        }\n        //cur记录每个数字出现了多少次\n        cur[a[i]]++;\n    }\n    int sum = -INF;\n    for (int i = 1; i <= n; i++) sum = max(sum, dp[i][(1 << 8) - 1]);\n    if (sum <= 0) return 0;\n    ans = max(ans, sum * L + (8 - sum) * (L - 1));\n    return 1;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    //记录每个出现的数字对应的下标，转移可以通过 vector 下标直接访问某个数字第 i 次出现的位置\n    for (int i = 1; i <= n; i++) pos[a[i]].push_back(i);\n\n    //二分枚举 L 且 L 至少为 2\n    int l = 2, r = n;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (ok(mid)) l = mid + 1;\n        else r = mid - 1;\n    }\n\n    //当答案为 0 的时候，考虑 L = 1 的情况\n    if (ans == 0) {\n        for (int i = 1; i <= 8; i++) {\n            if (pos[i].size() > 0) ans++;\n        }\n    }\n    cout << ans;\n}\n```","source":"_posts/CodeForces743E-Vladik-and-cards（状压DP-二分）.md","raw":"---\ntitle: CodeForces743E - Vladik and cards（状压DP + 二分）\ndate: 2017-08-18 10:56:01\ncategories: [ACM, DP, 状压DP]\ntags:\n---\n# 题目链接：\n\nhttp://codeforces.com/problemset/problem/743/E\n\n\n\n--------------------\n# 题目大意：\n\n给出一个只含数字 1~8 序列，找出一个符合下面条件的最长子序列。\n\n1. 选出的子序列，每种数字出现的次数差不能超过，没选视为出现 0 次。\n2. 选出的子序列中，相同数字出现的位置要连续。\n\n\n-------------------\n# 解题过程：\n\n补的好久之前的题，一开始题意都没看懂，然后去搜了下题意，顺便看到了二分+状压dp的标签，不过还是不会做。刚开始做的时候漏掉了第二个条件....\n\n最后翻到了两个博客：\n\n+ http://blog.csdn.net/mengxiang000000/article/details/53695321\n+ http://www.cnblogs.com/Saurus/p/6183721.html\n\n\n--------------------\n# 题目分析：\n\n首先因为每种序列的差最大不会超过 1，那么我们可以二分答案，枚举较长的连续数字长度 L 。\n\n然后用 DP 判断一个解是否可行，并且算出来最优的答案。\n\n假设我们现在限制最长的长度为 L，那么对于每种数字有 L 和 L-1 两种长度可选，显然选长度为 L 是比 L-1 更优的，现在我们要知道最多能选多少个长度为 L 的。\n\n首先用一个集合记录那些数已经选完，那些还没选，由于只有 8 个数字，所以可以用状态压缩。\n\n设二维的 DP 数组 $dp[i][j]$ 的含义是，只考虑序列里前 i 个数字，选取的状态为 j 的时，最多能选几个长度为 L 的连续数字。\n\n这时候有状态转移方程：\n\n$$dp[next(i, L-1)][s \\cup k] = max(itself, dp[i][s]) $$\n\n$$ dp[next(i, L)][s \\cup k] = max(itself, dp[i][s])$$\n\n$next(i, L)$ 表示从当前位置开始往后第 L 个数字 k 的位置，这个可以通过预处理获得。\n\n这样就得出了当最长的连续数字长度为 L 时可以选多少个长度为 L 的连续数字。\n\n设上面结果为 sum，那么 $sum \\cdot L + (8 - sum) \\cdot (L - 1)$ 就是原问题的答案。\n\n不过二分枚举 L 的时候 L 最小为 2，因为我们默认长度为 L-1 的连续数字是合法的。\n\n我们特殊处理一下 L = 1 的情况，判断下有多少个数字至少出现了一次即可。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1123;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> pos[10];\n\nint n, ans;\nint a[MAX], dp[MAX][1 << 8], cur[10];\n\nbool ok(int L) {\n    memset(cur, 0, sizeof(cur));\n    memset(dp, -1, sizeof(dp));\n    //初始合法的状态只有在字符串开始并且一个没放的情况\n    dp[1][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < (1 << 8); j++) {\n            if (dp[i][j] < 0) continue;\n            for (int k = 1; k <= 8; k++) {\n                //如果当前 dp 数组的值为负数，说明当前状态是不可到达的，不进行往后转移\n                if (j & (1 << (k - 1))) continue;\n                if (pos[k].size() - cur[k] < L - 1) continue;\n                dp[pos[k][cur[k] + L - 2]][j | (1 << (k - 1))] = max(dp[pos[k][cur[k] + L - 2]][j | (1 << (k - 1))],\n                                                                     dp[i][j]);\n                if (pos[k].size() - cur[k] < L) continue;\n                dp[pos[k][cur[k] + L - 1]][j | (1 << (k - 1))] = max(dp[pos[k][cur[k] + L - 1]][j | (1 << (k - 1))],\n                                                                     dp[i][j] + 1);\n            }\n        }\n        //cur记录每个数字出现了多少次\n        cur[a[i]]++;\n    }\n    int sum = -INF;\n    for (int i = 1; i <= n; i++) sum = max(sum, dp[i][(1 << 8) - 1]);\n    if (sum <= 0) return 0;\n    ans = max(ans, sum * L + (8 - sum) * (L - 1));\n    return 1;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    //记录每个出现的数字对应的下标，转移可以通过 vector 下标直接访问某个数字第 i 次出现的位置\n    for (int i = 1; i <= n; i++) pos[a[i]].push_back(i);\n\n    //二分枚举 L 且 L 至少为 2\n    int l = 2, r = n;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (ok(mid)) l = mid + 1;\n        else r = mid - 1;\n    }\n\n    //当答案为 0 的时候，考虑 L = 1 的情况\n    if (ans == 0) {\n        for (int i = 1; i <= 8; i++) {\n            if (pos[i].size() > 0) ans++;\n        }\n    }\n    cout << ans;\n}\n```","slug":"CodeForces743E-Vladik-and-cards（状压DP-二分）","published":1,"updated":"2017-08-24T12:15:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9t000vy9idlp6e0ya0","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/743/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/743/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个只含数字 1~8 序列，找出一个符合下面条件的最长子序列。</p>\n<ol>\n<li>选出的子序列，每种数字出现的次数差不能超过，没选视为出现 0 次。</li>\n<li>选出的子序列中，相同数字出现的位置要连续。</li>\n</ol>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>补的好久之前的题，一开始题意都没看懂，然后去搜了下题意，顺便看到了二分+状压dp的标签，不过还是不会做。刚开始做的时候漏掉了第二个条件….</p>\n<p>最后翻到了两个博客：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/mengxiang000000/article/details/53695321\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mengxiang000000/article/details/53695321</a></li>\n<li><a href=\"http://www.cnblogs.com/Saurus/p/6183721.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Saurus/p/6183721.html</a></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先因为每种序列的差最大不会超过 1，那么我们可以二分答案，枚举较长的连续数字长度 L 。</p>\n<p>然后用 DP 判断一个解是否可行，并且算出来最优的答案。</p>\n<p>假设我们现在限制最长的长度为 L，那么对于每种数字有 L 和 L-1 两种长度可选，显然选长度为 L 是比 L-1 更优的，现在我们要知道最多能选多少个长度为 L 的。</p>\n<p>首先用一个集合记录那些数已经选完，那些还没选，由于只有 8 个数字，所以可以用状态压缩。</p>\n<p>设二维的 DP 数组 $dp[i][j]$ 的含义是，只考虑序列里前 i 个数字，选取的状态为 j 的时，最多能选几个长度为 L 的连续数字。</p>\n<p>这时候有状态转移方程：</p>\n<p>$$dp[next(i, L-1)][s \\cup k] = max(itself, dp[i][s]) $$</p>\n<p>$$ dp[next(i, L)][s \\cup k] = max(itself, dp[i][s])$$</p>\n<p>$next(i, L)$ 表示从当前位置开始往后第 L 个数字 k 的位置，这个可以通过预处理获得。</p>\n<p>这样就得出了当最长的连续数字长度为 L 时可以选多少个长度为 L 的连续数字。</p>\n<p>设上面结果为 sum，那么 $sum \\cdot L + (8 - sum) \\cdot (L - 1)$ 就是原问题的答案。</p>\n<p>不过二分枚举 L 的时候 L 最小为 2，因为我们默认长度为 L-1 的连续数字是合法的。</p>\n<p>我们特殊处理一下 L = 1 的情况，判断下有多少个数字至少出现了一次即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pos[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, ans;</div><div class=\"line\"><span class=\"keyword\">int</span> a[MAX], dp[MAX][<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>], cur[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">(<span class=\"keyword\">int</span> L)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(cur, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(cur));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"comment\">//初始合法的状态只有在字符串开始并且一个没放的情况</span></div><div class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>); j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dp[i][j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= <span class=\"number\">8</span>; k++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前 dp 数组的值为负数，说明当前状态是不可到达的，不进行往后转移</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos[k].size() - cur[k] &lt; L - <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                dp[pos[k][cur[k] + L - <span class=\"number\">2</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))] = max(dp[pos[k][cur[k] + L - <span class=\"number\">2</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))],</div><div class=\"line\">                                                                     dp[i][j]);</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos[k].size() - cur[k] &lt; L) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                dp[pos[k][cur[k] + L - <span class=\"number\">1</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))] = max(dp[pos[k][cur[k] + L - <span class=\"number\">1</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))],</div><div class=\"line\">                                                                     dp[i][j] + <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//cur记录每个数字出现了多少次</span></div><div class=\"line\">        cur[a[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) sum = max(sum, dp[i][(<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>) - <span class=\"number\">1</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (sum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    ans = max(ans, sum * L + (<span class=\"number\">8</span> - sum) * (L - <span class=\"number\">1</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//记录每个出现的数字对应的下标，转移可以通过 vector 下标直接访问某个数字第 i 次出现的位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) pos[a[i]].push_back(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//二分枚举 L 且 L 至少为 2</span></div><div class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">2</span>, r = n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ok(mid)) l = mid + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//当答案为 0 的时候，考虑 L = 1 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">8</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos[i].size() &gt; <span class=\"number\">0</span>) ans++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/743/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/743/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个只含数字 1~8 序列，找出一个符合下面条件的最长子序列。</p>\n<ol>\n<li>选出的子序列，每种数字出现的次数差不能超过，没选视为出现 0 次。</li>\n<li>选出的子序列中，相同数字出现的位置要连续。</li>\n</ol>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>补的好久之前的题，一开始题意都没看懂，然后去搜了下题意，顺便看到了二分+状压dp的标签，不过还是不会做。刚开始做的时候漏掉了第二个条件….</p>\n<p>最后翻到了两个博客：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/mengxiang000000/article/details/53695321\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mengxiang000000/article/details/53695321</a></li>\n<li><a href=\"http://www.cnblogs.com/Saurus/p/6183721.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Saurus/p/6183721.html</a></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先因为每种序列的差最大不会超过 1，那么我们可以二分答案，枚举较长的连续数字长度 L 。</p>\n<p>然后用 DP 判断一个解是否可行，并且算出来最优的答案。</p>\n<p>假设我们现在限制最长的长度为 L，那么对于每种数字有 L 和 L-1 两种长度可选，显然选长度为 L 是比 L-1 更优的，现在我们要知道最多能选多少个长度为 L 的。</p>\n<p>首先用一个集合记录那些数已经选完，那些还没选，由于只有 8 个数字，所以可以用状态压缩。</p>\n<p>设二维的 DP 数组 $dp[i][j]$ 的含义是，只考虑序列里前 i 个数字，选取的状态为 j 的时，最多能选几个长度为 L 的连续数字。</p>\n<p>这时候有状态转移方程：</p>\n<p>$$dp[next(i, L-1)][s \\cup k] = max(itself, dp[i][s]) $$</p>\n<p>$$ dp[next(i, L)][s \\cup k] = max(itself, dp[i][s])$$</p>\n<p>$next(i, L)$ 表示从当前位置开始往后第 L 个数字 k 的位置，这个可以通过预处理获得。</p>\n<p>这样就得出了当最长的连续数字长度为 L 时可以选多少个长度为 L 的连续数字。</p>\n<p>设上面结果为 sum，那么 $sum \\cdot L + (8 - sum) \\cdot (L - 1)$ 就是原问题的答案。</p>\n<p>不过二分枚举 L 的时候 L 最小为 2，因为我们默认长度为 L-1 的连续数字是合法的。</p>\n<p>我们特殊处理一下 L = 1 的情况，判断下有多少个数字至少出现了一次即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pos[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, ans;</div><div class=\"line\"><span class=\"keyword\">int</span> a[MAX], dp[MAX][<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>], cur[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">(<span class=\"keyword\">int</span> L)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(cur, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(cur));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"comment\">//初始合法的状态只有在字符串开始并且一个没放的情况</span></div><div class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>); j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dp[i][j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= <span class=\"number\">8</span>; k++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前 dp 数组的值为负数，说明当前状态是不可到达的，不进行往后转移</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos[k].size() - cur[k] &lt; L - <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                dp[pos[k][cur[k] + L - <span class=\"number\">2</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))] = max(dp[pos[k][cur[k] + L - <span class=\"number\">2</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))],</div><div class=\"line\">                                                                     dp[i][j]);</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos[k].size() - cur[k] &lt; L) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                dp[pos[k][cur[k] + L - <span class=\"number\">1</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))] = max(dp[pos[k][cur[k] + L - <span class=\"number\">1</span>]][j | (<span class=\"number\">1</span> &lt;&lt; (k - <span class=\"number\">1</span>))],</div><div class=\"line\">                                                                     dp[i][j] + <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//cur记录每个数字出现了多少次</span></div><div class=\"line\">        cur[a[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) sum = max(sum, dp[i][(<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>) - <span class=\"number\">1</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (sum &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    ans = max(ans, sum * L + (<span class=\"number\">8</span> - sum) * (L - <span class=\"number\">1</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//记录每个出现的数字对应的下标，转移可以通过 vector 下标直接访问某个数字第 i 次出现的位置</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) pos[a[i]].push_back(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//二分枚举 L 且 L 至少为 2</span></div><div class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">2</span>, r = n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ok(mid)) l = mid + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//当答案为 0 的时候，考虑 L = 1 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">8</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos[i].size() &gt; <span class=\"number\">0</span>) ans++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces744B - Hongcow's Game（交互+二进制）","date":"2017-08-18T13:25:01.000Z","_content":"# 题目链接：\n\nhttp://codeforces.com/problemset/problem/744/B\n\n\n\n--------------------\n# 题目大意：\n\n给出一个矩阵，矩阵主对角线元素均为 0，选择可以最多进行 20 次询问。\n\n每次询问选择一些行，回答会输出每一行中这些列的最小的元素。\n\n矩阵大小小于等于 1000 。\n\n\n\n-------------------\n# 解题过程：\n\n想了半天没思路，到是有想到先询问一下奇数行和偶数行，然后没往后想...\n\n也算是见识了一下新套路，这样利用位运算有点类似之前在知乎上看到的小白鼠测毒药的问题了233\n\n\n\n--------------------\n# 题目分析：\n\n按二进制位将所有行分组，首先按最后一位分组，0为一组，1为一组，然后倒数第二位，以此类推，然后每次都查询一组里面所有的列。\n\n这样这样考虑，对于第 i 行的第 j 列($j \\ne i$)  ，既然不相等那么至少有一个二进制位是不同的，那么 i 和 j 至少有一次会被分到不同的组里面。这样对于所有行的每个元素都符合上面的描述，答案就可以求出来了。\n\n对每次询问，如果这某一行的对角线所在的列也在分组中的话，就不更新答案。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 1123;\n\nint ans[MAX];\n\nint main() {\n    int n;\n    cin >> n;\n    memset(ans, INF, sizeof(ans));\n\n    //数据不会超过1000\n    for (int i = 0; i < 10; i++) {\n        vector<int> data1, data2;\n        for (int j = 1; j <= n; j++) {\n            //按二进制位为0或1分组\n            if (j & (1 << i)) data1.push_back(j);\n            else data2.push_back(j);\n        }\n\n        //询问第一组\n        if (data1.size()) {\n            cout << data1.size() << endl;\n            for (int j = 0; j < data1.size(); j++) {\n                cout << data1[j] << \" \";\n            }\n            for (int j = 1; j <= n; j++) {\n                int t;\n                cin >> t;\n                //对对角线不在分组中的列更新答案\n                if ((j & (1 << i)) == 0) {\n                    ans[j] = min(ans[j], t);\n                }\n            }\n            cout << endl;\n            fflush(stdout);\n        }\n\n        //询问第二组\n        if (data2.size()) {\n            cout << data2.size() << endl;\n            for (int j = 0; j < data2.size(); j++) {\n                cout << data2[j] << \" \";\n            }\n            for (int j = 1; j <= n; j++) {\n                int t;\n                cin >> t;\n                if (j & (1 << i)) ans[j] = min(ans[j], t);\n            }\n            cout << endl;\n            fflush(stdout);\n        }\n    }\n\n    fflush(stdout);\n    cout << -1 << endl;\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n}\n```","source":"_posts/CodeForces744B-Hongcow-s-Game（交互-二进制）.md","raw":"---\ntitle: CodeForces744B - Hongcow's Game（交互+二进制）\ndate: 2017-08-18 21:25:01\ncategories: [ACM, 二进制]\ntags:\n---\n# 题目链接：\n\nhttp://codeforces.com/problemset/problem/744/B\n\n\n\n--------------------\n# 题目大意：\n\n给出一个矩阵，矩阵主对角线元素均为 0，选择可以最多进行 20 次询问。\n\n每次询问选择一些行，回答会输出每一行中这些列的最小的元素。\n\n矩阵大小小于等于 1000 。\n\n\n\n-------------------\n# 解题过程：\n\n想了半天没思路，到是有想到先询问一下奇数行和偶数行，然后没往后想...\n\n也算是见识了一下新套路，这样利用位运算有点类似之前在知乎上看到的小白鼠测毒药的问题了233\n\n\n\n--------------------\n# 题目分析：\n\n按二进制位将所有行分组，首先按最后一位分组，0为一组，1为一组，然后倒数第二位，以此类推，然后每次都查询一组里面所有的列。\n\n这样这样考虑，对于第 i 行的第 j 列($j \\ne i$)  ，既然不相等那么至少有一个二进制位是不同的，那么 i 和 j 至少有一次会被分到不同的组里面。这样对于所有行的每个元素都符合上面的描述，答案就可以求出来了。\n\n对每次询问，如果这某一行的对角线所在的列也在分组中的话，就不更新答案。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 1123;\n\nint ans[MAX];\n\nint main() {\n    int n;\n    cin >> n;\n    memset(ans, INF, sizeof(ans));\n\n    //数据不会超过1000\n    for (int i = 0; i < 10; i++) {\n        vector<int> data1, data2;\n        for (int j = 1; j <= n; j++) {\n            //按二进制位为0或1分组\n            if (j & (1 << i)) data1.push_back(j);\n            else data2.push_back(j);\n        }\n\n        //询问第一组\n        if (data1.size()) {\n            cout << data1.size() << endl;\n            for (int j = 0; j < data1.size(); j++) {\n                cout << data1[j] << \" \";\n            }\n            for (int j = 1; j <= n; j++) {\n                int t;\n                cin >> t;\n                //对对角线不在分组中的列更新答案\n                if ((j & (1 << i)) == 0) {\n                    ans[j] = min(ans[j], t);\n                }\n            }\n            cout << endl;\n            fflush(stdout);\n        }\n\n        //询问第二组\n        if (data2.size()) {\n            cout << data2.size() << endl;\n            for (int j = 0; j < data2.size(); j++) {\n                cout << data2[j] << \" \";\n            }\n            for (int j = 1; j <= n; j++) {\n                int t;\n                cin >> t;\n                if (j & (1 << i)) ans[j] = min(ans[j], t);\n            }\n            cout << endl;\n            fflush(stdout);\n        }\n    }\n\n    fflush(stdout);\n    cout << -1 << endl;\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n}\n```","slug":"CodeForces744B-Hongcow-s-Game（交互-二进制）","published":1,"updated":"2017-08-19T02:50:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9v000xy9idr6sicyhp","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/744/B\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/744/B</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个矩阵，矩阵主对角线元素均为 0，选择可以最多进行 20 次询问。</p>\n<p>每次询问选择一些行，回答会输出每一行中这些列的最小的元素。</p>\n<p>矩阵大小小于等于 1000 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想了半天没思路，到是有想到先询问一下奇数行和偶数行，然后没往后想…</p>\n<p>也算是见识了一下新套路，这样利用位运算有点类似之前在知乎上看到的小白鼠测毒药的问题了233</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>按二进制位将所有行分组，首先按最后一位分组，0为一组，1为一组，然后倒数第二位，以此类推，然后每次都查询一组里面所有的列。</p>\n<p>这样这样考虑，对于第 i 行的第 j 列($j \\ne i$)  ，既然不相等那么至少有一个二进制位是不同的，那么 i 和 j 至少有一次会被分到不同的组里面。这样对于所有行的每个元素都符合上面的描述，答案就可以求出来了。</p>\n<p>对每次询问，如果这某一行的对角线所在的列也在分组中的话，就不更新答案。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans, INF, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据不会超过1000</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data1, data2;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//按二进制位为0或1分组</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) data1.push_back(j);</div><div class=\"line\">            <span class=\"keyword\">else</span> data2.push_back(j);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//询问第一组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (data1.size()) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; data1.size() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data1.size(); j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; data1[j] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t;</div><div class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">                <span class=\"comment\">//对对角线不在分组中的列更新答案</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    ans[j] = min(ans[j], t);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//询问第二组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (data2.size()) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; data2.size() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data2.size(); j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; data2[j] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t;</div><div class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">                <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) ans[j] = min(ans[j], t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/744/B\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/744/B</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个矩阵，矩阵主对角线元素均为 0，选择可以最多进行 20 次询问。</p>\n<p>每次询问选择一些行，回答会输出每一行中这些列的最小的元素。</p>\n<p>矩阵大小小于等于 1000 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想了半天没思路，到是有想到先询问一下奇数行和偶数行，然后没往后想…</p>\n<p>也算是见识了一下新套路，这样利用位运算有点类似之前在知乎上看到的小白鼠测毒药的问题了233</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>按二进制位将所有行分组，首先按最后一位分组，0为一组，1为一组，然后倒数第二位，以此类推，然后每次都查询一组里面所有的列。</p>\n<p>这样这样考虑，对于第 i 行的第 j 列($j \\ne i$)  ，既然不相等那么至少有一个二进制位是不同的，那么 i 和 j 至少有一次会被分到不同的组里面。这样对于所有行的每个元素都符合上面的描述，答案就可以求出来了。</p>\n<p>对每次询问，如果这某一行的对角线所在的列也在分组中的话，就不更新答案。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans, INF, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据不会超过1000</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data1, data2;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//按二进制位为0或1分组</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) data1.push_back(j);</div><div class=\"line\">            <span class=\"keyword\">else</span> data2.push_back(j);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//询问第一组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (data1.size()) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; data1.size() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data1.size(); j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; data1[j] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t;</div><div class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">                <span class=\"comment\">//对对角线不在分组中的列更新答案</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    ans[j] = min(ans[j], t);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//询问第二组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (data2.size()) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; data2.size() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data2.size(); j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; data2[j] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t;</div><div class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">                <span class=\"keyword\">if</span> (j &amp; (<span class=\"number\">1</span> &lt;&lt; i)) ans[j] = min(ans[j], t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">            fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CodeForces748E - Santa Claus and Tangerines(递推|二分DP)","date":"2017-08-19T02:32:15.000Z","_content":"# 题目链接：\n\nhttp://codeforces.com/problemset/problem/748/E\n\n\n\n--------------------\n# 题目大意：\n\n给出 n 个数，可以将一个数 k 拆成 k / 2 和 (k + 1) / 2，把这 n 个数至少拆成 k 个数，使得这 k 个数中最小的尽量的大。\n\n\n\n-------------------\n# 解题过程：\n\n感觉就是二分答案 + DP，用 DFS 写的DP，结果 T 了好久，还以为是卡常数，试了好久，最后去翻了博客，才发现写成递推就稳了....\n\n而且看到了一个神奇的做法。\n\n\n\n--------------------\n# 题目分析：\n\n第一种做法是，二分答案，然后DP去验证是否有解。\n\ndp[i] 表示最多可以得到多少个 i，然后对于所有的 $i / 2 \\ge mid$，让 dp[i] 累加到 dp[i/2], dp[(i+1)/2] 上。对于 $i/2 < mid$ 直接统计到结果上，如果最后结果大于等于 k，表示有解。\n\n\n\n第二种做法，直接枚举答案，并在一次递推中维护。\n\ndp[i] 数组含义和上面一样，枚举到一个数字的时候，先让答案加上 dp[i]，这时候应该把 i 的父亲减去，因为 i 的父亲已经分解成 i 了，不应该对答案有贡献，但是只需要减去 $2i$和$2i-1$，就可以了因为 $2i+1$会在枚举 i+1 的时候减去。\n\n注意对1特判一下，1没有$2i-1$这个父亲。\n\n\n\n----------------------\n# AC代码：\n\n##做法一\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 10000000 + 10;\n\nint data[MAX];\nlong long dp[MAX];\n\nint n, m, mid, mmm;\n\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nbool ok() {\n    long long rst = 0;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n        dp[data[i]]++;\n    }\n    for (int i = mmm; i >= mid; i--) {\n        if (i / 2 >= mid && dp[i] > 0) {\n            dp[i / 2] += dp[i];\n            dp[(i + 1) / 2] += dp[i];\n        } else rst += dp[i];\n    }\n\n    return rst >= m;\n}\n\nint main() {\n    n = Scan();\n    m = Scan();\n    int l = 1, r = 0;\n    for (int i = 0; i < n; i++) {\n        data[i] = Scan();\n        r = max(r, data[i]);\n    }\n    int ans = r >= m ? 1 : -1;\n    mmm = r;\n    while (l <= r) {\n        mid = (l + r) / 2;\n        if (ok()) {\n            ans = mid;\n            l = mid + 1;\n        } else r = mid - 1;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n```\n##做法二\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000000;\n\nint a[maxn + 1], n, m, mx;\n\nlong long dp[maxn * 10 + 1], cur;\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), cur += a[i], dp[a[i]]++, mx = max(mx, a[i]);\n    if (cur < m) return puts(\"-1\"), 0;\n    cur = 0;\n    for (int i = mx; i; i--) {\n        cur += dp[i];\n        //减去父亲贡献\n        if (i * 2 <= mx) cur -= dp[i << 1];\n        if (i * 2 - 1 <= mx && i != 1) cur -= dp[i * 2 - 1];\n        //找到的第一个符合条件的答案即是最大值\n        if (cur >= m) return printf(\"%d\\n\", i), 0;\n        //对当前数拆分\n        dp[i >> 1] += dp[i];\n        dp[i + 1 >> 1] += dp[i];\n    }\n}\n```\n\n","source":"_posts/CodeForces748E-Santa-Claus-and-Tangerines-递推-二分DP.md","raw":"---\ntitle: CodeForces748E - Santa Claus and Tangerines(递推|二分DP)\ndate: 2017-08-19 10:32:15\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\nhttp://codeforces.com/problemset/problem/748/E\n\n\n\n--------------------\n# 题目大意：\n\n给出 n 个数，可以将一个数 k 拆成 k / 2 和 (k + 1) / 2，把这 n 个数至少拆成 k 个数，使得这 k 个数中最小的尽量的大。\n\n\n\n-------------------\n# 解题过程：\n\n感觉就是二分答案 + DP，用 DFS 写的DP，结果 T 了好久，还以为是卡常数，试了好久，最后去翻了博客，才发现写成递推就稳了....\n\n而且看到了一个神奇的做法。\n\n\n\n--------------------\n# 题目分析：\n\n第一种做法是，二分答案，然后DP去验证是否有解。\n\ndp[i] 表示最多可以得到多少个 i，然后对于所有的 $i / 2 \\ge mid$，让 dp[i] 累加到 dp[i/2], dp[(i+1)/2] 上。对于 $i/2 < mid$ 直接统计到结果上，如果最后结果大于等于 k，表示有解。\n\n\n\n第二种做法，直接枚举答案，并在一次递推中维护。\n\ndp[i] 数组含义和上面一样，枚举到一个数字的时候，先让答案加上 dp[i]，这时候应该把 i 的父亲减去，因为 i 的父亲已经分解成 i 了，不应该对答案有贡献，但是只需要减去 $2i$和$2i-1$，就可以了因为 $2i+1$会在枚举 i+1 的时候减去。\n\n注意对1特判一下，1没有$2i-1$这个父亲。\n\n\n\n----------------------\n# AC代码：\n\n##做法一\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 10000000 + 10;\n\nint data[MAX];\nlong long dp[MAX];\n\nint n, m, mid, mmm;\n\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nbool ok() {\n    long long rst = 0;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n        dp[data[i]]++;\n    }\n    for (int i = mmm; i >= mid; i--) {\n        if (i / 2 >= mid && dp[i] > 0) {\n            dp[i / 2] += dp[i];\n            dp[(i + 1) / 2] += dp[i];\n        } else rst += dp[i];\n    }\n\n    return rst >= m;\n}\n\nint main() {\n    n = Scan();\n    m = Scan();\n    int l = 1, r = 0;\n    for (int i = 0; i < n; i++) {\n        data[i] = Scan();\n        r = max(r, data[i]);\n    }\n    int ans = r >= m ? 1 : -1;\n    mmm = r;\n    while (l <= r) {\n        mid = (l + r) / 2;\n        if (ok()) {\n            ans = mid;\n            l = mid + 1;\n        } else r = mid - 1;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n```\n##做法二\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000000;\n\nint a[maxn + 1], n, m, mx;\n\nlong long dp[maxn * 10 + 1], cur;\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), cur += a[i], dp[a[i]]++, mx = max(mx, a[i]);\n    if (cur < m) return puts(\"-1\"), 0;\n    cur = 0;\n    for (int i = mx; i; i--) {\n        cur += dp[i];\n        //减去父亲贡献\n        if (i * 2 <= mx) cur -= dp[i << 1];\n        if (i * 2 - 1 <= mx && i != 1) cur -= dp[i * 2 - 1];\n        //找到的第一个符合条件的答案即是最大值\n        if (cur >= m) return printf(\"%d\\n\", i), 0;\n        //对当前数拆分\n        dp[i >> 1] += dp[i];\n        dp[i + 1 >> 1] += dp[i];\n    }\n}\n```\n\n","slug":"CodeForces748E-Santa-Claus-and-Tangerines-递推-二分DP","published":1,"updated":"2017-08-19T02:47:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9w000zy9id05qqycee","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/748/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/748/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 n 个数，可以将一个数 k 拆成 k / 2 和 (k + 1) / 2，把这 n 个数至少拆成 k 个数，使得这 k 个数中最小的尽量的大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>感觉就是二分答案 + DP，用 DFS 写的DP，结果 T 了好久，还以为是卡常数，试了好久，最后去翻了博客，才发现写成递推就稳了….</p>\n<p>而且看到了一个神奇的做法。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>第一种做法是，二分答案，然后DP去验证是否有解。</p>\n<p>dp[i] 表示最多可以得到多少个 i，然后对于所有的 $i / 2 \\ge mid$，让 dp[i] 累加到 dp[i/2], dp[(i+1)/2] 上。对于 $i/2 &lt; mid$ 直接统计到结果上，如果最后结果大于等于 k，表示有解。</p>\n<p>第二种做法，直接枚举答案，并在一次递推中维护。</p>\n<p>dp[i] 数组含义和上面一样，枚举到一个数字的时候，先让答案加上 dp[i]，这时候应该把 i 的父亲减去，因为 i 的父亲已经分解成 i 了，不应该对答案有贡献，但是只需要减去 $2i$和$2i-1$，就可以了因为 $2i+1$会在枚举 i+1 的时候减去。</p>\n<p>注意对1特判一下，1没有$2i-1$这个父亲。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><p>##做法一</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, mid, mmm;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        dp[data[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mmm; i &gt;= mid; i--) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i / <span class=\"number\">2</span> &gt;= mid &amp;&amp; dp[i] &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            dp[i / <span class=\"number\">2</span>] += dp[i];</div><div class=\"line\">            dp[(i + <span class=\"number\">1</span>) / <span class=\"number\">2</span>] += dp[i];</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> rst += dp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> rst &gt;= m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    m = Scan();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>, r = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        data[i] = Scan();</div><div class=\"line\">        r = max(r, data[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = r &gt;= m ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">    mmm = r;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        mid = (l + r) / <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ok()) &#123;</div><div class=\"line\">            ans = mid;</div><div class=\"line\">            l = mid + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>##做法二</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1000000</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> a[maxn + <span class=\"number\">1</span>], n, m, mx;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn * <span class=\"number\">10</span> + <span class=\"number\">1</span>], cur;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]), cur += a[i], dp[a[i]]++, mx = max(mx, a[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur &lt; m) <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>), <span class=\"number\">0</span>;</div><div class=\"line\">    cur = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mx; i; i--) &#123;</div><div class=\"line\">        cur += dp[i];</div><div class=\"line\">        <span class=\"comment\">//减去父亲贡献</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> &lt;= mx) cur -= dp[i &lt;&lt; <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> - <span class=\"number\">1</span> &lt;= mx &amp;&amp; i != <span class=\"number\">1</span>) cur -= dp[i * <span class=\"number\">2</span> - <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"comment\">//找到的第一个符合条件的答案即是最大值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cur &gt;= m) <span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, i), <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//对当前数拆分</span></div><div class=\"line\">        dp[i &gt;&gt; <span class=\"number\">1</span>] += dp[i];</div><div class=\"line\">        dp[i + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>] += dp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/problemset/problem/748/E\" target=\"_blank\" rel=\"external\">http://codeforces.com/problemset/problem/748/E</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 n 个数，可以将一个数 k 拆成 k / 2 和 (k + 1) / 2，把这 n 个数至少拆成 k 个数，使得这 k 个数中最小的尽量的大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>感觉就是二分答案 + DP，用 DFS 写的DP，结果 T 了好久，还以为是卡常数，试了好久，最后去翻了博客，才发现写成递推就稳了….</p>\n<p>而且看到了一个神奇的做法。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>第一种做法是，二分答案，然后DP去验证是否有解。</p>\n<p>dp[i] 表示最多可以得到多少个 i，然后对于所有的 $i / 2 \\ge mid$，让 dp[i] 累加到 dp[i/2], dp[(i+1)/2] 上。对于 $i/2 &lt; mid$ 直接统计到结果上，如果最后结果大于等于 k，表示有解。</p>\n<p>第二种做法，直接枚举答案，并在一次递推中维护。</p>\n<p>dp[i] 数组含义和上面一样，枚举到一个数字的时候，先让答案加上 dp[i]，这时候应该把 i 的父亲减去，因为 i 的父亲已经分解成 i 了，不应该对答案有贡献，但是只需要减去 $2i$和$2i-1$，就可以了因为 $2i+1$会在枚举 i+1 的时候减去。</p>\n<p>注意对1特判一下，1没有$2i-1$这个父亲。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><p>##做法一</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, mid, mmm;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        dp[data[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mmm; i &gt;= mid; i--) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i / <span class=\"number\">2</span> &gt;= mid &amp;&amp; dp[i] &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            dp[i / <span class=\"number\">2</span>] += dp[i];</div><div class=\"line\">            dp[(i + <span class=\"number\">1</span>) / <span class=\"number\">2</span>] += dp[i];</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> rst += dp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> rst &gt;= m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    m = Scan();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>, r = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        data[i] = Scan();</div><div class=\"line\">        r = max(r, data[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = r &gt;= m ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">    mmm = r;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        mid = (l + r) / <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ok()) &#123;</div><div class=\"line\">            ans = mid;</div><div class=\"line\">            l = mid + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>##做法二</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1000000</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> a[maxn + <span class=\"number\">1</span>], n, m, mx;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn * <span class=\"number\">10</span> + <span class=\"number\">1</span>], cur;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]), cur += a[i], dp[a[i]]++, mx = max(mx, a[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur &lt; m) <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>), <span class=\"number\">0</span>;</div><div class=\"line\">    cur = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mx; i; i--) &#123;</div><div class=\"line\">        cur += dp[i];</div><div class=\"line\">        <span class=\"comment\">//减去父亲贡献</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> &lt;= mx) cur -= dp[i &lt;&lt; <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> - <span class=\"number\">1</span> &lt;= mx &amp;&amp; i != <span class=\"number\">1</span>) cur -= dp[i * <span class=\"number\">2</span> - <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"comment\">//找到的第一个符合条件的答案即是最大值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cur &gt;= m) <span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, i), <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//对当前数拆分</span></div><div class=\"line\">        dp[i &gt;&gt; <span class=\"number\">1</span>] += dp[i];</div><div class=\"line\">        dp[i + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>] += dp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"CodeForces868C - Qualification Rounds(思维+二进制)","date":"2017-10-09T08:41:24.000Z","_content":"# 题目链接：\n\n[http://codeforces.com/contest/868/problem/C](http://codeforces.com/contest/868/problem/C)\n\n# 题目大意：\n\n现在有 n 个长度为 k 二进制串，现在要从中选出 m 个二进制串，使得每一位的 1 的数量不能大于 0 的数量。\n\n$1 \\le n \\le 10^5, 1 \\le k \\le 4$\n\n\n\n# 解题过程：\n\n比赛的时候一直没思路，于是乱写了一个假算法，对每个串分配权重并贪心，不过居然能过，不过还是被 Hack 掉了。\n\n# 题目分析：\n\n首先，这里 K 非常小，所以最多也就是有 16 种不同的串，考虑用桶来统计。\n\n然后假设有一个解，那么可以[证明](http://www.cnblogs.com/yyf0309/p/7632780.html)，至多只需要选两个串就可以满足题目要求（如果存在 0000 的串，那么只需这一个串就可以满足题目要求了）。\n\n那么这时候我们暴力枚举这如果串就可以了，复杂度$O(16\\times 16)$ \n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//统计每个串的出现次数\nint data[1123];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    while (n--) {\n        int temp = 0, cnt = 1;\n        for (int i = 1; i <= k; i++) {\n            int t;\n            cin >> t;\n            temp += t * cnt;\n            cnt *= 2;\n        }\n        data[temp]++;\n    }\n    //如果存在 0000 这样的串，那么只选这一个串就可以了\n    if (data[0]) {\n        printf(\"YES\\n\");\n        return 0;\n    } else {\n        //枚举如果串\n        for (int i = 0; i < (1 << k); i++) {\n            if (!data[i]) continue;\n            data[i]--;\n            for (int j = 0; j < (1 << k); j++) {\n                //这里要保证两个串的每一位至少有一个是 0，那么他们 and 操作结果是 0\n                if ((i & j) == 0 && data[j]) {\n                    printf(\"YES\\n\");\n                    return 0;\n                }\n            }\n            data[i]++;\n        }\n    }\n    printf(\"NO\\n\");\n}\n```","source":"_posts/CodeForces868C-Qualification-Rounds-思维-二进制.md","raw":"---\ntitle: CodeForces868C - Qualification Rounds(思维+二进制)\ndate: 2017-10-09 16:41:24\ncategories:\ntags:\n---\n# 题目链接：\n\n[http://codeforces.com/contest/868/problem/C](http://codeforces.com/contest/868/problem/C)\n\n# 题目大意：\n\n现在有 n 个长度为 k 二进制串，现在要从中选出 m 个二进制串，使得每一位的 1 的数量不能大于 0 的数量。\n\n$1 \\le n \\le 10^5, 1 \\le k \\le 4$\n\n\n\n# 解题过程：\n\n比赛的时候一直没思路，于是乱写了一个假算法，对每个串分配权重并贪心，不过居然能过，不过还是被 Hack 掉了。\n\n# 题目分析：\n\n首先，这里 K 非常小，所以最多也就是有 16 种不同的串，考虑用桶来统计。\n\n然后假设有一个解，那么可以[证明](http://www.cnblogs.com/yyf0309/p/7632780.html)，至多只需要选两个串就可以满足题目要求（如果存在 0000 的串，那么只需这一个串就可以满足题目要求了）。\n\n那么这时候我们暴力枚举这如果串就可以了，复杂度$O(16\\times 16)$ \n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//统计每个串的出现次数\nint data[1123];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    while (n--) {\n        int temp = 0, cnt = 1;\n        for (int i = 1; i <= k; i++) {\n            int t;\n            cin >> t;\n            temp += t * cnt;\n            cnt *= 2;\n        }\n        data[temp]++;\n    }\n    //如果存在 0000 这样的串，那么只选这一个串就可以了\n    if (data[0]) {\n        printf(\"YES\\n\");\n        return 0;\n    } else {\n        //枚举如果串\n        for (int i = 0; i < (1 << k); i++) {\n            if (!data[i]) continue;\n            data[i]--;\n            for (int j = 0; j < (1 << k); j++) {\n                //这里要保证两个串的每一位至少有一个是 0，那么他们 and 操作结果是 0\n                if ((i & j) == 0 && data[j]) {\n                    printf(\"YES\\n\");\n                    return 0;\n                }\n            }\n            data[i]++;\n        }\n    }\n    printf(\"NO\\n\");\n}\n```","slug":"CodeForces868C-Qualification-Rounds-思维-二进制","published":1,"updated":"2017-10-09T08:54:01.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6n9z0011y9idahy8au0k","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/868/problem/C\" target=\"_blank\" rel=\"external\">http://codeforces.com/contest/868/problem/C</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在有 n 个长度为 k 二进制串，现在要从中选出 m 个二进制串，使得每一位的 1 的数量不能大于 0 的数量。</p>\n<p>$1 \\le n \\le 10^5, 1 \\le k \\le 4$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候一直没思路，于是乱写了一个假算法，对每个串分配权重并贪心，不过居然能过，不过还是被 Hack 掉了。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先，这里 K 非常小，所以最多也就是有 16 种不同的串，考虑用桶来统计。</p>\n<p>然后假设有一个解，那么可以<a href=\"http://www.cnblogs.com/yyf0309/p/7632780.html\" target=\"_blank\" rel=\"external\">证明</a>，至多只需要选两个串就可以满足题目要求（如果存在 0000 的串，那么只需这一个串就可以满足题目要求了）。</p>\n<p>那么这时候我们暴力枚举这如果串就可以了，复杂度$O(16\\times 16)$ </p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//统计每个串的出现次数</span></div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, k;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</div><div class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>, cnt = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">            temp += t * cnt;</div><div class=\"line\">            cnt *= <span class=\"number\">2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[temp]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果存在 0000 这样的串，那么只选这一个串就可以了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (data[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//枚举如果串</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; k); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            data[i]--;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; (<span class=\"number\">1</span> &lt;&lt; k); j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//这里要保证两个串的每一位至少有一个是 0，那么他们 and 操作结果是 0</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((i &amp; j) == <span class=\"number\">0</span> &amp;&amp; data[j]) &#123;</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            data[i]++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/868/problem/C\" target=\"_blank\" rel=\"external\">http://codeforces.com/contest/868/problem/C</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在有 n 个长度为 k 二进制串，现在要从中选出 m 个二进制串，使得每一位的 1 的数量不能大于 0 的数量。</p>\n<p>$1 \\le n \\le 10^5, 1 \\le k \\le 4$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候一直没思路，于是乱写了一个假算法，对每个串分配权重并贪心，不过居然能过，不过还是被 Hack 掉了。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先，这里 K 非常小，所以最多也就是有 16 种不同的串，考虑用桶来统计。</p>\n<p>然后假设有一个解，那么可以<a href=\"http://www.cnblogs.com/yyf0309/p/7632780.html\" target=\"_blank\" rel=\"external\">证明</a>，至多只需要选两个串就可以满足题目要求（如果存在 0000 的串，那么只需这一个串就可以满足题目要求了）。</p>\n<p>那么这时候我们暴力枚举这如果串就可以了，复杂度$O(16\\times 16)$ </p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//统计每个串的出现次数</span></div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, k;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</div><div class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>, cnt = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; t;</div><div class=\"line\">            temp += t * cnt;</div><div class=\"line\">            cnt *= <span class=\"number\">2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[temp]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果存在 0000 这样的串，那么只选这一个串就可以了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (data[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//枚举如果串</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; k); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            data[i]--;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; (<span class=\"number\">1</span> &lt;&lt; k); j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//这里要保证两个串的每一位至少有一个是 0，那么他们 and 操作结果是 0</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((i &amp; j) == <span class=\"number\">0</span> &amp;&amp; data[j]) &#123;</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            data[i]++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"FZU - 2112 Tickets （欧拉回路+联通块判断）","date":"2017-05-04T09:38:11.000Z","_content":"# 题目链接：\nhttps://cn.vjudge.net/problem/FZU-2112\n\n-------------------\n# 题目大意：\n给定一个图的N个边，求添加最少的边使这个图形成欧拉路。不必所有的点都联通，只需要把已给出的边形成欧拉路。\n\n---------------------------------------\n# 解题过程：\n\n之前好像做过一次做过题，然后又看到了，当时也忘记在哪看到了，不知道A了没有，反正记得看题解没理解……\n\n这道题刚开始理解错了，还以为是求哈密顿图，这个是真的不会。回来又看了一遍题意才发现是之前做过的欧拉路。\n\n然后又仔细想了下，可算是想通了。\n\n-----------------------\n\n# 题目分析：\n首先BFS一遍记录下联通块个数， 每个联通块奇点的个数。\n\n要构成欧拉路，就要把这些联通块之前用一条边连起来。\n假设N个联通块，那么需要N-1个边把他们连接起来。\n\n然后对于每一个联通块，如果奇点个数大于2，那么每多了个奇点，需要花费一条边连起来这两个奇点。\n\n可以证明，对于任意一个无向图，他奇点的个数一定是偶数个。对于每无向边那么一定会给两个点增加一个度，所以奇点的个数一定是偶数个的。\n\n\n\n\n\n----------------\n# AC代码：\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint n, m;\nint vis[MAX];\nint book[MAX];\nvector<int> edge[MAX];\n\n//Dfs判断联通块个数和统计奇点的个数\nvoid dfs(int u, int& odd) {\n    if (edge[u].size()%2)\n        odd++;\n    vis[u] = 1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!vis[v])\n            dfs(v, odd);\n    }\n}\n\nint solve() {\n    int cnt = 0;\n    for (int i = 1; i <= n; i++) {\n        if (vis[i] || !book[i])\n            continue;\n        int odd = 0;\n        dfs(i, odd);\n        \n        //每个联通块的奇点如果大于2那么应该给做过联通块添加边消去奇点\n        cnt += odd > 2 ? (odd-2)/2:0; \n        cnt++;\n    }\n    printf(\"%d\\n\", cnt-1);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n\n        scanf(\"%d %d\", &n, &m);\n        memset(vis, 0, sizeof(vis));\n        memset(book, 0, sizeof(book));\n        for (int i = 0; i <= n; i++) {\n            edge[i].clear();\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            book[u] = book[v] = 1;\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        solve();\n    }\n}\n\n```","source":"_posts/FZU-2112-Tickets-（欧拉回路-联通块判断）.md","raw":"---\ntitle: FZU - 2112 Tickets （欧拉回路+联通块判断）\ndate: 2017-05-04 17:38:11\ncategories: [ACM, 图论]\ntags:\n---\n# 题目链接：\nhttps://cn.vjudge.net/problem/FZU-2112\n\n-------------------\n# 题目大意：\n给定一个图的N个边，求添加最少的边使这个图形成欧拉路。不必所有的点都联通，只需要把已给出的边形成欧拉路。\n\n---------------------------------------\n# 解题过程：\n\n之前好像做过一次做过题，然后又看到了，当时也忘记在哪看到了，不知道A了没有，反正记得看题解没理解……\n\n这道题刚开始理解错了，还以为是求哈密顿图，这个是真的不会。回来又看了一遍题意才发现是之前做过的欧拉路。\n\n然后又仔细想了下，可算是想通了。\n\n-----------------------\n\n# 题目分析：\n首先BFS一遍记录下联通块个数， 每个联通块奇点的个数。\n\n要构成欧拉路，就要把这些联通块之前用一条边连起来。\n假设N个联通块，那么需要N-1个边把他们连接起来。\n\n然后对于每一个联通块，如果奇点个数大于2，那么每多了个奇点，需要花费一条边连起来这两个奇点。\n\n可以证明，对于任意一个无向图，他奇点的个数一定是偶数个。对于每无向边那么一定会给两个点增加一个度，所以奇点的个数一定是偶数个的。\n\n\n\n\n\n----------------\n# AC代码：\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint n, m;\nint vis[MAX];\nint book[MAX];\nvector<int> edge[MAX];\n\n//Dfs判断联通块个数和统计奇点的个数\nvoid dfs(int u, int& odd) {\n    if (edge[u].size()%2)\n        odd++;\n    vis[u] = 1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!vis[v])\n            dfs(v, odd);\n    }\n}\n\nint solve() {\n    int cnt = 0;\n    for (int i = 1; i <= n; i++) {\n        if (vis[i] || !book[i])\n            continue;\n        int odd = 0;\n        dfs(i, odd);\n        \n        //每个联通块的奇点如果大于2那么应该给做过联通块添加边消去奇点\n        cnt += odd > 2 ? (odd-2)/2:0; \n        cnt++;\n    }\n    printf(\"%d\\n\", cnt-1);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n\n        scanf(\"%d %d\", &n, &m);\n        memset(vis, 0, sizeof(vis));\n        memset(book, 0, sizeof(book));\n        for (int i = 0; i <= n; i++) {\n            edge[i].clear();\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            book[u] = book[v] = 1;\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        solve();\n    }\n}\n\n```","slug":"FZU-2112-Tickets-（欧拉回路-联通块判断）","published":1,"updated":"2017-07-23T02:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6na20012y9id05bfkjgq","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/FZU-2112\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/FZU-2112</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个图的N个边，求添加最少的边使这个图形成欧拉路。不必所有的点都联通，只需要把已给出的边形成欧拉路。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前好像做过一次做过题，然后又看到了，当时也忘记在哪看到了，不知道A了没有，反正记得看题解没理解……</p>\n<p>这道题刚开始理解错了，还以为是求哈密顿图，这个是真的不会。回来又看了一遍题意才发现是之前做过的欧拉路。</p>\n<p>然后又仔细想了下，可算是想通了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先BFS一遍记录下联通块个数， 每个联通块奇点的个数。</p>\n<p>要构成欧拉路，就要把这些联通块之前用一条边连起来。<br>假设N个联通块，那么需要N-1个边把他们连接起来。</p>\n<p>然后对于每一个联通块，如果奇点个数大于2，那么每多了个奇点，需要花费一条边连起来这两个奇点。</p>\n<p>可以证明，对于任意一个无向图，他奇点的个数一定是偶数个。对于每无向边那么一定会给两个点增加一个度，所以奇点的个数一定是偶数个的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> book[MAX];</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Dfs判断联通块个数和统计奇点的个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span>&amp; odd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (edge[u].size()%<span class=\"number\">2</span>)</div><div class=\"line\">        odd++;</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v])</div><div class=\"line\">            dfs(v, odd);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i] || !book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> odd = <span class=\"number\">0</span>;</div><div class=\"line\">        dfs(i, odd);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//每个联通块的奇点如果大于2那么应该给做过联通块添加边消去奇点</span></div><div class=\"line\">        cnt += odd &gt; <span class=\"number\">2</span> ? (odd<span class=\"number\">-2</span>)/<span class=\"number\">2</span>:<span class=\"number\">0</span>; </div><div class=\"line\">        cnt++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            book[u] = book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            edge[u].push_back(v);</div><div class=\"line\">            edge[v].push_back(u);</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/FZU-2112\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/FZU-2112</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个图的N个边，求添加最少的边使这个图形成欧拉路。不必所有的点都联通，只需要把已给出的边形成欧拉路。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前好像做过一次做过题，然后又看到了，当时也忘记在哪看到了，不知道A了没有，反正记得看题解没理解……</p>\n<p>这道题刚开始理解错了，还以为是求哈密顿图，这个是真的不会。回来又看了一遍题意才发现是之前做过的欧拉路。</p>\n<p>然后又仔细想了下，可算是想通了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先BFS一遍记录下联通块个数， 每个联通块奇点的个数。</p>\n<p>要构成欧拉路，就要把这些联通块之前用一条边连起来。<br>假设N个联通块，那么需要N-1个边把他们连接起来。</p>\n<p>然后对于每一个联通块，如果奇点个数大于2，那么每多了个奇点，需要花费一条边连起来这两个奇点。</p>\n<p>可以证明，对于任意一个无向图，他奇点的个数一定是偶数个。对于每无向边那么一定会给两个点增加一个度，所以奇点的个数一定是偶数个的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> book[MAX];</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Dfs判断联通块个数和统计奇点的个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span>&amp; odd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (edge[u].size()%<span class=\"number\">2</span>)</div><div class=\"line\">        odd++;</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[v])</div><div class=\"line\">            dfs(v, odd);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[i] || !book[i])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> odd = <span class=\"number\">0</span>;</div><div class=\"line\">        dfs(i, odd);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//每个联通块的奇点如果大于2那么应该给做过联通块添加边消去奇点</span></div><div class=\"line\">        cnt += odd &gt; <span class=\"number\">2</span> ? (odd<span class=\"number\">-2</span>)/<span class=\"number\">2</span>:<span class=\"number\">0</span>; </div><div class=\"line\">        cnt++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            book[u] = book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            edge[u].push_back(v);</div><div class=\"line\">            edge[v].push_back(u);</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"DAG上的动态规划","date":"2017-04-26T02:49:13.000Z","_content":"# 不定终点的最长路：\n--------------\n## 矩阵嵌套问题：\n--------------------------\n### 题目链接：\nhttp://acm.nyist.net/JudgeOnline/problem.php?pid=16\n\n------------------------\n### 题目大意：\n 如果一个矩形的长和宽都大于另一个矩形，那么说这个矩形可以嵌套另一个矩形，现在有很多个矩形，输入矩形的长宽，求出他们的最大嵌套数。注意矩形的长宽是可以互换的。\n\n---------------------\n### 题目分析：\n 这是一道经典的DAG上的动态规划问题，需要把问题转化成DAG上的最长路问题，把每个矩形看成点，如果两个矩形可以嵌套，那么他们建边，这样问题就是求最长路了。\n\n 状态的定义是对于第 i 个节点，由他出发最长的距离，根据边转移，如果一个矩形可以装下另一个矩形，那么这个矩形出发的最长距离就是他可以装下的那个矩形的最长距离加一。\n\n 递归边界是隐含的，如果一个矩形无法嵌套嵌套的矩阵，那么由他出发的最长距离是 1 ，即只有他本身。\n\n---------------------------\n### AC代码：\n```cpp\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint edge[1123][1123];\nint d[1123], n;\n\nint dp(int i) {\n    int& ans =  d[i];\n    if (ans > 0)\n        return ans;\n    ans = 1;\n    for (int j = 0; j < n; j++) {\n        if (edge[i][j])\n            ans = max(ans, dp(j)+1);//状态转移\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d\", &n);\n        int data[1123][2];\n        for (int i = 0 ; i < n; i++) {\n            scanf(\"%d %d\", &data[i][0], &data[i][1]);\n            if (data[i][0] > data[i][1])\n                swap(data[i][0], data[i][1]);\n        }\n\n        memset(edge, 0, sizeof(edge));\n        memset(d, 0, sizeof(d));\n\n        for (int i = 0; i < n; i ++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j)\n                    continue;\n                if (data[i][0] > data[j][0] && data[i][1] > data[j][1])\n                    edge[i][j] = 1;//如果可以嵌套那么建边\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, dp(i));//最终答案是所有节点出发最长的那个\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```\n\n## The Tower of Babylon\n\n---------------------------------\n### 题目链接：\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=378\n\n------------------------\n### 题目大意：\n 现在有很多立方体，每个立方体输入他的三个棱长即可确定，现在规定如果一个立方体的面的长和宽都大于另一个立方体的长和宽，那么这两个立方体是可以堆叠起来的。现在输入很多立方体，求堆叠出的最高高度。注意两个立方体三个棱长都要考虑，两个棱长确定是否可堆叠，一个决定堆起来的高度。立方体可以重复使用。\n\n---------------------------\n### 题目分析：\n 和上一题近似，不过这里我可以把每个立方体拆成三个，分别对于三个不同的面和高，然后根据面的长宽大小，对他们建边。然后就是求DAG上的最长路问题，不过这题的不同是，每条边有权了，并且不能直接拿长宽的大小当数组的下标。\n\n-----------------------------\n### AC代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int a, b;\n    int h;\n    Node(int a, int b, int h) {\n        if (a > b)\n            swap(a, b);\n        this->a = a;\n        this->b = b;\n        this->h = h;\n    }\n};\n\nbool operator < (const struct Node& a, const struct Node& b) {\n    if (a.a < b.a && a.b < b.b)\n        return true;\n    return false;\n}\n\nvector<Node> data;\nint edge[1123][1123];\nint dp[1123];\n\nint dfs(int u) {\n    int& rst = dp[u];\n    if (rst >= 0)\n        return rst;\n    rst = 0;\n    for (int i = 0; i < data.size(); i++) {\n        if (edge[u][i])\n            rst = max(rst, dfs(i));\n    }\n    //最后要加上当前的立方体的高度\n    return rst += data[u].h;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n) && n) {\n        data.clear();\n        for (int i = 0; i < n; i++) {\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            //把立方体根据每个面拆成三个\n            data.push_back(Node(a, b, c));\n            data.push_back(Node(a, c, b));\n            data.push_back(Node(b, c, a));\n        }\n        memset(edge, 0, sizeof(edge));\n        for (int i = 0; i < data.size(); i++) {\n            for (int j = 0; j < data.size(); j++) {\n                //如果可以堆叠，那么建边\n                if (data[i] < data[j]) {\n                    edge[i][j] = 1;\n                }\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n        int ans = 0;\n        for (int i = 0; i < data.size(); i++) {\n            ans = max(dfs(i), ans);\n        }\n        printf(\"Case %d: maximum height = %d\\n\", ++cases, ans);\n    }\n}\n```","source":"_posts/DAG上的动态规划.md","raw":"---\ntitle: DAG上的动态规划\ndate: 2017-04-26 10:49:13\ncategories: [ACM, DP]\ntags:\n---\n# 不定终点的最长路：\n--------------\n## 矩阵嵌套问题：\n--------------------------\n### 题目链接：\nhttp://acm.nyist.net/JudgeOnline/problem.php?pid=16\n\n------------------------\n### 题目大意：\n 如果一个矩形的长和宽都大于另一个矩形，那么说这个矩形可以嵌套另一个矩形，现在有很多个矩形，输入矩形的长宽，求出他们的最大嵌套数。注意矩形的长宽是可以互换的。\n\n---------------------\n### 题目分析：\n 这是一道经典的DAG上的动态规划问题，需要把问题转化成DAG上的最长路问题，把每个矩形看成点，如果两个矩形可以嵌套，那么他们建边，这样问题就是求最长路了。\n\n 状态的定义是对于第 i 个节点，由他出发最长的距离，根据边转移，如果一个矩形可以装下另一个矩形，那么这个矩形出发的最长距离就是他可以装下的那个矩形的最长距离加一。\n\n 递归边界是隐含的，如果一个矩形无法嵌套嵌套的矩阵，那么由他出发的最长距离是 1 ，即只有他本身。\n\n---------------------------\n### AC代码：\n```cpp\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint edge[1123][1123];\nint d[1123], n;\n\nint dp(int i) {\n    int& ans =  d[i];\n    if (ans > 0)\n        return ans;\n    ans = 1;\n    for (int j = 0; j < n; j++) {\n        if (edge[i][j])\n            ans = max(ans, dp(j)+1);//状态转移\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d\", &n);\n        int data[1123][2];\n        for (int i = 0 ; i < n; i++) {\n            scanf(\"%d %d\", &data[i][0], &data[i][1]);\n            if (data[i][0] > data[i][1])\n                swap(data[i][0], data[i][1]);\n        }\n\n        memset(edge, 0, sizeof(edge));\n        memset(d, 0, sizeof(d));\n\n        for (int i = 0; i < n; i ++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j)\n                    continue;\n                if (data[i][0] > data[j][0] && data[i][1] > data[j][1])\n                    edge[i][j] = 1;//如果可以嵌套那么建边\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, dp(i));//最终答案是所有节点出发最长的那个\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```\n\n## The Tower of Babylon\n\n---------------------------------\n### 题目链接：\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=378\n\n------------------------\n### 题目大意：\n 现在有很多立方体，每个立方体输入他的三个棱长即可确定，现在规定如果一个立方体的面的长和宽都大于另一个立方体的长和宽，那么这两个立方体是可以堆叠起来的。现在输入很多立方体，求堆叠出的最高高度。注意两个立方体三个棱长都要考虑，两个棱长确定是否可堆叠，一个决定堆起来的高度。立方体可以重复使用。\n\n---------------------------\n### 题目分析：\n 和上一题近似，不过这里我可以把每个立方体拆成三个，分别对于三个不同的面和高，然后根据面的长宽大小，对他们建边。然后就是求DAG上的最长路问题，不过这题的不同是，每条边有权了，并且不能直接拿长宽的大小当数组的下标。\n\n-----------------------------\n### AC代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int a, b;\n    int h;\n    Node(int a, int b, int h) {\n        if (a > b)\n            swap(a, b);\n        this->a = a;\n        this->b = b;\n        this->h = h;\n    }\n};\n\nbool operator < (const struct Node& a, const struct Node& b) {\n    if (a.a < b.a && a.b < b.b)\n        return true;\n    return false;\n}\n\nvector<Node> data;\nint edge[1123][1123];\nint dp[1123];\n\nint dfs(int u) {\n    int& rst = dp[u];\n    if (rst >= 0)\n        return rst;\n    rst = 0;\n    for (int i = 0; i < data.size(); i++) {\n        if (edge[u][i])\n            rst = max(rst, dfs(i));\n    }\n    //最后要加上当前的立方体的高度\n    return rst += data[u].h;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n) && n) {\n        data.clear();\n        for (int i = 0; i < n; i++) {\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            //把立方体根据每个面拆成三个\n            data.push_back(Node(a, b, c));\n            data.push_back(Node(a, c, b));\n            data.push_back(Node(b, c, a));\n        }\n        memset(edge, 0, sizeof(edge));\n        for (int i = 0; i < data.size(); i++) {\n            for (int j = 0; j < data.size(); j++) {\n                //如果可以堆叠，那么建边\n                if (data[i] < data[j]) {\n                    edge[i][j] = 1;\n                }\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n        int ans = 0;\n        for (int i = 0; i < data.size(); i++) {\n            ans = max(dfs(i), ans);\n        }\n        printf(\"Case %d: maximum height = %d\\n\", ++cases, ans);\n    }\n}\n```","slug":"DAG上的动态规划","published":1,"updated":"2017-10-19T01:04:12.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6na40014y9id830a0opm","content":"<h1 id=\"不定终点的最长路：\"><a href=\"#不定终点的最长路：\" class=\"headerlink\" title=\"不定终点的最长路：\"></a>不定终点的最长路：</h1><hr>\n<h2 id=\"矩阵嵌套问题：\"><a href=\"#矩阵嵌套问题：\" class=\"headerlink\" title=\"矩阵嵌套问题：\"></a>矩阵嵌套问题：</h2><hr>\n<h3 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h3><p><a href=\"http://acm.nyist.net/JudgeOnline/problem.php?pid=16\" target=\"_blank\" rel=\"external\">http://acm.nyist.net/JudgeOnline/problem.php?pid=16</a></p>\n<hr>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p> 如果一个矩形的长和宽都大于另一个矩形，那么说这个矩形可以嵌套另一个矩形，现在有很多个矩形，输入矩形的长宽，求出他们的最大嵌套数。注意矩形的长宽是可以互换的。</p>\n<hr>\n<h3 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p> 这是一道经典的DAG上的动态规划问题，需要把问题转化成DAG上的最长路问题，把每个矩形看成点，如果两个矩形可以嵌套，那么他们建边，这样问题就是求最长路了。</p>\n<p> 状态的定义是对于第 i 个节点，由他出发最长的距离，根据边转移，如果一个矩形可以装下另一个矩形，那么这个矩形出发的最长距离就是他可以装下的那个矩形的最长距离加一。</p>\n<p> 递归边界是隐含的，如果一个矩形无法嵌套嵌套的矩阵，那么由他出发的最长距离是 1 ，即只有他本身。</p>\n<hr>\n<h3 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> edge[<span class=\"number\">1123</span>][<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">1123</span>], n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; ans =  d[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> ans;</div><div class=\"line\">    ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i][j])</div><div class=\"line\">            ans = max(ans, dp(j)+<span class=\"number\">1</span>);<span class=\"comment\">//状态转移</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">int</span> data[<span class=\"number\">1123</span>][<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;data[i][<span class=\"number\">0</span>], &amp;data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i][<span class=\"number\">0</span>] &gt; data[i][<span class=\"number\">1</span>])</div><div class=\"line\">                swap(data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(edge, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edge));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][<span class=\"number\">0</span>] &gt; data[j][<span class=\"number\">0</span>] &amp;&amp; data[i][<span class=\"number\">1</span>] &gt; data[j][<span class=\"number\">1</span>])</div><div class=\"line\">                    edge[i][j] = <span class=\"number\">1</span>;<span class=\"comment\">//如果可以嵌套那么建边</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            ans = max(ans, dp(i));<span class=\"comment\">//最终答案是所有节点出发最长的那个</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"The-Tower-of-Babylon\"><a href=\"#The-Tower-of-Babylon\" class=\"headerlink\" title=\"The Tower of Babylon\"></a>The Tower of Babylon</h2><hr>\n<h3 id=\"题目链接：-1\"><a href=\"#题目链接：-1\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h3><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=378\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=378</a></p>\n<hr>\n<h3 id=\"题目大意：-1\"><a href=\"#题目大意：-1\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p> 现在有很多立方体，每个立方体输入他的三个棱长即可确定，现在规定如果一个立方体的面的长和宽都大于另一个立方体的长和宽，那么这两个立方体是可以堆叠起来的。现在输入很多立方体，求堆叠出的最高高度。注意两个立方体三个棱长都要考虑，两个棱长确定是否可堆叠，一个决定堆起来的高度。立方体可以重复使用。</p>\n<hr>\n<h3 id=\"题目分析：-1\"><a href=\"#题目分析：-1\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p> 和上一题近似，不过这里我可以把每个立方体拆成三个，分别对于三个不同的面和高，然后根据面的长宽大小，对他们建边。然后就是求DAG上的最长路问题，不过这题的不同是，每条边有权了，并且不能直接拿长宽的大小当数组的下标。</p>\n<hr>\n<h3 id=\"AC代码：-1\"><a href=\"#AC代码：-1\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> a, b;</div><div class=\"line\">    <span class=\"keyword\">int</span> h;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> h) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b)</div><div class=\"line\">            swap(a, b);</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;a = a;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;b = b;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;h = h;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node&amp; a, <span class=\"keyword\">const</span> struct Node&amp; b) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a.a &lt; b.a &amp;&amp; a.b &lt; b.b)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; data;</div><div class=\"line\"><span class=\"keyword\">int</span> edge[<span class=\"number\">1123</span>][<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; rst = dp[u];</div><div class=\"line\">    <span class=\"keyword\">if</span> (rst &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[u][i])</div><div class=\"line\">            rst = max(rst, dfs(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//最后要加上当前的立方体的高度</span></div><div class=\"line\">    <span class=\"keyword\">return</span> rst += data[u].h;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;a, &amp;b, &amp;c);</div><div class=\"line\">            <span class=\"comment\">//把立方体根据每个面拆成三个</span></div><div class=\"line\">            data.push_back(Node(a, b, c));</div><div class=\"line\">            data.push_back(Node(a, c, b));</div><div class=\"line\">            data.push_back(Node(b, c, a));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(edge, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edge));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data.size(); j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果可以堆叠，那么建边</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i] &lt; data[j]) &#123;</div><div class=\"line\">                    edge[i][j] = <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            ans = max(dfs(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: maximum height = %d\\n\"</span>, ++cases, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"不定终点的最长路：\"><a href=\"#不定终点的最长路：\" class=\"headerlink\" title=\"不定终点的最长路：\"></a>不定终点的最长路：</h1><hr>\n<h2 id=\"矩阵嵌套问题：\"><a href=\"#矩阵嵌套问题：\" class=\"headerlink\" title=\"矩阵嵌套问题：\"></a>矩阵嵌套问题：</h2><hr>\n<h3 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h3><p><a href=\"http://acm.nyist.net/JudgeOnline/problem.php?pid=16\" target=\"_blank\" rel=\"external\">http://acm.nyist.net/JudgeOnline/problem.php?pid=16</a></p>\n<hr>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p> 如果一个矩形的长和宽都大于另一个矩形，那么说这个矩形可以嵌套另一个矩形，现在有很多个矩形，输入矩形的长宽，求出他们的最大嵌套数。注意矩形的长宽是可以互换的。</p>\n<hr>\n<h3 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p> 这是一道经典的DAG上的动态规划问题，需要把问题转化成DAG上的最长路问题，把每个矩形看成点，如果两个矩形可以嵌套，那么他们建边，这样问题就是求最长路了。</p>\n<p> 状态的定义是对于第 i 个节点，由他出发最长的距离，根据边转移，如果一个矩形可以装下另一个矩形，那么这个矩形出发的最长距离就是他可以装下的那个矩形的最长距离加一。</p>\n<p> 递归边界是隐含的，如果一个矩形无法嵌套嵌套的矩阵，那么由他出发的最长距离是 1 ，即只有他本身。</p>\n<hr>\n<h3 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> edge[<span class=\"number\">1123</span>][<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">1123</span>], n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; ans =  d[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> ans;</div><div class=\"line\">    ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i][j])</div><div class=\"line\">            ans = max(ans, dp(j)+<span class=\"number\">1</span>);<span class=\"comment\">//状态转移</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">int</span> data[<span class=\"number\">1123</span>][<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;data[i][<span class=\"number\">0</span>], &amp;data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i][<span class=\"number\">0</span>] &gt; data[i][<span class=\"number\">1</span>])</div><div class=\"line\">                swap(data[i][<span class=\"number\">0</span>], data[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(edge, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edge));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][<span class=\"number\">0</span>] &gt; data[j][<span class=\"number\">0</span>] &amp;&amp; data[i][<span class=\"number\">1</span>] &gt; data[j][<span class=\"number\">1</span>])</div><div class=\"line\">                    edge[i][j] = <span class=\"number\">1</span>;<span class=\"comment\">//如果可以嵌套那么建边</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            ans = max(ans, dp(i));<span class=\"comment\">//最终答案是所有节点出发最长的那个</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"The-Tower-of-Babylon\"><a href=\"#The-Tower-of-Babylon\" class=\"headerlink\" title=\"The Tower of Babylon\"></a>The Tower of Babylon</h2><hr>\n<h3 id=\"题目链接：-1\"><a href=\"#题目链接：-1\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h3><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=378\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=378</a></p>\n<hr>\n<h3 id=\"题目大意：-1\"><a href=\"#题目大意：-1\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p> 现在有很多立方体，每个立方体输入他的三个棱长即可确定，现在规定如果一个立方体的面的长和宽都大于另一个立方体的长和宽，那么这两个立方体是可以堆叠起来的。现在输入很多立方体，求堆叠出的最高高度。注意两个立方体三个棱长都要考虑，两个棱长确定是否可堆叠，一个决定堆起来的高度。立方体可以重复使用。</p>\n<hr>\n<h3 id=\"题目分析：-1\"><a href=\"#题目分析：-1\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p> 和上一题近似，不过这里我可以把每个立方体拆成三个，分别对于三个不同的面和高，然后根据面的长宽大小，对他们建边。然后就是求DAG上的最长路问题，不过这题的不同是，每条边有权了，并且不能直接拿长宽的大小当数组的下标。</p>\n<hr>\n<h3 id=\"AC代码：-1\"><a href=\"#AC代码：-1\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> a, b;</div><div class=\"line\">    <span class=\"keyword\">int</span> h;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> h) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b)</div><div class=\"line\">            swap(a, b);</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;a = a;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;b = b;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;h = h;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node&amp; a, <span class=\"keyword\">const</span> struct Node&amp; b) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a.a &lt; b.a &amp;&amp; a.b &lt; b.b)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; data;</div><div class=\"line\"><span class=\"keyword\">int</span> edge[<span class=\"number\">1123</span>][<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; rst = dp[u];</div><div class=\"line\">    <span class=\"keyword\">if</span> (rst &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[u][i])</div><div class=\"line\">            rst = max(rst, dfs(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//最后要加上当前的立方体的高度</span></div><div class=\"line\">    <span class=\"keyword\">return</span> rst += data[u].h;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;a, &amp;b, &amp;c);</div><div class=\"line\">            <span class=\"comment\">//把立方体根据每个面拆成三个</span></div><div class=\"line\">            data.push_back(Node(a, b, c));</div><div class=\"line\">            data.push_back(Node(a, c, b));</div><div class=\"line\">            data.push_back(Node(b, c, a));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(edge, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edge));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; data.size(); j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果可以堆叠，那么建边</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i] &lt; data[j]) &#123;</div><div class=\"line\">                    edge[i][j] = <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            ans = max(dfs(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: maximum height = %d\\n\"</span>, ++cases, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Gym 100917J Judgement(背包DP+bitset)","date":"2017-08-21T13:02:23.000Z","_content":"# 题目链接：\n\nhttps://vjudge.net/problem/Gym-100917J\n\n\n\n--------------------\n# 题目大意：\n\n给出两个长度为 n 序列 $ A\\_ {i}, B\\_ {i} $ 和 p , q。如果存在一个集合$c\\_ 1,c\\_ 2,c\\_ 3 \\dots c\\_ k$，使得$(\\sum A\\_ {c\\_ i} \\ge p \\wedge \\sum B\\_ {c\\_ i} < q) \\bigvee (\\sum A\\_ {c\\_ i} < p \\wedge \\sum B\\_ {c\\_ i}  \\ge q)$ 那么输出 NO，并用 01 输出集合中的元素，全集为1~n。\n\n\n\n-------------------\n# 解题过程：\n\n比赛的时候想用贪心暴力水一发的，居然水道37组样例，结果还是不对，赛后补的，也算是学下 bitset 了。\n\n\n\n--------------------\n# 题目分析：\n\n跑两次 DP，定义 dp[i] = j 的含义为，第一个序列的和为 i 时，第二个序列的最大值为 j。\n\n我们只跑 i < p 的，如果存在 j >= q，那么就不符合上面的条件了。\n\n然后对第一个序列第二个序列交换位置，再跑一次。\n\n最后答案要输出路径，记录下最后从哪个状态转移而来的，并输出状态。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\n\nint n;\nint a[MAX], b[MAX];\nbitset<120> fa[MAX];\nint dp[MAX];\n\nbool solve() {\n    int p = a[0], q = b[0];\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < MAX; i++) fa[i].reset();\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = p; j >= 0; j--) {\n            if (dp[j] < 0) continue;\n            if (j + a[i] < p && dp[j + a[i]] < dp[j] + b[i]) {\n                dp[j + a[i]] = dp[j] + b[i];\n                fa[j + a[i]] = fa[j];\n                fa[j + a[i]].set(i);\n                if (dp[j + a[i]] >= q) {\n                    puts(\"NO\");\n                    for (int k = 1; k <= n; k++) {\n                        printf(\"%d\", (int)fa[j+a[i]][k]);\n                    }\n                    puts(\"\");\n                    return true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) swap(a[i], b[i]);\n    return false;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 0; i <= n; i++) scanf(\"%d\", &b[i]);\n    if (!(solve() || solve())) puts(\"YES\");\n}\n```","source":"_posts/Gym-100917J-Judgement-背包DP-bitset.md","raw":"---\ntitle: Gym 100917J Judgement(背包DP+bitset)\ndate: 2017-08-21 21:02:23\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\nhttps://vjudge.net/problem/Gym-100917J\n\n\n\n--------------------\n# 题目大意：\n\n给出两个长度为 n 序列 $ A\\_ {i}, B\\_ {i} $ 和 p , q。如果存在一个集合$c\\_ 1,c\\_ 2,c\\_ 3 \\dots c\\_ k$，使得$(\\sum A\\_ {c\\_ i} \\ge p \\wedge \\sum B\\_ {c\\_ i} < q) \\bigvee (\\sum A\\_ {c\\_ i} < p \\wedge \\sum B\\_ {c\\_ i}  \\ge q)$ 那么输出 NO，并用 01 输出集合中的元素，全集为1~n。\n\n\n\n-------------------\n# 解题过程：\n\n比赛的时候想用贪心暴力水一发的，居然水道37组样例，结果还是不对，赛后补的，也算是学下 bitset 了。\n\n\n\n--------------------\n# 题目分析：\n\n跑两次 DP，定义 dp[i] = j 的含义为，第一个序列的和为 i 时，第二个序列的最大值为 j。\n\n我们只跑 i < p 的，如果存在 j >= q，那么就不符合上面的条件了。\n\n然后对第一个序列第二个序列交换位置，再跑一次。\n\n最后答案要输出路径，记录下最后从哪个状态转移而来的，并输出状态。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\n\nint n;\nint a[MAX], b[MAX];\nbitset<120> fa[MAX];\nint dp[MAX];\n\nbool solve() {\n    int p = a[0], q = b[0];\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < MAX; i++) fa[i].reset();\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = p; j >= 0; j--) {\n            if (dp[j] < 0) continue;\n            if (j + a[i] < p && dp[j + a[i]] < dp[j] + b[i]) {\n                dp[j + a[i]] = dp[j] + b[i];\n                fa[j + a[i]] = fa[j];\n                fa[j + a[i]].set(i);\n                if (dp[j + a[i]] >= q) {\n                    puts(\"NO\");\n                    for (int k = 1; k <= n; k++) {\n                        printf(\"%d\", (int)fa[j+a[i]][k]);\n                    }\n                    puts(\"\");\n                    return true;\n                }\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) swap(a[i], b[i]);\n    return false;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 0; i <= n; i++) scanf(\"%d\", &b[i]);\n    if (!(solve() || solve())) puts(\"YES\");\n}\n```","slug":"Gym-100917J-Judgement-背包DP-bitset","published":1,"updated":"2017-08-25T02:55:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6na70016y9id1lu8mmij","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/Gym-100917J\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/Gym-100917J</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出两个长度为 n 序列 $ A_ {i}, B_ {i} $ 和 p , q。如果存在一个集合$c_ 1,c_ 2,c_ 3 \\dots c_ k$，使得$(\\sum A_ {c_ i} \\ge p \\wedge \\sum B_ {c_ i} &lt; q) \\bigvee (\\sum A_ {c_ i} &lt; p \\wedge \\sum B_ {c_ i}  \\ge q)$ 那么输出 NO，并用 01 输出集合中的元素，全集为1~n。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候想用贪心暴力水一发的，居然水道37组样例，结果还是不对，赛后补的，也算是学下 bitset 了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>跑两次 DP，定义 dp[i] = j 的含义为，第一个序列的和为 i 时，第二个序列的最大值为 j。</p>\n<p>我们只跑 i &lt; p 的，如果存在 j &gt;= q，那么就不符合上面的条件了。</p>\n<p>然后对第一个序列第二个序列交换位置，再跑一次。</p>\n<p>最后答案要输出路径，记录下最后从哪个状态转移而来的，并输出状态。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> a[MAX], b[MAX];</div><div class=\"line\"><span class=\"built_in\">bitset</span>&lt;120&gt; fa[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> p = a[<span class=\"number\">0</span>], q = b[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) fa[i].reset();</div><div class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = p; j &gt;= <span class=\"number\">0</span>; j--) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dp[j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j + a[i] &lt; p &amp;&amp; dp[j + a[i]] &lt; dp[j] + b[i]) &#123;</div><div class=\"line\">                dp[j + a[i]] = dp[j] + b[i];</div><div class=\"line\">                fa[j + a[i]] = fa[j];</div><div class=\"line\">                fa[j + a[i]].<span class=\"built_in\">set</span>(i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[j + a[i]] &gt;= q) &#123;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"NO\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, (<span class=\"keyword\">int</span>)fa[j+a[i]][k]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) swap(a[i], b[i]);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;b[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!(solve() || solve())) <span class=\"built_in\">puts</span>(<span class=\"string\">\"YES\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/Gym-100917J\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/Gym-100917J</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出两个长度为 n 序列 $ A_ {i}, B_ {i} $ 和 p , q。如果存在一个集合$c_ 1,c_ 2,c_ 3 \\dots c_ k$，使得$(\\sum A_ {c_ i} \\ge p \\wedge \\sum B_ {c_ i} &lt; q) \\bigvee (\\sum A_ {c_ i} &lt; p \\wedge \\sum B_ {c_ i}  \\ge q)$ 那么输出 NO，并用 01 输出集合中的元素，全集为1~n。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候想用贪心暴力水一发的，居然水道37组样例，结果还是不对，赛后补的，也算是学下 bitset 了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>跑两次 DP，定义 dp[i] = j 的含义为，第一个序列的和为 i 时，第二个序列的最大值为 j。</p>\n<p>我们只跑 i &lt; p 的，如果存在 j &gt;= q，那么就不符合上面的条件了。</p>\n<p>然后对第一个序列第二个序列交换位置，再跑一次。</p>\n<p>最后答案要输出路径，记录下最后从哪个状态转移而来的，并输出状态。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> a[MAX], b[MAX];</div><div class=\"line\"><span class=\"built_in\">bitset</span>&lt;120&gt; fa[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> p = a[<span class=\"number\">0</span>], q = b[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) fa[i].reset();</div><div class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = p; j &gt;= <span class=\"number\">0</span>; j--) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dp[j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j + a[i] &lt; p &amp;&amp; dp[j + a[i]] &lt; dp[j] + b[i]) &#123;</div><div class=\"line\">                dp[j + a[i]] = dp[j] + b[i];</div><div class=\"line\">                fa[j + a[i]] = fa[j];</div><div class=\"line\">                fa[j + a[i]].<span class=\"built_in\">set</span>(i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[j + a[i]] &gt;= q) &#123;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"NO\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, (<span class=\"keyword\">int</span>)fa[j+a[i]][k]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">\"\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) swap(a[i], b[i]);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;b[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!(solve() || solve())) <span class=\"built_in\">puts</span>(<span class=\"string\">\"YES\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU1024 - Max Sum Plus Plus（DP+降维优化）","date":"2017-06-30T07:18:11.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1024\n\n------------------\n# 题目大意：\n给定一个长度为n的序列，一个数m，求m段不相交的区间和的最大值。\n\n-----------------------\n# 解题过程：\n自己好菜啊，简单的状态转移方程都没推出来，值得以后注意的是，以后定义状态不要太”松“了。比如刚开始定义的状态$dp[i][j]$前$i$个数构成的$j$个区间和的最大值，然后发现不会转移。最后看了博客才发现别人不光是前$i$个数还要以$i$结尾，这样就转移方程就任意写出来了，虽说转移操作的复杂度增加了不少。\n\n\n-----------------\n# 题目分析：\n首先定义状态$dp[i][j]$含义是前$i$个数以第$i$个数结尾分了$j$个区间的最大和。\n那么有两种转移方式，一是把第$i$个数加到第$i-1$个数所在的区间里面，二是第$i$个数单独为一个区间，那么状态转移方程为。\n\n$$dp[i][j] = max(dp[i-1][j], dp[k][j-1],\\quad 0 < k < i,\\; i \\le j$$\n\n然后这个转移方程，一个直观的写法是这样的：\n```\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n```\n显然这样时间上会超时，复杂度高达$O(n^2m)$。\n\n这时候需要观察下上面写的代码，发现可以把n和m的循环交换顺序。\n\n```\n    for (int j = 1; j <= m; j++) {\n        for (int i = j; i <= n; i++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n```\n\n然后发现，最内层的$k$次循环其实是没有必要的，因为对于每一趟内$i$循环，都可以在上一趟循环中预处理出来最大的$k$。\n\n```\n        for (int j = 1; j <= m; j++) {\n            maxn = -INF;\n            for (int i = j; i <= n; i++) {\n                dp[i] = max(dp[i-1], pre[i-1]) + data[i];\n                pre[i-1] = maxn;\n                maxn = max(maxn, dp[i]);\n            }\n        }\n```\n这里$pre$数组的含义是，$pre[i]$为从$1$到i中，最大的$dp[k][j-1]$。\n\n---------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\nconst int INF = 0x7fffffff;\n\nint data[MAX], dp[MAX], pre[MAX];\n\nint main() {\n    int m, n;\n    while (~scanf(\"%d %d\", &m, &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data + i);\n            dp[i] = pre[i] = 0;\n        }\n        int maxn;\n        for (int j = 1; j <= m; j++) {\n            maxn = -INF;\n            for (int i = j; i <= n; i++) {\n                dp[i] = max(dp[i-1], pre[i-1]) + data[i];\n                pre[i-1] = maxn;\n                maxn = max(maxn, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", maxn);\n    }\n\n    for (int j = 1; j <= m; j++) {\n        for (int i = 1; i <= n; i++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n}\n\n```\n","source":"_posts/HDU1024-Max-Sum-Plus-Plus（DP-降维优化）.md","raw":"---\ntitle: HDU1024 - Max Sum Plus Plus（DP+降维优化）\ndate: 2017-06-30 15:18:11\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1024\n\n------------------\n# 题目大意：\n给定一个长度为n的序列，一个数m，求m段不相交的区间和的最大值。\n\n-----------------------\n# 解题过程：\n自己好菜啊，简单的状态转移方程都没推出来，值得以后注意的是，以后定义状态不要太”松“了。比如刚开始定义的状态$dp[i][j]$前$i$个数构成的$j$个区间和的最大值，然后发现不会转移。最后看了博客才发现别人不光是前$i$个数还要以$i$结尾，这样就转移方程就任意写出来了，虽说转移操作的复杂度增加了不少。\n\n\n-----------------\n# 题目分析：\n首先定义状态$dp[i][j]$含义是前$i$个数以第$i$个数结尾分了$j$个区间的最大和。\n那么有两种转移方式，一是把第$i$个数加到第$i-1$个数所在的区间里面，二是第$i$个数单独为一个区间，那么状态转移方程为。\n\n$$dp[i][j] = max(dp[i-1][j], dp[k][j-1],\\quad 0 < k < i,\\; i \\le j$$\n\n然后这个转移方程，一个直观的写法是这样的：\n```\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n```\n显然这样时间上会超时，复杂度高达$O(n^2m)$。\n\n这时候需要观察下上面写的代码，发现可以把n和m的循环交换顺序。\n\n```\n    for (int j = 1; j <= m; j++) {\n        for (int i = j; i <= n; i++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n```\n\n然后发现，最内层的$k$次循环其实是没有必要的，因为对于每一趟内$i$循环，都可以在上一趟循环中预处理出来最大的$k$。\n\n```\n        for (int j = 1; j <= m; j++) {\n            maxn = -INF;\n            for (int i = j; i <= n; i++) {\n                dp[i] = max(dp[i-1], pre[i-1]) + data[i];\n                pre[i-1] = maxn;\n                maxn = max(maxn, dp[i]);\n            }\n        }\n```\n这里$pre$数组的含义是，$pre[i]$为从$1$到i中，最大的$dp[k][j-1]$。\n\n---------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\nconst int INF = 0x7fffffff;\n\nint data[MAX], dp[MAX], pre[MAX];\n\nint main() {\n    int m, n;\n    while (~scanf(\"%d %d\", &m, &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data + i);\n            dp[i] = pre[i] = 0;\n        }\n        int maxn;\n        for (int j = 1; j <= m; j++) {\n            maxn = -INF;\n            for (int i = j; i <= n; i++) {\n                dp[i] = max(dp[i-1], pre[i-1]) + data[i];\n                pre[i-1] = maxn;\n                maxn = max(maxn, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", maxn);\n    }\n\n    for (int j = 1; j <= m; j++) {\n        for (int i = 1; i <= n; i++) {\n            dp[i][j] = dp[i-1][j];\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = max(dp[i][j], dp[k][j-1]);\n            }\n        }\n    }\n}\n\n```\n","slug":"HDU1024-Max-Sum-Plus-Plus（DP-降维优化）","published":1,"updated":"2017-07-23T01:44:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nab0018y9ido4d4byme","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1024\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1024</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个长度为n的序列，一个数m，求m段不相交的区间和的最大值。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己好菜啊，简单的状态转移方程都没推出来，值得以后注意的是，以后定义状态不要太”松“了。比如刚开始定义的状态$dp[i][j]$前$i$个数构成的$j$个区间和的最大值，然后发现不会转移。最后看了博客才发现别人不光是前$i$个数还要以$i$结尾，这样就转移方程就任意写出来了，虽说转移操作的复杂度增加了不少。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先定义状态$dp[i][j]$含义是前$i$个数以第$i$个数结尾分了$j$个区间的最大和。<br>那么有两种转移方式，一是把第$i$个数加到第$i-1$个数所在的区间里面，二是第$i$个数单独为一个区间，那么状态转移方程为。</p>\n<p>$$dp[i][j] = max(dp[i-1][j], dp[k][j-1],\\quad 0 &lt; k &lt; i,\\; i \\le j$$</p>\n<p>然后这个转移方程，一个直观的写法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 1; i &lt;= n; i++) &#123;</div><div class=\"line\">    for (int j = 1; j &lt;= i; j++) &#123;</div><div class=\"line\">        dp[i][j] = dp[i-1][j];</div><div class=\"line\">        for (int k = 1; k &lt; i; k++) &#123;</div><div class=\"line\">            dp[i][j] = max(dp[i][j], dp[k][j-1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>显然这样时间上会超时，复杂度高达$O(n^2m)$。</p>\n<p>这时候需要观察下上面写的代码，发现可以把n和m的循环交换顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 1; j &lt;= m; j++) &#123;</div><div class=\"line\">    for (int i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i][j] = dp[i-1][j];</div><div class=\"line\">        for (int k = 1; k &lt; i; k++) &#123;</div><div class=\"line\">            dp[i][j] = max(dp[i][j], dp[k][j-1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后发现，最内层的$k$次循环其实是没有必要的，因为对于每一趟内$i$循环，都可以在上一趟循环中预处理出来最大的$k$。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 1; j &lt;= m; j++) &#123;</div><div class=\"line\">    maxn = -INF;</div><div class=\"line\">    for (int i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i] = max(dp[i-1], pre[i-1]) + data[i];</div><div class=\"line\">        pre[i-1] = maxn;</div><div class=\"line\">        maxn = max(maxn, dp[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里$pre$数组的含义是，$pre[i]$为从$1$到i中，最大的$dp[k][j-1]$。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x7fffffff</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], dp[MAX], pre[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m, n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;m, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">            dp[i] = pre[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> maxn;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">            maxn = -INF;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">                dp[i] = max(dp[i<span class=\"number\">-1</span>], pre[i<span class=\"number\">-1</span>]) + data[i];</div><div class=\"line\">                pre[i<span class=\"number\">-1</span>] = maxn;</div><div class=\"line\">                maxn = max(maxn, dp[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, maxn);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt; i; k++) &#123;</div><div class=\"line\">                dp[i][j] = max(dp[i][j], dp[k][j<span class=\"number\">-1</span>]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1024\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1024</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个长度为n的序列，一个数m，求m段不相交的区间和的最大值。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己好菜啊，简单的状态转移方程都没推出来，值得以后注意的是，以后定义状态不要太”松“了。比如刚开始定义的状态$dp[i][j]$前$i$个数构成的$j$个区间和的最大值，然后发现不会转移。最后看了博客才发现别人不光是前$i$个数还要以$i$结尾，这样就转移方程就任意写出来了，虽说转移操作的复杂度增加了不少。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先定义状态$dp[i][j]$含义是前$i$个数以第$i$个数结尾分了$j$个区间的最大和。<br>那么有两种转移方式，一是把第$i$个数加到第$i-1$个数所在的区间里面，二是第$i$个数单独为一个区间，那么状态转移方程为。</p>\n<p>$$dp[i][j] = max(dp[i-1][j], dp[k][j-1],\\quad 0 &lt; k &lt; i,\\; i \\le j$$</p>\n<p>然后这个转移方程，一个直观的写法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 1; i &lt;= n; i++) &#123;</div><div class=\"line\">    for (int j = 1; j &lt;= i; j++) &#123;</div><div class=\"line\">        dp[i][j] = dp[i-1][j];</div><div class=\"line\">        for (int k = 1; k &lt; i; k++) &#123;</div><div class=\"line\">            dp[i][j] = max(dp[i][j], dp[k][j-1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>显然这样时间上会超时，复杂度高达$O(n^2m)$。</p>\n<p>这时候需要观察下上面写的代码，发现可以把n和m的循环交换顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 1; j &lt;= m; j++) &#123;</div><div class=\"line\">    for (int i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i][j] = dp[i-1][j];</div><div class=\"line\">        for (int k = 1; k &lt; i; k++) &#123;</div><div class=\"line\">            dp[i][j] = max(dp[i][j], dp[k][j-1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后发现，最内层的$k$次循环其实是没有必要的，因为对于每一趟内$i$循环，都可以在上一趟循环中预处理出来最大的$k$。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j = 1; j &lt;= m; j++) &#123;</div><div class=\"line\">    maxn = -INF;</div><div class=\"line\">    for (int i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i] = max(dp[i-1], pre[i-1]) + data[i];</div><div class=\"line\">        pre[i-1] = maxn;</div><div class=\"line\">        maxn = max(maxn, dp[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里$pre$数组的含义是，$pre[i]$为从$1$到i中，最大的$dp[k][j-1]$。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x7fffffff</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], dp[MAX], pre[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m, n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;m, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">            dp[i] = pre[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> maxn;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">            maxn = -INF;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = j; i &lt;= n; i++) &#123;</div><div class=\"line\">                dp[i] = max(dp[i<span class=\"number\">-1</span>], pre[i<span class=\"number\">-1</span>]) + data[i];</div><div class=\"line\">                pre[i<span class=\"number\">-1</span>] = maxn;</div><div class=\"line\">                maxn = max(maxn, dp[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, maxn);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt; i; k++) &#123;</div><div class=\"line\">                dp[i][j] = max(dp[i][j], dp[k][j<span class=\"number\">-1</span>]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"HDOJ1176. 免费馅饼.（DP）","date":"2016-12-05T14:05:33.000Z","_content":"# 题目链接：\n[免费馅饼](http://acm.hdu.edu.cn/showproblem.php?pid=1176)\n\n\n----------\n# 题目大意：\n![这里写图片描述](http://acm.sdut.edu.cn/image/1366.jpg)\n初始位置为5，输入时间和位置，从1秒开始，每次可以移动一个位置，一秒时可接住4,5,6处馅饼，求最大接住馅饼数。\n\n\n----------\n# 解题过程：\n\n - 刚开始就找到了状态转移方程：\n - j代表位置，i代表时间\n  ***dp[j][i] = max(dp[j-1][i], dp[j-1][i-1], dp[j-1][i+1]) + data[j][i]; （j点位置曾经达到过）***\n  \n - 数塔是没想到，看到题解后才发现原来这可以归一类问题\n - 不过没想到状态转移方程出来后题目还是WA，莫名其妙，反复改后变成TLE了，介于这题cin都会TLE估计是卡了常数……\n - 于是发现别人数塔都是从后往前数的于是改了下状态转移方程A了，这样也不需要开data数组了。\n - 于是找了下之前数塔的题，发现直接都是从前往后数的，或者多开了一个数组……算是学到了。\n\n\n----------\n# 题目分析：\n\n - 就是一个数塔\n -  j代表位置，i代表时间\n - 状态转移方程：\n  ***dp[j][i] = max(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i]***\n\n\n----------\n# AC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint dp[20][1123456];\n\nint MaxOf3(int a, int b, int c){\n    int max = (a > b) ? a : b;\n    return (max > c) ? max : c;\n}\n\nint MaxOf2(int a, int b){\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n;\n    while ((scanf(\"%d\", &n) != EOF) && n)\n    {\n        int maxt = 0, position, time;\n\n        memset(dp, 0, sizeof(dp));\n\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d %d\", &position, &time);\n            dp[position+1][time]++;\n            if (maxt < time)\n                maxt = time;\n        }\n\n        for (int i = maxt; i >= 0; i--)\n        {\n            for (int j = 1; j < 12; j++)\n            {\n                dp[j][i] = MaxOf3(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i];\n            }\n        }\n\n        cout << dp[6][0] << endl;\n    }\n}\n```\n\n# 从前往后TLE的错误代码：\n\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint dp[20][1123456];\nint data[20][1123456];\n\nint MaxOf3(int a, int b, int c){\n    int max = (a > b) ? a : b;\n    return (max > c) ? max : c;\n}\n\nint MaxOf2(int a, int b){\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n;\n    while ((scanf(\"%d\", &n) != EOF) && n)\n    {\n        int maxt = 0, position, time;\n\n        memset(dp, -1, sizeof(dp));\n        memset(data, 0, sizeof(data));\n        dp[6][0] = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d %d\", &position, &time);\n            data[position+1][time]++;\n            if (maxt < time)\n                maxt = time;\n        }\n\n\n        for (int i = 1; i <= maxt; i++)\n        {\n            for (int j = 1; j < 12; j++)\n            {\n                dp[j][i] = MaxOf3(dp[j][i-1], dp[j-1][i-1], dp[j+1][i-1]);\n                if (dp[j][i] != -1)\n                    dp[j][i] += data[j][i];\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < 12; i++)\n        {\n            if (ans < dp[i][maxt])\n                ans = dp[i][maxt];\n        }\n        cout << ans << endl;\n    }\n}\n```","source":"_posts/HDOJ1176-免费馅饼-（DP）.md","raw":"---\ntitle: HDOJ1176. 免费馅饼.（DP）\ndate: 2016-12-05 22:05:33\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n[免费馅饼](http://acm.hdu.edu.cn/showproblem.php?pid=1176)\n\n\n----------\n# 题目大意：\n![这里写图片描述](http://acm.sdut.edu.cn/image/1366.jpg)\n初始位置为5，输入时间和位置，从1秒开始，每次可以移动一个位置，一秒时可接住4,5,6处馅饼，求最大接住馅饼数。\n\n\n----------\n# 解题过程：\n\n - 刚开始就找到了状态转移方程：\n - j代表位置，i代表时间\n  ***dp[j][i] = max(dp[j-1][i], dp[j-1][i-1], dp[j-1][i+1]) + data[j][i]; （j点位置曾经达到过）***\n  \n - 数塔是没想到，看到题解后才发现原来这可以归一类问题\n - 不过没想到状态转移方程出来后题目还是WA，莫名其妙，反复改后变成TLE了，介于这题cin都会TLE估计是卡了常数……\n - 于是发现别人数塔都是从后往前数的于是改了下状态转移方程A了，这样也不需要开data数组了。\n - 于是找了下之前数塔的题，发现直接都是从前往后数的，或者多开了一个数组……算是学到了。\n\n\n----------\n# 题目分析：\n\n - 就是一个数塔\n -  j代表位置，i代表时间\n - 状态转移方程：\n  ***dp[j][i] = max(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i]***\n\n\n----------\n# AC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint dp[20][1123456];\n\nint MaxOf3(int a, int b, int c){\n    int max = (a > b) ? a : b;\n    return (max > c) ? max : c;\n}\n\nint MaxOf2(int a, int b){\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n;\n    while ((scanf(\"%d\", &n) != EOF) && n)\n    {\n        int maxt = 0, position, time;\n\n        memset(dp, 0, sizeof(dp));\n\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d %d\", &position, &time);\n            dp[position+1][time]++;\n            if (maxt < time)\n                maxt = time;\n        }\n\n        for (int i = maxt; i >= 0; i--)\n        {\n            for (int j = 1; j < 12; j++)\n            {\n                dp[j][i] = MaxOf3(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i];\n            }\n        }\n\n        cout << dp[6][0] << endl;\n    }\n}\n```\n\n# 从前往后TLE的错误代码：\n\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint dp[20][1123456];\nint data[20][1123456];\n\nint MaxOf3(int a, int b, int c){\n    int max = (a > b) ? a : b;\n    return (max > c) ? max : c;\n}\n\nint MaxOf2(int a, int b){\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n;\n    while ((scanf(\"%d\", &n) != EOF) && n)\n    {\n        int maxt = 0, position, time;\n\n        memset(dp, -1, sizeof(dp));\n        memset(data, 0, sizeof(data));\n        dp[6][0] = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d %d\", &position, &time);\n            data[position+1][time]++;\n            if (maxt < time)\n                maxt = time;\n        }\n\n\n        for (int i = 1; i <= maxt; i++)\n        {\n            for (int j = 1; j < 12; j++)\n            {\n                dp[j][i] = MaxOf3(dp[j][i-1], dp[j-1][i-1], dp[j+1][i-1]);\n                if (dp[j][i] != -1)\n                    dp[j][i] += data[j][i];\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < 12; i++)\n        {\n            if (ans < dp[i][maxt])\n                ans = dp[i][maxt];\n        }\n        cout << ans << endl;\n    }\n}\n```","slug":"HDOJ1176-免费馅饼-（DP）","published":1,"updated":"2017-07-23T04:17:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nad001ay9idocxlaw8b","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1176\" target=\"_blank\" rel=\"external\">免费馅饼</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><img src=\"http://acm.sdut.edu.cn/image/1366.jpg\" alt=\"这里写图片描述\"><br>初始位置为5，输入时间和位置，从1秒开始，每次可以移动一个位置，一秒时可接住4,5,6处馅饼，求最大接住馅饼数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>刚开始就找到了状态转移方程：</li>\n<li><p>j代表位置，i代表时间<br><strong><em>dp[j][i] = max(dp[j-1][i], dp[j-1][i-1], dp[j-1][i+1]) + data[j][i]; （j点位置曾经达到过）</em></strong></p>\n</li>\n<li><p>数塔是没想到，看到题解后才发现原来这可以归一类问题</p>\n</li>\n<li>不过没想到状态转移方程出来后题目还是WA，莫名其妙，反复改后变成TLE了，介于这题cin都会TLE估计是卡了常数……</li>\n<li>于是发现别人数塔都是从后往前数的于是改了下状态转移方程A了，这样也不需要开data数组了。</li>\n<li>于是找了下之前数塔的题，发现直接都是从前往后数的，或者多开了一个数组……算是学到了。</li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>就是一个数塔</li>\n<li>j代表位置，i代表时间</li>\n<li>状态转移方程：<br><strong><em>dp[j][i] = max(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i]</em></strong></li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">20</span>][<span class=\"number\">1123456</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxOf3</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> max = (a &gt; b) ? a : b;</div><div class=\"line\">    <span class=\"keyword\">return</span> (max &gt; c) ? max : c;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxOf2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) != EOF) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> maxt = <span class=\"number\">0</span>, position, time;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;position, &amp;time);</div><div class=\"line\">            dp[position+<span class=\"number\">1</span>][time]++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (maxt &lt; time)</div><div class=\"line\">                maxt = time;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxt; i &gt;= <span class=\"number\">0</span>; i--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">12</span>; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dp[j][i] = MaxOf3(dp[j][i+<span class=\"number\">1</span>], dp[j<span class=\"number\">-1</span>][i+<span class=\"number\">1</span>], dp[j+<span class=\"number\">1</span>][i+<span class=\"number\">1</span>]) + dp[j][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; dp[<span class=\"number\">6</span>][<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"从前往后TLE的错误代码：\"><a href=\"#从前往后TLE的错误代码：\" class=\"headerlink\" title=\"从前往后TLE的错误代码：\"></a>从前往后TLE的错误代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;iostream&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstdio&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int dp[20][1123456];</div><div class=\"line\">int data[20][1123456];</div><div class=\"line\"></div><div class=\"line\">int MaxOf3(int a, int b, int c)&#123;</div><div class=\"line\">    int max = (a &gt; b) ? a : b;</div><div class=\"line\">    return (max &gt; c) ? max : c;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int MaxOf2(int a, int b)&#123;</div><div class=\"line\">    return (a &gt; b) ? a : b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n;</div><div class=\"line\">    while ((scanf(&quot;%d&quot;, &amp;n) != EOF) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        int maxt = 0, position, time;</div><div class=\"line\"></div><div class=\"line\">        memset(dp, -1, sizeof(dp));</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        dp[6][0] = 0;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            scanf(&quot;%d %d&quot;, &amp;position, &amp;time);</div><div class=\"line\">            data[position+1][time]++;</div><div class=\"line\">            if (maxt &lt; time)</div><div class=\"line\">                maxt = time;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        for (int i = 1; i &lt;= maxt; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            for (int j = 1; j &lt; 12; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dp[j][i] = MaxOf3(dp[j][i-1], dp[j-1][i-1], dp[j+1][i-1]);</div><div class=\"line\">                if (dp[j][i] != -1)</div><div class=\"line\">                    dp[j][i] += data[j][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int ans = -1;</div><div class=\"line\">        for (int i = 0; i &lt; 12; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (ans &lt; dp[i][maxt])</div><div class=\"line\">                ans = dp[i][maxt];</div><div class=\"line\">        &#125;</div><div class=\"line\">        cout &lt;&lt; ans &lt;&lt; endl;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1176\" target=\"_blank\" rel=\"external\">免费馅饼</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><img src=\"http://acm.sdut.edu.cn/image/1366.jpg\" alt=\"这里写图片描述\"><br>初始位置为5，输入时间和位置，从1秒开始，每次可以移动一个位置，一秒时可接住4,5,6处馅饼，求最大接住馅饼数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>刚开始就找到了状态转移方程：</li>\n<li><p>j代表位置，i代表时间<br><strong><em>dp[j][i] = max(dp[j-1][i], dp[j-1][i-1], dp[j-1][i+1]) + data[j][i]; （j点位置曾经达到过）</em></strong></p>\n</li>\n<li><p>数塔是没想到，看到题解后才发现原来这可以归一类问题</p>\n</li>\n<li>不过没想到状态转移方程出来后题目还是WA，莫名其妙，反复改后变成TLE了，介于这题cin都会TLE估计是卡了常数……</li>\n<li>于是发现别人数塔都是从后往前数的于是改了下状态转移方程A了，这样也不需要开data数组了。</li>\n<li>于是找了下之前数塔的题，发现直接都是从前往后数的，或者多开了一个数组……算是学到了。</li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>就是一个数塔</li>\n<li>j代表位置，i代表时间</li>\n<li>状态转移方程：<br><strong><em>dp[j][i] = max(dp[j][i+1], dp[j-1][i+1], dp[j+1][i+1]) + dp[j][i]</em></strong></li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">20</span>][<span class=\"number\">1123456</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxOf3</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> max = (a &gt; b) ? a : b;</div><div class=\"line\">    <span class=\"keyword\">return</span> (max &gt; c) ? max : c;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxOf2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) != EOF) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> maxt = <span class=\"number\">0</span>, position, time;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;position, &amp;time);</div><div class=\"line\">            dp[position+<span class=\"number\">1</span>][time]++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (maxt &lt; time)</div><div class=\"line\">                maxt = time;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxt; i &gt;= <span class=\"number\">0</span>; i--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">12</span>; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dp[j][i] = MaxOf3(dp[j][i+<span class=\"number\">1</span>], dp[j<span class=\"number\">-1</span>][i+<span class=\"number\">1</span>], dp[j+<span class=\"number\">1</span>][i+<span class=\"number\">1</span>]) + dp[j][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; dp[<span class=\"number\">6</span>][<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"从前往后TLE的错误代码：\"><a href=\"#从前往后TLE的错误代码：\" class=\"headerlink\" title=\"从前往后TLE的错误代码：\"></a>从前往后TLE的错误代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;iostream&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstdio&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int dp[20][1123456];</div><div class=\"line\">int data[20][1123456];</div><div class=\"line\"></div><div class=\"line\">int MaxOf3(int a, int b, int c)&#123;</div><div class=\"line\">    int max = (a &gt; b) ? a : b;</div><div class=\"line\">    return (max &gt; c) ? max : c;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int MaxOf2(int a, int b)&#123;</div><div class=\"line\">    return (a &gt; b) ? a : b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n;</div><div class=\"line\">    while ((scanf(&quot;%d&quot;, &amp;n) != EOF) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        int maxt = 0, position, time;</div><div class=\"line\"></div><div class=\"line\">        memset(dp, -1, sizeof(dp));</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        dp[6][0] = 0;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            scanf(&quot;%d %d&quot;, &amp;position, &amp;time);</div><div class=\"line\">            data[position+1][time]++;</div><div class=\"line\">            if (maxt &lt; time)</div><div class=\"line\">                maxt = time;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        for (int i = 1; i &lt;= maxt; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            for (int j = 1; j &lt; 12; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dp[j][i] = MaxOf3(dp[j][i-1], dp[j-1][i-1], dp[j+1][i-1]);</div><div class=\"line\">                if (dp[j][i] != -1)</div><div class=\"line\">                    dp[j][i] += data[j][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int ans = -1;</div><div class=\"line\">        for (int i = 0; i &lt; 12; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (ans &lt; dp[i][maxt])</div><div class=\"line\">                ans = dp[i][maxt];</div><div class=\"line\">        &#125;</div><div class=\"line\">        cout &lt;&lt; ans &lt;&lt; endl;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU1269 - 迷宫城堡(强连通)","date":"2017-08-02T12:51:21.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1269\n\n----------------------\n# 题目大意：\n给出一个有向图，判断是否为一个强连通的图。\n\n----------------------------\n# 解题过程：\n\n看完了lrj的白书后去刷的题，裸的板子题，当tarjan练手。\n\n-------------------\n# 题目分析：\n对原图进行强连通分量分解，判断强连通分量的数量是否为1。\n\n-------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nconst int MAX = 10000+10;\n\nvector<int> edge[MAX];\n\n//pre表示访问的时间，low是当前节点及其儿子节点能回到的最早的祖先，mark是所在强连通分量的编号\n//剩下两个变量是用来计数\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nvoid dfs(int u) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!pre[v]) {\n            dfs(v);\n            //用当前节点的儿子节点更新low数组\n            low[u] = min(low[u], low[v]);\n        }\n        else if (!mark[v]) {\n            //用当前节点能回到的祖先节点更新low数组\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    //如果当前节点及其儿子节点都不能返回到更早的祖先节点，那么当前节点就是一个强连通分量的第一次访问到的节点\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        //将当前节点的儿子节点出栈\n        do {\n            x = S.top(); S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid find_scc(int n) {\n    dfs_clock = scc_cnt = 0;\n    memset(mark, 0, sizeof(mark));\n    memset(pre, 0, sizeof(pre));\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        for (int i = 1; i <= n; i++) edge[i].clear();\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            edge[u].push_back(v);\n        }\n        find_scc(n);\n        if (scc_cnt != 1) printf(\"No\\n\");\n        else printf(\"Yes\\n\");\n    }\n}\n```","source":"_posts/HDU1269-迷宫城堡-强连通.md","raw":"---\ntitle: HDU1269 - 迷宫城堡(强连通)\ndate: 2017-08-02 20:51:21\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1269\n\n----------------------\n# 题目大意：\n给出一个有向图，判断是否为一个强连通的图。\n\n----------------------------\n# 解题过程：\n\n看完了lrj的白书后去刷的题，裸的板子题，当tarjan练手。\n\n-------------------\n# 题目分析：\n对原图进行强连通分量分解，判断强连通分量的数量是否为1。\n\n-------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nconst int MAX = 10000+10;\n\nvector<int> edge[MAX];\n\n//pre表示访问的时间，low是当前节点及其儿子节点能回到的最早的祖先，mark是所在强连通分量的编号\n//剩下两个变量是用来计数\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nvoid dfs(int u) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (!pre[v]) {\n            dfs(v);\n            //用当前节点的儿子节点更新low数组\n            low[u] = min(low[u], low[v]);\n        }\n        else if (!mark[v]) {\n            //用当前节点能回到的祖先节点更新low数组\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    //如果当前节点及其儿子节点都不能返回到更早的祖先节点，那么当前节点就是一个强连通分量的第一次访问到的节点\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        //将当前节点的儿子节点出栈\n        do {\n            x = S.top(); S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid find_scc(int n) {\n    dfs_clock = scc_cnt = 0;\n    memset(mark, 0, sizeof(mark));\n    memset(pre, 0, sizeof(pre));\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        for (int i = 1; i <= n; i++) edge[i].clear();\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            edge[u].push_back(v);\n        }\n        find_scc(n);\n        if (scc_cnt != 1) printf(\"No\\n\");\n        else printf(\"Yes\\n\");\n    }\n}\n```","slug":"HDU1269-迷宫城堡-强连通","published":1,"updated":"2017-08-02T13:00:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6naf001dy9idip8bkitv","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1269\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1269</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，判断是否为一个强连通的图。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>看完了lrj的白书后去刷的题，裸的板子题，当tarjan练手。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对原图进行强连通分量分解，判断强连通分量的数量是否为1。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//pre表示访问的时间，low是当前节点及其儿子节点能回到的最早的祖先，mark是所在强连通分量的编号</span></div><div class=\"line\"><span class=\"comment\">//剩下两个变量是用来计数</span></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            <span class=\"comment\">//用当前节点的儿子节点更新low数组</span></div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            <span class=\"comment\">//用当前节点能回到的祖先节点更新low数组</span></div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果当前节点及其儿子节点都不能返回到更早的祖先节点，那么当前节点就是一个强连通分量的第一次访问到的节点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"comment\">//将当前节点的儿子节点出栈</span></div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top(); S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find_scc</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) edge[i].clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            edge[u].push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        find_scc(n);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scc_cnt != <span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1269\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1269</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，判断是否为一个强连通的图。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>看完了lrj的白书后去刷的题，裸的板子题，当tarjan练手。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对原图进行强连通分量分解，判断强连通分量的数量是否为1。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//pre表示访问的时间，low是当前节点及其儿子节点能回到的最早的祖先，mark是所在强连通分量的编号</span></div><div class=\"line\"><span class=\"comment\">//剩下两个变量是用来计数</span></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            <span class=\"comment\">//用当前节点的儿子节点更新low数组</span></div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            <span class=\"comment\">//用当前节点能回到的祖先节点更新low数组</span></div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果当前节点及其儿子节点都不能返回到更早的祖先节点，那么当前节点就是一个强连通分量的第一次访问到的节点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"comment\">//将当前节点的儿子节点出栈</span></div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top(); S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find_scc</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) edge[i].clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            edge[u].push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        find_scc(n);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scc_cnt != <span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU1394 - Minimum Inversion Number（线段树）","date":"2017-06-21T06:49:36.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1394\n\n------------------------\n# 题目大意：\n给定一个由$0$到$n-1$组成，长度为$n$每个元素唯一的序列，可以进行一种操作，把第一个元素放到最后一个位置。求经过若干次操作后的，最小逆序对数。\n\n\n----------------------------\n# 解题过程：\n这题之前写过一个暴力解法的题解，现在用线段树来解决一下。\n\n-------------------------\n# 题目分析：\n这里用线段树主要是求解初始状态的逆序对数，对于每次的操作有一个结论可以用。\n\n要求逆序对数，那么对于每个数我要求在这个数之前有多少个大于这个数的元素。\n\n因为序列的元素是从$0$到$n-1$的，那么我用$n$个叶子节点去维护这些值是否出现过，出现置$1$否则为$0$，对于非叶子节点就维护区间内数字出现的个数，那么我要查询比$a$大的数有几个，那么我只需要查询$[a, n]$这个区间的值就好了。\n\n这题比较容易做，其他题可能也会用到这个思想，不过数字不是从$0$到$n-1$的，需要离散化一下。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n\nconst int MAX = 5000+10;\n\nint data[MAX], tree[MAX<<2];\n\nvoid build(int root, int l, int r) {\n    if (l == r) {\n        tree[root] = 0;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid updata(int root, int l, int r, int pos) {\n    if (pos < l || pos > r)\n        return;\n    if (l == r) {\n        tree[root] = 1;\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos);\n    updata(rson, m+1, r, pos);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nint query(int root, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql)\n        return 0;\n    if (ql <= l && r <= qr) {\n        return tree[root];\n    }\n    MID;\n    return query(lson, l, m, ql, qr) + query(rson, m+1, r, ql, qr);\n}\n\nint main() {\n    int n;\n    while (~scanf(\"%d\", &n)) {\n        build(1, 1, n);\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &data[i]);\n            data[i] += 1;\n            //这里处理了一下，下标从1开始比较方便\n            //大于data[i]，查询[data[i], n]区间的值就是i之前比data[i]大的元素的个数\n            sum += query(1, 1, n, data[i], n);\n            updata(1, 1, n, data[i]);\n        }\n        int rst = sum;\n        for (int i = 1; i <= n; i++) {\n            sum += n - data[i];\n            sum -= data[i] - 1;\n            rst = min(sum, rst);\n        }\n        printf(\"%d\\n\", rst);\n    }\n}\n```","source":"_posts/HDU1394-Minimum-Inversion-Number（线段树）.md","raw":"---\ntitle: HDU1394 - Minimum Inversion Number（线段树）\ndate: 2017-06-21 14:49:36\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1394\n\n------------------------\n# 题目大意：\n给定一个由$0$到$n-1$组成，长度为$n$每个元素唯一的序列，可以进行一种操作，把第一个元素放到最后一个位置。求经过若干次操作后的，最小逆序对数。\n\n\n----------------------------\n# 解题过程：\n这题之前写过一个暴力解法的题解，现在用线段树来解决一下。\n\n-------------------------\n# 题目分析：\n这里用线段树主要是求解初始状态的逆序对数，对于每次的操作有一个结论可以用。\n\n要求逆序对数，那么对于每个数我要求在这个数之前有多少个大于这个数的元素。\n\n因为序列的元素是从$0$到$n-1$的，那么我用$n$个叶子节点去维护这些值是否出现过，出现置$1$否则为$0$，对于非叶子节点就维护区间内数字出现的个数，那么我要查询比$a$大的数有几个，那么我只需要查询$[a, n]$这个区间的值就好了。\n\n这题比较容易做，其他题可能也会用到这个思想，不过数字不是从$0$到$n-1$的，需要离散化一下。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n\nconst int MAX = 5000+10;\n\nint data[MAX], tree[MAX<<2];\n\nvoid build(int root, int l, int r) {\n    if (l == r) {\n        tree[root] = 0;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid updata(int root, int l, int r, int pos) {\n    if (pos < l || pos > r)\n        return;\n    if (l == r) {\n        tree[root] = 1;\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos);\n    updata(rson, m+1, r, pos);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nint query(int root, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql)\n        return 0;\n    if (ql <= l && r <= qr) {\n        return tree[root];\n    }\n    MID;\n    return query(lson, l, m, ql, qr) + query(rson, m+1, r, ql, qr);\n}\n\nint main() {\n    int n;\n    while (~scanf(\"%d\", &n)) {\n        build(1, 1, n);\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &data[i]);\n            data[i] += 1;\n            //这里处理了一下，下标从1开始比较方便\n            //大于data[i]，查询[data[i], n]区间的值就是i之前比data[i]大的元素的个数\n            sum += query(1, 1, n, data[i], n);\n            updata(1, 1, n, data[i]);\n        }\n        int rst = sum;\n        for (int i = 1; i <= n; i++) {\n            sum += n - data[i];\n            sum -= data[i] - 1;\n            rst = min(sum, rst);\n        }\n        printf(\"%d\\n\", rst);\n    }\n}\n```","slug":"HDU1394-Minimum-Inversion-Number（线段树）","published":1,"updated":"2017-07-23T01:59:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nai001fy9id5scpumnq","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1394\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1394</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个由$0$到$n-1$组成，长度为$n$每个元素唯一的序列，可以进行一种操作，把第一个元素放到最后一个位置。求经过若干次操作后的，最小逆序对数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题之前写过一个暴力解法的题解，现在用线段树来解决一下。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里用线段树主要是求解初始状态的逆序对数，对于每次的操作有一个结论可以用。</p>\n<p>要求逆序对数，那么对于每个数我要求在这个数之前有多少个大于这个数的元素。</p>\n<p>因为序列的元素是从$0$到$n-1$的，那么我用$n$个叶子节点去维护这些值是否出现过，出现置$1$否则为$0$，对于非叶子节点就维护区间内数字出现的个数，那么我要查询比$a$大的数有几个，那么我只需要查询$[a, n]$这个区间的值就好了。</p>\n<p>这题比较容易做，其他题可能也会用到这个思想，不过数字不是从$0$到$n-1$的，需要离散化一下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt; l || pos &gt; r)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root] = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, pos);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">            data[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"comment\">//这里处理了一下，下标从1开始比较方便</span></div><div class=\"line\">            <span class=\"comment\">//大于data[i]，查询[data[i], n]区间的值就是i之前比data[i]大的元素的个数</span></div><div class=\"line\">            sum += query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, data[i], n);</div><div class=\"line\">            updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> rst = sum;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            sum += n - data[i];</div><div class=\"line\">            sum -= data[i] - <span class=\"number\">1</span>;</div><div class=\"line\">            rst = min(sum, rst);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, rst);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1394\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1394</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个由$0$到$n-1$组成，长度为$n$每个元素唯一的序列，可以进行一种操作，把第一个元素放到最后一个位置。求经过若干次操作后的，最小逆序对数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题之前写过一个暴力解法的题解，现在用线段树来解决一下。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里用线段树主要是求解初始状态的逆序对数，对于每次的操作有一个结论可以用。</p>\n<p>要求逆序对数，那么对于每个数我要求在这个数之前有多少个大于这个数的元素。</p>\n<p>因为序列的元素是从$0$到$n-1$的，那么我用$n$个叶子节点去维护这些值是否出现过，出现置$1$否则为$0$，对于非叶子节点就维护区间内数字出现的个数，那么我要查询比$a$大的数有几个，那么我只需要查询$[a, n]$这个区间的值就好了。</p>\n<p>这题比较容易做，其他题可能也会用到这个思想，不过数字不是从$0$到$n-1$的，需要离散化一下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt; l || pos &gt; r)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root] = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, pos);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">            data[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"comment\">//这里处理了一下，下标从1开始比较方便</span></div><div class=\"line\">            <span class=\"comment\">//大于data[i]，查询[data[i], n]区间的值就是i之前比data[i]大的元素的个数</span></div><div class=\"line\">            sum += query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, data[i], n);</div><div class=\"line\">            updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> rst = sum;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            sum += n - data[i];</div><div class=\"line\">            sum -= data[i] - <span class=\"number\">1</span>;</div><div class=\"line\">            rst = min(sum, rst);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, rst);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU1827 - Summer Holiday(强连通+缩点)","date":"2017-08-02T13:03:17.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1827\n\n--------------------\n# 题目大意：\n给出一个有向图，选择若干的点作为起点，使得从这些起点出发可以遍历所有的点，选出每个点为起点需要花费$A_i$，求最小费用。\n$N <= 1000, M <= 2000$\n\n-------------------\n\n# 解题过程：\n\n想起来还是比较容易的，因为在刷强连通的题，想到缩点转化成DAG就简单了。\n不过卡了好久，因为自己的`++dfs_clock`写成`dfs_clock++`了。\n\n--------------------\n# 题目分析：\n\n首先进行强连通分量分解，缩点化为DAG，因为强连通的每个点都可以互相到达，那么只需要能到达强连通分量里面的任一点就可以了，对于缩点后，他的费用为他包含的所有点中最小的。\n\n然后现在是一个DAG图，如果一个点的入度不为0，那么他一定可以从另外的一个点到达，那么我只需要选取所有入度为0的点，并累加他们的值既可以了。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1000+10;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\n\n//G1为原图，G2为重建的图\nvector<int> G1[MAX], G2[MAX];\n//原始费用，重建的图的费用\nint cost[MAX], ans_cost[MAX];\n\nint low[MAX], dfn[MAX], mark[MAX], scc_cnt, dfs_clock;\nint in[MAX], out[MAX];\nstack<int> S;\n\nvoid tarjan(int u) {\n    low[u] = dfn[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!dfn[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        else if (!mark[v]) {\n            low[u] = min(low[u], dfn[v]);\n        }\n    }\n    if (low[u] == dfn[u]) {\n        int x;\n        ++scc_cnt;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid rebuild() {\n    //枚举每条边进行重建图\n    for (int u = 1; u <= n; u++) {\n        //更新强连通分量的花费\n        ans_cost[mark[u]] = min(ans_cost[mark[u]], cost[u]);\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                in[mark[v]]++;\n                G2[mark[u]].push_back(mark[v]);\n            }\n        }\n    }\n}\n\nvoid init() {\n    memset(dfn, 0, sizeof(dfn));\n    memset(ans_cost, INF, sizeof(ans_cost));\n    memset(mark, 0, sizeof(mark));\n    memset(in, 0, sizeof(in));\n    memset(out, 0, sizeof(out));\n    scc_cnt = dfs_clock = 0;\n    for (int i = 1; i <= n; i++) {\n        G1[i].clear(); G2[i].clear();\n        scanf(\"%d\", cost + i);\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n\n    rebuild();\n\n    int ans = 0, ans_cnt = 0;\n    //统计入度为0的点\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (in[i] == 0) ans += ans_cost[i], ans_cnt++;\n    }\n    printf(\"%d %d\\n\", ans_cnt, ans);\n}\n\nint main() {\n\n    while (~scanf(\"%d %d\", &n, &m)) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/HDU1827-Summer-Holiday-强连通-缩点.md","raw":"---\ntitle: HDU1827 - Summer Holiday(强连通+缩点)\ndate: 2017-08-02 21:03:17\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1827\n\n--------------------\n# 题目大意：\n给出一个有向图，选择若干的点作为起点，使得从这些起点出发可以遍历所有的点，选出每个点为起点需要花费$A_i$，求最小费用。\n$N <= 1000, M <= 2000$\n\n-------------------\n\n# 解题过程：\n\n想起来还是比较容易的，因为在刷强连通的题，想到缩点转化成DAG就简单了。\n不过卡了好久，因为自己的`++dfs_clock`写成`dfs_clock++`了。\n\n--------------------\n# 题目分析：\n\n首先进行强连通分量分解，缩点化为DAG，因为强连通的每个点都可以互相到达，那么只需要能到达强连通分量里面的任一点就可以了，对于缩点后，他的费用为他包含的所有点中最小的。\n\n然后现在是一个DAG图，如果一个点的入度不为0，那么他一定可以从另外的一个点到达，那么我只需要选取所有入度为0的点，并累加他们的值既可以了。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1000+10;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\n\n//G1为原图，G2为重建的图\nvector<int> G1[MAX], G2[MAX];\n//原始费用，重建的图的费用\nint cost[MAX], ans_cost[MAX];\n\nint low[MAX], dfn[MAX], mark[MAX], scc_cnt, dfs_clock;\nint in[MAX], out[MAX];\nstack<int> S;\n\nvoid tarjan(int u) {\n    low[u] = dfn[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!dfn[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        else if (!mark[v]) {\n            low[u] = min(low[u], dfn[v]);\n        }\n    }\n    if (low[u] == dfn[u]) {\n        int x;\n        ++scc_cnt;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid rebuild() {\n    //枚举每条边进行重建图\n    for (int u = 1; u <= n; u++) {\n        //更新强连通分量的花费\n        ans_cost[mark[u]] = min(ans_cost[mark[u]], cost[u]);\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                in[mark[v]]++;\n                G2[mark[u]].push_back(mark[v]);\n            }\n        }\n    }\n}\n\nvoid init() {\n    memset(dfn, 0, sizeof(dfn));\n    memset(ans_cost, INF, sizeof(ans_cost));\n    memset(mark, 0, sizeof(mark));\n    memset(in, 0, sizeof(in));\n    memset(out, 0, sizeof(out));\n    scc_cnt = dfs_clock = 0;\n    for (int i = 1; i <= n; i++) {\n        G1[i].clear(); G2[i].clear();\n        scanf(\"%d\", cost + i);\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n\n    rebuild();\n\n    int ans = 0, ans_cnt = 0;\n    //统计入度为0的点\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (in[i] == 0) ans += ans_cost[i], ans_cnt++;\n    }\n    printf(\"%d %d\\n\", ans_cnt, ans);\n}\n\nint main() {\n\n    while (~scanf(\"%d %d\", &n, &m)) {\n        init();\n        solve();\n    }\n}\n```","slug":"HDU1827-Summer-Holiday-强连通-缩点","published":1,"updated":"2017-08-02T13:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nak001iy9idyew6s3zg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1827\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1827</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，选择若干的点作为起点，使得从这些起点出发可以遍历所有的点，选出每个点为起点需要花费$A_i$，求最小费用。<br>$N &lt;= 1000, M &lt;= 2000$</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想起来还是比较容易的，因为在刷强连通的题，想到缩点转化成DAG就简单了。<br>不过卡了好久，因为自己的<code>++dfs_clock</code>写成<code>dfs_clock++</code>了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先进行强连通分量分解，缩点化为DAG，因为强连通的每个点都可以互相到达，那么只需要能到达强连通分量里面的任一点就可以了，对于缩点后，他的费用为他包含的所有点中最小的。</p>\n<p>然后现在是一个DAG图，如果一个点的入度不为0，那么他一定可以从另外的一个点到达，那么我只需要选取所有入度为0的点，并累加他们的值既可以了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//G1为原图，G2为重建的图</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[MAX];</div><div class=\"line\"><span class=\"comment\">//原始费用，重建的图的费用</span></div><div class=\"line\"><span class=\"keyword\">int</span> cost[MAX], ans_cost[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], dfn[MAX], mark[MAX], scc_cnt, dfs_clock;</div><div class=\"line\"><span class=\"keyword\">int</span> in[MAX], out[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = dfn[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!dfn[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], dfn[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == dfn[u]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//枚举每条边进行重建图</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"comment\">//更新强连通分量的花费</span></div><div class=\"line\">        ans_cost[mark[u]] = min(ans_cost[mark[u]], cost[u]);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                in[mark[v]]++;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dfn, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dfn));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans_cost, INF, <span class=\"keyword\">sizeof</span>(ans_cost));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(out, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(out));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G1[i].clear(); G2[i].clear();</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, cost + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!dfn[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>, ans_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//统计入度为0的点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] == <span class=\"number\">0</span>) ans += ans_cost[i], ans_cnt++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, ans_cnt, ans);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1827\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=1827</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，选择若干的点作为起点，使得从这些起点出发可以遍历所有的点，选出每个点为起点需要花费$A_i$，求最小费用。<br>$N &lt;= 1000, M &lt;= 2000$</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想起来还是比较容易的，因为在刷强连通的题，想到缩点转化成DAG就简单了。<br>不过卡了好久，因为自己的<code>++dfs_clock</code>写成<code>dfs_clock++</code>了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先进行强连通分量分解，缩点化为DAG，因为强连通的每个点都可以互相到达，那么只需要能到达强连通分量里面的任一点就可以了，对于缩点后，他的费用为他包含的所有点中最小的。</p>\n<p>然后现在是一个DAG图，如果一个点的入度不为0，那么他一定可以从另外的一个点到达，那么我只需要选取所有入度为0的点，并累加他们的值既可以了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1000</span>+<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//G1为原图，G2为重建的图</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[MAX];</div><div class=\"line\"><span class=\"comment\">//原始费用，重建的图的费用</span></div><div class=\"line\"><span class=\"keyword\">int</span> cost[MAX], ans_cost[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], dfn[MAX], mark[MAX], scc_cnt, dfs_clock;</div><div class=\"line\"><span class=\"keyword\">int</span> in[MAX], out[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = dfn[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!dfn[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], dfn[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == dfn[u]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//枚举每条边进行重建图</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"comment\">//更新强连通分量的花费</span></div><div class=\"line\">        ans_cost[mark[u]] = min(ans_cost[mark[u]], cost[u]);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                in[mark[v]]++;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dfn, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dfn));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans_cost, INF, <span class=\"keyword\">sizeof</span>(ans_cost));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(out, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(out));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G1[i].clear(); G2[i].clear();</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, cost + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!dfn[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>, ans_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//统计入度为0的点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] == <span class=\"number\">0</span>) ans += ans_cost[i], ans_cnt++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, ans_cnt, ans);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU2196 - Computer（树的直径+DP）","date":"2017-06-28T12:41:14.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2196\n\n-----------------------------\n# 题目大意：\n给定一个无向连通无环图，求每个节点到达的最远的节点的距离。\n\n\n----------------------------\n# 解题过程：\n上午看了一下DP进阶之路的PDF，突然想学树型DP。然后找到了这个题，之前做了一个POJ的BFS求树的直径的，这次再来一发DP的。\n\n--------------------------------\n# 题目分析：\n由于题目给的是无向连通无环图，这里构造出一颗树来，不妨假设节点$1$为根。\n\n那么对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点，或者经过他父亲到达的一个节点。\n\n这里可以经过一次DFS求出每个节点到他子树中最远的节点的距离。\n\n然后第二次DFS的时候求出每个节点经过他根节点能到达的最远的距离，求经过根节点能到达的最远的距离时，需要当前节点到根节点的距离加上根节点到最远的节点的距离。不过要注意的是，可能当前节点在根节点最远距离的路径上。\n\n这里解决的方法是，求出每个节点最远的距离和次远的距离，如果当前节点在最远的距离路径上那么就选择次远的距离，判断是否在路径上需要记录下最远的距离是由那个儿子求出来的。\n\n----------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234;\nconst int INF = 0x3f3f3f3f;\n\nint n;\nvector<pair<int, int> > edge[MAX];\n\n//dis1记录最远距离，dis2记录次远距离，num用来标记最远距离由那个节点而来的\nint num[MAX], dis1[MAX], dis2[MAX], dp[MAX];\n\n\nvoid read() {\n    for (int i = 1; i <= n; i++) {\n        edge[i].clear();\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 2; i <= n; i++) {\n        int v, w;\n        scanf(\"%d %d\", &v, &w);\n        edge[v].push_back(make_pair(i, w));\n    }\n}\n\nvoid dfs1(int u) {\n    dis1[u] = 0;\n    //这里的含义是，对于每个节点求他所有儿子节点的最远距离，那么当前节点的最远距离就是到儿子节点的距离加上儿子节点的最远距离\n    //显然对于一个叶子节点，最远距离是0\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        dfs1(v);\n        if (dis1[v] + w > dis1[u]) {\n            dis1[u] = dis1[v] + w;\n            num[u] = v;\n        }\n    }\n    //和上一步相似，求次远距离\n    dis2[u] = -INF;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        //当前距离不能是最远距离\n        if (v != num[u] && dis1[v] + w > dis2[u]) {\n            dis2[u] = dis1[v] + w;\n        }\n    }\n}\n\nvoid dfs2(int u) {\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        //dp[u]的含义是，当前节点经过父节点能到达的最远的距离\n        //如果当前节点在最远距离的路径上，那么用次远距离，否则用最远距离\n        if (v == num[u])\n            dp[v] = max(dp[u], dis2[u]) + w;\n        else\n            dp[v] = max(dp[u], dis1[u]) + w;\n        dfs2(v);\n    }\n}\n\nvoid go() {\n    dfs1(1);\n    dfs2(1);\n    //输出每个点的最远距离\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d\\n\", max(dp[i], dis1[i]));\n    }\n}\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n        read();\n        go();\n    }\n}\n```","source":"_posts/HDU2196-Computer（树的直径-DP）.md","raw":"---\ntitle: HDU2196 - Computer（树的直径+DP）\ndate: 2017-06-28 20:41:14\ncategories: [ACM, DP, 树型DP]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2196\n\n-----------------------------\n# 题目大意：\n给定一个无向连通无环图，求每个节点到达的最远的节点的距离。\n\n\n----------------------------\n# 解题过程：\n上午看了一下DP进阶之路的PDF，突然想学树型DP。然后找到了这个题，之前做了一个POJ的BFS求树的直径的，这次再来一发DP的。\n\n--------------------------------\n# 题目分析：\n由于题目给的是无向连通无环图，这里构造出一颗树来，不妨假设节点$1$为根。\n\n那么对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点，或者经过他父亲到达的一个节点。\n\n这里可以经过一次DFS求出每个节点到他子树中最远的节点的距离。\n\n然后第二次DFS的时候求出每个节点经过他根节点能到达的最远的距离，求经过根节点能到达的最远的距离时，需要当前节点到根节点的距离加上根节点到最远的节点的距离。不过要注意的是，可能当前节点在根节点最远距离的路径上。\n\n这里解决的方法是，求出每个节点最远的距离和次远的距离，如果当前节点在最远的距离路径上那么就选择次远的距离，判断是否在路径上需要记录下最远的距离是由那个儿子求出来的。\n\n----------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234;\nconst int INF = 0x3f3f3f3f;\n\nint n;\nvector<pair<int, int> > edge[MAX];\n\n//dis1记录最远距离，dis2记录次远距离，num用来标记最远距离由那个节点而来的\nint num[MAX], dis1[MAX], dis2[MAX], dp[MAX];\n\n\nvoid read() {\n    for (int i = 1; i <= n; i++) {\n        edge[i].clear();\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 2; i <= n; i++) {\n        int v, w;\n        scanf(\"%d %d\", &v, &w);\n        edge[v].push_back(make_pair(i, w));\n    }\n}\n\nvoid dfs1(int u) {\n    dis1[u] = 0;\n    //这里的含义是，对于每个节点求他所有儿子节点的最远距离，那么当前节点的最远距离就是到儿子节点的距离加上儿子节点的最远距离\n    //显然对于一个叶子节点，最远距离是0\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        dfs1(v);\n        if (dis1[v] + w > dis1[u]) {\n            dis1[u] = dis1[v] + w;\n            num[u] = v;\n        }\n    }\n    //和上一步相似，求次远距离\n    dis2[u] = -INF;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        //当前距离不能是最远距离\n        if (v != num[u] && dis1[v] + w > dis2[u]) {\n            dis2[u] = dis1[v] + w;\n        }\n    }\n}\n\nvoid dfs2(int u) {\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i].first;\n        int w = edge[u][i].second;\n        //dp[u]的含义是，当前节点经过父节点能到达的最远的距离\n        //如果当前节点在最远距离的路径上，那么用次远距离，否则用最远距离\n        if (v == num[u])\n            dp[v] = max(dp[u], dis2[u]) + w;\n        else\n            dp[v] = max(dp[u], dis1[u]) + w;\n        dfs2(v);\n    }\n}\n\nvoid go() {\n    dfs1(1);\n    dfs2(1);\n    //输出每个点的最远距离\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d\\n\", max(dp[i], dis1[i]));\n    }\n}\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n        read();\n        go();\n    }\n}\n```","slug":"HDU2196-Computer（树的直径-DP）","published":1,"updated":"2017-07-23T01:47:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nam001jy9id8w6p6jq6","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2196\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2196</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个无向连通无环图，求每个节点到达的最远的节点的距离。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>上午看了一下DP进阶之路的PDF，突然想学树型DP。然后找到了这个题，之前做了一个POJ的BFS求树的直径的，这次再来一发DP的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于题目给的是无向连通无环图，这里构造出一颗树来，不妨假设节点$1$为根。</p>\n<p>那么对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点，或者经过他父亲到达的一个节点。</p>\n<p>这里可以经过一次DFS求出每个节点到他子树中最远的节点的距离。</p>\n<p>然后第二次DFS的时候求出每个节点经过他根节点能到达的最远的距离，求经过根节点能到达的最远的距离时，需要当前节点到根节点的距离加上根节点到最远的节点的距离。不过要注意的是，可能当前节点在根节点最远距离的路径上。</p>\n<p>这里解决的方法是，求出每个节点最远的距离和次远的距离，如果当前节点在最远的距离路径上那么就选择次远的距离，判断是否在路径上需要记录下最远的距离是由那个儿子求出来的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dis1记录最远距离，dis2记录次远距离，num用来标记最远距离由那个节点而来的</span></div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], dis1[MAX], dis2[MAX], dp[MAX];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        edge[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;v, &amp;w);</div><div class=\"line\">        edge[v].push_back(make_pair(i, w));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    dis1[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//这里的含义是，对于每个节点求他所有儿子节点的最远距离，那么当前节点的最远距离就是到儿子节点的距离加上儿子节点的最远距离</span></div><div class=\"line\">    <span class=\"comment\">//显然对于一个叶子节点，最远距离是0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        dfs1(v);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dis1[v] + w &gt; dis1[u]) &#123;</div><div class=\"line\">            dis1[u] = dis1[v] + w;</div><div class=\"line\">            num[u] = v;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//和上一步相似，求次远距离</span></div><div class=\"line\">    dis2[u] = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        <span class=\"comment\">//当前距离不能是最远距离</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (v != num[u] &amp;&amp; dis1[v] + w &gt; dis2[u]) &#123;</div><div class=\"line\">            dis2[u] = dis1[v] + w;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        <span class=\"comment\">//dp[u]的含义是，当前节点经过父节点能到达的最远的距离</span></div><div class=\"line\">        <span class=\"comment\">//如果当前节点在最远距离的路径上，那么用次远距离，否则用最远距离</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (v == num[u])</div><div class=\"line\">            dp[v] = max(dp[u], dis2[u]) + w;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            dp[v] = max(dp[u], dis1[u]) + w;</div><div class=\"line\">        dfs2(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">go</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs1(<span class=\"number\">1</span>);</div><div class=\"line\">    dfs2(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//输出每个点的最远距离</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max(dp[i], dis1[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        read();</div><div class=\"line\">        go();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2196\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2196</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个无向连通无环图，求每个节点到达的最远的节点的距离。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>上午看了一下DP进阶之路的PDF，突然想学树型DP。然后找到了这个题，之前做了一个POJ的BFS求树的直径的，这次再来一发DP的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于题目给的是无向连通无环图，这里构造出一颗树来，不妨假设节点$1$为根。</p>\n<p>那么对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点，或者经过他父亲到达的一个节点。</p>\n<p>这里可以经过一次DFS求出每个节点到他子树中最远的节点的距离。</p>\n<p>然后第二次DFS的时候求出每个节点经过他根节点能到达的最远的距离，求经过根节点能到达的最远的距离时，需要当前节点到根节点的距离加上根节点到最远的节点的距离。不过要注意的是，可能当前节点在根节点最远距离的路径上。</p>\n<p>这里解决的方法是，求出每个节点最远的距离和次远的距离，如果当前节点在最远的距离路径上那么就选择次远的距离，判断是否在路径上需要记录下最远的距离是由那个儿子求出来的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dis1记录最远距离，dis2记录次远距离，num用来标记最远距离由那个节点而来的</span></div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], dis1[MAX], dis2[MAX], dp[MAX];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        edge[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;v, &amp;w);</div><div class=\"line\">        edge[v].push_back(make_pair(i, w));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    dis1[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//这里的含义是，对于每个节点求他所有儿子节点的最远距离，那么当前节点的最远距离就是到儿子节点的距离加上儿子节点的最远距离</span></div><div class=\"line\">    <span class=\"comment\">//显然对于一个叶子节点，最远距离是0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        dfs1(v);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dis1[v] + w &gt; dis1[u]) &#123;</div><div class=\"line\">            dis1[u] = dis1[v] + w;</div><div class=\"line\">            num[u] = v;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//和上一步相似，求次远距离</span></div><div class=\"line\">    dis2[u] = -INF;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        <span class=\"comment\">//当前距离不能是最远距离</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (v != num[u] &amp;&amp; dis1[v] + w &gt; dis2[u]) &#123;</div><div class=\"line\">            dis2[u] = dis1[v] + w;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">        <span class=\"comment\">//dp[u]的含义是，当前节点经过父节点能到达的最远的距离</span></div><div class=\"line\">        <span class=\"comment\">//如果当前节点在最远距离的路径上，那么用次远距离，否则用最远距离</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (v == num[u])</div><div class=\"line\">            dp[v] = max(dp[u], dis2[u]) + w;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            dp[v] = max(dp[u], dis1[u]) + w;</div><div class=\"line\">        dfs2(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">go</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs1(<span class=\"number\">1</span>);</div><div class=\"line\">    dfs2(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//输出每个点的最远距离</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max(dp[i], dis1[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        read();</div><div class=\"line\">        go();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU2242 - 考研路茫茫——空调教室（边双连通+树型DP）","date":"2017-08-03T02:38:56.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2242\n\n--------------------\n# 题目大意：\n给出一个连通的无向图，要求删除一条边使得无向图变为两个连通分量，每个点有一个权值$A_i$，使得两连通分量的权值差最小。\n\n-------------------\n# 解题过程：\n拿来练手的题，看了一堆树和博客，这题主要是要处理重边比较麻烦，对于无向图的边双连通，其实和有向图的强连通的处理方式差不多。单纯的将边双连通分量标记好就可以了，每个点只属于一个边双连通分量。\n\n另外比较重要是，对无向图进行双连通缩点后，所剩下的图是一个树形图！\n\n--------------------\n# 题目分析：\n首先缩点成树形图，缩后点的权值为包含所有点的和。然后用树型DP求每个节点及其儿子的权值和。\n\n这时对于树型图，剩下的每一条边都是桥。那么枚举每一个点，假设删去它与它父亲之间的边。那么拆成的两个连通分量的权值差为$ABS(\\sum_{i=0}^{n}A_i - DP_i)$，$DP_i$为$i$节点及其儿子节点的权值和。这里缩点后是一个无根树，任意找一个点作为根节点即可。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 10000 + 10;\n\nstruct Edge {\n    int v, nxt;\n} edge[MAX << 2];\n\nint n, m, data[MAX], sum;\n\nint head[MAX], ecnt;\nvector<int> G[MAX];\n\nint dfs_clock, scc_cnt;\nint low[MAX], pre[MAX], mark[MAX];\nstack<int> S;\n\nint dp[MAX];\n\nvoid add_edge(int u, int v) {\n    edge[ecnt].v = v;\n    edge[ecnt].nxt = head[u];\n    head[u] = ecnt++;\n}\n\nvoid init() {\n    dfs_clock = scc_cnt = sum = ecnt = 0;\n    memset(head, -1, sizeof(head));\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= n; i++) {\n        G[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", data + i);\n        sum += data[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n}\n\n\n//无向图边双连通和有向图的强连通神似\nvoid tarjan(int u, int fa) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        //这里不直接用v != fa来做判断，是为了避免重边的情况\n        if (i == (fa ^ 1)) continue;\n        int v = edge[i].v;\n        if (!pre[v]) {\n            tarjan(v, i);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (pre[u] == low[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top(); S.pop();\n            mark[x] = scc_cnt;\n            dp[scc_cnt] += data[x];\n        } while (x != u);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 0; u < n; u++) {\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            if (mark[u] != mark[v]) G[mark[u]].push_back(mark[v]);\n        }\n    }\n}\n\n//树型DP求权值和\nint dfs(int u, int fat) {\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if (v == fat) continue;\n        dfs(v, u);\n        dp[u] += dp[v];\n    }\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        if (!pre[i]) tarjan(i, -1);\n    }\n    if (scc_cnt == 1) { puts(\"impossible\"); return; }\n    rebuild();\n    dfs(1, -1);\n    int ans = 1e9;\n    for (int i = 1; i <= scc_cnt; i++) {\n        ans = min(ans, abs(sum - dp[i] * 2));\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && n) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/HDU2242-考研路茫茫——空调教室（边双连通-树型DP）.md","raw":"---\ntitle: HDU2242 - 考研路茫茫——空调教室（边双连通+树型DP）\ndate: 2017-08-03 10:38:56\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2242\n\n--------------------\n# 题目大意：\n给出一个连通的无向图，要求删除一条边使得无向图变为两个连通分量，每个点有一个权值$A_i$，使得两连通分量的权值差最小。\n\n-------------------\n# 解题过程：\n拿来练手的题，看了一堆树和博客，这题主要是要处理重边比较麻烦，对于无向图的边双连通，其实和有向图的强连通的处理方式差不多。单纯的将边双连通分量标记好就可以了，每个点只属于一个边双连通分量。\n\n另外比较重要是，对无向图进行双连通缩点后，所剩下的图是一个树形图！\n\n--------------------\n# 题目分析：\n首先缩点成树形图，缩后点的权值为包含所有点的和。然后用树型DP求每个节点及其儿子的权值和。\n\n这时对于树型图，剩下的每一条边都是桥。那么枚举每一个点，假设删去它与它父亲之间的边。那么拆成的两个连通分量的权值差为$ABS(\\sum_{i=0}^{n}A_i - DP_i)$，$DP_i$为$i$节点及其儿子节点的权值和。这里缩点后是一个无根树，任意找一个点作为根节点即可。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 10000 + 10;\n\nstruct Edge {\n    int v, nxt;\n} edge[MAX << 2];\n\nint n, m, data[MAX], sum;\n\nint head[MAX], ecnt;\nvector<int> G[MAX];\n\nint dfs_clock, scc_cnt;\nint low[MAX], pre[MAX], mark[MAX];\nstack<int> S;\n\nint dp[MAX];\n\nvoid add_edge(int u, int v) {\n    edge[ecnt].v = v;\n    edge[ecnt].nxt = head[u];\n    head[u] = ecnt++;\n}\n\nvoid init() {\n    dfs_clock = scc_cnt = sum = ecnt = 0;\n    memset(head, -1, sizeof(head));\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= n; i++) {\n        G[i].clear();\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", data + i);\n        sum += data[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n}\n\n\n//无向图边双连通和有向图的强连通神似\nvoid tarjan(int u, int fa) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        //这里不直接用v != fa来做判断，是为了避免重边的情况\n        if (i == (fa ^ 1)) continue;\n        int v = edge[i].v;\n        if (!pre[v]) {\n            tarjan(v, i);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (pre[u] == low[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top(); S.pop();\n            mark[x] = scc_cnt;\n            dp[scc_cnt] += data[x];\n        } while (x != u);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 0; u < n; u++) {\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            if (mark[u] != mark[v]) G[mark[u]].push_back(mark[v]);\n        }\n    }\n}\n\n//树型DP求权值和\nint dfs(int u, int fat) {\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if (v == fat) continue;\n        dfs(v, u);\n        dp[u] += dp[v];\n    }\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        if (!pre[i]) tarjan(i, -1);\n    }\n    if (scc_cnt == 1) { puts(\"impossible\"); return; }\n    rebuild();\n    dfs(1, -1);\n    int ans = 1e9;\n    for (int i = 1; i <= scc_cnt; i++) {\n        ans = min(ans, abs(sum - dp[i] * 2));\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && n) {\n        init();\n        solve();\n    }\n}\n```","slug":"HDU2242-考研路茫茫——空调教室（边双连通-树型DP）","published":1,"updated":"2017-08-03T02:56:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nan001ly9idulfd4p8d","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2242\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2242</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个连通的无向图，要求删除一条边使得无向图变为两个连通分量，每个点有一个权值$A_i$，使得两连通分量的权值差最小。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>拿来练手的题，看了一堆树和博客，这题主要是要处理重边比较麻烦，对于无向图的边双连通，其实和有向图的强连通的处理方式差不多。单纯的将边双连通分量标记好就可以了，每个点只属于一个边双连通分量。</p>\n<p>另外比较重要是，对无向图进行双连通缩点后，所剩下的图是一个树形图！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先缩点成树形图，缩后点的权值为包含所有点的和。然后用树型DP求每个节点及其儿子的权值和。</p>\n<p>这时对于树型图，剩下的每一条边都是桥。那么枚举每一个点，假设删去它与它父亲之间的边。那么拆成的两个连通分量的权值差为$ABS(\\sum_{i=0}^{n}A_i - DP_i)$，$DP_i$为$i$节点及其儿子节点的权值和。这里缩点后是一个无根树，任意找一个点作为根节点即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, data[MAX], sum;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], ecnt;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], pre[MAX], mark[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[ecnt].v = v;</div><div class=\"line\">    edge[ecnt].nxt = head[u];</div><div class=\"line\">    head[u] = ecnt++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = sum = ecnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        add_edge(u, v);</div><div class=\"line\">        add_edge(v, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//无向图边双连通和有向图的强连通神似</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fa)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"comment\">//这里不直接用v != fa来做判断，是为了避免重边的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i == (fa ^ <span class=\"number\">1</span>)) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v, i);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pre[u] == low[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top(); S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">            dp[scc_cnt] += data[x];</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) G[mark[u]].push_back(mark[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//树型DP求权值和</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (v == fat) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs(v, u);</div><div class=\"line\">        dp[u] += dp[v];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i, <span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scc_cnt == <span class=\"number\">1</span>) &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">\"impossible\"</span>); <span class=\"keyword\">return</span>; &#125;</div><div class=\"line\">    rebuild();</div><div class=\"line\">    dfs(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1e9</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        ans = min(ans, <span class=\"built_in\">abs</span>(sum - dp[i] * <span class=\"number\">2</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; n) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2242\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2242</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个连通的无向图，要求删除一条边使得无向图变为两个连通分量，每个点有一个权值$A_i$，使得两连通分量的权值差最小。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>拿来练手的题，看了一堆树和博客，这题主要是要处理重边比较麻烦，对于无向图的边双连通，其实和有向图的强连通的处理方式差不多。单纯的将边双连通分量标记好就可以了，每个点只属于一个边双连通分量。</p>\n<p>另外比较重要是，对无向图进行双连通缩点后，所剩下的图是一个树形图！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先缩点成树形图，缩后点的权值为包含所有点的和。然后用树型DP求每个节点及其儿子的权值和。</p>\n<p>这时对于树型图，剩下的每一条边都是桥。那么枚举每一个点，假设删去它与它父亲之间的边。那么拆成的两个连通分量的权值差为$ABS(\\sum_{i=0}^{n}A_i - DP_i)$，$DP_i$为$i$节点及其儿子节点的权值和。这里缩点后是一个无根树，任意找一个点作为根节点即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, data[MAX], sum;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], ecnt;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> low[MAX], pre[MAX], mark[MAX];</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[ecnt].v = v;</div><div class=\"line\">    edge[ecnt].nxt = head[u];</div><div class=\"line\">    head[u] = ecnt++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    dfs_clock = scc_cnt = sum = ecnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        add_edge(u, v);</div><div class=\"line\">        add_edge(v, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//无向图边双连通和有向图的强连通神似</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fa)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"comment\">//这里不直接用v != fa来做判断，是为了避免重边的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i == (fa ^ <span class=\"number\">1</span>)) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v, i);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pre[u] == low[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top(); S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">            dp[scc_cnt] += data[x];</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) G[mark[u]].push_back(mark[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//树型DP求权值和</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (v == fat) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        dfs(v, u);</div><div class=\"line\">        dp[u] += dp[v];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i, <span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scc_cnt == <span class=\"number\">1</span>) &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">\"impossible\"</span>); <span class=\"keyword\">return</span>; &#125;</div><div class=\"line\">    rebuild();</div><div class=\"line\">    dfs(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1e9</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        ans = min(ans, <span class=\"built_in\">abs</span>(sum - dp[i] * <span class=\"number\">2</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; n) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3085 - Nightmare Ⅱ（双向BFS）","date":"2017-05-31T12:50:32.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3085\n\n----------------------\n# 题目大意：\n 在一个N*M的网格里，有两个人 G 和 M，并且有两只鬼。\n G每秒可以走一步，G每秒可以走三步，每只鬼可以分裂，分裂到周围的的两格。假设#为鬼分裂后为1，如下图所示。每只分裂后的新鬼可以继续分裂。\n\n0|0|1|0|0\n-------|\n0|1|1|1|0\n1|1|#|1|1\n0|1|1|1|0\n0|0|1|0|0\n\n\n------------------------------\n# 解题过程：\n 没做个两个人走的步数不同的bfs，这几天又比较咸鱼，于是去搜了题解。\n\nhttp://acm.zzkun.com/archives/823\n\n dalao的博客。\n \n------------------------\n# 题目分析：\n先预处理距离，这里可以了解下哈密顿距离。\n\n然后用两个队列进行bfs，bfs操作可以写成一个函数，队列为传进来的参数，每次bfs的时候只bfs一层。层数在外面计数，传进来当参数。\n\ninline 关键字，可以替换宏定义的函数，和宏定义的函数等价。\n\n`Node v(1, 2)` 可以直接这样创建变量并初始化。\n\n\n\n-----------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int x, y;\n    //构造方法可以带默认值\n    Node(int x = 0, int y = 0):x(x),y(y){}\n};\n\nconst int dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\nconst int MAX = 800+5;\n\nint N, M, dist[MAX][MAX];\nchar data[MAX][MAX];\nqueue<Node> q[2];\nbool vis[MAX][MAX][2];\nNode mm, gg, z1, z2;\n\nvoid init() {\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            //求两个幽灵到每个点的哈密顿距离，取最短的那个\n            int t1 = (abs(i - z1.x) + abs(j - z1.y) + 1) / 2;\n            int t2 = (abs(i - z2.x) + abs(j - z2.y) + 1) / 2;\n            dist[i][j] = min(t1, t2);\n        }\n    }\n}\n\n\n//用作判断是否在边界内，这里用内联函数非常合适\ninline bool in(int x, int y) {\n    return x >= 1 && x <= N && y >= 1 && y <= M && data[x][y] != 'X';\n}\n\n\n//全局的队列，bfs函数只是用来操作一层\nbool bfs(int x, int step) {\n    int sz = q[x].size();\n    while (sz--) {\n        Node u = q[x].front(); q[x].pop();\n        if (step >= dist[u.x][u.y])\n            continue;\n        for (int i = 0; i < 4; i++) {\n            //可以直接这样调用构造方法\n            Node v(u.x + dir[i][0], u.y + dir[i][1]);\n            if (in(v.x, v.y) && !vis[v.x][v.y][x] && step < dist[v.x][v.y]) {\n                if (vis[v.x][v.y][!x])\n                    return true;\n                vis[v.x][v.y][x] = true;\n                q[x].push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint solve() {\n    while (!q[0].empty()) q[0].pop();\n    while (!q[1].empty()) q[1].pop();\n    q[0].push(mm), q[1].push(gg);\n    memset(vis, 0, sizeof(vis));\n    vis[mm.x][mm.y][0] = vis[gg.x][gg.y][1] = true;\n    int step = 0;\n    while (!q[0].empty() && !q[1].empty()) {\n        ++step;\n        //对gg bfs三层，mm bfs一层，如果相遇就返回当前的时间\n        if (bfs(0, step) || bfs(0, step) || bfs(0, step) || bfs(1, step))\n            return step;\n    }\n    return -1;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &N, &M);\n        mm = gg = z1 = z2 = Node(0, 0);\n        for (int i = 1; i <= N; i++) {\n            scanf(\"%s\", data[i]+1);\n            for (int j = 1; j <= M; j++) {\n                if (data[i][j] == 'G')\n                    gg = Node(i, j);\n                if (data[i][j] == 'M')\n                    mm = Node(i, j);\n                if (data[i][j] == 'Z') {\n                    if (!z1.x)\n                        z1 = Node(i, j);\n                    else\n                        z2 = Node(i, j);\n                }\n            }\n        }\n        init();\n        printf(\"%d\\n\", solve());\n    }\n}\n```","source":"_posts/HDU3085-Nightmare-Ⅱ（双向BFS）.md","raw":"---\ntitle: HDU3085 - Nightmare Ⅱ（双向BFS）\ndate: 2017-05-31 20:50:32\ncategories: [ACM, 搜索, BFS]\ntags: \n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3085\n\n----------------------\n# 题目大意：\n 在一个N*M的网格里，有两个人 G 和 M，并且有两只鬼。\n G每秒可以走一步，G每秒可以走三步，每只鬼可以分裂，分裂到周围的的两格。假设#为鬼分裂后为1，如下图所示。每只分裂后的新鬼可以继续分裂。\n\n0|0|1|0|0\n-------|\n0|1|1|1|0\n1|1|#|1|1\n0|1|1|1|0\n0|0|1|0|0\n\n\n------------------------------\n# 解题过程：\n 没做个两个人走的步数不同的bfs，这几天又比较咸鱼，于是去搜了题解。\n\nhttp://acm.zzkun.com/archives/823\n\n dalao的博客。\n \n------------------------\n# 题目分析：\n先预处理距离，这里可以了解下哈密顿距离。\n\n然后用两个队列进行bfs，bfs操作可以写成一个函数，队列为传进来的参数，每次bfs的时候只bfs一层。层数在外面计数，传进来当参数。\n\ninline 关键字，可以替换宏定义的函数，和宏定义的函数等价。\n\n`Node v(1, 2)` 可以直接这样创建变量并初始化。\n\n\n\n-----------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int x, y;\n    //构造方法可以带默认值\n    Node(int x = 0, int y = 0):x(x),y(y){}\n};\n\nconst int dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\nconst int MAX = 800+5;\n\nint N, M, dist[MAX][MAX];\nchar data[MAX][MAX];\nqueue<Node> q[2];\nbool vis[MAX][MAX][2];\nNode mm, gg, z1, z2;\n\nvoid init() {\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            //求两个幽灵到每个点的哈密顿距离，取最短的那个\n            int t1 = (abs(i - z1.x) + abs(j - z1.y) + 1) / 2;\n            int t2 = (abs(i - z2.x) + abs(j - z2.y) + 1) / 2;\n            dist[i][j] = min(t1, t2);\n        }\n    }\n}\n\n\n//用作判断是否在边界内，这里用内联函数非常合适\ninline bool in(int x, int y) {\n    return x >= 1 && x <= N && y >= 1 && y <= M && data[x][y] != 'X';\n}\n\n\n//全局的队列，bfs函数只是用来操作一层\nbool bfs(int x, int step) {\n    int sz = q[x].size();\n    while (sz--) {\n        Node u = q[x].front(); q[x].pop();\n        if (step >= dist[u.x][u.y])\n            continue;\n        for (int i = 0; i < 4; i++) {\n            //可以直接这样调用构造方法\n            Node v(u.x + dir[i][0], u.y + dir[i][1]);\n            if (in(v.x, v.y) && !vis[v.x][v.y][x] && step < dist[v.x][v.y]) {\n                if (vis[v.x][v.y][!x])\n                    return true;\n                vis[v.x][v.y][x] = true;\n                q[x].push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint solve() {\n    while (!q[0].empty()) q[0].pop();\n    while (!q[1].empty()) q[1].pop();\n    q[0].push(mm), q[1].push(gg);\n    memset(vis, 0, sizeof(vis));\n    vis[mm.x][mm.y][0] = vis[gg.x][gg.y][1] = true;\n    int step = 0;\n    while (!q[0].empty() && !q[1].empty()) {\n        ++step;\n        //对gg bfs三层，mm bfs一层，如果相遇就返回当前的时间\n        if (bfs(0, step) || bfs(0, step) || bfs(0, step) || bfs(1, step))\n            return step;\n    }\n    return -1;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &N, &M);\n        mm = gg = z1 = z2 = Node(0, 0);\n        for (int i = 1; i <= N; i++) {\n            scanf(\"%s\", data[i]+1);\n            for (int j = 1; j <= M; j++) {\n                if (data[i][j] == 'G')\n                    gg = Node(i, j);\n                if (data[i][j] == 'M')\n                    mm = Node(i, j);\n                if (data[i][j] == 'Z') {\n                    if (!z1.x)\n                        z1 = Node(i, j);\n                    else\n                        z2 = Node(i, j);\n                }\n            }\n        }\n        init();\n        printf(\"%d\\n\", solve());\n    }\n}\n```","slug":"HDU3085-Nightmare-Ⅱ（双向BFS）","published":1,"updated":"2017-07-23T02:24:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nar001my9id8jfg1kz7","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3085\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3085</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 在一个N*M的网格里，有两个人 G 和 M，并且有两只鬼。<br> G每秒可以走一步，G每秒可以走三步，每只鬼可以分裂，分裂到周围的的两格。假设#为鬼分裂后为1，如下图所示。每只分裂后的新鬼可以继续分裂。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>#</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 没做个两个人走的步数不同的bfs，这几天又比较咸鱼，于是去搜了题解。</p>\n<p><a href=\"http://acm.zzkun.com/archives/823\" target=\"_blank\" rel=\"external\">http://acm.zzkun.com/archives/823</a></p>\n<p> dalao的博客。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先预处理距离，这里可以了解下哈密顿距离。</p>\n<p>然后用两个队列进行bfs，bfs操作可以写成一个函数，队列为传进来的参数，每次bfs的时候只bfs一层。层数在外面计数，传进来当参数。</p>\n<p>inline 关键字，可以替换宏定义的函数，和宏定义的函数等价。</p>\n<p><code>Node v(1, 2)</code> 可以直接这样创建变量并初始化。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"comment\">//构造方法可以带默认值</span></div><div class=\"line\">    Node(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>):x(x),y(y)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dir[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">800</span>+<span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, M, dist[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">char</span> data[MAX][MAX];</div><div class=\"line\"><span class=\"built_in\">queue</span>&lt;Node&gt; q[<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX][MAX][<span class=\"number\">2</span>];</div><div class=\"line\">Node mm, gg, z1, z2;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//求两个幽灵到每个点的哈密顿距离，取最短的那个</span></div><div class=\"line\">            <span class=\"keyword\">int</span> t1 = (<span class=\"built_in\">abs</span>(i - z1.x) + <span class=\"built_in\">abs</span>(j - z1.y) + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t2 = (<span class=\"built_in\">abs</span>(i - z2.x) + <span class=\"built_in\">abs</span>(j - z2.y) + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</div><div class=\"line\">            dist[i][j] = min(t1, t2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用作判断是否在边界内，这里用内联函数非常合适</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">in</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &gt;= <span class=\"number\">1</span> &amp;&amp; y &lt;= M &amp;&amp; data[x][y] != <span class=\"string\">'X'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//全局的队列，bfs函数只是用来操作一层</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> step)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sz = q[x].size();</div><div class=\"line\">    <span class=\"keyword\">while</span> (sz--) &#123;</div><div class=\"line\">        Node u = q[x].front(); q[x].pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (step &gt;= dist[u.x][u.y])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            <span class=\"comment\">//可以直接这样调用构造方法</span></div><div class=\"line\">            <span class=\"function\">Node <span class=\"title\">v</span><span class=\"params\">(u.x + dir[i][<span class=\"number\">0</span>], u.y + dir[i][<span class=\"number\">1</span>])</span></span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (in(v.x, v.y) &amp;&amp; !vis[v.x][v.y][x] &amp;&amp; step &lt; dist[v.x][v.y]) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (vis[v.x][v.y][!x])</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                vis[v.x][v.y][x] = <span class=\"literal\">true</span>;</div><div class=\"line\">                q[x].push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].empty()) q[<span class=\"number\">0</span>].pop();</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].empty()) q[<span class=\"number\">1</span>].pop();</div><div class=\"line\">    q[<span class=\"number\">0</span>].push(mm), q[<span class=\"number\">1</span>].push(gg);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[mm.x][mm.y][<span class=\"number\">0</span>] = vis[gg.x][gg.y][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> step = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].empty() &amp;&amp; !q[<span class=\"number\">1</span>].empty()) &#123;</div><div class=\"line\">        ++step;</div><div class=\"line\">        <span class=\"comment\">//对gg bfs三层，mm bfs一层，如果相遇就返回当前的时间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">1</span>, step))</div><div class=\"line\">            <span class=\"keyword\">return</span> step;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">        mm = gg = z1 = z2 = Node(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data[i]+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'G'</span>)</div><div class=\"line\">                    gg = Node(i, j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'M'</span>)</div><div class=\"line\">                    mm = Node(i, j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'Z'</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!z1.x)</div><div class=\"line\">                        z1 = Node(i, j);</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        z2 = Node(i, j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, solve());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3085\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3085</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 在一个N*M的网格里，有两个人 G 和 M，并且有两只鬼。<br> G每秒可以走一步，G每秒可以走三步，每只鬼可以分裂，分裂到周围的的两格。假设#为鬼分裂后为1，如下图所示。每只分裂后的新鬼可以继续分裂。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>#</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 没做个两个人走的步数不同的bfs，这几天又比较咸鱼，于是去搜了题解。</p>\n<p><a href=\"http://acm.zzkun.com/archives/823\" target=\"_blank\" rel=\"external\">http://acm.zzkun.com/archives/823</a></p>\n<p> dalao的博客。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先预处理距离，这里可以了解下哈密顿距离。</p>\n<p>然后用两个队列进行bfs，bfs操作可以写成一个函数，队列为传进来的参数，每次bfs的时候只bfs一层。层数在外面计数，传进来当参数。</p>\n<p>inline 关键字，可以替换宏定义的函数，和宏定义的函数等价。</p>\n<p><code>Node v(1, 2)</code> 可以直接这样创建变量并初始化。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"comment\">//构造方法可以带默认值</span></div><div class=\"line\">    Node(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>):x(x),y(y)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dir[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">800</span>+<span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, M, dist[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">char</span> data[MAX][MAX];</div><div class=\"line\"><span class=\"built_in\">queue</span>&lt;Node&gt; q[<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[MAX][MAX][<span class=\"number\">2</span>];</div><div class=\"line\">Node mm, gg, z1, z2;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//求两个幽灵到每个点的哈密顿距离，取最短的那个</span></div><div class=\"line\">            <span class=\"keyword\">int</span> t1 = (<span class=\"built_in\">abs</span>(i - z1.x) + <span class=\"built_in\">abs</span>(j - z1.y) + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t2 = (<span class=\"built_in\">abs</span>(i - z2.x) + <span class=\"built_in\">abs</span>(j - z2.y) + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</div><div class=\"line\">            dist[i][j] = min(t1, t2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用作判断是否在边界内，这里用内联函数非常合适</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">in</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &gt;= <span class=\"number\">1</span> &amp;&amp; y &lt;= M &amp;&amp; data[x][y] != <span class=\"string\">'X'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//全局的队列，bfs函数只是用来操作一层</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> step)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sz = q[x].size();</div><div class=\"line\">    <span class=\"keyword\">while</span> (sz--) &#123;</div><div class=\"line\">        Node u = q[x].front(); q[x].pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (step &gt;= dist[u.x][u.y])</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            <span class=\"comment\">//可以直接这样调用构造方法</span></div><div class=\"line\">            <span class=\"function\">Node <span class=\"title\">v</span><span class=\"params\">(u.x + dir[i][<span class=\"number\">0</span>], u.y + dir[i][<span class=\"number\">1</span>])</span></span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (in(v.x, v.y) &amp;&amp; !vis[v.x][v.y][x] &amp;&amp; step &lt; dist[v.x][v.y]) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (vis[v.x][v.y][!x])</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                vis[v.x][v.y][x] = <span class=\"literal\">true</span>;</div><div class=\"line\">                q[x].push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].empty()) q[<span class=\"number\">0</span>].pop();</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].empty()) q[<span class=\"number\">1</span>].pop();</div><div class=\"line\">    q[<span class=\"number\">0</span>].push(mm), q[<span class=\"number\">1</span>].push(gg);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[mm.x][mm.y][<span class=\"number\">0</span>] = vis[gg.x][gg.y][<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> step = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].empty() &amp;&amp; !q[<span class=\"number\">1</span>].empty()) &#123;</div><div class=\"line\">        ++step;</div><div class=\"line\">        <span class=\"comment\">//对gg bfs三层，mm bfs一层，如果相遇就返回当前的时间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">0</span>, step) || bfs(<span class=\"number\">1</span>, step))</div><div class=\"line\">            <span class=\"keyword\">return</span> step;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">        mm = gg = z1 = z2 = Node(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data[i]+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'G'</span>)</div><div class=\"line\">                    gg = Node(i, j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'M'</span>)</div><div class=\"line\">                    mm = Node(i, j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] == <span class=\"string\">'Z'</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!z1.x)</div><div class=\"line\">                        z1 = Node(i, j);</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        z2 = Node(i, j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, solve());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3639 - Hawk-and-Chicken（强连通+缩点）","date":"2017-08-03T00:49:59.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3639\n\n--------------------\n# 题目大意：\n给出一个有向图，记每个点的值为他的子节点的个数，求出最大的值为多少，有那些顶点值最大。\n\n-------------------\n# 解题过程：\n题意刚开始理解错了...以为一个点可以贡献多次。\n\n--------------------\n# 题目分析：\n这题写出来主要是提醒自己一下，在DAG上不能直接用一个点维护他所有子节点权值和那样的东西，因为DAG上一个点可以有多个父亲，不像树形图那样。\n\n另外这个题，只需要统计入度为0的点就可以了，刚开始要方向建图，这样dfs的时候才符合他的子节点贡献给父亲节点。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nint T, n, m, Case;\n\nvector<int> G1[MAX], G2[MAX];\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint self_supports[MAX], dp[MAX], in[MAX];\nbool winner[MAX];\n\nvoid tarjan(int u) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid get_G() {\n    for (int i = 1; i <= n; i++) {\n        self_supports[mark[i]]++;\n    }\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v]);\n                in[mark[v]]++;\n            }\n        }\n    }\n}\n\nvoid init() {\n    scanf(\"%d %d\", &n, &m);\n    dfs_clock = scc_cnt = 0;\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(winner, 0, sizeof(winner));\n    memset(dp, -1, sizeof(dp));\n    memset(in, 0, sizeof(in));\n    memset(self_supports, 0, sizeof(self_supports));\n    for (int i = 0; i <= n; i++) {\n        G1[i].clear();\n        G2[i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u++, v++;\n        G1[v].push_back(u);\n    }\n}\n\nint dfs(int u) {\n    int ans = self_supports[u] - 1;\n    pre[u] = 1;\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!pre[v]) {\n            ans += dfs(v) + 1;\n        }\n    }\n    return ans;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n    get_G();\n    int ans = 0;\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (in[i] != 0) continue;\n        memset(pre, 0, sizeof(pre));\n        dp[i] = dfs(i);\n        ans = max(dp[i], ans);\n    }\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (dp[i] == ans) winner[i] = true;\n    }\n    bool fir = true;\n    printf(\"Case %d: %d\\n\", ++Case, ans);\n    for (int i = 1; i <= n; i++) {\n        if (winner[mark[i]]) {\n            if (!fir) putchar(' ');\n            printf(\"%d\", i - 1);\n            fir = false;\n        }\n    }\n    putchar('\\n');\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/HDU3639-Hawk-and-Chicken（强连通-缩点）.md","raw":"---\ntitle: HDU3639 - Hawk-and-Chicken（强连通+缩点）\ndate: 2017-08-03 08:49:59\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3639\n\n--------------------\n# 题目大意：\n给出一个有向图，记每个点的值为他的子节点的个数，求出最大的值为多少，有那些顶点值最大。\n\n-------------------\n# 解题过程：\n题意刚开始理解错了...以为一个点可以贡献多次。\n\n--------------------\n# 题目分析：\n这题写出来主要是提醒自己一下，在DAG上不能直接用一个点维护他所有子节点权值和那样的东西，因为DAG上一个点可以有多个父亲，不像树形图那样。\n\n另外这个题，只需要统计入度为0的点就可以了，刚开始要方向建图，这样dfs的时候才符合他的子节点贡献给父亲节点。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nint T, n, m, Case;\n\nvector<int> G1[MAX], G2[MAX];\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint self_supports[MAX], dp[MAX], in[MAX];\nbool winner[MAX];\n\nvoid tarjan(int u) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid get_G() {\n    for (int i = 1; i <= n; i++) {\n        self_supports[mark[i]]++;\n    }\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v]);\n                in[mark[v]]++;\n            }\n        }\n    }\n}\n\nvoid init() {\n    scanf(\"%d %d\", &n, &m);\n    dfs_clock = scc_cnt = 0;\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(winner, 0, sizeof(winner));\n    memset(dp, -1, sizeof(dp));\n    memset(in, 0, sizeof(in));\n    memset(self_supports, 0, sizeof(self_supports));\n    for (int i = 0; i <= n; i++) {\n        G1[i].clear();\n        G2[i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u++, v++;\n        G1[v].push_back(u);\n    }\n}\n\nint dfs(int u) {\n    int ans = self_supports[u] - 1;\n    pre[u] = 1;\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!pre[v]) {\n            ans += dfs(v) + 1;\n        }\n    }\n    return ans;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n    get_G();\n    int ans = 0;\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (in[i] != 0) continue;\n        memset(pre, 0, sizeof(pre));\n        dp[i] = dfs(i);\n        ans = max(dp[i], ans);\n    }\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (dp[i] == ans) winner[i] = true;\n    }\n    bool fir = true;\n    printf(\"Case %d: %d\\n\", ++Case, ans);\n    for (int i = 1; i <= n; i++) {\n        if (winner[mark[i]]) {\n            if (!fir) putchar(' ');\n            printf(\"%d\", i - 1);\n            fir = false;\n        }\n    }\n    putchar('\\n');\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```","slug":"HDU3639-Hawk-and-Chicken（强连通-缩点）","published":1,"updated":"2017-08-03T01:05:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nau001py9ids49ilbj0","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3639\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3639</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，记每个点的值为他的子节点的个数，求出最大的值为多少，有那些顶点值最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>题意刚开始理解错了…以为一个点可以贡献多次。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这题写出来主要是提醒自己一下，在DAG上不能直接用一个点维护他所有子节点权值和那样的东西，因为DAG上一个点可以有多个父亲，不像树形图那样。</p>\n<p>另外这个题，只需要统计入度为0的点就可以了，刚开始要方向建图，这样dfs的时候才符合他的子节点贡献给父亲节点。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> T, n, m, Case;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> self_supports[MAX], dp[MAX], in[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> winner[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_G</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        self_supports[mark[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">                in[mark[v]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    dfs_clock = scc_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(winner, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(winner));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(self_supports, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(self_supports));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G1[i].clear();</div><div class=\"line\">        G2[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        u++, v++;</div><div class=\"line\">        G1[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = self_supports[u] - <span class=\"number\">1</span>;</div><div class=\"line\">    pre[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            ans += dfs(v) + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    get_G();</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">        dp[i] = dfs(i);</div><div class=\"line\">        ans = max(dp[i], ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dp[i] == ans) winner[i] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">bool</span> fir = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, ++Case, ans);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (winner[mark[i]]) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!fir) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, i - <span class=\"number\">1</span>);</div><div class=\"line\">            fir = <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3639\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3639</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，记每个点的值为他的子节点的个数，求出最大的值为多少，有那些顶点值最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>题意刚开始理解错了…以为一个点可以贡献多次。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这题写出来主要是提醒自己一下，在DAG上不能直接用一个点维护他所有子节点权值和那样的东西，因为DAG上一个点可以有多个父亲，不像树形图那样。</p>\n<p>另外这个题，只需要统计入度为0的点就可以了，刚开始要方向建图，这样dfs的时候才符合他的子节点贡献给父亲节点。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> T, n, m, Case;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> self_supports[MAX], dp[MAX], in[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> winner[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_G</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        self_supports[mark[i]]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">                in[mark[v]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    dfs_clock = scc_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(winner, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(winner));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(self_supports, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(self_supports));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        G1[i].clear();</div><div class=\"line\">        G2[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        u++, v++;</div><div class=\"line\">        G1[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = self_supports[u] - <span class=\"number\">1</span>;</div><div class=\"line\">    pre[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            ans += dfs(v) + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    get_G();</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">        dp[i] = dfs(i);</div><div class=\"line\">        ans = max(dp[i], ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dp[i] == ans) winner[i] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">bool</span> fir = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, ++Case, ans);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (winner[mark[i]]) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!fir) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, i - <span class=\"number\">1</span>);</div><div class=\"line\">            fir = <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3487 - Play with Chain(Splay + 模板详解)","date":"2017-10-09T13:36:56.000Z","_content":"# 题目链接：\n\n[https://vjudge.net/problem/HDU-3487](https://vjudge.net/problem/HDU-3487)\n\n\n\n# 题目大意：\n\n给出一个 1 ~ n 的序列，有 m 次操作，分为以下两种：\n\n+ CUT a, b, c 将区间 a ~ b 剪下来，放到剩下的序列中第 c 个元素后面。\n+ FLIP a, b 将区间 a ~ b 翻转。\n\n输出执行完全部操作后的序列。\n\n$1 \\le n, m \\le 3 \\times 100000$\n\n# 解题过程：\n\n模板题，对着板子敲的，理解了下 Splay 的细节。\n\n\n\n# 题目分析：\n\n区间翻转和区间删除插入都是 Splay 树的经典操作，然后会 Splay 后这就是一个模板题。\n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n//用来处理区间询问，每个节点维护的是一个子树的信息\n//Splay可以将一段连续区间内的节点放到一颗子树内，所以这样可以维护一段区间的信息\nstruct Info {\n    int size;\n    int ma;\n\n    Info() {};\n\n    Info(int x) {\n        size = 1;\n        ma = x;\n    }\n\n    void addIt(int x) {\n        ma += x;\n    }\n};\n\n//区间（子树）信息的合并\nInfo operator+(const Info &l, const Info &r) {\n    Info ret;\n    ret.size = l.size + r.size;\n    ret.ma = max(l.ma, r.ma);\n    return ret;\n}\n\nconst int maxn = 3 * 100000 + 10;\n\nint root;\n\n//Splay的节点\nstruct Node {\n    //son[0]是左儿子，son[1]是右儿子\n    int son[2], fa;\n    int val, lazy;\n    bool flp;\n    Info info;\n\n    int &l() { return son[0]; }\n\n    int &r() { return son[1]; }\n\n    Node(int v = 0) {\n        l() = r() = fa = -1;\n        val = v;\n        info = Info(v);\n        lazy = 0;\n        flp = false;\n    }\n\n    //修改Splay上的节点后，也需要对 info 的信息进行维护\n    void addIt(int v) {\n        val += v;\n        lazy += v;\n        info.addIt(v);\n    }\n\n    void maintain();\n\n    void push_down();\n} node[maxn];\n\n\n//进行 pushdown 操作，类似线段树\nvoid Node::push_down() {\n    if (lazy != 0) {\n        if (l() != -1) node[l()].addIt(lazy);\n        if (r() != -1) node[r()].addIt(lazy);\n        lazy = 0;\n    }\n    if (flp) {\n        swap(l(), r());\n        if (l() != -1) node[l()].flp ^= 1;\n        if (r() != -1) node[r()].flp ^= 1;\n        flp = false;\n    }\n}\n\n//Splay 进行旋转操作时，子树发生了改变，需要重新维护区间（子树）信息\nvoid Node::maintain() {\n    info = Info(val);\n    if (l() != -1) info = node[l()].info + info;\n    if (r() != -1) info = info + node[r()].info;\n}\n\n\n//查询当前节点是父亲的左儿子还是右儿子，左儿子返回0，右儿子返回1，如果无父亲返回-1\nint ori(int st) {\n    int fa = node[st].fa;\n    if (fa == -1) return -1;\n    return st == node[fa].r();\n}\n\n\n//把 sn 变成 st 的儿子节点，如果 d 是 0 是左儿子，否则是右儿子\n//这里子树发生了改变，需要重新维护 info 信息\nvoid setc(int st, int sn, int d) {\n    if (st != -1) {\n        node[st].son[d] = sn;\n        node[st].maintain();\n    }\n    if (sn != -1) node[sn].fa = st;\n}\n\n//进行旋转操作，这里需要自己画图理解一下\nvoid zg(int x) {\n    int st = node[x].fa, p = -1;\n    node[st].push_down();\n    node[x].push_down();\n\n    int d = ori(x), dst = ori(st);\n    if (st != -1) p = node[st].fa;\n    setc(st, node[x].son[d ^ 1], d);\n    setc(x, st, d ^ 1);\n    setc(p, x, dst);\n}\n\n#define f(x) (node[x].fa)\n\n//将 x 旋转成 fa 的儿子，如果将 x 旋转成 根节点的话则不填 fa\nvoid splay(int x, int fa = -1) {\n    //循环直到 x 是 fa 的儿子\n    while (f(x) != fa) {\n        //如果 fa 是 x 的爷爷，那么只需要一次旋转\n        if (f(f(x)) == fa) zg(x);\n        else {\n            //双旋！\n\n            //说明进行 zig zig 或者 zag zag 旋转\n            if (ori(x) == ori(f(x))) zg(f(x));\n            else zg(x);\n            zg(x);\n        }\n    }\n    //更新根节点\n    if (fa == -1) root = x;\n}\n\nint value[maxn];\nint pos;\n\n//要保证 value 有序，类似线段树建树，这样树高是 log(n) 的\nint build(int l, int r) {\n    int st = pos++;\n    int m = (l + r) >> 1;\n    node[st] = Node(value[m]);\n    if (l < m) setc(st, build(l, m - 1), 0);\n    if (m < r) setc(st, build(m + 1, r), 1);\n    return st;\n}\n\nint build(int n) {\n    pos = 0;\n    //添加 0 和 n + 1 两个虚拟节点，方便 cut 操作\n    return build(0, n + 1);\n}\n\n//获得以 st 为根节点，中序遍历的第 v 个节点\nint getid(int v, int st) {\n    //在树上进行二分\n    node[st].push_down();\n    int l = node[st].l();\n    int lsize = 1 + (l == -1 ? 0 : node[l].info.size);\n    if (v == lsize) return st;\n    int d = v > lsize;\n    if (d) v -= lsize;\n    return getid(v, node[st].son[d]);\n}\n\nint getseg(int l, int r) {\n    l--, r++;\n    l = getid(l + 1, root), r = getid(r + 1, root);\n    //现在 r+1 是 l-1 的父亲，那么 l-r 这一段子树肯定是 l-1 的右儿子\n    splay(r);\n    splay(l, r);\n    return node[l].r();\n}\n\nvoid flip(int l, int r) {\n    int pos = getseg(l, r);\n    node[pos].flp ^= 1;\n}\n\nvoid cut(int l, int r, int idx) {\n    //切下来 l - r 这段区间\n    int rootson1 = getseg(l, r);\n    int father = node[rootson1].fa;\n    setc(father, -1, 1);\n    l = idx, r = idx + 1;\n    //因为这里是虚拟节点，所以要多加一个 1\n    l = getid(l + 1, root);\n    r = getid(r + 1, root);\n    //将 idx+1 成为 idx 的父亲，那么上面切下来的区间放到idx的右边即可\n    splay(r);\n    splay(l, r);\n    setc(l, rootson1, 1);\n}\n\nint n, m;\nint ans[maxn], cnt;\n\n//中序遍历\nvoid dfs(int now) {\n    node[now].push_down();\n    if (node[now].son[0] != -1) dfs(node[now].son[0]);\n    ans[cnt++] = node[now].val;\n    if (node[now].son[1] != -1) dfs(node[now].son[1]);\n}\n\nint main() {\n    char op[10];\n    int L, R, idx;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        if (n == -1 && m == -1) break;\n        for (int i = 1; i <= n; i++) value[i] = i;\n        root = build(n);\n        while (m--) {\n            scanf(\"%s %d %d\", op, &L, &R);\n            if (op[0] == 'F') flip(L, R);\n            else {\n                scanf(\"%d\", &idx);\n                cut(L, R, idx);\n            }\n        }\n        cnt = 0;\n        memset(ans, 0, sizeof(ans));\n        dfs(root);\n        for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n    }\n}\n```","source":"_posts/HDU3487-Play-with-Chain-Splay-模板详解.md","raw":"---\ntitle: HDU3487 - Play with Chain(Splay + 模板详解)\ndate: 2017-10-09 21:36:56\ncategories: [ACM, 数据结构, Splay]\ntags:\n---\n# 题目链接：\n\n[https://vjudge.net/problem/HDU-3487](https://vjudge.net/problem/HDU-3487)\n\n\n\n# 题目大意：\n\n给出一个 1 ~ n 的序列，有 m 次操作，分为以下两种：\n\n+ CUT a, b, c 将区间 a ~ b 剪下来，放到剩下的序列中第 c 个元素后面。\n+ FLIP a, b 将区间 a ~ b 翻转。\n\n输出执行完全部操作后的序列。\n\n$1 \\le n, m \\le 3 \\times 100000$\n\n# 解题过程：\n\n模板题，对着板子敲的，理解了下 Splay 的细节。\n\n\n\n# 题目分析：\n\n区间翻转和区间删除插入都是 Splay 树的经典操作，然后会 Splay 后这就是一个模板题。\n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n//用来处理区间询问，每个节点维护的是一个子树的信息\n//Splay可以将一段连续区间内的节点放到一颗子树内，所以这样可以维护一段区间的信息\nstruct Info {\n    int size;\n    int ma;\n\n    Info() {};\n\n    Info(int x) {\n        size = 1;\n        ma = x;\n    }\n\n    void addIt(int x) {\n        ma += x;\n    }\n};\n\n//区间（子树）信息的合并\nInfo operator+(const Info &l, const Info &r) {\n    Info ret;\n    ret.size = l.size + r.size;\n    ret.ma = max(l.ma, r.ma);\n    return ret;\n}\n\nconst int maxn = 3 * 100000 + 10;\n\nint root;\n\n//Splay的节点\nstruct Node {\n    //son[0]是左儿子，son[1]是右儿子\n    int son[2], fa;\n    int val, lazy;\n    bool flp;\n    Info info;\n\n    int &l() { return son[0]; }\n\n    int &r() { return son[1]; }\n\n    Node(int v = 0) {\n        l() = r() = fa = -1;\n        val = v;\n        info = Info(v);\n        lazy = 0;\n        flp = false;\n    }\n\n    //修改Splay上的节点后，也需要对 info 的信息进行维护\n    void addIt(int v) {\n        val += v;\n        lazy += v;\n        info.addIt(v);\n    }\n\n    void maintain();\n\n    void push_down();\n} node[maxn];\n\n\n//进行 pushdown 操作，类似线段树\nvoid Node::push_down() {\n    if (lazy != 0) {\n        if (l() != -1) node[l()].addIt(lazy);\n        if (r() != -1) node[r()].addIt(lazy);\n        lazy = 0;\n    }\n    if (flp) {\n        swap(l(), r());\n        if (l() != -1) node[l()].flp ^= 1;\n        if (r() != -1) node[r()].flp ^= 1;\n        flp = false;\n    }\n}\n\n//Splay 进行旋转操作时，子树发生了改变，需要重新维护区间（子树）信息\nvoid Node::maintain() {\n    info = Info(val);\n    if (l() != -1) info = node[l()].info + info;\n    if (r() != -1) info = info + node[r()].info;\n}\n\n\n//查询当前节点是父亲的左儿子还是右儿子，左儿子返回0，右儿子返回1，如果无父亲返回-1\nint ori(int st) {\n    int fa = node[st].fa;\n    if (fa == -1) return -1;\n    return st == node[fa].r();\n}\n\n\n//把 sn 变成 st 的儿子节点，如果 d 是 0 是左儿子，否则是右儿子\n//这里子树发生了改变，需要重新维护 info 信息\nvoid setc(int st, int sn, int d) {\n    if (st != -1) {\n        node[st].son[d] = sn;\n        node[st].maintain();\n    }\n    if (sn != -1) node[sn].fa = st;\n}\n\n//进行旋转操作，这里需要自己画图理解一下\nvoid zg(int x) {\n    int st = node[x].fa, p = -1;\n    node[st].push_down();\n    node[x].push_down();\n\n    int d = ori(x), dst = ori(st);\n    if (st != -1) p = node[st].fa;\n    setc(st, node[x].son[d ^ 1], d);\n    setc(x, st, d ^ 1);\n    setc(p, x, dst);\n}\n\n#define f(x) (node[x].fa)\n\n//将 x 旋转成 fa 的儿子，如果将 x 旋转成 根节点的话则不填 fa\nvoid splay(int x, int fa = -1) {\n    //循环直到 x 是 fa 的儿子\n    while (f(x) != fa) {\n        //如果 fa 是 x 的爷爷，那么只需要一次旋转\n        if (f(f(x)) == fa) zg(x);\n        else {\n            //双旋！\n\n            //说明进行 zig zig 或者 zag zag 旋转\n            if (ori(x) == ori(f(x))) zg(f(x));\n            else zg(x);\n            zg(x);\n        }\n    }\n    //更新根节点\n    if (fa == -1) root = x;\n}\n\nint value[maxn];\nint pos;\n\n//要保证 value 有序，类似线段树建树，这样树高是 log(n) 的\nint build(int l, int r) {\n    int st = pos++;\n    int m = (l + r) >> 1;\n    node[st] = Node(value[m]);\n    if (l < m) setc(st, build(l, m - 1), 0);\n    if (m < r) setc(st, build(m + 1, r), 1);\n    return st;\n}\n\nint build(int n) {\n    pos = 0;\n    //添加 0 和 n + 1 两个虚拟节点，方便 cut 操作\n    return build(0, n + 1);\n}\n\n//获得以 st 为根节点，中序遍历的第 v 个节点\nint getid(int v, int st) {\n    //在树上进行二分\n    node[st].push_down();\n    int l = node[st].l();\n    int lsize = 1 + (l == -1 ? 0 : node[l].info.size);\n    if (v == lsize) return st;\n    int d = v > lsize;\n    if (d) v -= lsize;\n    return getid(v, node[st].son[d]);\n}\n\nint getseg(int l, int r) {\n    l--, r++;\n    l = getid(l + 1, root), r = getid(r + 1, root);\n    //现在 r+1 是 l-1 的父亲，那么 l-r 这一段子树肯定是 l-1 的右儿子\n    splay(r);\n    splay(l, r);\n    return node[l].r();\n}\n\nvoid flip(int l, int r) {\n    int pos = getseg(l, r);\n    node[pos].flp ^= 1;\n}\n\nvoid cut(int l, int r, int idx) {\n    //切下来 l - r 这段区间\n    int rootson1 = getseg(l, r);\n    int father = node[rootson1].fa;\n    setc(father, -1, 1);\n    l = idx, r = idx + 1;\n    //因为这里是虚拟节点，所以要多加一个 1\n    l = getid(l + 1, root);\n    r = getid(r + 1, root);\n    //将 idx+1 成为 idx 的父亲，那么上面切下来的区间放到idx的右边即可\n    splay(r);\n    splay(l, r);\n    setc(l, rootson1, 1);\n}\n\nint n, m;\nint ans[maxn], cnt;\n\n//中序遍历\nvoid dfs(int now) {\n    node[now].push_down();\n    if (node[now].son[0] != -1) dfs(node[now].son[0]);\n    ans[cnt++] = node[now].val;\n    if (node[now].son[1] != -1) dfs(node[now].son[1]);\n}\n\nint main() {\n    char op[10];\n    int L, R, idx;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        if (n == -1 && m == -1) break;\n        for (int i = 1; i <= n; i++) value[i] = i;\n        root = build(n);\n        while (m--) {\n            scanf(\"%s %d %d\", op, &L, &R);\n            if (op[0] == 'F') flip(L, R);\n            else {\n                scanf(\"%d\", &idx);\n                cut(L, R, idx);\n            }\n        }\n        cnt = 0;\n        memset(ans, 0, sizeof(ans));\n        dfs(root);\n        for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n    }\n}\n```","slug":"HDU3487-Play-with-Chain-Splay-模板详解","published":1,"updated":"2017-10-10T14:18:27.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nav001ry9idiz430pbd","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HDU-3487\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HDU-3487</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个 1 ~ n 的序列，有 m 次操作，分为以下两种：</p>\n<ul>\n<li>CUT a, b, c 将区间 a ~ b 剪下来，放到剩下的序列中第 c 个元素后面。</li>\n<li>FLIP a, b 将区间 a ~ b 翻转。</li>\n</ul>\n<p>输出执行完全部操作后的序列。</p>\n<p>$1 \\le n, m \\le 3 \\times 100000$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>模板题，对着板子敲的，理解了下 Splay 的细节。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>区间翻转和区间删除插入都是 Splay 树的经典操作，然后会 Splay 后这就是一个模板题。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来处理区间询问，每个节点维护的是一个子树的信息</span></div><div class=\"line\"><span class=\"comment\">//Splay可以将一段连续区间内的节点放到一颗子树内，所以这样可以维护一段区间的信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">int</span> ma;</div><div class=\"line\"></div><div class=\"line\">    Info() &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">    Info(<span class=\"keyword\">int</span> x) &#123;</div><div class=\"line\">        size = <span class=\"number\">1</span>;</div><div class=\"line\">        ma = x;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        ma += x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//区间（子树）信息的合并</span></div><div class=\"line\">Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Info &amp;l, <span class=\"keyword\">const</span> Info &amp;r) &#123;</div><div class=\"line\">    Info ret;</div><div class=\"line\">    ret.size = l.size + r.size;</div><div class=\"line\">    ret.ma = max(l.ma, r.ma);</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">3</span> * <span class=\"number\">100000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Splay的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"comment\">//son[0]是左儿子，son[1]是右儿子</span></div><div class=\"line\">    <span class=\"keyword\">int</span> son[<span class=\"number\">2</span>], fa;</div><div class=\"line\">    <span class=\"keyword\">int</span> val, lazy;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flp;</div><div class=\"line\">    Info info;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">l</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">r</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    Node(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        l() = r() = fa = <span class=\"number\">-1</span>;</div><div class=\"line\">        val = v;</div><div class=\"line\">        info = Info(v);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        flp = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//修改Splay上的节点后，也需要对 info 的信息进行维护</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">        val += v;</div><div class=\"line\">        lazy += v;</div><div class=\"line\">        info.addIt(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125; node[maxn];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行 pushdown 操作，类似线段树</span></div><div class=\"line\"><span class=\"keyword\">void</span> Node::push_down() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lazy != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].addIt(lazy);</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].addIt(lazy);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flp) &#123;</div><div class=\"line\">        swap(l(), r());</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">        flp = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Splay 进行旋转操作时，子树发生了改变，需要重新维护区间（子树）信息</span></div><div class=\"line\"><span class=\"keyword\">void</span> Node::maintain() &#123;</div><div class=\"line\">    info = Info(val);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) info = node[l()].info + info;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) info = info + node[r()].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询当前节点是父亲的左儿子还是右儿子，左儿子返回0，右儿子返回1，如果无父亲返回-1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ori</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = node[st].fa;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> st == node[fa].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//把 sn 变成 st 的儿子节点，如果 d 是 0 是左儿子，否则是右儿子</span></div><div class=\"line\"><span class=\"comment\">//这里子树发生了改变，需要重新维护 info 信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setc</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> sn, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        node[st].son[d] = sn;</div><div class=\"line\">        node[st].maintain();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sn != <span class=\"number\">-1</span>) node[sn].fa = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行旋转操作，这里需要自己画图理解一下</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zg</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = node[x].fa, p = <span class=\"number\">-1</span>;</div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    node[x].push_down();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> d = ori(x), dst = ori(st);</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) p = node[st].fa;</div><div class=\"line\">    setc(st, node[x].son[d ^ <span class=\"number\">1</span>], d);</div><div class=\"line\">    setc(x, st, d ^ <span class=\"number\">1</span>);</div><div class=\"line\">    setc(p, x, dst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f(x) (node[x].fa)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将 x 旋转成 fa 的儿子，如果将 x 旋转成 根节点的话则不填 fa</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> fa = <span class=\"number\">-1</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//循环直到 x 是 fa 的儿子</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (f(x) != fa) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果 fa 是 x 的爷爷，那么只需要一次旋转</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f(f(x)) == fa) zg(x);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//双旋！</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//说明进行 zig zig 或者 zag zag 旋转</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (ori(x) == ori(f(x))) zg(f(x));</div><div class=\"line\">            <span class=\"keyword\">else</span> zg(x);</div><div class=\"line\">            zg(x);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//更新根节点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) root = x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> value[maxn];</div><div class=\"line\"><span class=\"keyword\">int</span> pos;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//要保证 value 有序，类似线段树建树，这样树高是 log(n) 的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = pos++;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    node[st] = Node(value[m]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt; m) setc(st, build(l, m - <span class=\"number\">1</span>), <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m &lt; r) setc(st, build(m + <span class=\"number\">1</span>, r), <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    pos = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加 0 和 n + 1 两个虚拟节点，方便 cut 操作</span></div><div class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得以 st 为根节点，中序遍历的第 v 个节点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getid</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在树上进行二分</span></div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = node[st].l();</div><div class=\"line\">    <span class=\"keyword\">int</span> lsize = <span class=\"number\">1</span> + (l == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : node[l].info.size);</div><div class=\"line\">    <span class=\"keyword\">if</span> (v == lsize) <span class=\"keyword\">return</span> st;</div><div class=\"line\">    <span class=\"keyword\">int</span> d = v &gt; lsize;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d) v -= lsize;</div><div class=\"line\">    <span class=\"keyword\">return</span> getid(v, node[st].son[d]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getseg</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    l--, r++;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root), r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    <span class=\"comment\">//现在 r+1 是 l-1 的父亲，那么 l-r 这一段子树肯定是 l-1 的右儿子</span></div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    <span class=\"keyword\">return</span> node[l].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flip</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cut</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//切下来 l - r 这段区间</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rootson1 = getseg(l, r);</div><div class=\"line\">    <span class=\"keyword\">int</span> father = node[rootson1].fa;</div><div class=\"line\">    setc(father, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    l = idx, r = idx + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">//因为这里是虚拟节点，所以要多加一个 1</span></div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root);</div><div class=\"line\">    r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    <span class=\"comment\">//将 idx+1 成为 idx 的父亲，那么上面切下来的区间放到idx的右边即可</span></div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    setc(l, rootson1, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> ans[maxn], cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//中序遍历</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now)</span> </span>&#123;</div><div class=\"line\">    node[now].push_down();</div><div class=\"line\">    <span class=\"keyword\">if</span> (node[now].son[<span class=\"number\">0</span>] != <span class=\"number\">-1</span>) dfs(node[now].son[<span class=\"number\">0</span>]);</div><div class=\"line\">    ans[cnt++] = node[now].val;</div><div class=\"line\">    <span class=\"keyword\">if</span> (node[now].son[<span class=\"number\">1</span>] != <span class=\"number\">-1</span>) dfs(node[now].son[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> L, R, idx;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">-1</span> &amp;&amp; m == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) value[i] = i;</div><div class=\"line\">        root = build(n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %d %d\"</span>, op, &amp;L, &amp;R);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[<span class=\"number\">0</span>] == <span class=\"string\">'F'</span>) flip(L, R);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;idx);</div><div class=\"line\">                cut(L, R, idx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cnt = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">        dfs(root);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i == n ? <span class=\"string\">'\\n'</span> : <span class=\"string\">' '</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HDU-3487\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HDU-3487</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个 1 ~ n 的序列，有 m 次操作，分为以下两种：</p>\n<ul>\n<li>CUT a, b, c 将区间 a ~ b 剪下来，放到剩下的序列中第 c 个元素后面。</li>\n<li>FLIP a, b 将区间 a ~ b 翻转。</li>\n</ul>\n<p>输出执行完全部操作后的序列。</p>\n<p>$1 \\le n, m \\le 3 \\times 100000$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>模板题，对着板子敲的，理解了下 Splay 的细节。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>区间翻转和区间删除插入都是 Splay 树的经典操作，然后会 Splay 后这就是一个模板题。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来处理区间询问，每个节点维护的是一个子树的信息</span></div><div class=\"line\"><span class=\"comment\">//Splay可以将一段连续区间内的节点放到一颗子树内，所以这样可以维护一段区间的信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">int</span> ma;</div><div class=\"line\"></div><div class=\"line\">    Info() &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">    Info(<span class=\"keyword\">int</span> x) &#123;</div><div class=\"line\">        size = <span class=\"number\">1</span>;</div><div class=\"line\">        ma = x;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        ma += x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//区间（子树）信息的合并</span></div><div class=\"line\">Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Info &amp;l, <span class=\"keyword\">const</span> Info &amp;r) &#123;</div><div class=\"line\">    Info ret;</div><div class=\"line\">    ret.size = l.size + r.size;</div><div class=\"line\">    ret.ma = max(l.ma, r.ma);</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">3</span> * <span class=\"number\">100000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Splay的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"comment\">//son[0]是左儿子，son[1]是右儿子</span></div><div class=\"line\">    <span class=\"keyword\">int</span> son[<span class=\"number\">2</span>], fa;</div><div class=\"line\">    <span class=\"keyword\">int</span> val, lazy;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flp;</div><div class=\"line\">    Info info;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">l</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> &amp;<span class=\"title\">r</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]; &#125;</div><div class=\"line\"></div><div class=\"line\">    Node(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        l() = r() = fa = <span class=\"number\">-1</span>;</div><div class=\"line\">        val = v;</div><div class=\"line\">        info = Info(v);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">        flp = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//修改Splay上的节点后，也需要对 info 的信息进行维护</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addIt</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">        val += v;</div><div class=\"line\">        lazy += v;</div><div class=\"line\">        info.addIt(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125; node[maxn];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行 pushdown 操作，类似线段树</span></div><div class=\"line\"><span class=\"keyword\">void</span> Node::push_down() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lazy != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].addIt(lazy);</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].addIt(lazy);</div><div class=\"line\">        lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flp) &#123;</div><div class=\"line\">        swap(l(), r());</div><div class=\"line\">        <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) node[l()].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) node[r()].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">        flp = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Splay 进行旋转操作时，子树发生了改变，需要重新维护区间（子树）信息</span></div><div class=\"line\"><span class=\"keyword\">void</span> Node::maintain() &#123;</div><div class=\"line\">    info = Info(val);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l() != <span class=\"number\">-1</span>) info = node[l()].info + info;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r() != <span class=\"number\">-1</span>) info = info + node[r()].info;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询当前节点是父亲的左儿子还是右儿子，左儿子返回0，右儿子返回1，如果无父亲返回-1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ori</span><span class=\"params\">(<span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = node[st].fa;</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> st == node[fa].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//把 sn 变成 st 的儿子节点，如果 d 是 0 是左儿子，否则是右儿子</span></div><div class=\"line\"><span class=\"comment\">//这里子树发生了改变，需要重新维护 info 信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setc</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> sn, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        node[st].son[d] = sn;</div><div class=\"line\">        node[st].maintain();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sn != <span class=\"number\">-1</span>) node[sn].fa = st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行旋转操作，这里需要自己画图理解一下</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zg</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = node[x].fa, p = <span class=\"number\">-1</span>;</div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    node[x].push_down();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> d = ori(x), dst = ori(st);</div><div class=\"line\">    <span class=\"keyword\">if</span> (st != <span class=\"number\">-1</span>) p = node[st].fa;</div><div class=\"line\">    setc(st, node[x].son[d ^ <span class=\"number\">1</span>], d);</div><div class=\"line\">    setc(x, st, d ^ <span class=\"number\">1</span>);</div><div class=\"line\">    setc(p, x, dst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f(x) (node[x].fa)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将 x 旋转成 fa 的儿子，如果将 x 旋转成 根节点的话则不填 fa</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> fa = <span class=\"number\">-1</span>)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//循环直到 x 是 fa 的儿子</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (f(x) != fa) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果 fa 是 x 的爷爷，那么只需要一次旋转</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f(f(x)) == fa) zg(x);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//双旋！</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//说明进行 zig zig 或者 zag zag 旋转</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (ori(x) == ori(f(x))) zg(f(x));</div><div class=\"line\">            <span class=\"keyword\">else</span> zg(x);</div><div class=\"line\">            zg(x);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//更新根节点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == <span class=\"number\">-1</span>) root = x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> value[maxn];</div><div class=\"line\"><span class=\"keyword\">int</span> pos;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//要保证 value 有序，类似线段树建树，这样树高是 log(n) 的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> st = pos++;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    node[st] = Node(value[m]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt; m) setc(st, build(l, m - <span class=\"number\">1</span>), <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m &lt; r) setc(st, build(m + <span class=\"number\">1</span>, r), <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> st;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    pos = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加 0 和 n + 1 两个虚拟节点，方便 cut 操作</span></div><div class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获得以 st 为根节点，中序遍历的第 v 个节点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getid</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> st)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在树上进行二分</span></div><div class=\"line\">    node[st].push_down();</div><div class=\"line\">    <span class=\"keyword\">int</span> l = node[st].l();</div><div class=\"line\">    <span class=\"keyword\">int</span> lsize = <span class=\"number\">1</span> + (l == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : node[l].info.size);</div><div class=\"line\">    <span class=\"keyword\">if</span> (v == lsize) <span class=\"keyword\">return</span> st;</div><div class=\"line\">    <span class=\"keyword\">int</span> d = v &gt; lsize;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d) v -= lsize;</div><div class=\"line\">    <span class=\"keyword\">return</span> getid(v, node[st].son[d]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getseg</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    l--, r++;</div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root), r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    <span class=\"comment\">//现在 r+1 是 l-1 的父亲，那么 l-r 这一段子树肯定是 l-1 的右儿子</span></div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    <span class=\"keyword\">return</span> node[l].r();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flip</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos = getseg(l, r);</div><div class=\"line\">    node[pos].flp ^= <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cut</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//切下来 l - r 这段区间</span></div><div class=\"line\">    <span class=\"keyword\">int</span> rootson1 = getseg(l, r);</div><div class=\"line\">    <span class=\"keyword\">int</span> father = node[rootson1].fa;</div><div class=\"line\">    setc(father, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    l = idx, r = idx + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">//因为这里是虚拟节点，所以要多加一个 1</span></div><div class=\"line\">    l = getid(l + <span class=\"number\">1</span>, root);</div><div class=\"line\">    r = getid(r + <span class=\"number\">1</span>, root);</div><div class=\"line\">    <span class=\"comment\">//将 idx+1 成为 idx 的父亲，那么上面切下来的区间放到idx的右边即可</span></div><div class=\"line\">    splay(r);</div><div class=\"line\">    splay(l, r);</div><div class=\"line\">    setc(l, rootson1, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> ans[maxn], cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//中序遍历</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now)</span> </span>&#123;</div><div class=\"line\">    node[now].push_down();</div><div class=\"line\">    <span class=\"keyword\">if</span> (node[now].son[<span class=\"number\">0</span>] != <span class=\"number\">-1</span>) dfs(node[now].son[<span class=\"number\">0</span>]);</div><div class=\"line\">    ans[cnt++] = node[now].val;</div><div class=\"line\">    <span class=\"keyword\">if</span> (node[now].son[<span class=\"number\">1</span>] != <span class=\"number\">-1</span>) dfs(node[now].son[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> L, R, idx;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">-1</span> &amp;&amp; m == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) value[i] = i;</div><div class=\"line\">        root = build(n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %d %d\"</span>, op, &amp;L, &amp;R);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[<span class=\"number\">0</span>] == <span class=\"string\">'F'</span>) flip(L, R);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;idx);</div><div class=\"line\">                cut(L, R, idx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cnt = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">        dfs(root);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i == n ? <span class=\"string\">'\\n'</span> : <span class=\"string\">' '</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3829 - Cat VS Dog（二分图匹配）","date":"2017-08-18T03:30:36.000Z","_content":"# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3829\n\n\n\n--------------------\n# 题目大意：\n\n有 N 条狗， M 只猫和 P 个人。\n\n每个人会喜欢一条狗讨厌一只猫或喜欢一只猫讨厌一条狗。\n\n现在可以将一些狗或猫移除。如果一个人喜欢的动物被保留，并且讨厌的动物被移除，那么称这个人是开心的。现在求最多可以使多少人开心。\n\n\n\n-------------------\n# 解题过程：\n\n刚开始一直想的是狗和猫之间建图，然后怎么想都不好解决，因为狗和猫没有直接的关系...\n\n然后这个题放了挺久的，直到后来才想起来补题，不错的题，感觉匹配问题主要是要将原问题如何转化到图论模型上。\n\n\n\n--------------------\n# 题目分析：\n\n首先我们对人建图。如果一个人喜欢的动物是另一个人讨厌的，那么这两个人是矛盾的，对所有矛盾的人之间建一条边。\n\n这时候会发现，如果这样建图的话，不会出现长度为奇数的环，因为一个人只能如果喜欢猫了不能再讨厌猫。\n\n所以这样建的图是一个二分图。对于矛盾的人，他们是不可能同时高兴的，也就是我们要尽量多的找出来一堆的人，他们之间不能有边。然后这就是最大独立集了。\n\n对于二分图: \n\n+ 最大匹配 = 最小点覆盖\n+ 最小点覆盖 + 最大独立集 = |V|\n\n那么跑一边二分图最大匹配就出来答案了。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 2000 + 10;\n\nstruct Node {\n    char like[112], dislike[112];\n} data[MAX];\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX * MAX * 10];\n\nint head[MAX], etot;\nint n, m, p;\nint matching[MAX], vis[MAX];\n\nvoid add_edge(int u, int v) {\n    edge[etot].u = u;\n    edge[etot].v = v;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nbool find(int u) {\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (vis[v]) continue;\n        vis[v] = true;\n        if (matching[v] == -1 || find(matching[v])) {\n            matching[v] = u;\n            matching[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &n, &m, &p)) {\n        memset(head, -1, sizeof(head));\n        etot = 0;\n        for (int i = 0; i < p; i++) {\n            scanf(\"%s %s\", data[i].like, data[i].dislike);\n        }\n\n        for (int i = 0; i < p; i++) {\n            for (int j = i + 1; j < p; j++) {\n                if (strcmp(data[i].like, data[j].dislike) == 0 ||\n                    strcmp(data[i].dislike, data[j].like) == 0) {\n                    add_edge(i, j);\n                    add_edge(j, i);\n                }\n            }\n        }\n\n        int ans = 0;\n\n        memset(matching, -1, sizeof(matching));\n        for (int i = 0; i < p; i++) {\n            if (matching[i] != -1) continue;\n            memset(vis, 0, sizeof(vis));\n            if (find(i)) ans++;\n        }\n\n        printf(\"%d\\n\", p - ans);\n    }\n}\n```","source":"_posts/HDU3829-Cat-VS-Dog（二分图匹配）.md","raw":"---\ntitle: HDU3829 - Cat VS Dog（二分图匹配）\ndate: 2017-08-18 11:30:36\ncategories: [ACM, 图论, 匹配]\ntags:\n---\n# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3829\n\n\n\n--------------------\n# 题目大意：\n\n有 N 条狗， M 只猫和 P 个人。\n\n每个人会喜欢一条狗讨厌一只猫或喜欢一只猫讨厌一条狗。\n\n现在可以将一些狗或猫移除。如果一个人喜欢的动物被保留，并且讨厌的动物被移除，那么称这个人是开心的。现在求最多可以使多少人开心。\n\n\n\n-------------------\n# 解题过程：\n\n刚开始一直想的是狗和猫之间建图，然后怎么想都不好解决，因为狗和猫没有直接的关系...\n\n然后这个题放了挺久的，直到后来才想起来补题，不错的题，感觉匹配问题主要是要将原问题如何转化到图论模型上。\n\n\n\n--------------------\n# 题目分析：\n\n首先我们对人建图。如果一个人喜欢的动物是另一个人讨厌的，那么这两个人是矛盾的，对所有矛盾的人之间建一条边。\n\n这时候会发现，如果这样建图的话，不会出现长度为奇数的环，因为一个人只能如果喜欢猫了不能再讨厌猫。\n\n所以这样建的图是一个二分图。对于矛盾的人，他们是不可能同时高兴的，也就是我们要尽量多的找出来一堆的人，他们之间不能有边。然后这就是最大独立集了。\n\n对于二分图: \n\n+ 最大匹配 = 最小点覆盖\n+ 最小点覆盖 + 最大独立集 = |V|\n\n那么跑一边二分图最大匹配就出来答案了。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 2000 + 10;\n\nstruct Node {\n    char like[112], dislike[112];\n} data[MAX];\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX * MAX * 10];\n\nint head[MAX], etot;\nint n, m, p;\nint matching[MAX], vis[MAX];\n\nvoid add_edge(int u, int v) {\n    edge[etot].u = u;\n    edge[etot].v = v;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nbool find(int u) {\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (vis[v]) continue;\n        vis[v] = true;\n        if (matching[v] == -1 || find(matching[v])) {\n            matching[v] = u;\n            matching[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &n, &m, &p)) {\n        memset(head, -1, sizeof(head));\n        etot = 0;\n        for (int i = 0; i < p; i++) {\n            scanf(\"%s %s\", data[i].like, data[i].dislike);\n        }\n\n        for (int i = 0; i < p; i++) {\n            for (int j = i + 1; j < p; j++) {\n                if (strcmp(data[i].like, data[j].dislike) == 0 ||\n                    strcmp(data[i].dislike, data[j].like) == 0) {\n                    add_edge(i, j);\n                    add_edge(j, i);\n                }\n            }\n        }\n\n        int ans = 0;\n\n        memset(matching, -1, sizeof(matching));\n        for (int i = 0; i < p; i++) {\n            if (matching[i] != -1) continue;\n            memset(vis, 0, sizeof(vis));\n            if (find(i)) ans++;\n        }\n\n        printf(\"%d\\n\", p - ans);\n    }\n}\n```","slug":"HDU3829-Cat-VS-Dog（二分图匹配）","published":1,"updated":"2017-08-18T03:46:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6naz001uy9idv5aqf5cy","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3829\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3829</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>有 N 条狗， M 只猫和 P 个人。</p>\n<p>每个人会喜欢一条狗讨厌一只猫或喜欢一只猫讨厌一条狗。</p>\n<p>现在可以将一些狗或猫移除。如果一个人喜欢的动物被保留，并且讨厌的动物被移除，那么称这个人是开心的。现在求最多可以使多少人开心。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始一直想的是狗和猫之间建图，然后怎么想都不好解决，因为狗和猫没有直接的关系…</p>\n<p>然后这个题放了挺久的，直到后来才想起来补题，不错的题，感觉匹配问题主要是要将原问题如何转化到图论模型上。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先我们对人建图。如果一个人喜欢的动物是另一个人讨厌的，那么这两个人是矛盾的，对所有矛盾的人之间建一条边。</p>\n<p>这时候会发现，如果这样建图的话，不会出现长度为奇数的环，因为一个人只能如果喜欢猫了不能再讨厌猫。</p>\n<p>所以这样建的图是一个二分图。对于矛盾的人，他们是不可能同时高兴的，也就是我们要尽量多的找出来一堆的人，他们之间不能有边。然后这就是最大独立集了。</p>\n<p>对于二分图: </p>\n<ul>\n<li>最大匹配 = 最小点覆盖</li>\n<li>最小点覆盖 + 最大独立集 = |V|</li>\n</ul>\n<p>那么跑一边二分图最大匹配就出来答案了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">char</span> like[<span class=\"number\">112</span>], dislike[<span class=\"number\">112</span>];</div><div class=\"line\">&#125; data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX * MAX * <span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, p;</div><div class=\"line\"><span class=\"keyword\">int</span> matching[MAX], vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        vis[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || find(matching[v])) &#123;</div><div class=\"line\">            matching[v] = u;</div><div class=\"line\">            matching[u] = v;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;p)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %s\"</span>, data[i].like, data[i].dislike);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; p; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(data[i].like, data[j].dislike) == <span class=\"number\">0</span> ||</div><div class=\"line\">                    <span class=\"built_in\">strcmp</span>(data[i].dislike, data[j].like) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    add_edge(i, j);</div><div class=\"line\">                    add_edge(j, i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[i] != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">            <span class=\"keyword\">if</span> (find(i)) ans++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, p - ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3829\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3829</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>有 N 条狗， M 只猫和 P 个人。</p>\n<p>每个人会喜欢一条狗讨厌一只猫或喜欢一只猫讨厌一条狗。</p>\n<p>现在可以将一些狗或猫移除。如果一个人喜欢的动物被保留，并且讨厌的动物被移除，那么称这个人是开心的。现在求最多可以使多少人开心。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始一直想的是狗和猫之间建图，然后怎么想都不好解决，因为狗和猫没有直接的关系…</p>\n<p>然后这个题放了挺久的，直到后来才想起来补题，不错的题，感觉匹配问题主要是要将原问题如何转化到图论模型上。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先我们对人建图。如果一个人喜欢的动物是另一个人讨厌的，那么这两个人是矛盾的，对所有矛盾的人之间建一条边。</p>\n<p>这时候会发现，如果这样建图的话，不会出现长度为奇数的环，因为一个人只能如果喜欢猫了不能再讨厌猫。</p>\n<p>所以这样建的图是一个二分图。对于矛盾的人，他们是不可能同时高兴的，也就是我们要尽量多的找出来一堆的人，他们之间不能有边。然后这就是最大独立集了。</p>\n<p>对于二分图: </p>\n<ul>\n<li>最大匹配 = 最小点覆盖</li>\n<li>最小点覆盖 + 最大独立集 = |V|</li>\n</ul>\n<p>那么跑一边二分图最大匹配就出来答案了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">char</span> like[<span class=\"number\">112</span>], dislike[<span class=\"number\">112</span>];</div><div class=\"line\">&#125; data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX * MAX * <span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, p;</div><div class=\"line\"><span class=\"keyword\">int</span> matching[MAX], vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        vis[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || find(matching[v])) &#123;</div><div class=\"line\">            matching[v] = u;</div><div class=\"line\">            matching[u] = v;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;p)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %s\"</span>, data[i].like, data[i].dislike);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; p; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(data[i].like, data[j].dislike) == <span class=\"number\">0</span> ||</div><div class=\"line\">                    <span class=\"built_in\">strcmp</span>(data[i].dislike, data[j].like) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    add_edge(i, j);</div><div class=\"line\">                    add_edge(j, i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[i] != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">            <span class=\"keyword\">if</span> (find(i)) ans++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, p - ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3861 - The King’s Problem（强连通+缩点+匈牙利）","date":"2017-08-02T13:28:16.000Z","_content":"# 题目链接：\n--------------------\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3861\n\n# 题目大意：\n\n给出一个有向图，想在要把无向图分成k个部分，对于每对可以互相到达的(u, v)要属于同一个部分，另外每个部分中任意两个点(u, v)至少可以由u到达v或者由v到达u。\n\n-------------------\n# 解题过程：\n\n刚开始一点都不会，还看错了题意，只知道可以缩成DAG，但是缩完也不知道该怎么搞，只好去翻了下博客，发现缩完点，要求的就是最小路径覆盖，然后最小路径覆盖需要用到二分图匹配，顺手去学了一下匈牙利。\n\n不过匈牙利刚开始没仔细看，学的曲线有点歪...回来才弄明白。\n\n--------------------\n# 题目分析：\n\n首先对原图强连通分量分解，缩点转化为DAG图。然后分析一下，题目说描述的就是最小路径覆盖。\n\n> 一个有向图中，路径覆盖就是在图中找一些路径，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联\n\n对于DAG的最小路径覆盖就是DAG的顶点数减去DAG对应的二分图的最大匹配数。\n\n这篇[博客](http://www.cnblogs.com/justPassBy/p/5369930.html) 讲的就非常好，也有必要的证明。\n\n需要补充一下的就是代码部分了，这个代码写的有点强，虽然说上面的分析讲到要对DAG的每个点拆成两个点建图，然后跑最大二分图匹配。但是代码上并没有拆点。\n\n使用匈牙利匹配的时候，DFS函数里面从u匹配到v时，只对v进行标记一下，这样虽然u已经匹配了，但是他还可以当做入点再匹配一次。这样也相当于拆点建图了。对于每个点当做入点被匹配和当做出点被匹配是相对独立的，正好符合上面描述的算法。\n\n不过这里老老实实的拆点再匹配也可以AC，就是相对于上面的代码麻烦点了。\n\n----------------------\n# AC代码：\n\n## 不拆点\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nvector<int> G1[MAX], G2[2 * MAX];\n\nint n, m, T;\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint check[2 * MAX], matching[2 * MAX];\n\nvoid tarjan(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        ++scc_cnt;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    scc_cnt = dfs_clock = 0;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) G1[i].clear();\n    for (int i = 1; i <= 2 * n; i++) G2[i].clear();\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v]);\n            }\n        }\n    }\n}\n\nbool dfs(int u) {\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!check[v]) {\n            check[v] = true;\n            if (matching[v] == -1 || dfs(matching[v])) {\n                matching[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n\n    memset(pre, 0, sizeof(pre));\n    rebuild();\n\n    int max_match = 0;\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (matching[i] == -1) {\n            memset(check, 0, sizeof(check));\n            if (dfs(i)) max_match++;\n        }\n    }\n\n    printf(\"%d\\n\", scc_cnt - max_match);\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```\n\n## 拆点\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nvector<int> G1[MAX], G2[2 * MAX];\n\nint n, m, T;\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint check[2 * MAX], matching[2 * MAX];\n\nvoid tarjan(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        ++scc_cnt;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    scc_cnt = dfs_clock = 0;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) G1[i].clear();\n    for (int i = 1; i <= 2 * n; i++) G2[i].clear();\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v] + scc_cnt);\n            }\n        }\n    }\n}\n\nbool dfs(int u) {\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!check[v]) {\n            check[v] = true;\n            if (matching[v] == -1 || dfs(matching[v])) {\n                matching[v] = u;\n                matching[u] = v;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n\n    memset(pre, 0, sizeof(pre));\n    rebuild();\n\n    int max_match = 0;\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= 2 * scc_cnt; i++) {\n        if (matching[i] == -1) {\n            memset(check, 0, sizeof(check));\n            if (dfs(i)) max_match++;\n        }\n    }\n\n    printf(\"%d\\n\", scc_cnt - max_match);\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/HDU3861-The-King’s-Problem（强连通-缩点-匈牙利）.md","raw":"---\ntitle: HDU3861 - The King’s Problem（强连通+缩点+匈牙利）\ndate: 2017-08-02 21:28:16\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\n--------------------\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3861\n\n# 题目大意：\n\n给出一个有向图，想在要把无向图分成k个部分，对于每对可以互相到达的(u, v)要属于同一个部分，另外每个部分中任意两个点(u, v)至少可以由u到达v或者由v到达u。\n\n-------------------\n# 解题过程：\n\n刚开始一点都不会，还看错了题意，只知道可以缩成DAG，但是缩完也不知道该怎么搞，只好去翻了下博客，发现缩完点，要求的就是最小路径覆盖，然后最小路径覆盖需要用到二分图匹配，顺手去学了一下匈牙利。\n\n不过匈牙利刚开始没仔细看，学的曲线有点歪...回来才弄明白。\n\n--------------------\n# 题目分析：\n\n首先对原图强连通分量分解，缩点转化为DAG图。然后分析一下，题目说描述的就是最小路径覆盖。\n\n> 一个有向图中，路径覆盖就是在图中找一些路径，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联\n\n对于DAG的最小路径覆盖就是DAG的顶点数减去DAG对应的二分图的最大匹配数。\n\n这篇[博客](http://www.cnblogs.com/justPassBy/p/5369930.html) 讲的就非常好，也有必要的证明。\n\n需要补充一下的就是代码部分了，这个代码写的有点强，虽然说上面的分析讲到要对DAG的每个点拆成两个点建图，然后跑最大二分图匹配。但是代码上并没有拆点。\n\n使用匈牙利匹配的时候，DFS函数里面从u匹配到v时，只对v进行标记一下，这样虽然u已经匹配了，但是他还可以当做入点再匹配一次。这样也相当于拆点建图了。对于每个点当做入点被匹配和当做出点被匹配是相对独立的，正好符合上面描述的算法。\n\n不过这里老老实实的拆点再匹配也可以AC，就是相对于上面的代码麻烦点了。\n\n----------------------\n# AC代码：\n\n## 不拆点\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nvector<int> G1[MAX], G2[2 * MAX];\n\nint n, m, T;\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint check[2 * MAX], matching[2 * MAX];\n\nvoid tarjan(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        ++scc_cnt;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    scc_cnt = dfs_clock = 0;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) G1[i].clear();\n    for (int i = 1; i <= 2 * n; i++) G2[i].clear();\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v]);\n            }\n        }\n    }\n}\n\nbool dfs(int u) {\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!check[v]) {\n            check[v] = true;\n            if (matching[v] == -1 || dfs(matching[v])) {\n                matching[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n\n    memset(pre, 0, sizeof(pre));\n    rebuild();\n\n    int max_match = 0;\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= scc_cnt; i++) {\n        if (matching[i] == -1) {\n            memset(check, 0, sizeof(check));\n            if (dfs(i)) max_match++;\n        }\n    }\n\n    printf(\"%d\\n\", scc_cnt - max_match);\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```\n\n## 拆点\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 5000 + 10;\n\nvector<int> G1[MAX], G2[2 * MAX];\n\nint n, m, T;\n\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nint check[2 * MAX], matching[2 * MAX];\n\nvoid tarjan(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = 0; i < G1[u].size(); i++) {\n        int v = G1[u][i];\n        if (!pre[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        ++scc_cnt;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    scc_cnt = dfs_clock = 0;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) G1[i].clear();\n    for (int i = 1; i <= 2 * n; i++) G2[i].clear();\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        G1[u].push_back(v);\n    }\n}\n\nvoid rebuild() {\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G1[u].size(); i++) {\n            int v = G1[u][i];\n            if (mark[u] != mark[v]) {\n                G2[mark[u]].push_back(mark[v] + scc_cnt);\n            }\n        }\n    }\n}\n\nbool dfs(int u) {\n    for (int i = 0; i < G2[u].size(); i++) {\n        int v = G2[u][i];\n        if (!check[v]) {\n            check[v] = true;\n            if (matching[v] == -1 || dfs(matching[v])) {\n                matching[v] = u;\n                matching[u] = v;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) tarjan(i);\n    }\n\n    memset(pre, 0, sizeof(pre));\n    rebuild();\n\n    int max_match = 0;\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= 2 * scc_cnt; i++) {\n        if (matching[i] == -1) {\n            memset(check, 0, sizeof(check));\n            if (dfs(i)) max_match++;\n        }\n    }\n\n    printf(\"%d\\n\", scc_cnt - max_match);\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```","slug":"HDU3861-The-King’s-Problem（强连通-缩点-匈牙利）","published":1,"updated":"2017-08-03T00:40:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nb0001wy9id1e8sxn1y","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3861\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3861</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，想在要把无向图分成k个部分，对于每对可以互相到达的(u, v)要属于同一个部分，另外每个部分中任意两个点(u, v)至少可以由u到达v或者由v到达u。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始一点都不会，还看错了题意，只知道可以缩成DAG，但是缩完也不知道该怎么搞，只好去翻了下博客，发现缩完点，要求的就是最小路径覆盖，然后最小路径覆盖需要用到二分图匹配，顺手去学了一下匈牙利。</p>\n<p>不过匈牙利刚开始没仔细看，学的曲线有点歪…回来才弄明白。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对原图强连通分量分解，缩点转化为DAG图。然后分析一下，题目说描述的就是最小路径覆盖。</p>\n<blockquote>\n<p>一个有向图中，路径覆盖就是在图中找一些路径，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联</p>\n</blockquote>\n<p>对于DAG的最小路径覆盖就是DAG的顶点数减去DAG对应的二分图的最大匹配数。</p>\n<p>这篇<a href=\"http://www.cnblogs.com/justPassBy/p/5369930.html\" target=\"_blank\" rel=\"external\">博客</a> 讲的就非常好，也有必要的证明。</p>\n<p>需要补充一下的就是代码部分了，这个代码写的有点强，虽然说上面的分析讲到要对DAG的每个点拆成两个点建图，然后跑最大二分图匹配。但是代码上并没有拆点。</p>\n<p>使用匈牙利匹配的时候，DFS函数里面从u匹配到v时，只对v进行标记一下，这样虽然u已经匹配了，但是他还可以当做入点再匹配一次。这样也相当于拆点建图了。对于每个点当做入点被匹配和当做出点被匹配是相对独立的，正好符合上面描述的算法。</p>\n<p>不过这里老老实实的拆点再匹配也可以AC，就是相对于上面的代码麻烦点了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"不拆点\"><a href=\"#不拆点\" class=\"headerlink\" title=\"不拆点\"></a>不拆点</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, T;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> check[<span class=\"number\">2</span> * MAX], matching[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) G1[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * n; i++) G2[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!check[v]) &#123;</div><div class=\"line\">            check[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || dfs(matching[v])) &#123;</div><div class=\"line\">                matching[v] = u;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> max_match = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(check, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(check));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i)) max_match++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, scc_cnt - max_match);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"拆点\"><a href=\"#拆点\" class=\"headerlink\" title=\"拆点\"></a>拆点</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, T;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> check[<span class=\"number\">2</span> * MAX], matching[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) G1[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * n; i++) G2[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v] + scc_cnt);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!check[v]) &#123;</div><div class=\"line\">            check[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || dfs(matching[v])) &#123;</div><div class=\"line\">                matching[v] = u;</div><div class=\"line\">                matching[u] = v;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> max_match = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(check, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(check));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i)) max_match++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, scc_cnt - max_match);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3861\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3861</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有向图，想在要把无向图分成k个部分，对于每对可以互相到达的(u, v)要属于同一个部分，另外每个部分中任意两个点(u, v)至少可以由u到达v或者由v到达u。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始一点都不会，还看错了题意，只知道可以缩成DAG，但是缩完也不知道该怎么搞，只好去翻了下博客，发现缩完点，要求的就是最小路径覆盖，然后最小路径覆盖需要用到二分图匹配，顺手去学了一下匈牙利。</p>\n<p>不过匈牙利刚开始没仔细看，学的曲线有点歪…回来才弄明白。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对原图强连通分量分解，缩点转化为DAG图。然后分析一下，题目说描述的就是最小路径覆盖。</p>\n<blockquote>\n<p>一个有向图中，路径覆盖就是在图中找一些路径，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联</p>\n</blockquote>\n<p>对于DAG的最小路径覆盖就是DAG的顶点数减去DAG对应的二分图的最大匹配数。</p>\n<p>这篇<a href=\"http://www.cnblogs.com/justPassBy/p/5369930.html\" target=\"_blank\" rel=\"external\">博客</a> 讲的就非常好，也有必要的证明。</p>\n<p>需要补充一下的就是代码部分了，这个代码写的有点强，虽然说上面的分析讲到要对DAG的每个点拆成两个点建图，然后跑最大二分图匹配。但是代码上并没有拆点。</p>\n<p>使用匈牙利匹配的时候，DFS函数里面从u匹配到v时，只对v进行标记一下，这样虽然u已经匹配了，但是他还可以当做入点再匹配一次。这样也相当于拆点建图了。对于每个点当做入点被匹配和当做出点被匹配是相对独立的，正好符合上面描述的算法。</p>\n<p>不过这里老老实实的拆点再匹配也可以AC，就是相对于上面的代码麻烦点了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"不拆点\"><a href=\"#不拆点\" class=\"headerlink\" title=\"不拆点\"></a>不拆点</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, T;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> check[<span class=\"number\">2</span> * MAX], matching[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) G1[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * n; i++) G2[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!check[v]) &#123;</div><div class=\"line\">            check[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || dfs(matching[v])) &#123;</div><div class=\"line\">                matching[v] = u;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> max_match = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(check, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(check));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i)) max_match++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, scc_cnt - max_match);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"拆点\"><a href=\"#拆点\" class=\"headerlink\" title=\"拆点\"></a>拆点</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">5000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G1[MAX], G2[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, T;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> check[<span class=\"number\">2</span> * MAX], matching[<span class=\"number\">2</span> * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            tarjan(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        ++scc_cnt;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    scc_cnt = dfs_clock = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) G1[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * n; i++) G2[i].clear();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        G1[u].push_back(v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G1[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G1[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">                G2[mark[u]].push_back(mark[v] + scc_cnt);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G2[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = G2[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!check[v]) &#123;</div><div class=\"line\">            check[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || dfs(matching[v])) &#123;</div><div class=\"line\">                matching[v] = u;</div><div class=\"line\">                matching[u] = v;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) tarjan(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> max_match = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">2</span> * scc_cnt; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(check, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(check));</div><div class=\"line\">            <span class=\"keyword\">if</span> (dfs(i)) max_match++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, scc_cnt - max_match);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU3966 - Aragorn's Story（树链剖分+模板）","date":"2017-08-09T11:17:36.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3966\n\n\n--------------------\n# 题目大意：\n给出一颗树，每个点有点权。\n两种操作：\n1. 询问一个点的权值。\n2. 令一条路径上的所有点权值加value\n\n点数5e4\n\n-------------------\n# 解题过程：\n线段树的模板题，拿着学长的板子直接上了，结果又RE了，没改MAX大小...\n然后又交了一发TLE，用来存边的vector没初始化...\n然后又交了一发WA，push_down的时候直接把子节点的lazy标记覆盖了（这个地方不知道错了多少次了！！！）\n\n--------------------\n# 题目分析：\n树链剖分的模板题\n\n总的来说树链剖分就是一个工具，可以把一个路径上的点映射成几段连续的区间上。这样对于连续的区间可以用线段树维护，对于DFS序也是这样。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nusing namespace std;\n\nconst int MAX = 50000 + 10;\nconst int INF = 0x3f3f3f3f;\n\nstruct Info {\n    int sum, lazy, cnt;\n\n    Info() {\n        sum = lazy = cnt = 0;\n    }\n\n    Info operator+(const Info &a) {\n        Info rst;\n        rst.sum = sum + a.sum;\n        rst.cnt = cnt + a.cnt;\n        return rst;\n    }\n} tree[MAX << 2];\n\nvector<int> edge[MAX];\nint data[MAX], n, m, p;\nchar str[112];\n\nint id_data[MAX];\nint fa[MAX], son[MAX], siz[MAX];\nint deep[MAX], top[MAX], tid[MAX];\nint _cnt;\n\nvoid build(int o, int l, int r) {\n    tree[o].lazy = 0;\n    if (l == r) {\n        tree[o].sum = id_data[l];\n        tree[o].cnt = 1;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n    tree[o] = tree[lson] + tree[rson];\n}\n\nvoid push_down(int o) {\n    if (!tree[o].lazy) return;\n    int lazy = tree[o].lazy;\n    tree[lson].lazy += lazy;\n    tree[rson].lazy += lazy;\n    tree[lson].sum += lazy * tree[lson].cnt;\n    tree[rson].sum += lazy * tree[rson].cnt;\n    tree[o].lazy = 0;\n}\n\nvoid updata(int o, int l, int r, int ul, int ur, int d) {\n    if (r < ul || ur < l) return;\n    if (ul <= l && r <= ur) {\n        tree[o].sum += tree[o].cnt * d;\n        tree[o].lazy += d;\n        return;\n    }\n    push_down(o);\n    MID;\n    updata(lson, l, m, ul, ur, d);\n    updata(rson, m + 1, r, ul, ur, d);\n    tree[o] = tree[lson] + tree[rson];\n}\n\nInfo query(int o, int l, int r, int pos) {\n    if (r < pos || pos < l) return Info();\n    if (l == r) {\n        return tree[o];\n    }\n    push_down(o);\n    MID;\n    return query(lson, l, m, pos) + query(rson, m + 1, r, pos);\n}\n\n//第一次dfs记录信息\nvoid dffs(int u, int f, int d) {\n    siz[u] = 1, deep[u] = d;\n    fa[u] = f, son[u] = -1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (v != f) {\n            dffs(v, u, d + 1);\n            siz[u] += siz[v];\n            if (son[u] == -1 || siz[son[u]] < siz[v]) {\n                son[u] = v;\n            }\n        }\n    }\n}\n\n//第二次dfs找出重链，进行剖分\nvoid dfss(int u, int t) {\n    top[u] = t, tid[u] = _cnt++;\n    id_data[_cnt - 1] = data[u];\n    if (son[u] != -1) dfss(son[u], t);\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (son[u] != v && fa[u] != v) dfss(v, v);\n    }\n}\n\nvoid splite() {\n    _cnt = 1;\n    dffs(1, -1, 0);\n    dfss(1, 1);\n}\n\nvoid Updata(int x, int y, int d) {\n    int tx = top[x], ty = top[y];\n    while (tx != ty) {\n        if (deep[tx] < deep[ty]) swap(x, y), swap(tx, ty);\n        updata(1, 1, n, tid[tx], tid[x], d);\n        x = fa[tx], tx = top[x];\n    }\n    if (deep[x] < deep[y]) swap(x, y);\n    updata(1, 1, n, tid[y], tid[x], d);\n}\n\n//Info Query(int x, int y) {\n//    Info ix, iy;\n//    int tx = top[x], ty = top[y];\n//    while (tx != ty) {\n//        if (deep[tx] < deep[ty]) swap(x, y), swap(tx, ty), swap(ix, iy);\n//        ix = query(1, 1, n, tid[tx], tid[x]) + ix;\n//        x = fa[tx], tx = top[x];\n//    }\n//    if (deep[x] < deep[y]) swap(x, y);\n//    return ix + query(1, 1, n, tid[y], tid[x]) + iy;\n//}\n\nvoid init() {\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &data[i]);\n        edge[i].clear();\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n}\n\n\nvoid solve() {\n    splite();\n    build(1, 1, n);\n    while (p--) {\n        int a, b, c;\n        scanf(\"%s\", str);\n        if (str[0] == 'Q') {\n            scanf(\"%d\", &a);\n            printf(\"%d\\n\", query(1, 1, n, tid[a]).sum);\n        } else {\n            scanf(\"%d %d %d\", &a, &b, &c);\n            if (str[0] == 'I') {\n                Updata(a, b, c);\n            } else {\n                Updata(a, b, -c);\n            }\n        }\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &n, &m, &p)) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/HDU3966-Aragorn-s-Story（树链剖分-模板）.md","raw":"---\ntitle: HDU3966 - Aragorn's Story（树链剖分+模板）\ndate: 2017-08-09 19:17:36\ncategories: [ACM, 数据结构, 树链剖分]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3966\n\n\n--------------------\n# 题目大意：\n给出一颗树，每个点有点权。\n两种操作：\n1. 询问一个点的权值。\n2. 令一条路径上的所有点权值加value\n\n点数5e4\n\n-------------------\n# 解题过程：\n线段树的模板题，拿着学长的板子直接上了，结果又RE了，没改MAX大小...\n然后又交了一发TLE，用来存边的vector没初始化...\n然后又交了一发WA，push_down的时候直接把子节点的lazy标记覆盖了（这个地方不知道错了多少次了！！！）\n\n--------------------\n# 题目分析：\n树链剖分的模板题\n\n总的来说树链剖分就是一个工具，可以把一个路径上的点映射成几段连续的区间上。这样对于连续的区间可以用线段树维护，对于DFS序也是这样。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nusing namespace std;\n\nconst int MAX = 50000 + 10;\nconst int INF = 0x3f3f3f3f;\n\nstruct Info {\n    int sum, lazy, cnt;\n\n    Info() {\n        sum = lazy = cnt = 0;\n    }\n\n    Info operator+(const Info &a) {\n        Info rst;\n        rst.sum = sum + a.sum;\n        rst.cnt = cnt + a.cnt;\n        return rst;\n    }\n} tree[MAX << 2];\n\nvector<int> edge[MAX];\nint data[MAX], n, m, p;\nchar str[112];\n\nint id_data[MAX];\nint fa[MAX], son[MAX], siz[MAX];\nint deep[MAX], top[MAX], tid[MAX];\nint _cnt;\n\nvoid build(int o, int l, int r) {\n    tree[o].lazy = 0;\n    if (l == r) {\n        tree[o].sum = id_data[l];\n        tree[o].cnt = 1;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n    tree[o] = tree[lson] + tree[rson];\n}\n\nvoid push_down(int o) {\n    if (!tree[o].lazy) return;\n    int lazy = tree[o].lazy;\n    tree[lson].lazy += lazy;\n    tree[rson].lazy += lazy;\n    tree[lson].sum += lazy * tree[lson].cnt;\n    tree[rson].sum += lazy * tree[rson].cnt;\n    tree[o].lazy = 0;\n}\n\nvoid updata(int o, int l, int r, int ul, int ur, int d) {\n    if (r < ul || ur < l) return;\n    if (ul <= l && r <= ur) {\n        tree[o].sum += tree[o].cnt * d;\n        tree[o].lazy += d;\n        return;\n    }\n    push_down(o);\n    MID;\n    updata(lson, l, m, ul, ur, d);\n    updata(rson, m + 1, r, ul, ur, d);\n    tree[o] = tree[lson] + tree[rson];\n}\n\nInfo query(int o, int l, int r, int pos) {\n    if (r < pos || pos < l) return Info();\n    if (l == r) {\n        return tree[o];\n    }\n    push_down(o);\n    MID;\n    return query(lson, l, m, pos) + query(rson, m + 1, r, pos);\n}\n\n//第一次dfs记录信息\nvoid dffs(int u, int f, int d) {\n    siz[u] = 1, deep[u] = d;\n    fa[u] = f, son[u] = -1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (v != f) {\n            dffs(v, u, d + 1);\n            siz[u] += siz[v];\n            if (son[u] == -1 || siz[son[u]] < siz[v]) {\n                son[u] = v;\n            }\n        }\n    }\n}\n\n//第二次dfs找出重链，进行剖分\nvoid dfss(int u, int t) {\n    top[u] = t, tid[u] = _cnt++;\n    id_data[_cnt - 1] = data[u];\n    if (son[u] != -1) dfss(son[u], t);\n    for (int i = 0; i < edge[u].size(); i++) {\n        int v = edge[u][i];\n        if (son[u] != v && fa[u] != v) dfss(v, v);\n    }\n}\n\nvoid splite() {\n    _cnt = 1;\n    dffs(1, -1, 0);\n    dfss(1, 1);\n}\n\nvoid Updata(int x, int y, int d) {\n    int tx = top[x], ty = top[y];\n    while (tx != ty) {\n        if (deep[tx] < deep[ty]) swap(x, y), swap(tx, ty);\n        updata(1, 1, n, tid[tx], tid[x], d);\n        x = fa[tx], tx = top[x];\n    }\n    if (deep[x] < deep[y]) swap(x, y);\n    updata(1, 1, n, tid[y], tid[x], d);\n}\n\n//Info Query(int x, int y) {\n//    Info ix, iy;\n//    int tx = top[x], ty = top[y];\n//    while (tx != ty) {\n//        if (deep[tx] < deep[ty]) swap(x, y), swap(tx, ty), swap(ix, iy);\n//        ix = query(1, 1, n, tid[tx], tid[x]) + ix;\n//        x = fa[tx], tx = top[x];\n//    }\n//    if (deep[x] < deep[y]) swap(x, y);\n//    return ix + query(1, 1, n, tid[y], tid[x]) + iy;\n//}\n\nvoid init() {\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &data[i]);\n        edge[i].clear();\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n}\n\n\nvoid solve() {\n    splite();\n    build(1, 1, n);\n    while (p--) {\n        int a, b, c;\n        scanf(\"%s\", str);\n        if (str[0] == 'Q') {\n            scanf(\"%d\", &a);\n            printf(\"%d\\n\", query(1, 1, n, tid[a]).sum);\n        } else {\n            scanf(\"%d %d %d\", &a, &b, &c);\n            if (str[0] == 'I') {\n                Updata(a, b, c);\n            } else {\n                Updata(a, b, -c);\n            }\n        }\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &n, &m, &p)) {\n        init();\n        solve();\n    }\n}\n```","slug":"HDU3966-Aragorn-s-Story（树链剖分-模板）","published":1,"updated":"2017-08-09T11:25:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nb2001yy9idrzcpt7h4","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3966\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3966</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一颗树，每个点有点权。<br>两种操作：</p>\n<ol>\n<li>询问一个点的权值。</li>\n<li>令一条路径上的所有点权值加value</li>\n</ol>\n<p>点数5e4</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>线段树的模板题，拿着学长的板子直接上了，结果又RE了，没改MAX大小…<br>然后又交了一发TLE，用来存边的vector没初始化…<br>然后又交了一发WA，push_down的时候直接把子节点的lazy标记覆盖了（这个地方不知道错了多少次了！！！）</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>树链剖分的模板题</p>\n<p>总的来说树链剖分就是一个工具，可以把一个路径上的点映射成几段连续的区间上。这样对于连续的区间可以用线段树维护，对于DFS序也是这样。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">50000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sum, lazy, cnt;</div><div class=\"line\"></div><div class=\"line\">    Info() &#123;</div><div class=\"line\">        sum = lazy = cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Info &amp;a) &#123;</div><div class=\"line\">        Info rst;</div><div class=\"line\">        rst.sum = sum + a.sum;</div><div class=\"line\">        rst.cnt = cnt + a.cnt;</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; tree[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], n, m, p;</div><div class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> id_data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> fa[MAX], son[MAX], siz[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> deep[MAX], top[MAX], tid[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> _cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[o].sum = id_data[l];</div><div class=\"line\">        tree[o].cnt = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[o] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!tree[o].lazy) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> lazy = tree[o].lazy;</div><div class=\"line\">    tree[lson].lazy += lazy;</div><div class=\"line\">    tree[rson].lazy += lazy;</div><div class=\"line\">    tree[lson].sum += lazy * tree[lson].cnt;</div><div class=\"line\">    tree[rson].sum += lazy * tree[rson].cnt;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        tree[o].sum += tree[o].cnt * d;</div><div class=\"line\">        tree[o].lazy += d;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur, d);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, ul, ur, d);</div><div class=\"line\">    tree[o] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; pos || pos &lt; l) <span class=\"keyword\">return</span> Info();</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o];</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, pos) + query(rson, m + <span class=\"number\">1</span>, r, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第一次dfs记录信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dffs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    siz[u] = <span class=\"number\">1</span>, deep[u] = d;</div><div class=\"line\">    fa[u] = f, son[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (v != f) &#123;</div><div class=\"line\">            dffs(v, u, d + <span class=\"number\">1</span>);</div><div class=\"line\">            siz[u] += siz[v];</div><div class=\"line\">            <span class=\"keyword\">if</span> (son[u] == <span class=\"number\">-1</span> || siz[son[u]] &lt; siz[v]) &#123;</div><div class=\"line\">                son[u] = v;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二次dfs找出重链，进行剖分</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfss</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    top[u] = t, tid[u] = _cnt++;</div><div class=\"line\">    id_data[_cnt - <span class=\"number\">1</span>] = data[u];</div><div class=\"line\">    <span class=\"keyword\">if</span> (son[u] != <span class=\"number\">-1</span>) dfss(son[u], t);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (son[u] != v &amp;&amp; fa[u] != v) dfss(v, v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splite</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    _cnt = <span class=\"number\">1</span>;</div><div class=\"line\">    dffs(<span class=\"number\">1</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    dfss(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Updata</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tx = top[x], ty = top[y];</div><div class=\"line\">    <span class=\"keyword\">while</span> (tx != ty) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deep[tx] &lt; deep[ty]) swap(x, y), swap(tx, ty);</div><div class=\"line\">        updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[tx], tid[x], d);</div><div class=\"line\">        x = fa[tx], tx = top[x];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (deep[x] &lt; deep[y]) swap(x, y);</div><div class=\"line\">    updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[y], tid[x], d);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Info Query(int x, int y) &#123;</span></div><div class=\"line\"><span class=\"comment\">//    Info ix, iy;</span></div><div class=\"line\"><span class=\"comment\">//    int tx = top[x], ty = top[y];</span></div><div class=\"line\"><span class=\"comment\">//    while (tx != ty) &#123;</span></div><div class=\"line\"><span class=\"comment\">//        if (deep[tx] &lt; deep[ty]) swap(x, y), swap(tx, ty), swap(ix, iy);</span></div><div class=\"line\"><span class=\"comment\">//        ix = query(1, 1, n, tid[tx], tid[x]) + ix;</span></div><div class=\"line\"><span class=\"comment\">//        x = fa[tx], tx = top[x];</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"><span class=\"comment\">//    if (deep[x] &lt; deep[y]) swap(x, y);</span></div><div class=\"line\"><span class=\"comment\">//    return ix + query(1, 1, n, tid[y], tid[x]) + iy;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">        edge[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edge[u].push_back(v);</div><div class=\"line\">        edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    splite();</div><div class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"keyword\">while</span> (p--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[a]).sum);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;a, &amp;b, &amp;c);</div><div class=\"line\">            <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) &#123;</div><div class=\"line\">                Updata(a, b, c);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Updata(a, b, -c);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;p)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3966\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3966</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一颗树，每个点有点权。<br>两种操作：</p>\n<ol>\n<li>询问一个点的权值。</li>\n<li>令一条路径上的所有点权值加value</li>\n</ol>\n<p>点数5e4</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>线段树的模板题，拿着学长的板子直接上了，结果又RE了，没改MAX大小…<br>然后又交了一发TLE，用来存边的vector没初始化…<br>然后又交了一发WA，push_down的时候直接把子节点的lazy标记覆盖了（这个地方不知道错了多少次了！！！）</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>树链剖分的模板题</p>\n<p>总的来说树链剖分就是一个工具，可以把一个路径上的点映射成几段连续的区间上。这样对于连续的区间可以用线段树维护，对于DFS序也是这样。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">50000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sum, lazy, cnt;</div><div class=\"line\"></div><div class=\"line\">    Info() &#123;</div><div class=\"line\">        sum = lazy = cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Info <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Info &amp;a) &#123;</div><div class=\"line\">        Info rst;</div><div class=\"line\">        rst.sum = sum + a.sum;</div><div class=\"line\">        rst.cnt = cnt + a.cnt;</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; tree[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], n, m, p;</div><div class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> id_data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> fa[MAX], son[MAX], siz[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> deep[MAX], top[MAX], tid[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> _cnt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[o].sum = id_data[l];</div><div class=\"line\">        tree[o].cnt = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[o] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!tree[o].lazy) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> lazy = tree[o].lazy;</div><div class=\"line\">    tree[lson].lazy += lazy;</div><div class=\"line\">    tree[rson].lazy += lazy;</div><div class=\"line\">    tree[lson].sum += lazy * tree[lson].cnt;</div><div class=\"line\">    tree[rson].sum += lazy * tree[rson].cnt;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        tree[o].sum += tree[o].cnt * d;</div><div class=\"line\">        tree[o].lazy += d;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur, d);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, ul, ur, d);</div><div class=\"line\">    tree[o] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; pos || pos &lt; l) <span class=\"keyword\">return</span> Info();</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o];</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, pos) + query(rson, m + <span class=\"number\">1</span>, r, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第一次dfs记录信息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dffs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    siz[u] = <span class=\"number\">1</span>, deep[u] = d;</div><div class=\"line\">    fa[u] = f, son[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (v != f) &#123;</div><div class=\"line\">            dffs(v, u, d + <span class=\"number\">1</span>);</div><div class=\"line\">            siz[u] += siz[v];</div><div class=\"line\">            <span class=\"keyword\">if</span> (son[u] == <span class=\"number\">-1</span> || siz[son[u]] &lt; siz[v]) &#123;</div><div class=\"line\">                son[u] = v;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二次dfs找出重链，进行剖分</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfss</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    top[u] = t, tid[u] = _cnt++;</div><div class=\"line\">    id_data[_cnt - <span class=\"number\">1</span>] = data[u];</div><div class=\"line\">    <span class=\"keyword\">if</span> (son[u] != <span class=\"number\">-1</span>) dfss(son[u], t);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (son[u] != v &amp;&amp; fa[u] != v) dfss(v, v);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splite</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    _cnt = <span class=\"number\">1</span>;</div><div class=\"line\">    dffs(<span class=\"number\">1</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    dfss(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Updata</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> d)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tx = top[x], ty = top[y];</div><div class=\"line\">    <span class=\"keyword\">while</span> (tx != ty) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deep[tx] &lt; deep[ty]) swap(x, y), swap(tx, ty);</div><div class=\"line\">        updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[tx], tid[x], d);</div><div class=\"line\">        x = fa[tx], tx = top[x];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (deep[x] &lt; deep[y]) swap(x, y);</div><div class=\"line\">    updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[y], tid[x], d);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Info Query(int x, int y) &#123;</span></div><div class=\"line\"><span class=\"comment\">//    Info ix, iy;</span></div><div class=\"line\"><span class=\"comment\">//    int tx = top[x], ty = top[y];</span></div><div class=\"line\"><span class=\"comment\">//    while (tx != ty) &#123;</span></div><div class=\"line\"><span class=\"comment\">//        if (deep[tx] &lt; deep[ty]) swap(x, y), swap(tx, ty), swap(ix, iy);</span></div><div class=\"line\"><span class=\"comment\">//        ix = query(1, 1, n, tid[tx], tid[x]) + ix;</span></div><div class=\"line\"><span class=\"comment\">//        x = fa[tx], tx = top[x];</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"><span class=\"comment\">//    if (deep[x] &lt; deep[y]) swap(x, y);</span></div><div class=\"line\"><span class=\"comment\">//    return ix + query(1, 1, n, tid[y], tid[x]) + iy;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">        edge[i].clear();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edge[u].push_back(v);</div><div class=\"line\">        edge[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    splite();</div><div class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"keyword\">while</span> (p--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, str);</div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, tid[a]).sum);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;a, &amp;b, &amp;c);</div><div class=\"line\">            <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) &#123;</div><div class=\"line\">                Updata(a, b, c);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Updata(a, b, -c);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;p)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU4027 - Can you answer these queries? （线段树）","date":"2017-06-21T07:57:00.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4027\n\n-----------------------\n# 题目分析：\n区间开根号下取整，询问区间和。\n\n-----------------------\n# 解题过程：\n注意，进行更新和询问的操作的时候要注意$x$和$y$的大小，这里被坑了，差点以为自己清奇的脑洞不对……\n\n发现好多人都是转化为单点更新，自己比较耿直，写了好长的区间更新代码，也算是一题多解吧。\n\n----------------\n# 题目分析：\n## 单点更新解法：\n首先要注意到对于开根号操作，这里的输入数据大小不会超过$2^{64}$要不就没法玩了，这样的话，对于每个数顶多开$64$次根号。\n\n这样暴力进行单点更新最多也就$O(64\\times nlog(n))$，加上剪枝就可以过，对于每个区间，如果这个区间内的所有数都为$1$，那么这个区间开根号后区间和也没变化了，可以剪枝。\n\n## 区间更新解法：\n因为要进行区间更新，所以要用到lazy标记，但是用lazy标记要保证两个条件，一是标记可以叠加，二是打上标记后可以直接的更新区间维护的信息。\n\n对于开根号操作，好像是不符合第二个条件，对于一个区间打上lazy标记后，不能直接计算出新的区间和。这里想到可以预处理前缀和，因为每个数最多也就开$64$次根号，预处理完对于开$1$到$64$次根号所有的前缀和，这里加下判断，如果所有数都为$1$的话，那么就不需要继续往下计算了。\n\n有了前缀合，那么对于一段区间如果这段区间内所有数字开根号的次数都相同，那么我就可以用前缀和计算出区间和了。所以当一段区间内所有数的开根号次数都一样的话，就可以打lazy标记了。\n\n然后注意更新和合并区间的过程，更新有可能会使一段区间内开根号次数不同，或变得相同，合并区间时要处理一下。\n\n------------------------------------\n# AC代码：\n## 单点更新：\n```cpp\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n\ntypedef long long LL;\n\nconst int MAX = 112345;\n\nstruct Info {\n    LL value;\n}tree[MAX<<2];\n\nLL data[MAX];\n\nvoid build(int root, int l, int r) {\n    if (l == r) {\n        tree[root].value = data[l];\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    if (r < ul || ur < l || tree[root].value <= (r-l+1))\n        return;\n    if (ul <= l && r <= ur && l == r) {\n        tree[root].value = sqrt(tree[root].value);\n        return;\n    }\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m+1, r, ul, ur);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nLL query(int root, int l, int r, int ul, int ur) {\n    if (r < ul || ur < l)\n        return 0;\n    if (ul <= l && r <= ur) {\n        return tree[root].value;\n    }\n    MID;\n    return query(lson, l, m, ul, ur) + query(rson, m+1, r, ul, ur);\n}\n\nint main() {\n    int n, m, cases = 0;\n    while (~scanf(\"%d\", &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld\", &data[i]);\n        }\n        build(1, 1, n);\n        scanf(\"%d\", &m);\n        printf(\"Case #%d:\\n\", ++cases);\n        while (m--) {\n            int top, x, y;\n            scanf(\"%d %d %d\", &top, &x, &y);\n            if (x > y)\n                swap(x, y);\n            if (top) {\n                printf(\"%lld\\n\", query(1, 1, n, x, y));\n            }\n            else {\n                updata(1, 1, n, x ,y);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```\n## 区间更新：\n```cpp\n#include<stdio.h>\n#include<math.h>\n#include <algorithm>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l+r)/2\n\nconst int MAX = 112345;\ntypedef long long LL;\n\nLL pre[64][MAX];\n\nint times;\n\nstruct Info {\n    int lazy, l, r, num;\n    bool ok;\n    LL value;\n    Info() {\n        lazy = l = r = ok = num = value = 0;\n    }\n    void maintain(int v) {\n        num += v;\n        //如果开根号大于times次，那么和开times次相同\n        if (num > times)\n            num = times;\n        value = pre[num][r] - pre[num][l-1];\n    }\n}tree[MAX*4];\n\nvoid push_down(int root) {\n    if (tree[root].lazy) {\n        int v = tree[root].lazy;\n        tree[lson].lazy += v;\n        tree[rson].lazy += v;\n        //打完lazy标记后重新计算下区间和\n        tree[lson].maintain(v);\n        tree[rson].maintain(v);\n        tree[root].lazy = 0;\n    }\n}\n\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.l = a.l;\n    rst.r = b.r;\n    //如果左右儿子开根号次数相同，并且区间内所有元素开根号次数都相同，那么父节点区间内开根号次数都相同\n    rst.ok = (a.num == b.num) && a.ok && b.ok;\n    if (rst.ok) {\n        rst.num = a.num;\n        rst.maintain(0);\n    }\n    return rst;\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    //如果区间内所有元素都为1，那么可以跳过更新\n    if(r-l+1==tree[root].value) return;\n    //如果区间在更新的区间内，并且区间内所有元素开根号次数都相同，那么可以打lazy标记\n    if (ul <= l && r <= ur && tree[root].ok) {\n        tree[root].lazy += 1;\n        tree[root].maintain(1);\n        return;\n    }\n    MID;\n    push_down(root);\n    if (ul <= m) updata(lson, l, m, ul, ur);\n    if (m+1 <= ur) updata(rson, m+1, r, ul, ur);\n\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid build(int root, int l, int r) {\n    tree[root].l = l;\n    tree[root].r = r;\n    tree[root].value = 0;\n    tree[root].lazy = 0;\n    tree[root].ok = 1;\n    tree[root].num = 0;\n    if (l == r) {\n        tree[root].maintain(0);\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nLL query(int root, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr && tree[root].ok) {\n        return tree[root].value;\n    }\n    MID;\n    push_down(root);\n    LL sum = 0;\n    if (ql <= m) sum += query(lson, l, m, ql, qr);\n    if (m+1 <= qr) sum += query(rson, m+1, r, ql, qr);\n    return sum;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld\", &pre[0][i]);\n            pre[1][i] = sqrt(pre[0][i]);\n            pre[0][i] += pre[0][i-1];\n        }\n\n        //处理前缀和\n        for (int i = 1; i <= 64; i++) {\n            bool flag = 0;\n            for (int j = 1; j <= n; j++) {\n                if (pre[i][j] != 1)\n                    flag = 1;\n                pre[i+1][j] = sqrt(pre[i][j]);\n                pre[i][j] += pre[i][j-1];\n            }\n            //如果所有元素均为1，就不用处理后面的前缀和了\n            if (!flag) {\n                //times为最多多少次，所有数字均变为1\n                times = i;\n                break;\n            }\n        }\n\n        build(1, 1, n);\n        int m;\n        scanf(\"%d\", &m);\n        printf(\"Case #%d:\\n\", ++cases);\n        while (m--) {\n            int top, x, y;\n            scanf(\"%d %d %d\", &top, &x, &y);\n            if (x > y)\n                swap(x, y);\n            if (top) {\n                printf(\"%lld\\n\", query(1, 1, n, x, y));\n            }\n            else {\n                updata(1, 1, n, x, y);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```","source":"_posts/HDU4027-Can-you-answer-these-queries-（线段树）.md","raw":"---\ntitle: HDU4027 - Can you answer these queries? （线段树）\ndate: 2017-06-21 15:57:00\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4027\n\n-----------------------\n# 题目分析：\n区间开根号下取整，询问区间和。\n\n-----------------------\n# 解题过程：\n注意，进行更新和询问的操作的时候要注意$x$和$y$的大小，这里被坑了，差点以为自己清奇的脑洞不对……\n\n发现好多人都是转化为单点更新，自己比较耿直，写了好长的区间更新代码，也算是一题多解吧。\n\n----------------\n# 题目分析：\n## 单点更新解法：\n首先要注意到对于开根号操作，这里的输入数据大小不会超过$2^{64}$要不就没法玩了，这样的话，对于每个数顶多开$64$次根号。\n\n这样暴力进行单点更新最多也就$O(64\\times nlog(n))$，加上剪枝就可以过，对于每个区间，如果这个区间内的所有数都为$1$，那么这个区间开根号后区间和也没变化了，可以剪枝。\n\n## 区间更新解法：\n因为要进行区间更新，所以要用到lazy标记，但是用lazy标记要保证两个条件，一是标记可以叠加，二是打上标记后可以直接的更新区间维护的信息。\n\n对于开根号操作，好像是不符合第二个条件，对于一个区间打上lazy标记后，不能直接计算出新的区间和。这里想到可以预处理前缀和，因为每个数最多也就开$64$次根号，预处理完对于开$1$到$64$次根号所有的前缀和，这里加下判断，如果所有数都为$1$的话，那么就不需要继续往下计算了。\n\n有了前缀合，那么对于一段区间如果这段区间内所有数字开根号的次数都相同，那么我就可以用前缀和计算出区间和了。所以当一段区间内所有数的开根号次数都一样的话，就可以打lazy标记了。\n\n然后注意更新和合并区间的过程，更新有可能会使一段区间内开根号次数不同，或变得相同，合并区间时要处理一下。\n\n------------------------------------\n# AC代码：\n## 单点更新：\n```cpp\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n\ntypedef long long LL;\n\nconst int MAX = 112345;\n\nstruct Info {\n    LL value;\n}tree[MAX<<2];\n\nLL data[MAX];\n\nvoid build(int root, int l, int r) {\n    if (l == r) {\n        tree[root].value = data[l];\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    if (r < ul || ur < l || tree[root].value <= (r-l+1))\n        return;\n    if (ul <= l && r <= ur && l == r) {\n        tree[root].value = sqrt(tree[root].value);\n        return;\n    }\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m+1, r, ul, ur);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nLL query(int root, int l, int r, int ul, int ur) {\n    if (r < ul || ur < l)\n        return 0;\n    if (ul <= l && r <= ur) {\n        return tree[root].value;\n    }\n    MID;\n    return query(lson, l, m, ul, ur) + query(rson, m+1, r, ul, ur);\n}\n\nint main() {\n    int n, m, cases = 0;\n    while (~scanf(\"%d\", &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld\", &data[i]);\n        }\n        build(1, 1, n);\n        scanf(\"%d\", &m);\n        printf(\"Case #%d:\\n\", ++cases);\n        while (m--) {\n            int top, x, y;\n            scanf(\"%d %d %d\", &top, &x, &y);\n            if (x > y)\n                swap(x, y);\n            if (top) {\n                printf(\"%lld\\n\", query(1, 1, n, x, y));\n            }\n            else {\n                updata(1, 1, n, x ,y);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```\n## 区间更新：\n```cpp\n#include<stdio.h>\n#include<math.h>\n#include <algorithm>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l+r)/2\n\nconst int MAX = 112345;\ntypedef long long LL;\n\nLL pre[64][MAX];\n\nint times;\n\nstruct Info {\n    int lazy, l, r, num;\n    bool ok;\n    LL value;\n    Info() {\n        lazy = l = r = ok = num = value = 0;\n    }\n    void maintain(int v) {\n        num += v;\n        //如果开根号大于times次，那么和开times次相同\n        if (num > times)\n            num = times;\n        value = pre[num][r] - pre[num][l-1];\n    }\n}tree[MAX*4];\n\nvoid push_down(int root) {\n    if (tree[root].lazy) {\n        int v = tree[root].lazy;\n        tree[lson].lazy += v;\n        tree[rson].lazy += v;\n        //打完lazy标记后重新计算下区间和\n        tree[lson].maintain(v);\n        tree[rson].maintain(v);\n        tree[root].lazy = 0;\n    }\n}\n\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.l = a.l;\n    rst.r = b.r;\n    //如果左右儿子开根号次数相同，并且区间内所有元素开根号次数都相同，那么父节点区间内开根号次数都相同\n    rst.ok = (a.num == b.num) && a.ok && b.ok;\n    if (rst.ok) {\n        rst.num = a.num;\n        rst.maintain(0);\n    }\n    return rst;\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    //如果区间内所有元素都为1，那么可以跳过更新\n    if(r-l+1==tree[root].value) return;\n    //如果区间在更新的区间内，并且区间内所有元素开根号次数都相同，那么可以打lazy标记\n    if (ul <= l && r <= ur && tree[root].ok) {\n        tree[root].lazy += 1;\n        tree[root].maintain(1);\n        return;\n    }\n    MID;\n    push_down(root);\n    if (ul <= m) updata(lson, l, m, ul, ur);\n    if (m+1 <= ur) updata(rson, m+1, r, ul, ur);\n\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid build(int root, int l, int r) {\n    tree[root].l = l;\n    tree[root].r = r;\n    tree[root].value = 0;\n    tree[root].lazy = 0;\n    tree[root].ok = 1;\n    tree[root].num = 0;\n    if (l == r) {\n        tree[root].maintain(0);\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root].value = tree[lson].value + tree[rson].value;\n}\n\nLL query(int root, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr && tree[root].ok) {\n        return tree[root].value;\n    }\n    MID;\n    push_down(root);\n    LL sum = 0;\n    if (ql <= m) sum += query(lson, l, m, ql, qr);\n    if (m+1 <= qr) sum += query(rson, m+1, r, ql, qr);\n    return sum;\n}\n\nint main() {\n    int n, cases = 0;\n    while (~scanf(\"%d\", &n)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld\", &pre[0][i]);\n            pre[1][i] = sqrt(pre[0][i]);\n            pre[0][i] += pre[0][i-1];\n        }\n\n        //处理前缀和\n        for (int i = 1; i <= 64; i++) {\n            bool flag = 0;\n            for (int j = 1; j <= n; j++) {\n                if (pre[i][j] != 1)\n                    flag = 1;\n                pre[i+1][j] = sqrt(pre[i][j]);\n                pre[i][j] += pre[i][j-1];\n            }\n            //如果所有元素均为1，就不用处理后面的前缀和了\n            if (!flag) {\n                //times为最多多少次，所有数字均变为1\n                times = i;\n                break;\n            }\n        }\n\n        build(1, 1, n);\n        int m;\n        scanf(\"%d\", &m);\n        printf(\"Case #%d:\\n\", ++cases);\n        while (m--) {\n            int top, x, y;\n            scanf(\"%d %d %d\", &top, &x, &y);\n            if (x > y)\n                swap(x, y);\n            if (top) {\n                printf(\"%lld\\n\", query(1, 1, n, x, y));\n            }\n            else {\n                updata(1, 1, n, x, y);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```","slug":"HDU4027-Can-you-answer-these-queries-（线段树）","published":1,"updated":"2017-07-23T02:06:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nb50021y9idg7dblxd6","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4027\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4027</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>区间开根号下取整，询问区间和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>注意，进行更新和询问的操作的时候要注意$x$和$y$的大小，这里被坑了，差点以为自己清奇的脑洞不对……</p>\n<p>发现好多人都是转化为单点更新，自己比较耿直，写了好长的区间更新代码，也算是一题多解吧。</p>\n<hr>\n<h1 id=\"题目分析：-1\"><a href=\"#题目分析：-1\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><h2 id=\"单点更新解法：\"><a href=\"#单点更新解法：\" class=\"headerlink\" title=\"单点更新解法：\"></a>单点更新解法：</h2><p>首先要注意到对于开根号操作，这里的输入数据大小不会超过$2^{64}$要不就没法玩了，这样的话，对于每个数顶多开$64$次根号。</p>\n<p>这样暴力进行单点更新最多也就$O(64\\times nlog(n))$，加上剪枝就可以过，对于每个区间，如果这个区间内的所有数都为$1$，那么这个区间开根号后区间和也没变化了，可以剪枝。</p>\n<h2 id=\"区间更新解法：\"><a href=\"#区间更新解法：\" class=\"headerlink\" title=\"区间更新解法：\"></a>区间更新解法：</h2><p>因为要进行区间更新，所以要用到lazy标记，但是用lazy标记要保证两个条件，一是标记可以叠加，二是打上标记后可以直接的更新区间维护的信息。</p>\n<p>对于开根号操作，好像是不符合第二个条件，对于一个区间打上lazy标记后，不能直接计算出新的区间和。这里想到可以预处理前缀和，因为每个数最多也就开$64$次根号，预处理完对于开$1$到$64$次根号所有的前缀和，这里加下判断，如果所有数都为$1$的话，那么就不需要继续往下计算了。</p>\n<p>有了前缀合，那么对于一段区间如果这段区间内所有数字开根号的次数都相同，那么我就可以用前缀和计算出区间和了。所以当一段区间内所有数的开根号次数都一样的话，就可以打lazy标记了。</p>\n<p>然后注意更新和合并区间的过程，更新有可能会使一段区间内开根号次数不同，或变得相同，合并区间时要处理一下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"单点更新：\"><a href=\"#单点更新：\" class=\"headerlink\" title=\"单点更新：\"></a>单点更新：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    LL value;</div><div class=\"line\">&#125;tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">LL data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].value = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l || tree[root].value &lt;= (r-l+<span class=\"number\">1</span>))</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur &amp;&amp; l == r) &#123;</div><div class=\"line\">        tree[root].value = <span class=\"built_in\">sqrt</span>(tree[root].value);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root].value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ul, ur) + query(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> top, x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;top, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y)</div><div class=\"line\">                swap(x, y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (top) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x ,y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"区间更新：\"><a href=\"#区间更新：\" class=\"headerlink\" title=\"区间更新：\"></a>区间更新：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\">LL pre[<span class=\"number\">64</span>][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> times;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> lazy, l, r, num;</div><div class=\"line\">    <span class=\"keyword\">bool</span> ok;</div><div class=\"line\">    LL value;</div><div class=\"line\">    Info() &#123;</div><div class=\"line\">        lazy = l = r = ok = num = value = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">        num += v;</div><div class=\"line\">        <span class=\"comment\">//如果开根号大于times次，那么和开times次相同</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (num &gt; times)</div><div class=\"line\">            num = times;</div><div class=\"line\">        value = pre[num][r] - pre[num][l<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;tree[MAX*<span class=\"number\">4</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[root].lazy) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = tree[root].lazy;</div><div class=\"line\">        tree[lson].lazy += v;</div><div class=\"line\">        tree[rson].lazy += v;</div><div class=\"line\">        <span class=\"comment\">//打完lazy标记后重新计算下区间和</span></div><div class=\"line\">        tree[lson].maintain(v);</div><div class=\"line\">        tree[rson].maintain(v);</div><div class=\"line\">        tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.l = a.l;</div><div class=\"line\">    rst.r = b.r;</div><div class=\"line\">    <span class=\"comment\">//如果左右儿子开根号次数相同，并且区间内所有元素开根号次数都相同，那么父节点区间内开根号次数都相同</span></div><div class=\"line\">    rst.ok = (a.num == b.num) &amp;&amp; a.ok &amp;&amp; b.ok;</div><div class=\"line\">    <span class=\"keyword\">if</span> (rst.ok) &#123;</div><div class=\"line\">        rst.num = a.num;</div><div class=\"line\">        rst.maintain(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果区间内所有元素都为1，那么可以跳过更新</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(r-l+<span class=\"number\">1</span>==tree[root].value) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//如果区间在更新的区间内，并且区间内所有元素开根号次数都相同，那么可以打lazy标记</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur &amp;&amp; tree[root].ok) &#123;</div><div class=\"line\">        tree[root].lazy += <span class=\"number\">1</span>;</div><div class=\"line\">        tree[root].maintain(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= m) updata(lson, l, m, ul, ur);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m+<span class=\"number\">1</span> &lt;= ur) updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\"></div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[root].l = l;</div><div class=\"line\">    tree[root].r = r;</div><div class=\"line\">    tree[root].value = <span class=\"number\">0</span>;</div><div class=\"line\">    tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    tree[root].ok = <span class=\"number\">1</span>;</div><div class=\"line\">    tree[root].num = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; tree[root].ok) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root].value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    LL sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= m) sum += query(lson, l, m, ql, qr);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m+<span class=\"number\">1</span> &lt;= qr) sum += query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;pre[<span class=\"number\">0</span>][i]);</div><div class=\"line\">            pre[<span class=\"number\">1</span>][i] = <span class=\"built_in\">sqrt</span>(pre[<span class=\"number\">0</span>][i]);</div><div class=\"line\">            pre[<span class=\"number\">0</span>][i] += pre[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//处理前缀和</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">64</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">bool</span> flag = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pre[i][j] != <span class=\"number\">1</span>)</div><div class=\"line\">                    flag = <span class=\"number\">1</span>;</div><div class=\"line\">                pre[i+<span class=\"number\">1</span>][j] = <span class=\"built_in\">sqrt</span>(pre[i][j]);</div><div class=\"line\">                pre[i][j] += pre[i][j<span class=\"number\">-1</span>];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//如果所有元素均为1，就不用处理后面的前缀和了</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!flag) &#123;</div><div class=\"line\">                <span class=\"comment\">//times为最多多少次，所有数字均变为1</span></div><div class=\"line\">                times = i;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> top, x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;top, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y)</div><div class=\"line\">                swap(x, y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (top) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4027\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4027</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>区间开根号下取整，询问区间和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>注意，进行更新和询问的操作的时候要注意$x$和$y$的大小，这里被坑了，差点以为自己清奇的脑洞不对……</p>\n<p>发现好多人都是转化为单点更新，自己比较耿直，写了好长的区间更新代码，也算是一题多解吧。</p>\n<hr>\n<h1 id=\"题目分析：-1\"><a href=\"#题目分析：-1\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><h2 id=\"单点更新解法：\"><a href=\"#单点更新解法：\" class=\"headerlink\" title=\"单点更新解法：\"></a>单点更新解法：</h2><p>首先要注意到对于开根号操作，这里的输入数据大小不会超过$2^{64}$要不就没法玩了，这样的话，对于每个数顶多开$64$次根号。</p>\n<p>这样暴力进行单点更新最多也就$O(64\\times nlog(n))$，加上剪枝就可以过，对于每个区间，如果这个区间内的所有数都为$1$，那么这个区间开根号后区间和也没变化了，可以剪枝。</p>\n<h2 id=\"区间更新解法：\"><a href=\"#区间更新解法：\" class=\"headerlink\" title=\"区间更新解法：\"></a>区间更新解法：</h2><p>因为要进行区间更新，所以要用到lazy标记，但是用lazy标记要保证两个条件，一是标记可以叠加，二是打上标记后可以直接的更新区间维护的信息。</p>\n<p>对于开根号操作，好像是不符合第二个条件，对于一个区间打上lazy标记后，不能直接计算出新的区间和。这里想到可以预处理前缀和，因为每个数最多也就开$64$次根号，预处理完对于开$1$到$64$次根号所有的前缀和，这里加下判断，如果所有数都为$1$的话，那么就不需要继续往下计算了。</p>\n<p>有了前缀合，那么对于一段区间如果这段区间内所有数字开根号的次数都相同，那么我就可以用前缀和计算出区间和了。所以当一段区间内所有数的开根号次数都一样的话，就可以打lazy标记了。</p>\n<p>然后注意更新和合并区间的过程，更新有可能会使一段区间内开根号次数不同，或变得相同，合并区间时要处理一下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"单点更新：\"><a href=\"#单点更新：\" class=\"headerlink\" title=\"单点更新：\"></a>单点更新：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    LL value;</div><div class=\"line\">&#125;tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">LL data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].value = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l || tree[root].value &lt;= (r-l+<span class=\"number\">1</span>))</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur &amp;&amp; l == r) &#123;</div><div class=\"line\">        tree[root].value = <span class=\"built_in\">sqrt</span>(tree[root].value);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; ul || ur &lt; l)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root].value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ul, ur) + query(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> top, x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;top, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y)</div><div class=\"line\">                swap(x, y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (top) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x ,y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"区间更新：\"><a href=\"#区间更新：\" class=\"headerlink\" title=\"区间更新：\"></a>区间更新：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\">LL pre[<span class=\"number\">64</span>][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> times;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> lazy, l, r, num;</div><div class=\"line\">    <span class=\"keyword\">bool</span> ok;</div><div class=\"line\">    LL value;</div><div class=\"line\">    Info() &#123;</div><div class=\"line\">        lazy = l = r = ok = num = value = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">        num += v;</div><div class=\"line\">        <span class=\"comment\">//如果开根号大于times次，那么和开times次相同</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (num &gt; times)</div><div class=\"line\">            num = times;</div><div class=\"line\">        value = pre[num][r] - pre[num][l<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;tree[MAX*<span class=\"number\">4</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[root].lazy) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = tree[root].lazy;</div><div class=\"line\">        tree[lson].lazy += v;</div><div class=\"line\">        tree[rson].lazy += v;</div><div class=\"line\">        <span class=\"comment\">//打完lazy标记后重新计算下区间和</span></div><div class=\"line\">        tree[lson].maintain(v);</div><div class=\"line\">        tree[rson].maintain(v);</div><div class=\"line\">        tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.l = a.l;</div><div class=\"line\">    rst.r = b.r;</div><div class=\"line\">    <span class=\"comment\">//如果左右儿子开根号次数相同，并且区间内所有元素开根号次数都相同，那么父节点区间内开根号次数都相同</span></div><div class=\"line\">    rst.ok = (a.num == b.num) &amp;&amp; a.ok &amp;&amp; b.ok;</div><div class=\"line\">    <span class=\"keyword\">if</span> (rst.ok) &#123;</div><div class=\"line\">        rst.num = a.num;</div><div class=\"line\">        rst.maintain(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果区间内所有元素都为1，那么可以跳过更新</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(r-l+<span class=\"number\">1</span>==tree[root].value) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//如果区间在更新的区间内，并且区间内所有元素开根号次数都相同，那么可以打lazy标记</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur &amp;&amp; tree[root].ok) &#123;</div><div class=\"line\">        tree[root].lazy += <span class=\"number\">1</span>;</div><div class=\"line\">        tree[root].maintain(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= m) updata(lson, l, m, ul, ur);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m+<span class=\"number\">1</span> &lt;= ur) updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\"></div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[root].l = l;</div><div class=\"line\">    tree[root].r = r;</div><div class=\"line\">    tree[root].value = <span class=\"number\">0</span>;</div><div class=\"line\">    tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    tree[root].ok = <span class=\"number\">1</span>;</div><div class=\"line\">    tree[root].num = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root].value = tree[lson].value + tree[rson].value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; tree[root].ok) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root].value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    LL sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= m) sum += query(lson, l, m, ql, qr);</div><div class=\"line\">    <span class=\"keyword\">if</span> (m+<span class=\"number\">1</span> &lt;= qr) sum += query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;pre[<span class=\"number\">0</span>][i]);</div><div class=\"line\">            pre[<span class=\"number\">1</span>][i] = <span class=\"built_in\">sqrt</span>(pre[<span class=\"number\">0</span>][i]);</div><div class=\"line\">            pre[<span class=\"number\">0</span>][i] += pre[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//处理前缀和</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">64</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">bool</span> flag = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pre[i][j] != <span class=\"number\">1</span>)</div><div class=\"line\">                    flag = <span class=\"number\">1</span>;</div><div class=\"line\">                pre[i+<span class=\"number\">1</span>][j] = <span class=\"built_in\">sqrt</span>(pre[i][j]);</div><div class=\"line\">                pre[i][j] += pre[i][j<span class=\"number\">-1</span>];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//如果所有元素均为1，就不用处理后面的前缀和了</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!flag) &#123;</div><div class=\"line\">                <span class=\"comment\">//times为最多多少次，所有数字均变为1</span></div><div class=\"line\">                times = i;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> top, x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;top, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y)</div><div class=\"line\">                swap(x, y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (top) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x, y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU4280 - Island Transport（最大流+Dinic模板）","date":"2017-07-27T00:42:16.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4280\n\n---------------------------\n# 题目大意：\n给出$N$个点的坐标和$M$条有容量的边，找出从最西边的点到最东边的点的最大流量。\n\n-------------------------\n# 解题过程：\n自己的 Dinic 板子一直 TLE，然后抄的学长的，于是以后就打算用这个板子搞 Dinic 了。\n\n-----------------------\n# 题目分析：\n略\n\n---------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 100000+100;\n\nstruct Info {\n    int to, cap, nxt;\n} edge[MAX<<1];\n\nint head[MAX], tot;\nint N, M, T;\nint level[MAX];\n\n//用前向星建边\nvoid add_edge(int u, int v, int w) {\n    edge[tot].to = v;\n    edge[tot].cap = w;\n    edge[tot].nxt = head[u];\n    head[u] = tot++;\n\n    edge[tot].to = u;\n    edge[tot].cap = w;\n    edge[tot].nxt = head[v];\n    head[v] = tot++;\n}\n\n//BFS构建层次图\nbool bfs(int s, int e) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].to;\n            if (edge[i].cap > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[e] != -1;\n}\n\nint dfs(int u, int end, int f) {\n    //如果为终点的话就返回流量\n    if (u == end) return f;\n    int flow = 0, d;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].to;\n        //只由低层次的点向高层次的点增广\n        if (edge[i].cap > 0 && level[u] < level[v] && (d = dfs(v, end, min(edge[i].cap, f)))) {\n            edge[i].cap -= d;\n            edge[i^1].cap += d;\n            flow += d;\n            f -= d;\n            if (!f) break;\n        }\n    }\n    //如果当前点的流量为0，那么排除掉这个点\n    if (flow == 0) level[u] = -1;\n    return flow;\n}\n\nint max_flow(int s, int e) {\n    int flow = 0;\n    while (bfs(s, e)) {\n        flow += dfs(s, e, INF);\n    }\n    return flow;\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        tot = 0;\n        scanf(\"%d %d\", &N, &M);\n        int sx = INF, ex = -INF, s, e;\n        for (int i = 1; i <= N; i++) {\n            head[i] = -1;\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            if (x < sx) sx = x, s = i;\n            if (x > ex) ex = x, e = i;\n        }\n        for (int i = 1; i <= M; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            add_edge(u, v, w);\n        }\n        printf(\"%d\\n\", max_flow(s, e));\n    }\n}\n```","source":"_posts/HDU4280-Island-Transport（最大流-Dinic模板）.md","raw":"---\ntitle: HDU4280 - Island Transport（最大流+Dinic模板）\ndate: 2017-07-27 08:42:16\ncategories:  [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4280\n\n---------------------------\n# 题目大意：\n给出$N$个点的坐标和$M$条有容量的边，找出从最西边的点到最东边的点的最大流量。\n\n-------------------------\n# 解题过程：\n自己的 Dinic 板子一直 TLE，然后抄的学长的，于是以后就打算用这个板子搞 Dinic 了。\n\n-----------------------\n# 题目分析：\n略\n\n---------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 100000+100;\n\nstruct Info {\n    int to, cap, nxt;\n} edge[MAX<<1];\n\nint head[MAX], tot;\nint N, M, T;\nint level[MAX];\n\n//用前向星建边\nvoid add_edge(int u, int v, int w) {\n    edge[tot].to = v;\n    edge[tot].cap = w;\n    edge[tot].nxt = head[u];\n    head[u] = tot++;\n\n    edge[tot].to = u;\n    edge[tot].cap = w;\n    edge[tot].nxt = head[v];\n    head[v] = tot++;\n}\n\n//BFS构建层次图\nbool bfs(int s, int e) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].to;\n            if (edge[i].cap > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[e] != -1;\n}\n\nint dfs(int u, int end, int f) {\n    //如果为终点的话就返回流量\n    if (u == end) return f;\n    int flow = 0, d;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].to;\n        //只由低层次的点向高层次的点增广\n        if (edge[i].cap > 0 && level[u] < level[v] && (d = dfs(v, end, min(edge[i].cap, f)))) {\n            edge[i].cap -= d;\n            edge[i^1].cap += d;\n            flow += d;\n            f -= d;\n            if (!f) break;\n        }\n    }\n    //如果当前点的流量为0，那么排除掉这个点\n    if (flow == 0) level[u] = -1;\n    return flow;\n}\n\nint max_flow(int s, int e) {\n    int flow = 0;\n    while (bfs(s, e)) {\n        flow += dfs(s, e, INF);\n    }\n    return flow;\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        tot = 0;\n        scanf(\"%d %d\", &N, &M);\n        int sx = INF, ex = -INF, s, e;\n        for (int i = 1; i <= N; i++) {\n            head[i] = -1;\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            if (x < sx) sx = x, s = i;\n            if (x > ex) ex = x, e = i;\n        }\n        for (int i = 1; i <= M; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            add_edge(u, v, w);\n        }\n        printf(\"%d\\n\", max_flow(s, e));\n    }\n}\n```","slug":"HDU4280-Island-Transport（最大流-Dinic模板）","published":1,"updated":"2017-07-27T00:46:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nb60023y9id0jyto4wg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4280\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4280</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出$N$个点的坐标和$M$条有容量的边，找出从最西边的点到最东边的点的最大流量。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己的 Dinic 板子一直 TLE，然后抄的学长的，于是以后就打算用这个板子搞 Dinic 了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>略</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, cap, nxt;</div><div class=\"line\">&#125; edge[MAX&lt;&lt;<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], tot;</div><div class=\"line\"><span class=\"keyword\">int</span> N, M, T;</div><div class=\"line\"><span class=\"keyword\">int</span> level[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用前向星建边</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[tot].to = v;</div><div class=\"line\">    edge[tot].cap = w;</div><div class=\"line\">    edge[tot].nxt = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\"></div><div class=\"line\">    edge[tot].to = u;</div><div class=\"line\">    edge[tot].cap = w;</div><div class=\"line\">    edge[tot].nxt = head[v];</div><div class=\"line\">    head[v] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//BFS构建层次图</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(level, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(level));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    level[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                level[v] = level[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> level[e] != <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果为终点的话就返回流量</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end) <span class=\"keyword\">return</span> f;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">        <span class=\"comment\">//只由低层次的点向高层次的点增广</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; level[u] &lt; level[v] &amp;&amp; (d = dfs(v, end, min(edge[i].cap, f)))) &#123;</div><div class=\"line\">            edge[i].cap -= d;</div><div class=\"line\">            edge[i^<span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            flow += d;</div><div class=\"line\">            f -= d;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果当前点的流量为0，那么排除掉这个点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (flow == <span class=\"number\">0</span>) level[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (bfs(s, e)) &#123;</div><div class=\"line\">        flow += dfs(s, e, INF);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        tot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">        <span class=\"keyword\">int</span> sx = INF, ex = -INF, s, e;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            head[i] = <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &lt; sx) sx = x, s = i;</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; ex) ex = x, e = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            add_edge(u, v, w);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(s, e));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4280\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4280</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出$N$个点的坐标和$M$条有容量的边，找出从最西边的点到最东边的点的最大流量。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己的 Dinic 板子一直 TLE，然后抄的学长的，于是以后就打算用这个板子搞 Dinic 了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>略</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, cap, nxt;</div><div class=\"line\">&#125; edge[MAX&lt;&lt;<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], tot;</div><div class=\"line\"><span class=\"keyword\">int</span> N, M, T;</div><div class=\"line\"><span class=\"keyword\">int</span> level[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用前向星建边</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[tot].to = v;</div><div class=\"line\">    edge[tot].cap = w;</div><div class=\"line\">    edge[tot].nxt = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\"></div><div class=\"line\">    edge[tot].to = u;</div><div class=\"line\">    edge[tot].cap = w;</div><div class=\"line\">    edge[tot].nxt = head[v];</div><div class=\"line\">    head[v] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//BFS构建层次图</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(level, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(level));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    level[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                level[v] = level[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> level[e] != <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果为终点的话就返回流量</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end) <span class=\"keyword\">return</span> f;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">        <span class=\"comment\">//只由低层次的点向高层次的点增广</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; level[u] &lt; level[v] &amp;&amp; (d = dfs(v, end, min(edge[i].cap, f)))) &#123;</div><div class=\"line\">            edge[i].cap -= d;</div><div class=\"line\">            edge[i^<span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            flow += d;</div><div class=\"line\">            f -= d;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//如果当前点的流量为0，那么排除掉这个点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (flow == <span class=\"number\">0</span>) level[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (bfs(s, e)) &#123;</div><div class=\"line\">        flow += dfs(s, e, INF);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        tot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">        <span class=\"keyword\">int</span> sx = INF, ex = -INF, s, e;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            head[i] = <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &lt; sx) sx = x, s = i;</div><div class=\"line\">            <span class=\"keyword\">if</span> (x &gt; ex) ex = x, e = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            add_edge(u, v, w);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(s, e));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU4819 - Mosaic（二维线段树-单点更新区间查询 + 模板）","date":"2017-10-27T10:11:19.000Z","_content":"# 题目链接：\n\nhttps://vjudge.net/problem/HDU-4819\n\n\n\n# 题目大意：\n\n给出一个 n * n 的矩阵，每个位置有一个整数值。进行 q 次操作，每次选矩阵的一个元素为中心，取以这个元素为中心的 L * L 的最大值和最小值，将这个元素的值赋值成最大值最小值的平均值。\n\n$n \\le 800, q \\le 100000$\n\n\n\n# 题目分析：\n\n裸的二维线段树，单点修改，询问区间最值。\n\n其实二维的线段树就是一个行线段树套列线段树，注意进行更新的时候，不能直接赋值修改，只修改行线段树叶子节点里面列线段树的叶子节点，然后向上合并。\n\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 1010;\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l + r) >> 1\n\n\n//列线段树，用来维护列的节点\nstruct Nodey {\n    int Max, Min;\n\n    Nodey operator+(const struct Nodey &t) {\n        Nodey rst;\n        rst.Max = max(Max, t.Max);\n        rst.Min = min(Min, t.Min);\n        return rst;\n    }\n};\n\nint locy[MAX], locx[MAX];\n\n\n//行线段树，用来维护行的节点\nstruct Nodex {\n    Nodey sty[MAX << 2];\n\n    void build(int o, int l, int r) {\n        sty[o].Max = -INF;\n        sty[o].Min = INF;\n        if (l == r) {\n            locy[l] = o;\n            return;\n        }\n        MID;\n        build(lson, l, m);\n        build(rson, m + 1, r);\n    }\n\n    Nodey query(int o, int l, int r, int ql, int qr) {\n        if (qr < l || r < ql) return (Nodey) {-INF, INF};\n        if (ql <= l && r <= qr) return sty[o];\n        MID;\n        return query(lson, l, m, ql, qr) + query(rson, m + 1, r, ql, qr);\n    }\n} stx[MAX << 2];\n\nint n;\n\nvoid build(int o, int l, int r) {\n    stx[o].build(1, 1, n);\n    if (l == r) {\n        locx[l] = o;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\n\n//进行单点更新，这里首先更新了叶子节点，然后向上合并父亲节点；\nvoid Modify(int x, int y, int val) {\n    int tx = locx[x];\n    int ty = locx[y];\n    stx[tx].sty[ty].Min = stx[tx].sty[ty].Max = val;\n    for (int i = tx; i; i >>= 1) {\n        for (int j = ty; j; j >>= 1) {\n            if (i == tx && j == ty) continue;\n            if (j == ty) {\n                //如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新信息\n                stx[i].sty[j] = stx[i << 1].sty[j] + stx[i << 1 | 1].sty[j];\n            } else {\n                //否则由当前列的如果儿子节点来更新\n                stx[i].sty[j] = stx[i].sty[j << 1] +  stx[i].sty[j << 1 | 1];\n            }\n        }\n    }\n}\n\nNodey query(int o, int l, int r, int ql, int qr, int y1, int y2) {\n    if (qr < l || r < ql) return (Nodey) {-INF, INF};\n    if (ql <= l && r <= qr) return stx[o].query(1, 1, n, y1, y2);\n    MID;\n    return query(lson, l, m, ql, qr, y1, y2) + query(rson, m + 1, r, ql, qr, y1, y2);\n}\n\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    int Case = 0;\n    while (T--) {\n        Case++;\n        printf(\"Case #%d:\\n\", Case);\n        scanf(\"%d\", &n);\n        build(1, 1, n);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                int a;\n                scanf(\"%d\", &a);\n                Modify(i, j, a);\n            }\n        }\n        int q;\n        int x, y, L;\n        scanf(\"%d\", &q);\n        while (q--) {\n            scanf(\"%d %d %d\", &x, &y, &L);\n            int x1 = max(x - L / 2, 1);\n            int x2 = min(x + L / 2, n);\n            int y1 = max(y - L / 2, 1);\n            int y2 = min(y + L / 2, n);\n            Nodey ans = query(1, 1, n, x1, x2, y1, y2);\n            int t = (ans.Max + ans.Min) / 2;\n            printf(\"%d\\n\", t);\n            Modify(x, y, t);\n        }\n    }\n}\n```\n# 解题过程：\n\n晚上模拟赛的题，感觉是一个二维线段树的裸题，但是不会，马上要去CCPC秦皇岛了，现学的。","source":"_posts/HDU4819-Mosaic（二维线段树-单点更新区间查询-模板）.md","raw":"---\ntitle: HDU4819 - Mosaic（二维线段树-单点更新区间查询 + 模板）\ndate: 2017-10-27 18:11:19\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\n\nhttps://vjudge.net/problem/HDU-4819\n\n\n\n# 题目大意：\n\n给出一个 n * n 的矩阵，每个位置有一个整数值。进行 q 次操作，每次选矩阵的一个元素为中心，取以这个元素为中心的 L * L 的最大值和最小值，将这个元素的值赋值成最大值最小值的平均值。\n\n$n \\le 800, q \\le 100000$\n\n\n\n# 题目分析：\n\n裸的二维线段树，单点修改，询问区间最值。\n\n其实二维的线段树就是一个行线段树套列线段树，注意进行更新的时候，不能直接赋值修改，只修改行线段树叶子节点里面列线段树的叶子节点，然后向上合并。\n\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 1010;\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l + r) >> 1\n\n\n//列线段树，用来维护列的节点\nstruct Nodey {\n    int Max, Min;\n\n    Nodey operator+(const struct Nodey &t) {\n        Nodey rst;\n        rst.Max = max(Max, t.Max);\n        rst.Min = min(Min, t.Min);\n        return rst;\n    }\n};\n\nint locy[MAX], locx[MAX];\n\n\n//行线段树，用来维护行的节点\nstruct Nodex {\n    Nodey sty[MAX << 2];\n\n    void build(int o, int l, int r) {\n        sty[o].Max = -INF;\n        sty[o].Min = INF;\n        if (l == r) {\n            locy[l] = o;\n            return;\n        }\n        MID;\n        build(lson, l, m);\n        build(rson, m + 1, r);\n    }\n\n    Nodey query(int o, int l, int r, int ql, int qr) {\n        if (qr < l || r < ql) return (Nodey) {-INF, INF};\n        if (ql <= l && r <= qr) return sty[o];\n        MID;\n        return query(lson, l, m, ql, qr) + query(rson, m + 1, r, ql, qr);\n    }\n} stx[MAX << 2];\n\nint n;\n\nvoid build(int o, int l, int r) {\n    stx[o].build(1, 1, n);\n    if (l == r) {\n        locx[l] = o;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\n\n//进行单点更新，这里首先更新了叶子节点，然后向上合并父亲节点；\nvoid Modify(int x, int y, int val) {\n    int tx = locx[x];\n    int ty = locx[y];\n    stx[tx].sty[ty].Min = stx[tx].sty[ty].Max = val;\n    for (int i = tx; i; i >>= 1) {\n        for (int j = ty; j; j >>= 1) {\n            if (i == tx && j == ty) continue;\n            if (j == ty) {\n                //如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新信息\n                stx[i].sty[j] = stx[i << 1].sty[j] + stx[i << 1 | 1].sty[j];\n            } else {\n                //否则由当前列的如果儿子节点来更新\n                stx[i].sty[j] = stx[i].sty[j << 1] +  stx[i].sty[j << 1 | 1];\n            }\n        }\n    }\n}\n\nNodey query(int o, int l, int r, int ql, int qr, int y1, int y2) {\n    if (qr < l || r < ql) return (Nodey) {-INF, INF};\n    if (ql <= l && r <= qr) return stx[o].query(1, 1, n, y1, y2);\n    MID;\n    return query(lson, l, m, ql, qr, y1, y2) + query(rson, m + 1, r, ql, qr, y1, y2);\n}\n\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    int Case = 0;\n    while (T--) {\n        Case++;\n        printf(\"Case #%d:\\n\", Case);\n        scanf(\"%d\", &n);\n        build(1, 1, n);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                int a;\n                scanf(\"%d\", &a);\n                Modify(i, j, a);\n            }\n        }\n        int q;\n        int x, y, L;\n        scanf(\"%d\", &q);\n        while (q--) {\n            scanf(\"%d %d %d\", &x, &y, &L);\n            int x1 = max(x - L / 2, 1);\n            int x2 = min(x + L / 2, n);\n            int y1 = max(y - L / 2, 1);\n            int y2 = min(y + L / 2, n);\n            Nodey ans = query(1, 1, n, x1, x2, y1, y2);\n            int t = (ans.Max + ans.Min) / 2;\n            printf(\"%d\\n\", t);\n            Modify(x, y, t);\n        }\n    }\n}\n```\n# 解题过程：\n\n晚上模拟赛的题，感觉是一个二维线段树的裸题，但是不会，马上要去CCPC秦皇岛了，现学的。","slug":"HDU4819-Mosaic（二维线段树-单点更新区间查询-模板）","published":1,"updated":"2017-10-27T10:26:46.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nba0026y9id3x9mz2pg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HDU-4819\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HDU-4819</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个 n <em> n 的矩阵，每个位置有一个整数值。进行 q 次操作，每次选矩阵的一个元素为中心，取以这个元素为中心的 L </em> L 的最大值和最小值，将这个元素的值赋值成最大值最小值的平均值。</p>\n<p>$n \\le 800, q \\le 100000$</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>裸的二维线段树，单点修改，询问区间最值。</p>\n<p>其实二维的线段树就是一个行线段树套列线段树，注意进行更新的时候，不能直接赋值修改，只修改行线段树叶子节点里面列线段树的叶子节点，然后向上合并。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1010</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) &gt;&gt; 1</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//列线段树，用来维护列的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Nodey</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> Max, Min;</div><div class=\"line\"></div><div class=\"line\">    Nodey <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> struct Nodey &amp;t) &#123;</div><div class=\"line\">        Nodey rst;</div><div class=\"line\">        rst.Max = max(Max, t.Max);</div><div class=\"line\">        rst.Min = min(Min, t.Min);</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> locy[MAX], locx[MAX];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//行线段树，用来维护行的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Nodex</span> &#123;</span></div><div class=\"line\">    Nodey sty[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">        sty[o].Max = -INF;</div><div class=\"line\">        sty[o].Min = INF;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">            locy[l] = o;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        MID;</div><div class=\"line\">        build(lson, l, m);</div><div class=\"line\">        build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Nodey <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> (Nodey) &#123;-INF, INF&#125;;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class=\"keyword\">return</span> sty[o];</div><div class=\"line\">        MID;</div><div class=\"line\">        <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m + <span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; stx[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    stx[o].build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        locx[l] = o;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行单点更新，这里首先更新了叶子节点，然后向上合并父亲节点；</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Modify</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tx = locx[x];</div><div class=\"line\">    <span class=\"keyword\">int</span> ty = locx[y];</div><div class=\"line\">    stx[tx].sty[ty].Min = stx[tx].sty[ty].Max = val;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = tx; i; i &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = ty; j; j &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == tx &amp;&amp; j == ty) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j == ty) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新信息</span></div><div class=\"line\">                stx[i].sty[j] = stx[i &lt;&lt; <span class=\"number\">1</span>].sty[j] + stx[i &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sty[j];</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//否则由当前列的如果儿子节点来更新</span></div><div class=\"line\">                stx[i].sty[j] = stx[i].sty[j &lt;&lt; <span class=\"number\">1</span>] +  stx[i].sty[j &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Nodey <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr, <span class=\"keyword\">int</span> y1, <span class=\"keyword\">int</span> y2)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> (Nodey) &#123;-INF, INF&#125;;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class=\"keyword\">return</span> stx[o].query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, y1, y2);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr, y1, y2) + query(rson, m + <span class=\"number\">1</span>, r, ql, qr, y1, y2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">int</span> Case = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        Case++;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, Case);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> a;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</div><div class=\"line\">                Modify(i, j, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> q;</div><div class=\"line\">        <span class=\"keyword\">int</span> x, y, L;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">        <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;L);</div><div class=\"line\">            <span class=\"keyword\">int</span> x1 = max(x - L / <span class=\"number\">2</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> x2 = min(x + L / <span class=\"number\">2</span>, n);</div><div class=\"line\">            <span class=\"keyword\">int</span> y1 = max(y - L / <span class=\"number\">2</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> y2 = min(y + L / <span class=\"number\">2</span>, n);</div><div class=\"line\">            Nodey ans = query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x1, x2, y1, y2);</div><div class=\"line\">            <span class=\"keyword\">int</span> t = (ans.Max + ans.Min) / <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, t);</div><div class=\"line\">            Modify(x, y, t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>晚上模拟赛的题，感觉是一个二维线段树的裸题，但是不会，马上要去CCPC秦皇岛了，现学的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HDU-4819\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HDU-4819</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个 n <em> n 的矩阵，每个位置有一个整数值。进行 q 次操作，每次选矩阵的一个元素为中心，取以这个元素为中心的 L </em> L 的最大值和最小值，将这个元素的值赋值成最大值最小值的平均值。</p>\n<p>$n \\le 800, q \\le 100000$</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>裸的二维线段树，单点修改，询问区间最值。</p>\n<p>其实二维的线段树就是一个行线段树套列线段树，注意进行更新的时候，不能直接赋值修改，只修改行线段树叶子节点里面列线段树的叶子节点，然后向上合并。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1010</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) &gt;&gt; 1</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//列线段树，用来维护列的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Nodey</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> Max, Min;</div><div class=\"line\"></div><div class=\"line\">    Nodey <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> struct Nodey &amp;t) &#123;</div><div class=\"line\">        Nodey rst;</div><div class=\"line\">        rst.Max = max(Max, t.Max);</div><div class=\"line\">        rst.Min = min(Min, t.Min);</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> locy[MAX], locx[MAX];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//行线段树，用来维护行的节点</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Nodex</span> &#123;</span></div><div class=\"line\">    Nodey sty[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">        sty[o].Max = -INF;</div><div class=\"line\">        sty[o].Min = INF;</div><div class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">            locy[l] = o;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        MID;</div><div class=\"line\">        build(lson, l, m);</div><div class=\"line\">        build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Nodey <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> (Nodey) &#123;-INF, INF&#125;;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class=\"keyword\">return</span> sty[o];</div><div class=\"line\">        MID;</div><div class=\"line\">        <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m + <span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; stx[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    stx[o].build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        locx[l] = o;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//进行单点更新，这里首先更新了叶子节点，然后向上合并父亲节点；</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Modify</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tx = locx[x];</div><div class=\"line\">    <span class=\"keyword\">int</span> ty = locx[y];</div><div class=\"line\">    stx[tx].sty[ty].Min = stx[tx].sty[ty].Max = val;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = tx; i; i &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = ty; j; j &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == tx &amp;&amp; j == ty) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j == ty) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新信息</span></div><div class=\"line\">                stx[i].sty[j] = stx[i &lt;&lt; <span class=\"number\">1</span>].sty[j] + stx[i &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sty[j];</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//否则由当前列的如果儿子节点来更新</span></div><div class=\"line\">                stx[i].sty[j] = stx[i].sty[j &lt;&lt; <span class=\"number\">1</span>] +  stx[i].sty[j &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Nodey <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr, <span class=\"keyword\">int</span> y1, <span class=\"keyword\">int</span> y2)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> (Nodey) &#123;-INF, INF&#125;;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class=\"keyword\">return</span> stx[o].query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, y1, y2);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr, y1, y2) + query(rson, m + <span class=\"number\">1</span>, r, ql, qr, y1, y2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">int</span> Case = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        Case++;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, Case);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> a;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</div><div class=\"line\">                Modify(i, j, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> q;</div><div class=\"line\">        <span class=\"keyword\">int</span> x, y, L;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">        <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;L);</div><div class=\"line\">            <span class=\"keyword\">int</span> x1 = max(x - L / <span class=\"number\">2</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> x2 = min(x + L / <span class=\"number\">2</span>, n);</div><div class=\"line\">            <span class=\"keyword\">int</span> y1 = max(y - L / <span class=\"number\">2</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">int</span> y2 = min(y + L / <span class=\"number\">2</span>, n);</div><div class=\"line\">            Nodey ans = query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, x1, x2, y1, y2);</div><div class=\"line\">            <span class=\"keyword\">int</span> t = (ans.Max + ans.Min) / <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, t);</div><div class=\"line\">            Modify(x, y, t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>晚上模拟赛的题，感觉是一个二维线段树的裸题，但是不会，马上要去CCPC秦皇岛了，现学的。</p>\n"},{"title":"HDU4289 - Control（最大流最小割）","date":"2017-08-08T02:56:44.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4289\n\n--------------------\n# 题目大意：\n给出一个无向图，每个点有点权，要删除一些点使得A、B两点不再连通，问最小权值和。\n\n-------------------\n# 解题过程：\n想到大概是网络流，但是不知道该怎么建图，最后没做出来，看了题解后才发现，原来花费可以和容量交换一下....\n\n--------------------\n# 题目分析：\n对于每个点拆成入点和出点，中间建一条容量为点权的边。\n对原图的无向边(u,v)对u的出点建一条到v的入点边，对v的出点建一条到u的入点的边，容量为无穷大。\n\n这样问题就转化为，要用一些点的入点和出点之间的边去阻塞路径，阻塞所需要的流量就是所需要的花费，要最小花费就是求最小割。\n\n----------------------\n# AC代码：\n```cpp\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int INF = 0x3f3f3f3f;\n\nstruct Node {\n    int v, nxt, cap;\n} edge[MAX * MAX];\n\nint head[MAX], etot;\nint level[MAX];\n\nvoid add_edge(int u, int v, int cap1) {\n    edge[etot].v = v;\n    edge[etot].cap = cap1;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n\n    edge[etot].v = u;\n    edge[etot].cap = 0;\n    edge[etot].nxt = head[v];\n    head[v] = etot++;\n}\n\nbool bfs(int s, int t) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    q.push(s);\n    level[s] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            int cap = edge[i].cap;\n            if (cap > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[t] != -1;\n}\n\nint dfs(int u, int end, int f) {\n    if (u == end) return f;\n    int flow = 0, d;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        int cap = edge[i].cap;\n        if (cap > 0 && level[v] > level[u] && (d = dfs(v, end, min(f, cap)))) {\n            edge[i].cap -= d;\n            edge[i ^ 1].cap += d;\n            flow += d;\n            f -= d;\n            if (!f) break;\n        }\n    }\n    if (flow == 0) level[u] = -1;\n    return flow;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (bfs(s, t)) {\n        flow += dfs(s, t, INF);\n    }\n    return flow;\n}\n\nint main() {\n    int n, m, s, t;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        memset(head, -1, sizeof(head));\n        etot = 0;\n        scanf(\"%d %d\", &s, &t);\n\n        for (int i = 1; i <= n; i++) {\n            int cost;\n            scanf(\"%d\", &cost);\n            //对入点和出点建边，费用为点权\n            add_edge(i, i + n, cost);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            //对原图的边建两条容量为无穷大的边\n            add_edge(u + n, v, INF);\n            add_edge(v + n, u, INF);\n        }\n\n        //求得的最小割即为答案\n        printf(\"%d\\n\", max_flow(s, t + n));\n    }\n}\n```","source":"_posts/HDU4289-Control（最大流最小割）.md","raw":"---\ntitle: HDU4289 - Control（最大流最小割）\ndate: 2017-08-08 10:56:44\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4289\n\n--------------------\n# 题目大意：\n给出一个无向图，每个点有点权，要删除一些点使得A、B两点不再连通，问最小权值和。\n\n-------------------\n# 解题过程：\n想到大概是网络流，但是不知道该怎么建图，最后没做出来，看了题解后才发现，原来花费可以和容量交换一下....\n\n--------------------\n# 题目分析：\n对于每个点拆成入点和出点，中间建一条容量为点权的边。\n对原图的无向边(u,v)对u的出点建一条到v的入点边，对v的出点建一条到u的入点的边，容量为无穷大。\n\n这样问题就转化为，要用一些点的入点和出点之间的边去阻塞路径，阻塞所需要的流量就是所需要的花费，要最小花费就是求最小割。\n\n----------------------\n# AC代码：\n```cpp\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int INF = 0x3f3f3f3f;\n\nstruct Node {\n    int v, nxt, cap;\n} edge[MAX * MAX];\n\nint head[MAX], etot;\nint level[MAX];\n\nvoid add_edge(int u, int v, int cap1) {\n    edge[etot].v = v;\n    edge[etot].cap = cap1;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n\n    edge[etot].v = u;\n    edge[etot].cap = 0;\n    edge[etot].nxt = head[v];\n    head[v] = etot++;\n}\n\nbool bfs(int s, int t) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    q.push(s);\n    level[s] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            int cap = edge[i].cap;\n            if (cap > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[t] != -1;\n}\n\nint dfs(int u, int end, int f) {\n    if (u == end) return f;\n    int flow = 0, d;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        int cap = edge[i].cap;\n        if (cap > 0 && level[v] > level[u] && (d = dfs(v, end, min(f, cap)))) {\n            edge[i].cap -= d;\n            edge[i ^ 1].cap += d;\n            flow += d;\n            f -= d;\n            if (!f) break;\n        }\n    }\n    if (flow == 0) level[u] = -1;\n    return flow;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (bfs(s, t)) {\n        flow += dfs(s, t, INF);\n    }\n    return flow;\n}\n\nint main() {\n    int n, m, s, t;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        memset(head, -1, sizeof(head));\n        etot = 0;\n        scanf(\"%d %d\", &s, &t);\n\n        for (int i = 1; i <= n; i++) {\n            int cost;\n            scanf(\"%d\", &cost);\n            //对入点和出点建边，费用为点权\n            add_edge(i, i + n, cost);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            //对原图的边建两条容量为无穷大的边\n            add_edge(u + n, v, INF);\n            add_edge(v + n, u, INF);\n        }\n\n        //求得的最小割即为答案\n        printf(\"%d\\n\", max_flow(s, t + n));\n    }\n}\n```","slug":"HDU4289-Control（最大流最小割）","published":1,"updated":"2017-08-08T03:04:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbd0028y9idev6nn6e8","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4289\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4289</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个无向图，每个点有点权，要删除一些点使得A、B两点不再连通，问最小权值和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想到大概是网络流，但是不知道该怎么建图，最后没做出来，看了题解后才发现，原来花费可以和容量交换一下….</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对于每个点拆成入点和出点，中间建一条容量为点权的边。<br>对原图的无向边(u,v)对u的出点建一条到v的入点边，对v的出点建一条到u的入点的边，容量为无穷大。</p>\n<p>这样问题就转化为，要用一些点的入点和出点之间的边去阻塞路径，阻塞所需要的流量就是所需要的花费，要最小花费就是求最小割。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, nxt, cap;</div><div class=\"line\">&#125; edge[MAX * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> level[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> cap1)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].cap = cap1;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\"></div><div class=\"line\">    edge[etot].v = u;</div><div class=\"line\">    edge[etot].cap = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[etot].nxt = head[v];</div><div class=\"line\">    head[v] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(level, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(level));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    level[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">int</span> cap = edge[i].cap;</div><div class=\"line\">            <span class=\"keyword\">if</span> (cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                level[v] = level[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> level[t] != <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end) <span class=\"keyword\">return</span> f;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">int</span> cap = edge[i].cap;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] &gt; level[u] &amp;&amp; (d = dfs(v, end, min(f, cap)))) &#123;</div><div class=\"line\">            edge[i].cap -= d;</div><div class=\"line\">            edge[i ^ <span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            flow += d;</div><div class=\"line\">            f -= d;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flow == <span class=\"number\">0</span>) level[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (bfs(s, t)) &#123;</div><div class=\"line\">        flow += dfs(s, t, INF);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, s, t;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;s, &amp;t);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cost;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;cost);</div><div class=\"line\">            <span class=\"comment\">//对入点和出点建边，费用为点权</span></div><div class=\"line\">            add_edge(i, i + n, cost);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            <span class=\"comment\">//对原图的边建两条容量为无穷大的边</span></div><div class=\"line\">            add_edge(u + n, v, INF);</div><div class=\"line\">            add_edge(v + n, u, INF);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//求得的最小割即为答案</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(s, t + n));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4289\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4289</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个无向图，每个点有点权，要删除一些点使得A、B两点不再连通，问最小权值和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想到大概是网络流，但是不知道该怎么建图，最后没做出来，看了题解后才发现，原来花费可以和容量交换一下….</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对于每个点拆成入点和出点，中间建一条容量为点权的边。<br>对原图的无向边(u,v)对u的出点建一条到v的入点边，对v的出点建一条到u的入点的边，容量为无穷大。</p>\n<p>这样问题就转化为，要用一些点的入点和出点之间的边去阻塞路径，阻塞所需要的流量就是所需要的花费，要最小花费就是求最小割。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, nxt, cap;</div><div class=\"line\">&#125; edge[MAX * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> level[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> cap1)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].cap = cap1;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\"></div><div class=\"line\">    edge[etot].v = u;</div><div class=\"line\">    edge[etot].cap = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[etot].nxt = head[v];</div><div class=\"line\">    head[v] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(level, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(level));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    level[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">int</span> cap = edge[i].cap;</div><div class=\"line\">            <span class=\"keyword\">if</span> (cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                level[v] = level[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> level[t] != <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end) <span class=\"keyword\">return</span> f;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>, d;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">int</span> cap = edge[i].cap;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cap &gt; <span class=\"number\">0</span> &amp;&amp; level[v] &gt; level[u] &amp;&amp; (d = dfs(v, end, min(f, cap)))) &#123;</div><div class=\"line\">            edge[i].cap -= d;</div><div class=\"line\">            edge[i ^ <span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            flow += d;</div><div class=\"line\">            f -= d;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (flow == <span class=\"number\">0</span>) level[u] = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (bfs(s, t)) &#123;</div><div class=\"line\">        flow += dfs(s, t, INF);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, s, t;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;s, &amp;t);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cost;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;cost);</div><div class=\"line\">            <span class=\"comment\">//对入点和出点建边，费用为点权</span></div><div class=\"line\">            add_edge(i, i + n, cost);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">            <span class=\"comment\">//对原图的边建两条容量为无穷大的边</span></div><div class=\"line\">            add_edge(u + n, v, INF);</div><div class=\"line\">            add_edge(v + n, u, INF);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//求得的最小割即为答案</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(s, t + n));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU4288 - Coder（线段树）","date":"2017-08-08T02:43:50.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4288\n\n--------------------\n# 题目大意：\n给出一个有小到大排序的集合，初始化为空。\n\n三种操作：\n1. 插入一个数。\n2. 删除一个数。\n3. 询问 $\\sum_{1 \\le i \\le k} a_i, \\text{where} i \\mod 5 = 3$\n\n-------------------\n# 解题过程：\n当初好多人都是暴力水过去的，然后刚开始看错了题意，然后试了好多次都不行...\n然后重新写暴力TLE，最后没时间也放弃了，比赛后就直接用线段树去补了。\n\n--------------------\n# 题目分析：\n由于集合是有序的，先离散化输入的数据，用线段树去维护这个列表。\n\n用线段树去维护两个值，一个是线段树当前区间内已经插入的数字个数，一个是区间内下标%5分别等于0~4的已插入的元素的和。\n\n然后合并的时候父节点的`sum[i] =  sum1[i] + sum2[((i-cnt1)%5+5)%5]`，cnt1为左儿子插入的元素个数。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 112345;\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l + r) >> 1\n\nstruct Node {\n    ll sum[5];\n    int cnt;\n} tree[MAX<<2];\n\nvoid merge(int o) {\n    //进行合并，可以理解成，左儿子插入过了几个元素，右儿子要找的位置就要向左移几次\n    for (int i = 0; i < 5; i++) {\n        tree[o].sum[i] = tree[lson].sum[i]\n                         + tree[rson].sum[((i - tree[lson].cnt) % 5 + 5) % 5];\n    }\n}\n\nvoid build(int o, int l, int r) {\n    tree[o].cnt = 0;\n    memset(tree[o].sum, 0, sizeof(tree[o].sum));\n    if (l == r) return;\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\nvoid updata(int o, int l, int r, int pos, int v) {\n    if (r < pos || pos < l) return;\n    //记录插入的元素个数\n    tree[o].cnt += v > 0 ? 1 : -1;\n    if (l == r) {\n        //区间长度为1时，只有下标%5=1的元素\n        tree[o].sum[1] += v;\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos, v);\n    updata(rson, m + 1, r, pos, v);\n    merge(o);\n}\n\nint n;\nchar op[MAX][112];\nint tmp[MAX], data[MAX];\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n        int num = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", op[i]);\n            if (op[i][0] != 's') {\n                scanf(\"%d\", &data[i]);\n                tmp[num++] = data[i];\n            }\n        }\n        //对插入的元素进行离散化\n        sort(tmp, tmp + num);\n        num = unique(tmp, tmp + num) - tmp;\n        build(1, 1, num);\n        for (int i = 0; i < n; i++) {\n            int pos = lower_bound(tmp, tmp + num, data[i]) - tmp + 1;\n            if (op[i][0] == 'a') updata(1, 1, num, pos, data[i]);\n            if (op[i][0] == 'd') updata(1, 1, num, pos, -data[i]);\n            //每次询问整个区间下标%5=3的和\n            if (op[i][0] == 's') printf(\"%lld\\n\", tree[1].sum[3]);\n        }\n    }\n}\n\n```","source":"_posts/HDU4288-Coder（线段树）.md","raw":"---\ntitle: HDU4288 - Coder（线段树）\ndate: 2017-08-08 10:43:50\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4288\n\n--------------------\n# 题目大意：\n给出一个有小到大排序的集合，初始化为空。\n\n三种操作：\n1. 插入一个数。\n2. 删除一个数。\n3. 询问 $\\sum_{1 \\le i \\le k} a_i, \\text{where} i \\mod 5 = 3$\n\n-------------------\n# 解题过程：\n当初好多人都是暴力水过去的，然后刚开始看错了题意，然后试了好多次都不行...\n然后重新写暴力TLE，最后没时间也放弃了，比赛后就直接用线段树去补了。\n\n--------------------\n# 题目分析：\n由于集合是有序的，先离散化输入的数据，用线段树去维护这个列表。\n\n用线段树去维护两个值，一个是线段树当前区间内已经插入的数字个数，一个是区间内下标%5分别等于0~4的已插入的元素的和。\n\n然后合并的时候父节点的`sum[i] =  sum1[i] + sum2[((i-cnt1)%5+5)%5]`，cnt1为左儿子插入的元素个数。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 112345;\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l + r) >> 1\n\nstruct Node {\n    ll sum[5];\n    int cnt;\n} tree[MAX<<2];\n\nvoid merge(int o) {\n    //进行合并，可以理解成，左儿子插入过了几个元素，右儿子要找的位置就要向左移几次\n    for (int i = 0; i < 5; i++) {\n        tree[o].sum[i] = tree[lson].sum[i]\n                         + tree[rson].sum[((i - tree[lson].cnt) % 5 + 5) % 5];\n    }\n}\n\nvoid build(int o, int l, int r) {\n    tree[o].cnt = 0;\n    memset(tree[o].sum, 0, sizeof(tree[o].sum));\n    if (l == r) return;\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\nvoid updata(int o, int l, int r, int pos, int v) {\n    if (r < pos || pos < l) return;\n    //记录插入的元素个数\n    tree[o].cnt += v > 0 ? 1 : -1;\n    if (l == r) {\n        //区间长度为1时，只有下标%5=1的元素\n        tree[o].sum[1] += v;\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos, v);\n    updata(rson, m + 1, r, pos, v);\n    merge(o);\n}\n\nint n;\nchar op[MAX][112];\nint tmp[MAX], data[MAX];\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n        int num = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", op[i]);\n            if (op[i][0] != 's') {\n                scanf(\"%d\", &data[i]);\n                tmp[num++] = data[i];\n            }\n        }\n        //对插入的元素进行离散化\n        sort(tmp, tmp + num);\n        num = unique(tmp, tmp + num) - tmp;\n        build(1, 1, num);\n        for (int i = 0; i < n; i++) {\n            int pos = lower_bound(tmp, tmp + num, data[i]) - tmp + 1;\n            if (op[i][0] == 'a') updata(1, 1, num, pos, data[i]);\n            if (op[i][0] == 'd') updata(1, 1, num, pos, -data[i]);\n            //每次询问整个区间下标%5=3的和\n            if (op[i][0] == 's') printf(\"%lld\\n\", tree[1].sum[3]);\n        }\n    }\n}\n\n```","slug":"HDU4288-Coder（线段树）","published":1,"updated":"2017-08-08T03:04:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbg002ay9id7x5brz7g","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4288\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4288</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有小到大排序的集合，初始化为空。</p>\n<p>三种操作：</p>\n<ol>\n<li>插入一个数。</li>\n<li>删除一个数。</li>\n<li>询问 $\\sum_{1 \\le i \\le k} a_i, \\text{where} i \\mod 5 = 3$</li>\n</ol>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>当初好多人都是暴力水过去的，然后刚开始看错了题意，然后试了好多次都不行…<br>然后重新写暴力TLE，最后没时间也放弃了，比赛后就直接用线段树去补了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于集合是有序的，先离散化输入的数据，用线段树去维护这个列表。</p>\n<p>用线段树去维护两个值，一个是线段树当前区间内已经插入的数字个数，一个是区间内下标%5分别等于0~4的已插入的元素的和。</p>\n<p>然后合并的时候父节点的<code>sum[i] =  sum1[i] + sum2[((i-cnt1)%5+5)%5]</code>，cnt1为左儿子插入的元素个数。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) &gt;&gt; 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    ll sum[<span class=\"number\">5</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> cnt;</div><div class=\"line\">&#125; tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//进行合并，可以理解成，左儿子插入过了几个元素，右儿子要找的位置就要向左移几次</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        tree[o].sum[i] = tree[lson].sum[i]</div><div class=\"line\">                         + tree[rson].sum[((i - tree[lson].cnt) % <span class=\"number\">5</span> + <span class=\"number\">5</span>) % <span class=\"number\">5</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[o].cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(tree[o].sum, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tree[o].sum));</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; pos || pos &lt; l) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//记录插入的元素个数</span></div><div class=\"line\">    tree[o].cnt += v &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"comment\">//区间长度为1时，只有下标%5=1的元素</span></div><div class=\"line\">        tree[o].sum[<span class=\"number\">1</span>] += v;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos, v);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, pos, v);</div><div class=\"line\">    merge(o);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">char</span> op[MAX][<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> tmp[MAX], data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, op[i]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] != <span class=\"string\">'s'</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">                tmp[num++] = data[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//对插入的元素进行离散化</span></div><div class=\"line\">        sort(tmp, tmp + num);</div><div class=\"line\">        num = unique(tmp, tmp + num) - tmp;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> pos = lower_bound(tmp, tmp + num, data[i]) - tmp + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'a'</span>) updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num, pos, data[i]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'d'</span>) updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num, pos, -data[i]);</div><div class=\"line\">            <span class=\"comment\">//每次询问整个区间下标%5=3的和</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'s'</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, tree[<span class=\"number\">1</span>].sum[<span class=\"number\">3</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4288\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4288</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个有小到大排序的集合，初始化为空。</p>\n<p>三种操作：</p>\n<ol>\n<li>插入一个数。</li>\n<li>删除一个数。</li>\n<li>询问 $\\sum_{1 \\le i \\le k} a_i, \\text{where} i \\mod 5 = 3$</li>\n</ol>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>当初好多人都是暴力水过去的，然后刚开始看错了题意，然后试了好多次都不行…<br>然后重新写暴力TLE，最后没时间也放弃了，比赛后就直接用线段树去补了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于集合是有序的，先离散化输入的数据，用线段树去维护这个列表。</p>\n<p>用线段树去维护两个值，一个是线段树当前区间内已经插入的数字个数，一个是区间内下标%5分别等于0~4的已插入的元素的和。</p>\n<p>然后合并的时候父节点的<code>sum[i] =  sum1[i] + sum2[((i-cnt1)%5+5)%5]</code>，cnt1为左儿子插入的元素个数。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) &gt;&gt; 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    ll sum[<span class=\"number\">5</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> cnt;</div><div class=\"line\">&#125; tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//进行合并，可以理解成，左儿子插入过了几个元素，右儿子要找的位置就要向左移几次</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">        tree[o].sum[i] = tree[lson].sum[i]</div><div class=\"line\">                         + tree[rson].sum[((i - tree[lson].cnt) % <span class=\"number\">5</span> + <span class=\"number\">5</span>) % <span class=\"number\">5</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[o].cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(tree[o].sum, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tree[o].sum));</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt; pos || pos &lt; l) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//记录插入的元素个数</span></div><div class=\"line\">    tree[o].cnt += v &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"comment\">//区间长度为1时，只有下标%5=1的元素</span></div><div class=\"line\">        tree[o].sum[<span class=\"number\">1</span>] += v;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos, v);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, pos, v);</div><div class=\"line\">    merge(o);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">char</span> op[MAX][<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> tmp[MAX], data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, op[i]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] != <span class=\"string\">'s'</span>) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">                tmp[num++] = data[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//对插入的元素进行离散化</span></div><div class=\"line\">        sort(tmp, tmp + num);</div><div class=\"line\">        num = unique(tmp, tmp + num) - tmp;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> pos = lower_bound(tmp, tmp + num, data[i]) - tmp + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'a'</span>) updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num, pos, data[i]);</div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'d'</span>) updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, num, pos, -data[i]);</div><div class=\"line\">            <span class=\"comment\">//每次询问整个区间下标%5=3的和</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (op[i][<span class=\"number\">0</span>] == <span class=\"string\">'s'</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, tree[<span class=\"number\">1</span>].sum[<span class=\"number\">3</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU4725 - The Shortest Path in Nya Graph （Dijstra + 建图）","date":"2017-05-22T03:01:02.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4725\n\n\n--------------------------\n# 题目大意：\n\n 现在有N个节点，编号从1到N。有M条权值为Ci无向边，链接着两个节点。\n 新加入了一个条件，每个节点在一个层内，假设在 x 层，那么在 x 层内的节点可以直接到达 x + 1 层或 x -1 层的任意节点，花费为 C 。\n\n 现在求从 1 到 N 的最短路。\n\n------------------------------\n# 解题过程：\n \n 比赛的时候没做出来，现在才开始补题，当时觉得挺难的，没想到拆点重新建图。想通了就觉得挺简单了，然后处理下细节，不过这个题卡 SPFA 有点坑。\n\n-------------------------\n# 题目分析：\n\n 对于每一层，加入两个点，一个入点，一个出点。入点和出点和这一层里的所有点连一条边，并且权值为0 ， 然后每一个出点和相邻的两层的入点相连。剩下的就是普通的最短路了。\n\n 关于为什么要建一个入点一个出点而不是只加入一个点，是为了防止同一层的点互相移动，这样同一层里的点的最短距离都变成 0 了。\n\n--------------------------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 312345, INF = 0x3f3f3f3f;\n\nint N, M, C;\n\nvector<pair<int, int> > edge[MAX];\nint vis[MAX], dist[MAX];\n\nint dijstra() {\n    //普通的dijstra求最短路\n    memset(dist, INF, sizeof(dist));\n    priority_queue<pair<int, int> > q;\n    q.push(make_pair(0, 1));\n    dist[1] = 0;\n    while (!q.empty()) {\n        int u = q.top().second;\n        q.pop();\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i].first;\n            int w = edge[u][i].second;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                q.push(make_pair(-dist[v], v));\n            }\n        }\n    }\n    return dist[N];\n}\n\nint main() {\n    int T, cases = 0;\n    scanf(\"%d\", &T);\n    while (T--) {\n\n        for (int i = 0; i <= N*3; i++) {\n            edge[i].clear();\n            vis[i] = 0;\n        }\n\n        scanf(\"%d %d %d\", &N, &M, &C);\n        for (int i = 1; i <= N; i++) {\n            int t;\n            scanf(\"%d\", &t);\n            vis[t] = 1;\n            //这里 t*2-1+N 代表第 t 层的入点， t*2+N 代表出点\n            edge[t*2-1+N].push_back(make_pair(i, 0));\n            edge[i].push_back(make_pair(t*2+N, 0));\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            edge[u].push_back(make_pair(v, w));\n            edge[v].push_back(make_pair(u, w));\n        }\n\n        for (int i = 1; i <= N; i++) {\n            int u = N + i*2;\n\n            //当前层的出点与相邻层的入点建边\n            if (i > 1) {\n                int v = u-3;\n                edge[u].push_back(make_pair(v, C));\n            }\n            if (i < N) {\n                int v = u+1;\n                edge[u].push_back(make_pair(v, C));\n            }\n        }\n\n        int ans = dijstra();\n        printf(\"Case #%d: %d\\n\", ++cases, ans == INF? -1:ans);\n    }\n}\n```\n","source":"_posts/HDU4725-The-Shortest-Path-in-Nya-Graph-（Dijstra-建图）.md","raw":"---\ntitle: HDU4725 - The Shortest Path in Nya Graph （Dijstra + 建图）\ndate: 2017-05-22 11:01:02\ncategories: [ACM, 图论, 最短路]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4725\n\n\n--------------------------\n# 题目大意：\n\n 现在有N个节点，编号从1到N。有M条权值为Ci无向边，链接着两个节点。\n 新加入了一个条件，每个节点在一个层内，假设在 x 层，那么在 x 层内的节点可以直接到达 x + 1 层或 x -1 层的任意节点，花费为 C 。\n\n 现在求从 1 到 N 的最短路。\n\n------------------------------\n# 解题过程：\n \n 比赛的时候没做出来，现在才开始补题，当时觉得挺难的，没想到拆点重新建图。想通了就觉得挺简单了，然后处理下细节，不过这个题卡 SPFA 有点坑。\n\n-------------------------\n# 题目分析：\n\n 对于每一层，加入两个点，一个入点，一个出点。入点和出点和这一层里的所有点连一条边，并且权值为0 ， 然后每一个出点和相邻的两层的入点相连。剩下的就是普通的最短路了。\n\n 关于为什么要建一个入点一个出点而不是只加入一个点，是为了防止同一层的点互相移动，这样同一层里的点的最短距离都变成 0 了。\n\n--------------------------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 312345, INF = 0x3f3f3f3f;\n\nint N, M, C;\n\nvector<pair<int, int> > edge[MAX];\nint vis[MAX], dist[MAX];\n\nint dijstra() {\n    //普通的dijstra求最短路\n    memset(dist, INF, sizeof(dist));\n    priority_queue<pair<int, int> > q;\n    q.push(make_pair(0, 1));\n    dist[1] = 0;\n    while (!q.empty()) {\n        int u = q.top().second;\n        q.pop();\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i].first;\n            int w = edge[u][i].second;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                q.push(make_pair(-dist[v], v));\n            }\n        }\n    }\n    return dist[N];\n}\n\nint main() {\n    int T, cases = 0;\n    scanf(\"%d\", &T);\n    while (T--) {\n\n        for (int i = 0; i <= N*3; i++) {\n            edge[i].clear();\n            vis[i] = 0;\n        }\n\n        scanf(\"%d %d %d\", &N, &M, &C);\n        for (int i = 1; i <= N; i++) {\n            int t;\n            scanf(\"%d\", &t);\n            vis[t] = 1;\n            //这里 t*2-1+N 代表第 t 层的入点， t*2+N 代表出点\n            edge[t*2-1+N].push_back(make_pair(i, 0));\n            edge[i].push_back(make_pair(t*2+N, 0));\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            edge[u].push_back(make_pair(v, w));\n            edge[v].push_back(make_pair(u, w));\n        }\n\n        for (int i = 1; i <= N; i++) {\n            int u = N + i*2;\n\n            //当前层的出点与相邻层的入点建边\n            if (i > 1) {\n                int v = u-3;\n                edge[u].push_back(make_pair(v, C));\n            }\n            if (i < N) {\n                int v = u+1;\n                edge[u].push_back(make_pair(v, C));\n            }\n        }\n\n        int ans = dijstra();\n        printf(\"Case #%d: %d\\n\", ++cases, ans == INF? -1:ans);\n    }\n}\n```\n","slug":"HDU4725-The-Shortest-Path-in-Nya-Graph-（Dijstra-建图）","published":1,"updated":"2017-07-23T02:27:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbk002by9id2zfnwyo7","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4725\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4725</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有N个节点，编号从1到N。有M条权值为Ci无向边，链接着两个节点。<br> 新加入了一个条件，每个节点在一个层内，假设在 x 层，那么在 x 层内的节点可以直接到达 x + 1 层或 x -1 层的任意节点，花费为 C 。</p>\n<p> 现在求从 1 到 N 的最短路。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 比赛的时候没做出来，现在才开始补题，当时觉得挺难的，没想到拆点重新建图。想通了就觉得挺简单了，然后处理下细节，不过这个题卡 SPFA 有点坑。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 对于每一层，加入两个点，一个入点，一个出点。入点和出点和这一层里的所有点连一条边，并且权值为0 ， 然后每一个出点和相邻的两层的入点相连。剩下的就是普通的最短路了。</p>\n<p> 关于为什么要建一个入点一个出点而不是只加入一个点，是为了防止同一层的点互相移动，这样同一层里的点的最短距离都变成 0 了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">312345</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, M, C;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX], dist[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//普通的dijstra求最短路</span></div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</div><div class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.top().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">            <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + w;</div><div class=\"line\">                q.push(make_pair(-dist[v], v));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dist[N];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N*<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">            vis[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;M, &amp;C);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            vis[t] = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"comment\">//这里 t*2-1+N 代表第 t 层的入点， t*2+N 代表出点</span></div><div class=\"line\">            edge[t*<span class=\"number\">2</span><span class=\"number\">-1</span>+N].push_back(make_pair(i, <span class=\"number\">0</span>));</div><div class=\"line\">            edge[i].push_back(make_pair(t*<span class=\"number\">2</span>+N, <span class=\"number\">0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            edge[u].push_back(make_pair(v, w));</div><div class=\"line\">            edge[v].push_back(make_pair(u, w));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = N + i*<span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//当前层的出点与相邻层的入点建边</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = u<span class=\"number\">-3</span>;</div><div class=\"line\">                edge[u].push_back(make_pair(v, C));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i &lt; N) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = u+<span class=\"number\">1</span>;</div><div class=\"line\">                edge[u].push_back(make_pair(v, C));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = dijstra();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %d\\n\"</span>, ++cases, ans == INF? <span class=\"number\">-1</span>:ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4725\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4725</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有N个节点，编号从1到N。有M条权值为Ci无向边，链接着两个节点。<br> 新加入了一个条件，每个节点在一个层内，假设在 x 层，那么在 x 层内的节点可以直接到达 x + 1 层或 x -1 层的任意节点，花费为 C 。</p>\n<p> 现在求从 1 到 N 的最短路。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 比赛的时候没做出来，现在才开始补题，当时觉得挺难的，没想到拆点重新建图。想通了就觉得挺简单了，然后处理下细节，不过这个题卡 SPFA 有点坑。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 对于每一层，加入两个点，一个入点，一个出点。入点和出点和这一层里的所有点连一条边，并且权值为0 ， 然后每一个出点和相邻的两层的入点相连。剩下的就是普通的最短路了。</p>\n<p> 关于为什么要建一个入点一个出点而不是只加入一个点，是为了防止同一层的点互相移动，这样同一层里的点的最短距离都变成 0 了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">312345</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, M, C;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX], dist[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijstra</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//普通的dijstra求最短路</span></div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</div><div class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.top().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">            <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + w;</div><div class=\"line\">                q.push(make_pair(-dist[v], v));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dist[N];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N*<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">            vis[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;M, &amp;C);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            vis[t] = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"comment\">//这里 t*2-1+N 代表第 t 层的入点， t*2+N 代表出点</span></div><div class=\"line\">            edge[t*<span class=\"number\">2</span><span class=\"number\">-1</span>+N].push_back(make_pair(i, <span class=\"number\">0</span>));</div><div class=\"line\">            edge[i].push_back(make_pair(t*<span class=\"number\">2</span>+N, <span class=\"number\">0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            edge[u].push_back(make_pair(v, w));</div><div class=\"line\">            edge[v].push_back(make_pair(u, w));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = N + i*<span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//当前层的出点与相邻层的入点建边</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = u<span class=\"number\">-3</span>;</div><div class=\"line\">                edge[u].push_back(make_pair(v, C));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i &lt; N) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = u+<span class=\"number\">1</span>;</div><div class=\"line\">                edge[u].push_back(make_pair(v, C));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = dijstra();</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %d\\n\"</span>, ++cases, ans == INF? <span class=\"number\">-1</span>:ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"HDU5527 - Too Rich（贪心）","date":"2017-06-25T10:56:29.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=5527\n\n--------------------\n# 题目大意：\n现在你有$P$元钱，有$10$种不同面值的硬币，每种硬币有一定的数量，求用尽量多的硬币凑出P元钱，有可能凑不出。\n\n-------------------------\n# 解题过程：\n当初比赛没看这道题，最近才补，看起来挺简单的，实际知道思路上也不难……\n\n----------------------------\n# 题目分析：\n\n要用尽量多的硬币凑$P$元钱，假设我现在硬币总共的面值和为$M$，那么换个思路，我现在要从总共的硬币中拿走尽量少的硬币，使剩下的硬币为P元。\n\n那么问题转化成了，用尽量少的硬币去凑出$M-P$元，这个题目就有点熟悉了，不过这里有两个特殊的地方，一个是每种硬币都有数量限制，一个是面值大的硬币并不是面值小的硬币的整数倍。\n\n假设没有数量限制，那么就是简单的贪心，尽量用面值大的硬币去凑出$M-P$元就好了。但是这个题用这个思路的话，会有这种情况。\n\n假设现在有$20,20,20,50 $这四个硬币，要去凑$60$元，如果以之前的思路贪心的话，那么是无解的，但是这里可以不用$50$元这个硬币，而用$3$个$20$元的去凑出$60$元。\n\n那么对于这种情况，就要尝试一下，对于每种硬币，去掉一个这种硬币后的解。\n\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nLL coin[] = {1, 5, 10, 20, 50, 100, 200, 500, 1000, 2000};\nLL num[10], c[10];\n\nLL ans = INF;\n\nvoid dfs(int i, LL sum, LL t) {\n    //sum == 0 表示找到了一个解\n    if (sum == 0) {\n        ans = min(ans, t);\n        return;\n    }\n    //sum == -1 时需要返回，已经没有面值更小的硬币了\n    if (i < 0)\n        return;\n\n    //计算出来当前硬币最多取多少\n    c[i] = min(num[i], sum/coin[i]);\n    dfs(i-1, sum - coin[i] * c[i], t + c[i]);\n\n    //尝试少拿一个硬币\n    if (c[i] > 0) {\n        c[i]--;\n        dfs(i-1, sum - coin[i] * c[i], t + c[i]);\n    }\n}\n\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    while (n--) {\n        LL p;\n        LL total, sum;\n        total = sum = 0;\n        scanf(\"%lld\", &p);\n        for (int i = 0; i < 10; i++) {\n            scanf(\"%lld\", num + i);\n            //sum计算所有硬币总共的价值\n            sum += coin[i]*num[i];\n            //total计算总共的硬币数\n            total += num[i];\n        }\n\n        //计算出需要拿走多少钱\n        sum -= p;\n\n        if (sum < 0) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        ans = INF;\n        dfs(9, sum, 0);\n\n        //如果ans == INF 表示一个解都没有\n        if (ans == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%lld\\n\", total - ans);\n    }\n}\n```","source":"_posts/HDU5527-Too-Rich（贪心）.md","raw":"---\ntitle: HDU5527 - Too Rich（贪心）\ndate: 2017-06-25 18:56:29\ncategories: [ACM, 贪心]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=5527\n\n--------------------\n# 题目大意：\n现在你有$P$元钱，有$10$种不同面值的硬币，每种硬币有一定的数量，求用尽量多的硬币凑出P元钱，有可能凑不出。\n\n-------------------------\n# 解题过程：\n当初比赛没看这道题，最近才补，看起来挺简单的，实际知道思路上也不难……\n\n----------------------------\n# 题目分析：\n\n要用尽量多的硬币凑$P$元钱，假设我现在硬币总共的面值和为$M$，那么换个思路，我现在要从总共的硬币中拿走尽量少的硬币，使剩下的硬币为P元。\n\n那么问题转化成了，用尽量少的硬币去凑出$M-P$元，这个题目就有点熟悉了，不过这里有两个特殊的地方，一个是每种硬币都有数量限制，一个是面值大的硬币并不是面值小的硬币的整数倍。\n\n假设没有数量限制，那么就是简单的贪心，尽量用面值大的硬币去凑出$M-P$元就好了。但是这个题用这个思路的话，会有这种情况。\n\n假设现在有$20,20,20,50 $这四个硬币，要去凑$60$元，如果以之前的思路贪心的话，那么是无解的，但是这里可以不用$50$元这个硬币，而用$3$个$20$元的去凑出$60$元。\n\n那么对于这种情况，就要尝试一下，对于每种硬币，去掉一个这种硬币后的解。\n\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nLL coin[] = {1, 5, 10, 20, 50, 100, 200, 500, 1000, 2000};\nLL num[10], c[10];\n\nLL ans = INF;\n\nvoid dfs(int i, LL sum, LL t) {\n    //sum == 0 表示找到了一个解\n    if (sum == 0) {\n        ans = min(ans, t);\n        return;\n    }\n    //sum == -1 时需要返回，已经没有面值更小的硬币了\n    if (i < 0)\n        return;\n\n    //计算出来当前硬币最多取多少\n    c[i] = min(num[i], sum/coin[i]);\n    dfs(i-1, sum - coin[i] * c[i], t + c[i]);\n\n    //尝试少拿一个硬币\n    if (c[i] > 0) {\n        c[i]--;\n        dfs(i-1, sum - coin[i] * c[i], t + c[i]);\n    }\n}\n\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    while (n--) {\n        LL p;\n        LL total, sum;\n        total = sum = 0;\n        scanf(\"%lld\", &p);\n        for (int i = 0; i < 10; i++) {\n            scanf(\"%lld\", num + i);\n            //sum计算所有硬币总共的价值\n            sum += coin[i]*num[i];\n            //total计算总共的硬币数\n            total += num[i];\n        }\n\n        //计算出需要拿走多少钱\n        sum -= p;\n\n        if (sum < 0) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        ans = INF;\n        dfs(9, sum, 0);\n\n        //如果ans == INF 表示一个解都没有\n        if (ans == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%lld\\n\", total - ans);\n    }\n}\n```","slug":"HDU5527-Too-Rich（贪心）","published":1,"updated":"2017-07-23T01:55:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbm002ey9idv1xpg3fp","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=5527\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=5527</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在你有$P$元钱，有$10$种不同面值的硬币，每种硬币有一定的数量，求用尽量多的硬币凑出P元钱，有可能凑不出。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>当初比赛没看这道题，最近才补，看起来挺简单的，实际知道思路上也不难……</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>要用尽量多的硬币凑$P$元钱，假设我现在硬币总共的面值和为$M$，那么换个思路，我现在要从总共的硬币中拿走尽量少的硬币，使剩下的硬币为P元。</p>\n<p>那么问题转化成了，用尽量少的硬币去凑出$M-P$元，这个题目就有点熟悉了，不过这里有两个特殊的地方，一个是每种硬币都有数量限制，一个是面值大的硬币并不是面值小的硬币的整数倍。</p>\n<p>假设没有数量限制，那么就是简单的贪心，尽量用面值大的硬币去凑出$M-P$元就好了。但是这个题用这个思路的话，会有这种情况。</p>\n<p>假设现在有$20,20,20,50 $这四个硬币，要去凑$60$元，如果以之前的思路贪心的话，那么是无解的，但是这里可以不用$50$元这个硬币，而用$3$个$20$元的去凑出$60$元。</p>\n<p>那么对于这种情况，就要尝试一下，对于每种硬币，去掉一个这种硬币后的解。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\">LL coin[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">500</span>, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>&#125;;</div><div class=\"line\">LL num[<span class=\"number\">10</span>], c[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">LL ans = INF;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i, LL sum, LL t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//sum == 0 表示找到了一个解</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ans = min(ans, t);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//sum == -1 时需要返回，已经没有面值更小的硬币了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//计算出来当前硬币最多取多少</span></div><div class=\"line\">    c[i] = min(num[i], sum/coin[i]);</div><div class=\"line\">    dfs(i<span class=\"number\">-1</span>, sum - coin[i] * c[i], t + c[i]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//尝试少拿一个硬币</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (c[i] &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        c[i]--;</div><div class=\"line\">        dfs(i<span class=\"number\">-1</span>, sum - coin[i] * c[i], t + c[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    LL n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">        LL p;</div><div class=\"line\">        LL total, sum;</div><div class=\"line\">        total = sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;p);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, num + i);</div><div class=\"line\">            <span class=\"comment\">//sum计算所有硬币总共的价值</span></div><div class=\"line\">            sum += coin[i]*num[i];</div><div class=\"line\">            <span class=\"comment\">//total计算总共的硬币数</span></div><div class=\"line\">            total += num[i];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算出需要拿走多少钱</span></div><div class=\"line\">        sum -= p;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        ans = INF;</div><div class=\"line\">        dfs(<span class=\"number\">9</span>, sum, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果ans == INF 表示一个解都没有</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans == INF)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, total - ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=5527\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=5527</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在你有$P$元钱，有$10$种不同面值的硬币，每种硬币有一定的数量，求用尽量多的硬币凑出P元钱，有可能凑不出。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>当初比赛没看这道题，最近才补，看起来挺简单的，实际知道思路上也不难……</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>要用尽量多的硬币凑$P$元钱，假设我现在硬币总共的面值和为$M$，那么换个思路，我现在要从总共的硬币中拿走尽量少的硬币，使剩下的硬币为P元。</p>\n<p>那么问题转化成了，用尽量少的硬币去凑出$M-P$元，这个题目就有点熟悉了，不过这里有两个特殊的地方，一个是每种硬币都有数量限制，一个是面值大的硬币并不是面值小的硬币的整数倍。</p>\n<p>假设没有数量限制，那么就是简单的贪心，尽量用面值大的硬币去凑出$M-P$元就好了。但是这个题用这个思路的话，会有这种情况。</p>\n<p>假设现在有$20,20,20,50 $这四个硬币，要去凑$60$元，如果以之前的思路贪心的话，那么是无解的，但是这里可以不用$50$元这个硬币，而用$3$个$20$元的去凑出$60$元。</p>\n<p>那么对于这种情况，就要尝试一下，对于每种硬币，去掉一个这种硬币后的解。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\">LL coin[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">500</span>, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>&#125;;</div><div class=\"line\">LL num[<span class=\"number\">10</span>], c[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">LL ans = INF;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i, LL sum, LL t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//sum == 0 表示找到了一个解</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ans = min(ans, t);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//sum == -1 时需要返回，已经没有面值更小的硬币了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//计算出来当前硬币最多取多少</span></div><div class=\"line\">    c[i] = min(num[i], sum/coin[i]);</div><div class=\"line\">    dfs(i<span class=\"number\">-1</span>, sum - coin[i] * c[i], t + c[i]);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//尝试少拿一个硬币</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (c[i] &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        c[i]--;</div><div class=\"line\">        dfs(i<span class=\"number\">-1</span>, sum - coin[i] * c[i], t + c[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    LL n;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;n);</div><div class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">        LL p;</div><div class=\"line\">        LL total, sum;</div><div class=\"line\">        total = sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;p);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, num + i);</div><div class=\"line\">            <span class=\"comment\">//sum计算所有硬币总共的价值</span></div><div class=\"line\">            sum += coin[i]*num[i];</div><div class=\"line\">            <span class=\"comment\">//total计算总共的硬币数</span></div><div class=\"line\">            total += num[i];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算出需要拿走多少钱</span></div><div class=\"line\">        sum -= p;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        ans = INF;</div><div class=\"line\">        dfs(<span class=\"number\">9</span>, sum, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//如果ans == INF 表示一个解都没有</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans == INF)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, total - ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU5550 - Game room （DP）","date":"2017-05-21T06:42:00.000Z","_content":"# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=5550\n\n-----------------------------\n\n# 题目大意：\n\n 有一栋楼，有N层，每一层都有ai个想要玩A游戏的，bi个想要玩B游戏的，但是每层只能修建一种游戏厅。每个人移动上下一层楼需要消耗一点体力。使得所有人玩的上游戏并且消耗的体力尽量的少，最少消耗的体力。\n\n---------------------------------\n\n# 解题过程：\n\n 比赛的时候好不容易读懂了题意，发现并不会做，第一个想法是贪心的，从0层向下扫，累加想玩A游戏的人数和想玩B游戏的人数，对于每一层判断是想玩A的人多还是想玩B的人多，修建人多的那个。\n\n 显然这个思路得不到最优解，如果每个人只能向下走不能向上走的话应该可行。\n\n 然后这个题放置了好长时间，现在才去补，翻了两三个博客算是看懂了，感觉这种DP只能靠脑洞了，每一种都不一样。\n\n\n参考博客：\nhttps://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/\n\nhttp://blog.csdn.net/snowy_smile/article/details/49618219\n\n---------------------------------\n\n\n# 题目分析：\n 上面两个博客都说的非常详细，我主要是参照是第一个博客，代码加了注释，这里不做过多论述了。\n\n\n----------------------------------\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 4010;\nconst ll INF = 0x3f3f3f3f3f3f3f3fll;\n\nint T, n, cases = 0;\nll value[MAX_N][2], sum[MAX_N][2], pre[MAX_N][2], suf[MAX_N][2];\nll dp[MAX_N][2];\n\nvoid init() {\n    //初始化求出前缀和，pre[i]表示从第i层移到第0层所需要的代价，suf[i]代表从第i层移到第n+1层所需要的代价\n    for (int i = 1; i <= n; i++) {\n        sum[i][0] = sum[i-1][0] + value[i][0];\n        sum[i][1] = sum[i-1][1] + value[i][1];\n        pre[i][0] = pre[i-1][0] + value[i][0] * i;\n        pre[i][1] = pre[i-1][1] + value[i][1] * i;\n    }\n    for (int i = n; i >= 1; i--) {\n        suf[i][0] = suf[i+1][0] + value[i][0] * (n - i + 1);\n        suf[i][1] = suf[i+1][1] + value[i][1] * (n - i + 1);\n    }\n}\n\nll down(int a, int b, int id) {\n    //表示 [a, b] 这个区间里的人要达到b+1所需要的代价\n    return suf[a][id] - suf[b+1][id] - (sum[b][id] - sum[a-1][id]) * (n-b);\n}\n\nll up(int a, int b, int id) {\n    //表示 [a,b] 这个区间里的人要到达a所需要的代价\n    return pre[b][id] - pre[a][id] - (sum[b][id] - sum[a][id]) * a;\n}\n\nll work(int a, int b, int id) {\n    int mid = (a+b) >> 1;\n    //因为dp[i][0]表示的状态是当前是0，i+1是1，如果当前i为n，那么后面就没有1的房间了\n    if (b < n) return up(a, mid, id) + down(mid+1, b, id);\n    else return up(a, b, id);\n}\n\nvoid solve() {\n    init();\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = dp[i][1] = INF;\n        //计算前i个全为1或全为0的情况\n        if (i < n) dp[i][0] = down(1, i, 1);\n        if (i < n) dp[i][1] = down(1, i, 0);\n        for (int j = 1; j <= i-1; j++) {\n            //枚举上一个选1或0的位置\n            dp[i][0] = min(dp[i][0], dp[j][1] + work(j, i, 1));\n            dp[i][1] = min(dp[i][1], dp[j][0] + work(j, i, 0));\n        }\n    }\n    printf(\"Case #%d: %lld\\n\", ++cases, min(dp[n][0], dp[n][1]));\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld%lld\", &value[i][0], &value[i][1]);\n        }\n        solve();\n    }\n}\n```","source":"_posts/HDU5550-Game-room-（DP）.md","raw":"---\ntitle: HDU5550 - Game room （DP）\ndate: 2017-05-21 14:42:00\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=5550\n\n-----------------------------\n\n# 题目大意：\n\n 有一栋楼，有N层，每一层都有ai个想要玩A游戏的，bi个想要玩B游戏的，但是每层只能修建一种游戏厅。每个人移动上下一层楼需要消耗一点体力。使得所有人玩的上游戏并且消耗的体力尽量的少，最少消耗的体力。\n\n---------------------------------\n\n# 解题过程：\n\n 比赛的时候好不容易读懂了题意，发现并不会做，第一个想法是贪心的，从0层向下扫，累加想玩A游戏的人数和想玩B游戏的人数，对于每一层判断是想玩A的人多还是想玩B的人多，修建人多的那个。\n\n 显然这个思路得不到最优解，如果每个人只能向下走不能向上走的话应该可行。\n\n 然后这个题放置了好长时间，现在才去补，翻了两三个博客算是看懂了，感觉这种DP只能靠脑洞了，每一种都不一样。\n\n\n参考博客：\nhttps://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/\n\nhttp://blog.csdn.net/snowy_smile/article/details/49618219\n\n---------------------------------\n\n\n# 题目分析：\n 上面两个博客都说的非常详细，我主要是参照是第一个博客，代码加了注释，这里不做过多论述了。\n\n\n----------------------------------\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 4010;\nconst ll INF = 0x3f3f3f3f3f3f3f3fll;\n\nint T, n, cases = 0;\nll value[MAX_N][2], sum[MAX_N][2], pre[MAX_N][2], suf[MAX_N][2];\nll dp[MAX_N][2];\n\nvoid init() {\n    //初始化求出前缀和，pre[i]表示从第i层移到第0层所需要的代价，suf[i]代表从第i层移到第n+1层所需要的代价\n    for (int i = 1; i <= n; i++) {\n        sum[i][0] = sum[i-1][0] + value[i][0];\n        sum[i][1] = sum[i-1][1] + value[i][1];\n        pre[i][0] = pre[i-1][0] + value[i][0] * i;\n        pre[i][1] = pre[i-1][1] + value[i][1] * i;\n    }\n    for (int i = n; i >= 1; i--) {\n        suf[i][0] = suf[i+1][0] + value[i][0] * (n - i + 1);\n        suf[i][1] = suf[i+1][1] + value[i][1] * (n - i + 1);\n    }\n}\n\nll down(int a, int b, int id) {\n    //表示 [a, b] 这个区间里的人要达到b+1所需要的代价\n    return suf[a][id] - suf[b+1][id] - (sum[b][id] - sum[a-1][id]) * (n-b);\n}\n\nll up(int a, int b, int id) {\n    //表示 [a,b] 这个区间里的人要到达a所需要的代价\n    return pre[b][id] - pre[a][id] - (sum[b][id] - sum[a][id]) * a;\n}\n\nll work(int a, int b, int id) {\n    int mid = (a+b) >> 1;\n    //因为dp[i][0]表示的状态是当前是0，i+1是1，如果当前i为n，那么后面就没有1的房间了\n    if (b < n) return up(a, mid, id) + down(mid+1, b, id);\n    else return up(a, b, id);\n}\n\nvoid solve() {\n    init();\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = dp[i][1] = INF;\n        //计算前i个全为1或全为0的情况\n        if (i < n) dp[i][0] = down(1, i, 1);\n        if (i < n) dp[i][1] = down(1, i, 0);\n        for (int j = 1; j <= i-1; j++) {\n            //枚举上一个选1或0的位置\n            dp[i][0] = min(dp[i][0], dp[j][1] + work(j, i, 1));\n            dp[i][1] = min(dp[i][1], dp[j][0] + work(j, i, 0));\n        }\n    }\n    printf(\"Case #%d: %lld\\n\", ++cases, min(dp[n][0], dp[n][1]));\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lld%lld\", &value[i][0], &value[i][1]);\n        }\n        solve();\n    }\n}\n```","slug":"HDU5550-Game-room-（DP）","published":1,"updated":"2017-07-23T02:29:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbo002gy9idpad0idsj","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=5550\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=5550</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有一栋楼，有N层，每一层都有ai个想要玩A游戏的，bi个想要玩B游戏的，但是每层只能修建一种游戏厅。每个人移动上下一层楼需要消耗一点体力。使得所有人玩的上游戏并且消耗的体力尽量的少，最少消耗的体力。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 比赛的时候好不容易读懂了题意，发现并不会做，第一个想法是贪心的，从0层向下扫，累加想玩A游戏的人数和想玩B游戏的人数，对于每一层判断是想玩A的人多还是想玩B的人多，修建人多的那个。</p>\n<p> 显然这个思路得不到最优解，如果每个人只能向下走不能向上走的话应该可行。</p>\n<p> 然后这个题放置了好长时间，现在才去补，翻了两三个博客算是看懂了，感觉这种DP只能靠脑洞了，每一种都不一样。</p>\n<p>参考博客：<br><a href=\"https://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/\" target=\"_blank\" rel=\"external\">https://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/</a></p>\n<p><a href=\"http://blog.csdn.net/snowy_smile/article/details/49618219\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/snowy_smile/article/details/49618219</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 上面两个博客都说的非常详细，我主要是参照是第一个博客，代码加了注释，这里不做过多论述了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_N = <span class=\"number\">4010</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> ll INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> T, n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">ll value[MAX_N][<span class=\"number\">2</span>], sum[MAX_N][<span class=\"number\">2</span>], pre[MAX_N][<span class=\"number\">2</span>], suf[MAX_N][<span class=\"number\">2</span>];</div><div class=\"line\">ll dp[MAX_N][<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化求出前缀和，pre[i]表示从第i层移到第0层所需要的代价，suf[i]代表从第i层移到第n+1层所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        sum[i][<span class=\"number\">0</span>] = sum[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>];</div><div class=\"line\">        sum[i][<span class=\"number\">1</span>] = sum[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>];</div><div class=\"line\">        pre[i][<span class=\"number\">0</span>] = pre[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>] * i;</div><div class=\"line\">        pre[i][<span class=\"number\">1</span>] = pre[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>] * i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">        suf[i][<span class=\"number\">0</span>] = suf[i+<span class=\"number\">1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>] * (n - i + <span class=\"number\">1</span>);</div><div class=\"line\">        suf[i][<span class=\"number\">1</span>] = suf[i+<span class=\"number\">1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>] * (n - i + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">down</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//表示 [a, b] 这个区间里的人要达到b+1所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">return</span> suf[a][id] - suf[b+<span class=\"number\">1</span>][id] - (sum[b][id] - sum[a<span class=\"number\">-1</span>][id]) * (n-b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">up</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//表示 [a,b] 这个区间里的人要到达a所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">return</span> pre[b][id] - pre[a][id] - (sum[b][id] - sum[a][id]) * a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> mid = (a+b) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">//因为dp[i][0]表示的状态是当前是0，i+1是1，如果当前i为n，那么后面就没有1的房间了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (b &lt; n) <span class=\"keyword\">return</span> up(a, mid, id) + down(mid+<span class=\"number\">1</span>, b, id);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> up(a, b, id);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i][<span class=\"number\">0</span>] = dp[i][<span class=\"number\">1</span>] = INF;</div><div class=\"line\">        <span class=\"comment\">//计算前i个全为1或全为0的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt; n) dp[i][<span class=\"number\">0</span>] = down(<span class=\"number\">1</span>, i, <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt; n) dp[i][<span class=\"number\">1</span>] = down(<span class=\"number\">1</span>, i, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i<span class=\"number\">-1</span>; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//枚举上一个选1或0的位置</span></div><div class=\"line\">            dp[i][<span class=\"number\">0</span>] = min(dp[i][<span class=\"number\">0</span>], dp[j][<span class=\"number\">1</span>] + work(j, i, <span class=\"number\">1</span>));</div><div class=\"line\">            dp[i][<span class=\"number\">1</span>] = min(dp[i][<span class=\"number\">1</span>], dp[j][<span class=\"number\">0</span>] + work(j, i, <span class=\"number\">0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %lld\\n\"</span>, ++cases, min(dp[n][<span class=\"number\">0</span>], dp[n][<span class=\"number\">1</span>]));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld\"</span>, &amp;value[i][<span class=\"number\">0</span>], &amp;value[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=5550\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=5550</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有一栋楼，有N层，每一层都有ai个想要玩A游戏的，bi个想要玩B游戏的，但是每层只能修建一种游戏厅。每个人移动上下一层楼需要消耗一点体力。使得所有人玩的上游戏并且消耗的体力尽量的少，最少消耗的体力。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 比赛的时候好不容易读懂了题意，发现并不会做，第一个想法是贪心的，从0层向下扫，累加想玩A游戏的人数和想玩B游戏的人数，对于每一层判断是想玩A的人多还是想玩B的人多，修建人多的那个。</p>\n<p> 显然这个思路得不到最优解，如果每个人只能向下走不能向上走的话应该可行。</p>\n<p> 然后这个题放置了好长时间，现在才去补，翻了两三个博客算是看懂了，感觉这种DP只能靠脑洞了，每一种都不一样。</p>\n<p>参考博客：<br><a href=\"https://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/\" target=\"_blank\" rel=\"external\">https://ramay7.github.io/2016/11/04/HDU-5550-2015CCPC-K-dp/</a></p>\n<p><a href=\"http://blog.csdn.net/snowy_smile/article/details/49618219\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/snowy_smile/article/details/49618219</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 上面两个博客都说的非常详细，我主要是参照是第一个博客，代码加了注释，这里不做过多论述了。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_N = <span class=\"number\">4010</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> ll INF = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> T, n, cases = <span class=\"number\">0</span>;</div><div class=\"line\">ll value[MAX_N][<span class=\"number\">2</span>], sum[MAX_N][<span class=\"number\">2</span>], pre[MAX_N][<span class=\"number\">2</span>], suf[MAX_N][<span class=\"number\">2</span>];</div><div class=\"line\">ll dp[MAX_N][<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化求出前缀和，pre[i]表示从第i层移到第0层所需要的代价，suf[i]代表从第i层移到第n+1层所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        sum[i][<span class=\"number\">0</span>] = sum[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>];</div><div class=\"line\">        sum[i][<span class=\"number\">1</span>] = sum[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>];</div><div class=\"line\">        pre[i][<span class=\"number\">0</span>] = pre[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>] * i;</div><div class=\"line\">        pre[i][<span class=\"number\">1</span>] = pre[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>] * i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">        suf[i][<span class=\"number\">0</span>] = suf[i+<span class=\"number\">1</span>][<span class=\"number\">0</span>] + value[i][<span class=\"number\">0</span>] * (n - i + <span class=\"number\">1</span>);</div><div class=\"line\">        suf[i][<span class=\"number\">1</span>] = suf[i+<span class=\"number\">1</span>][<span class=\"number\">1</span>] + value[i][<span class=\"number\">1</span>] * (n - i + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">down</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//表示 [a, b] 这个区间里的人要达到b+1所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">return</span> suf[a][id] - suf[b+<span class=\"number\">1</span>][id] - (sum[b][id] - sum[a<span class=\"number\">-1</span>][id]) * (n-b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">up</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//表示 [a,b] 这个区间里的人要到达a所需要的代价</span></div><div class=\"line\">    <span class=\"keyword\">return</span> pre[b][id] - pre[a][id] - (sum[b][id] - sum[a][id]) * a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ll <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> mid = (a+b) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">//因为dp[i][0]表示的状态是当前是0，i+1是1，如果当前i为n，那么后面就没有1的房间了</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (b &lt; n) <span class=\"keyword\">return</span> up(a, mid, id) + down(mid+<span class=\"number\">1</span>, b, id);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> up(a, b, id);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        dp[i][<span class=\"number\">0</span>] = dp[i][<span class=\"number\">1</span>] = INF;</div><div class=\"line\">        <span class=\"comment\">//计算前i个全为1或全为0的情况</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt; n) dp[i][<span class=\"number\">0</span>] = down(<span class=\"number\">1</span>, i, <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt; n) dp[i][<span class=\"number\">1</span>] = down(<span class=\"number\">1</span>, i, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i<span class=\"number\">-1</span>; j++) &#123;</div><div class=\"line\">            <span class=\"comment\">//枚举上一个选1或0的位置</span></div><div class=\"line\">            dp[i][<span class=\"number\">0</span>] = min(dp[i][<span class=\"number\">0</span>], dp[j][<span class=\"number\">1</span>] + work(j, i, <span class=\"number\">1</span>));</div><div class=\"line\">            dp[i][<span class=\"number\">1</span>] = min(dp[i][<span class=\"number\">1</span>], dp[j][<span class=\"number\">0</span>] + work(j, i, <span class=\"number\">0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %lld\\n\"</span>, ++cases, min(dp[n][<span class=\"number\">0</span>], dp[n][<span class=\"number\">1</span>]));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld\"</span>, &amp;value[i][<span class=\"number\">0</span>], &amp;value[i][<span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU6070 - Dirt Ratio（线段树+二分答案）","date":"2017-08-04T01:53:27.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=6070\n\n--------------------\n# 题目大意：\n给出一个序列A，对于序列里面的每一个数字范围为1～n，要求找出一段连续子序列，Y为区间长度，X为区间不同数字的个数，使得X/Y尽量的小。\n\n-------------------\n# 解题过程：\n多校赛的第四题，也算是A题比较快的一场，最后卡在了这个题上，感觉可以做的，但是不会。只想到了线段树，完全没往二分上面想，听说有$O(N^2)$卡过去的。第一次遇到这样固定一个区间边界的线段树题。\n\n--------------------\n# 题目分析：\n首先X是肯定小于等于Y，那么答案的范围一定为[0~1]，这个题是特判，精度误差在$10^{-4}$就可以，这样二分答案只需要20次左右。\n\n对于二分答案就是检查当前线段树上是否有一个区间，使得\n$$ \\frac {size(l, r)} {r-l+1}  \\leq mid$$\n$$ size(l, r) + l \\times mid \\leq mid \\times (r + 1)$$\n\n上述的size(l, r)为[l, r]内不同数字的个数\n\n这么我们在线段树上维护左边的值，每次在线段树上查询是否有一段区间满足上述公式。\n\n对于线段树上的每一个节点，假设维护的区间为$(a, b)$，那么维护的信息为$min(size(i, r) + l \\times mid), a \\ge i \\le b$。\n\n由于我们相当于固定住了r这个边界，对r从1～n开始枚举，对于每次对线段树新插入一个数x，假设x上一次出现的位置为p，当前插入的位置为r，那么只对 $(p+1,r]$这段区间内的size值有影响，需要加一。\n\n另外在查询的时候，要保证查询的区间的右边界都要小于当前枚举到的r。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\n#define root 1, 1, n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nusing namespace std;\n\nconst int MAX = 60000 + 10;\n\nstruct Node {\n    int lazy;\n    double v;\n} tree[MAX << 2];\n\nint data[MAX], Case, n, last[MAX];\ndouble M;\n\ninline void tag(int o, int p) { tree[o].lazy += p, tree[o].v += p; }\n\ninline void push_down(int o) {\n    if (tree[o].lazy) { tag(lson, tree[o].lazy), tag(rson, tree[o].lazy), tree[o].lazy = 0; }\n}\n\nvoid merge(int o) {\n    //更新根节点的最小值\n    tree[o].v = min(tree[lson].v, tree[rson].v);\n}\n\nvoid build(int o, int l, int r) {\n    //初始化假设区间内不同的数字为0\n    tree[o].v = M * l;\n    tree[o].lazy = 0;\n    if (l == r) return;\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\nvoid updata(int o, int l, int r, int ul, int ur) {\n    if (ul > r || l > ur) return;\n    if (ul <= l && r <= ur) {\n        //区间内不同数字的数量加一\n        tag(o, 1); return;\n    }\n    push_down(o);\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m + 1, r, ul, ur);\n    merge(o);\n}\n\ndouble query(int o, int l, int r, int pos) {\n    //进行剪枝\n    if (l > pos) return 1e9;\n    //必须当前的右边界小于pos才能返回答案\n    if (r <= pos) {\n        return tree[o].v;\n    }\n    push_down(o);\n    MID;\n    return min(query(lson, l, m, pos), query(rson, m + 1, r, pos));\n}\n\nint main() {\n    scanf(\"%d\", &Case);\n    while (Case--) {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) scanf(\"%d\", data + i);\n        double L = 0, R = 1;\n        //最多需要二分20次\n        for (int times = 0; times < 20; times++) {\n            M = (L + R) / 2;\n            build(root);\n            for (int i = 1; i <= n; i++) last[i] = 0;\n            bool ok = false;\n            for (int i = 1; i <= n; i++) {\n                //last表示data[i]上一次出现的位置\n                updata(root, last[data[i]] + 1, i);\n                //t表示能找到的size(l,r)+mid*l的最小值\n                double t = query(root, i);\n                if (t - M * (i + 1) <= 0) { ok = true; break; };\n                last[data[i]] = i;\n            }\n            if (ok) R = M;\n            else L = M;\n        }\n        printf(\"%f\\n\", (L + R) / 2);\n    }\n}\n```","source":"_posts/HDU6070-Dirt-Ratio（线段树-二分答案）.md","raw":"---\ntitle: HDU6070 - Dirt Ratio（线段树+二分答案）\ndate: 2017-08-04 09:53:27\ncategories: [ACM, 二分]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=6070\n\n--------------------\n# 题目大意：\n给出一个序列A，对于序列里面的每一个数字范围为1～n，要求找出一段连续子序列，Y为区间长度，X为区间不同数字的个数，使得X/Y尽量的小。\n\n-------------------\n# 解题过程：\n多校赛的第四题，也算是A题比较快的一场，最后卡在了这个题上，感觉可以做的，但是不会。只想到了线段树，完全没往二分上面想，听说有$O(N^2)$卡过去的。第一次遇到这样固定一个区间边界的线段树题。\n\n--------------------\n# 题目分析：\n首先X是肯定小于等于Y，那么答案的范围一定为[0~1]，这个题是特判，精度误差在$10^{-4}$就可以，这样二分答案只需要20次左右。\n\n对于二分答案就是检查当前线段树上是否有一个区间，使得\n$$ \\frac {size(l, r)} {r-l+1}  \\leq mid$$\n$$ size(l, r) + l \\times mid \\leq mid \\times (r + 1)$$\n\n上述的size(l, r)为[l, r]内不同数字的个数\n\n这么我们在线段树上维护左边的值，每次在线段树上查询是否有一段区间满足上述公式。\n\n对于线段树上的每一个节点，假设维护的区间为$(a, b)$，那么维护的信息为$min(size(i, r) + l \\times mid), a \\ge i \\le b$。\n\n由于我们相当于固定住了r这个边界，对r从1～n开始枚举，对于每次对线段树新插入一个数x，假设x上一次出现的位置为p，当前插入的位置为r，那么只对 $(p+1,r]$这段区间内的size值有影响，需要加一。\n\n另外在查询的时候，要保证查询的区间的右边界都要小于当前枚举到的r。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\n#define root 1, 1, n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nusing namespace std;\n\nconst int MAX = 60000 + 10;\n\nstruct Node {\n    int lazy;\n    double v;\n} tree[MAX << 2];\n\nint data[MAX], Case, n, last[MAX];\ndouble M;\n\ninline void tag(int o, int p) { tree[o].lazy += p, tree[o].v += p; }\n\ninline void push_down(int o) {\n    if (tree[o].lazy) { tag(lson, tree[o].lazy), tag(rson, tree[o].lazy), tree[o].lazy = 0; }\n}\n\nvoid merge(int o) {\n    //更新根节点的最小值\n    tree[o].v = min(tree[lson].v, tree[rson].v);\n}\n\nvoid build(int o, int l, int r) {\n    //初始化假设区间内不同的数字为0\n    tree[o].v = M * l;\n    tree[o].lazy = 0;\n    if (l == r) return;\n    MID;\n    build(lson, l, m);\n    build(rson, m + 1, r);\n}\n\nvoid updata(int o, int l, int r, int ul, int ur) {\n    if (ul > r || l > ur) return;\n    if (ul <= l && r <= ur) {\n        //区间内不同数字的数量加一\n        tag(o, 1); return;\n    }\n    push_down(o);\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m + 1, r, ul, ur);\n    merge(o);\n}\n\ndouble query(int o, int l, int r, int pos) {\n    //进行剪枝\n    if (l > pos) return 1e9;\n    //必须当前的右边界小于pos才能返回答案\n    if (r <= pos) {\n        return tree[o].v;\n    }\n    push_down(o);\n    MID;\n    return min(query(lson, l, m, pos), query(rson, m + 1, r, pos));\n}\n\nint main() {\n    scanf(\"%d\", &Case);\n    while (Case--) {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) scanf(\"%d\", data + i);\n        double L = 0, R = 1;\n        //最多需要二分20次\n        for (int times = 0; times < 20; times++) {\n            M = (L + R) / 2;\n            build(root);\n            for (int i = 1; i <= n; i++) last[i] = 0;\n            bool ok = false;\n            for (int i = 1; i <= n; i++) {\n                //last表示data[i]上一次出现的位置\n                updata(root, last[data[i]] + 1, i);\n                //t表示能找到的size(l,r)+mid*l的最小值\n                double t = query(root, i);\n                if (t - M * (i + 1) <= 0) { ok = true; break; };\n                last[data[i]] = i;\n            }\n            if (ok) R = M;\n            else L = M;\n        }\n        printf(\"%f\\n\", (L + R) / 2);\n    }\n}\n```","slug":"HDU6070-Dirt-Ratio（线段树-二分答案）","published":1,"updated":"2017-08-04T02:24:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbr002iy9idqaelq2z0","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6070\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=6070</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个序列A，对于序列里面的每一个数字范围为1～n，要求找出一段连续子序列，Y为区间长度，X为区间不同数字的个数，使得X/Y尽量的小。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>多校赛的第四题，也算是A题比较快的一场，最后卡在了这个题上，感觉可以做的，但是不会。只想到了线段树，完全没往二分上面想，听说有$O(N^2)$卡过去的。第一次遇到这样固定一个区间边界的线段树题。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先X是肯定小于等于Y，那么答案的范围一定为[0~1]，这个题是特判，精度误差在$10^{-4}$就可以，这样二分答案只需要20次左右。</p>\n<p>对于二分答案就是检查当前线段树上是否有一个区间，使得<br>$$ \\frac {size(l, r)} {r-l+1}  \\leq mid$$<br>$$ size(l, r) + l \\times mid \\leq mid \\times (r + 1)$$</p>\n<p>上述的size(l, r)为[l, r]内不同数字的个数</p>\n<p>这么我们在线段树上维护左边的值，每次在线段树上查询是否有一段区间满足上述公式。</p>\n<p>对于线段树上的每一个节点，假设维护的区间为$(a, b)$，那么维护的信息为$min(size(i, r) + l \\times mid), a \\ge i \\le b$。</p>\n<p>由于我们相当于固定住了r这个边界，对r从1～n开始枚举，对于每次对线段树新插入一个数x，假设x上一次出现的位置为p，当前插入的位置为r，那么只对 $(p+1,r]$这段区间内的size值有影响，需要加一。</p>\n<p>另外在查询的时候，要保证查询的区间的右边界都要小于当前枚举到的r。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> root 1, 1, n</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">60000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> lazy;</div><div class=\"line\">    <span class=\"keyword\">double</span> v;</div><div class=\"line\">&#125; tree[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], Case, n, last[MAX];</div><div class=\"line\"><span class=\"keyword\">double</span> M;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">tag</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> p)</span> </span>&#123; tree[o].lazy += p, tree[o].v += p; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[o].lazy) &#123; tag(lson, tree[o].lazy), tag(rson, tree[o].lazy), tree[o].lazy = <span class=\"number\">0</span>; &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//更新根节点的最小值</span></div><div class=\"line\">    tree[o].v = min(tree[lson].v, tree[rson].v);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化假设区间内不同的数字为0</span></div><div class=\"line\">    tree[o].v = M * l;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &gt; r || l &gt; ur) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        <span class=\"comment\">//区间内不同数字的数量加一</span></div><div class=\"line\">        tag(o, <span class=\"number\">1</span>); <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    merge(o);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//进行剪枝</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &gt; pos) <span class=\"keyword\">return</span> <span class=\"number\">1e9</span>;</div><div class=\"line\">    <span class=\"comment\">//必须当前的右边界小于pos才能返回答案</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt;= pos) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o].v;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> min(query(lson, l, m, pos), query(rson, m + <span class=\"number\">1</span>, r, pos));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;Case);</div><div class=\"line\">    <span class=\"keyword\">while</span> (Case--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">        <span class=\"keyword\">double</span> L = <span class=\"number\">0</span>, R = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//最多需要二分20次</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; times &lt; <span class=\"number\">20</span>; times++) &#123;</div><div class=\"line\">            M = (L + R) / <span class=\"number\">2</span>;</div><div class=\"line\">            build(root);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) last[i] = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">bool</span> ok = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">                <span class=\"comment\">//last表示data[i]上一次出现的位置</span></div><div class=\"line\">                updata(root, last[data[i]] + <span class=\"number\">1</span>, i);</div><div class=\"line\">                <span class=\"comment\">//t表示能找到的size(l,r)+mid*l的最小值</span></div><div class=\"line\">                <span class=\"keyword\">double</span> t = query(root, i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (t - M * (i + <span class=\"number\">1</span>) &lt;= <span class=\"number\">0</span>) &#123; ok = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>; &#125;;</div><div class=\"line\">                last[data[i]] = i;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ok) R = M;</div><div class=\"line\">            <span class=\"keyword\">else</span> L = M;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, (L + R) / <span class=\"number\">2</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6070\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=6070</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个序列A，对于序列里面的每一个数字范围为1～n，要求找出一段连续子序列，Y为区间长度，X为区间不同数字的个数，使得X/Y尽量的小。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>多校赛的第四题，也算是A题比较快的一场，最后卡在了这个题上，感觉可以做的，但是不会。只想到了线段树，完全没往二分上面想，听说有$O(N^2)$卡过去的。第一次遇到这样固定一个区间边界的线段树题。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先X是肯定小于等于Y，那么答案的范围一定为[0~1]，这个题是特判，精度误差在$10^{-4}$就可以，这样二分答案只需要20次左右。</p>\n<p>对于二分答案就是检查当前线段树上是否有一个区间，使得<br>$$ \\frac {size(l, r)} {r-l+1}  \\leq mid$$<br>$$ size(l, r) + l \\times mid \\leq mid \\times (r + 1)$$</p>\n<p>上述的size(l, r)为[l, r]内不同数字的个数</p>\n<p>这么我们在线段树上维护左边的值，每次在线段树上查询是否有一段区间满足上述公式。</p>\n<p>对于线段树上的每一个节点，假设维护的区间为$(a, b)$，那么维护的信息为$min(size(i, r) + l \\times mid), a \\ge i \\le b$。</p>\n<p>由于我们相当于固定住了r这个边界，对r从1～n开始枚举，对于每次对线段树新插入一个数x，假设x上一次出现的位置为p，当前插入的位置为r，那么只对 $(p+1,r]$这段区间内的size值有影响，需要加一。</p>\n<p>另外在查询的时候，要保证查询的区间的右边界都要小于当前枚举到的r。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> root 1, 1, n</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">60000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> lazy;</div><div class=\"line\">    <span class=\"keyword\">double</span> v;</div><div class=\"line\">&#125; tree[MAX &lt;&lt; <span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX], Case, n, last[MAX];</div><div class=\"line\"><span class=\"keyword\">double</span> M;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">tag</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> p)</span> </span>&#123; tree[o].lazy += p, tree[o].v += p; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[o].lazy) &#123; tag(lson, tree[o].lazy), tag(rson, tree[o].lazy), tree[o].lazy = <span class=\"number\">0</span>; &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> o)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//更新根节点的最小值</span></div><div class=\"line\">    tree[o].v = min(tree[lson].v, tree[rson].v);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化假设区间内不同的数字为0</span></div><div class=\"line\">    tree[o].v = M * l;</div><div class=\"line\">    tree[o].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m + <span class=\"number\">1</span>, r);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &gt; r || l &gt; ur) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        <span class=\"comment\">//区间内不同数字的数量加一</span></div><div class=\"line\">        tag(o, <span class=\"number\">1</span>); <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m + <span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    merge(o);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//进行剪枝</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &gt; pos) <span class=\"keyword\">return</span> <span class=\"number\">1e9</span>;</div><div class=\"line\">    <span class=\"comment\">//必须当前的右边界小于pos才能返回答案</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (r &lt;= pos) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o].v;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(o);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> min(query(lson, l, m, pos), query(rson, m + <span class=\"number\">1</span>, r, pos));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;Case);</div><div class=\"line\">    <span class=\"keyword\">while</span> (Case--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">        <span class=\"keyword\">double</span> L = <span class=\"number\">0</span>, R = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//最多需要二分20次</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; times &lt; <span class=\"number\">20</span>; times++) &#123;</div><div class=\"line\">            M = (L + R) / <span class=\"number\">2</span>;</div><div class=\"line\">            build(root);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) last[i] = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">bool</span> ok = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">                <span class=\"comment\">//last表示data[i]上一次出现的位置</span></div><div class=\"line\">                updata(root, last[data[i]] + <span class=\"number\">1</span>, i);</div><div class=\"line\">                <span class=\"comment\">//t表示能找到的size(l,r)+mid*l的最小值</span></div><div class=\"line\">                <span class=\"keyword\">double</span> t = query(root, i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (t - M * (i + <span class=\"number\">1</span>) &lt;= <span class=\"number\">0</span>) &#123; ok = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>; &#125;;</div><div class=\"line\">                last[data[i]] = i;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ok) R = M;</div><div class=\"line\">            <span class=\"keyword\">else</span> L = M;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, (L + R) / <span class=\"number\">2</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU6156 - Palindrome Function（数位DP）","date":"2017-08-25T02:37:05.000Z","_content":"# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=6156\n\n\n\n--------------------\n# 题目大意：\n\n设函数 f(n, k) 的取值为，若 n 在 k 进制下为回文数字，那么函数值为 k 否则 为 1 。\n\n给出 a ，b ，L， R。\n\n求 $\\sum\\_{i=a}^b$ $ \\sum\\_{j = L}^R$ $f(i, j)$ 。\n\n\n\n-------------------\n# 解题过程：\n\nCCPC 网络赛的题，算是一个裸的板子题了，数位 DP 之前也算是做过，不过没做过这种类型的数位 DP ，然后弃疗了。过了好久把数位 DP 的专题刷掉之后才来补的。\n\n\n\n--------------------\n# 题目分析：\n\n定义状态`dp[start][pos][flag][k]`\n\n表示在 k 进制下以 start 位置开始的回文串，在 pos 位置下，回文串个数，flag 表示当前串是否为回文串。\n\n对于前导零是忽略掉的，选取前导零就视为将 start 位置减一。对于回文串，前一半随意枚举就可以，后一半要进行判断。即对 `(start+1)/2 > pos `的情况进行判断，这时候要用一个数组记录之前枚举的数字。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 50;\n\nLL dp[MAX][MAX][2][MAX];\nint num[MAX], tmp[MAX], k;\n\nLL dfs(int cur, int start, bool flag, bool bound) {\n    if (cur < 0) return flag;\n    if (!bound && dp[cur][start][flag][k] != -1) return dp[cur][start][flag][k];\n    int last = bound ? num[cur] : k - 1;\n    LL ans = 0;\n    for (int i = 0; i <= last; i++) {\n        //判断是否为前导零\n        bool st = (cur == start && i == 0);\n        bool new_flag = flag;\n        if (flag) {\n            //如果当前是回文串的后半段的话，就判断下当前是否构成回文串\n            if (!st && cur < (start + 1) / 2) new_flag = (tmp[start - cur] == i);\n        }\n        tmp[cur] = i;\n        ans += dfs(cur - 1, st ? start - 1 : start, new_flag, bound && (i == last));\n    }\n    if (!bound) dp[cur][start][flag][k] = ans;\n    return ans;\n}\n\nLL solve(int n) {\n    if (n == 0) return 1;\n    int len = 0;\n    while (n) {\n        num[len++] = n % k;\n        n /= k;\n    }\n    return dfs(len - 1, len - 1, true, true);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    memset(dp, -1, sizeof(dp));\n    for (int Case = 1; Case <= T; Case++) {\n        int a, b, l, r;\n        scanf(\"%d %d %d %d\", &a, &b, &l, &r);\n        LL ans = 0;\n        //枚举进制\n        for (int i = l; i <= r; i++) {\n            k = i;\n            LL t = (solve(b) - solve(a - 1));\n            ans += (b - a + 1) + t * (k - 1);\n        }\n        printf(\"Case #%d: %lld\\n\", Case, ans);\n    }\n}\n```","source":"_posts/HDU6156-Palindrome-Function（数位DP）.md","raw":"---\ntitle: HDU6156 - Palindrome Function（数位DP）\ndate: 2017-08-25 10:37:05\ncategories: [ACM, DP, 数位DP]\ntags:\n---\n# 题目链接：\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=6156\n\n\n\n--------------------\n# 题目大意：\n\n设函数 f(n, k) 的取值为，若 n 在 k 进制下为回文数字，那么函数值为 k 否则 为 1 。\n\n给出 a ，b ，L， R。\n\n求 $\\sum\\_{i=a}^b$ $ \\sum\\_{j = L}^R$ $f(i, j)$ 。\n\n\n\n-------------------\n# 解题过程：\n\nCCPC 网络赛的题，算是一个裸的板子题了，数位 DP 之前也算是做过，不过没做过这种类型的数位 DP ，然后弃疗了。过了好久把数位 DP 的专题刷掉之后才来补的。\n\n\n\n--------------------\n# 题目分析：\n\n定义状态`dp[start][pos][flag][k]`\n\n表示在 k 进制下以 start 位置开始的回文串，在 pos 位置下，回文串个数，flag 表示当前串是否为回文串。\n\n对于前导零是忽略掉的，选取前导零就视为将 start 位置减一。对于回文串，前一半随意枚举就可以，后一半要进行判断。即对 `(start+1)/2 > pos `的情况进行判断，这时候要用一个数组记录之前枚举的数字。\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAX = 50;\n\nLL dp[MAX][MAX][2][MAX];\nint num[MAX], tmp[MAX], k;\n\nLL dfs(int cur, int start, bool flag, bool bound) {\n    if (cur < 0) return flag;\n    if (!bound && dp[cur][start][flag][k] != -1) return dp[cur][start][flag][k];\n    int last = bound ? num[cur] : k - 1;\n    LL ans = 0;\n    for (int i = 0; i <= last; i++) {\n        //判断是否为前导零\n        bool st = (cur == start && i == 0);\n        bool new_flag = flag;\n        if (flag) {\n            //如果当前是回文串的后半段的话，就判断下当前是否构成回文串\n            if (!st && cur < (start + 1) / 2) new_flag = (tmp[start - cur] == i);\n        }\n        tmp[cur] = i;\n        ans += dfs(cur - 1, st ? start - 1 : start, new_flag, bound && (i == last));\n    }\n    if (!bound) dp[cur][start][flag][k] = ans;\n    return ans;\n}\n\nLL solve(int n) {\n    if (n == 0) return 1;\n    int len = 0;\n    while (n) {\n        num[len++] = n % k;\n        n /= k;\n    }\n    return dfs(len - 1, len - 1, true, true);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    memset(dp, -1, sizeof(dp));\n    for (int Case = 1; Case <= T; Case++) {\n        int a, b, l, r;\n        scanf(\"%d %d %d %d\", &a, &b, &l, &r);\n        LL ans = 0;\n        //枚举进制\n        for (int i = l; i <= r; i++) {\n            k = i;\n            LL t = (solve(b) - solve(a - 1));\n            ans += (b - a + 1) + t * (k - 1);\n        }\n        printf(\"Case #%d: %lld\\n\", Case, ans);\n    }\n}\n```","slug":"HDU6156-Palindrome-Function（数位DP）","published":1,"updated":"2017-08-25T02:53:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbt002jy9idsxqiaa1f","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6156\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=6156</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>设函数 f(n, k) 的取值为，若 n 在 k 进制下为回文数字，那么函数值为 k 否则 为 1 。</p>\n<p>给出 a ，b ，L， R。</p>\n<p>求 $\\sum_{i=a}^b$ $ \\sum_{j = L}^R$ $f(i, j)$ 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>CCPC 网络赛的题，算是一个裸的板子题了，数位 DP 之前也算是做过，不过没做过这种类型的数位 DP ，然后弃疗了。过了好久把数位 DP 的专题刷掉之后才来补的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态<code>dp[start][pos][flag][k]</code></p>\n<p>表示在 k 进制下以 start 位置开始的回文串，在 pos 位置下，回文串个数，flag 表示当前串是否为回文串。</p>\n<p>对于前导零是忽略掉的，选取前导零就视为将 start 位置减一。对于回文串，前一半随意枚举就可以，后一半要进行判断。即对 <code>(start+1)/2 &gt; pos</code>的情况进行判断，这时候要用一个数组记录之前枚举的数字。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">50</span>;</div><div class=\"line\"></div><div class=\"line\">LL dp[MAX][MAX][<span class=\"number\">2</span>][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], tmp[MAX], k;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span> start, <span class=\"keyword\">bool</span> flag, <span class=\"keyword\">bool</span> bound)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> flag;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!bound &amp;&amp; dp[cur][start][flag][k] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> dp[cur][start][flag][k];</div><div class=\"line\">    <span class=\"keyword\">int</span> last = bound ? num[cur] : k - <span class=\"number\">1</span>;</div><div class=\"line\">    LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= last; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//判断是否为前导零</span></div><div class=\"line\">        <span class=\"keyword\">bool</span> st = (cur == start &amp;&amp; i == <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">bool</span> new_flag = flag;</div><div class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果当前是回文串的后半段的话，就判断下当前是否构成回文串</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!st &amp;&amp; cur &lt; (start + <span class=\"number\">1</span>) / <span class=\"number\">2</span>) new_flag = (tmp[start - cur] == i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        tmp[cur] = i;</div><div class=\"line\">        ans += dfs(cur - <span class=\"number\">1</span>, st ? start - <span class=\"number\">1</span> : start, new_flag, bound &amp;&amp; (i == last));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!bound) dp[cur][start][flag][k] = ans;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</div><div class=\"line\">        num[len++] = n % k;</div><div class=\"line\">        n /= k;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dfs(len - <span class=\"number\">1</span>, len - <span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, l, r;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;a, &amp;b, &amp;l, &amp;r);</div><div class=\"line\">        LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//枚举进制</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l; i &lt;= r; i++) &#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            LL t = (solve(b) - solve(a - <span class=\"number\">1</span>));</div><div class=\"line\">            ans += (b - a + <span class=\"number\">1</span>) + t * (k - <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %lld\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6156\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=6156</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>设函数 f(n, k) 的取值为，若 n 在 k 进制下为回文数字，那么函数值为 k 否则 为 1 。</p>\n<p>给出 a ，b ，L， R。</p>\n<p>求 $\\sum_{i=a}^b$ $ \\sum_{j = L}^R$ $f(i, j)$ 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>CCPC 网络赛的题，算是一个裸的板子题了，数位 DP 之前也算是做过，不过没做过这种类型的数位 DP ，然后弃疗了。过了好久把数位 DP 的专题刷掉之后才来补的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态<code>dp[start][pos][flag][k]</code></p>\n<p>表示在 k 进制下以 start 位置开始的回文串，在 pos 位置下，回文串个数，flag 表示当前串是否为回文串。</p>\n<p>对于前导零是忽略掉的，选取前导零就视为将 start 位置减一。对于回文串，前一半随意枚举就可以，后一半要进行判断。即对 <code>(start+1)/2 &gt; pos</code>的情况进行判断，这时候要用一个数组记录之前枚举的数字。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">50</span>;</div><div class=\"line\"></div><div class=\"line\">LL dp[MAX][MAX][<span class=\"number\">2</span>][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> num[MAX], tmp[MAX], k;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span> start, <span class=\"keyword\">bool</span> flag, <span class=\"keyword\">bool</span> bound)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> flag;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!bound &amp;&amp; dp[cur][start][flag][k] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> dp[cur][start][flag][k];</div><div class=\"line\">    <span class=\"keyword\">int</span> last = bound ? num[cur] : k - <span class=\"number\">1</span>;</div><div class=\"line\">    LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= last; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//判断是否为前导零</span></div><div class=\"line\">        <span class=\"keyword\">bool</span> st = (cur == start &amp;&amp; i == <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">bool</span> new_flag = flag;</div><div class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果当前是回文串的后半段的话，就判断下当前是否构成回文串</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!st &amp;&amp; cur &lt; (start + <span class=\"number\">1</span>) / <span class=\"number\">2</span>) new_flag = (tmp[start - cur] == i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        tmp[cur] = i;</div><div class=\"line\">        ans += dfs(cur - <span class=\"number\">1</span>, st ? start - <span class=\"number\">1</span> : start, new_flag, bound &amp;&amp; (i == last));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!bound) dp[cur][start][flag][k] = ans;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</div><div class=\"line\">        num[len++] = n % k;</div><div class=\"line\">        n /= k;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dfs(len - <span class=\"number\">1</span>, len - <span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, l, r;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;a, &amp;b, &amp;l, &amp;r);</div><div class=\"line\">        LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//枚举进制</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l; i &lt;= r; i++) &#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            LL t = (solve(b) - solve(a - <span class=\"number\">1</span>));</div><div class=\"line\">            ans += (b - a + <span class=\"number\">1</span>) + t * (k - <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: %lld\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HackerRank - pairs-again（暴力+预处理）","date":"2017-06-26T03:13:15.000Z","_content":"# 题目链接：\nhttps://www.hackerrank.com/contests/w26/challenges/pairs-again\n\n------------------\n# 题目大意：\n给定一个数n，问有多少对$a,b$满足$xa+by=n$至少有一个解，$a<b$并且$0 < b, 0 < y$，且$x,y$是整数。\n\n-----------------------------\n# 解题过程：\n比赛时候的题，当初那场比赛运气还不错，这道题看到一堆人WA了60多发，于是没敢去做，后来去补了，也算是学下如何预处理约数。\n\n--------------------------------\n# 题目分析：\n\n这题的时限很奇怪，都能跑到59秒。\n\n这里要预处理出来前n个数的所有约数。然后枚举$a$和$x$，$n-xa$为$bx$，把$bx$的约数当做$b$，记录下$bx$大于$a$的约数，不过对于$ax+by = cx + by = n$的情况要去一下重。\n\n预处理约数可以类比下欧拉筛法的思想。\n\n----------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 312345;\n\nvector<int> divisor[MAX];\nint flag[MAX];\n\nint main() {\n    int n;\n    cin >> n;\n    //预处理前n个数的约数，类比欧拉筛法\n    for (int i = 2; i < n; i++) {\n        for (int j = i; j < n; j += i) {\n            divisor[j].push_back(i);\n        }\n    }\n    int ans = 0;\n    memset(flag, 0, sizeof(flag));\n    for (int a = 1; a < n; a++) {\n        for (int xa = a; xa < n; xa += a) {\n            int yb = n - xa;\n            for (int i = 0; i < divisor[yb].size(); i++) {\n                int t = divisor[yb][i];\n                //让每个t对于每个a只用一次，并且保证t > a\n                if (flag[t] == a || t <= a) continue;\n                flag[t] = a;\n                ans++;\n            }\n        }\n    }\n    cout << ans;\n}\n```","source":"_posts/HackerRank-pairs-again（暴力-预处理）.md","raw":"---\ntitle: HackerRank - pairs-again（暴力+预处理）\ndate: 2017-06-26 11:13:15\ncategories: [ACM, 数学]\ntags:\n---\n# 题目链接：\nhttps://www.hackerrank.com/contests/w26/challenges/pairs-again\n\n------------------\n# 题目大意：\n给定一个数n，问有多少对$a,b$满足$xa+by=n$至少有一个解，$a<b$并且$0 < b, 0 < y$，且$x,y$是整数。\n\n-----------------------------\n# 解题过程：\n比赛时候的题，当初那场比赛运气还不错，这道题看到一堆人WA了60多发，于是没敢去做，后来去补了，也算是学下如何预处理约数。\n\n--------------------------------\n# 题目分析：\n\n这题的时限很奇怪，都能跑到59秒。\n\n这里要预处理出来前n个数的所有约数。然后枚举$a$和$x$，$n-xa$为$bx$，把$bx$的约数当做$b$，记录下$bx$大于$a$的约数，不过对于$ax+by = cx + by = n$的情况要去一下重。\n\n预处理约数可以类比下欧拉筛法的思想。\n\n----------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 312345;\n\nvector<int> divisor[MAX];\nint flag[MAX];\n\nint main() {\n    int n;\n    cin >> n;\n    //预处理前n个数的约数，类比欧拉筛法\n    for (int i = 2; i < n; i++) {\n        for (int j = i; j < n; j += i) {\n            divisor[j].push_back(i);\n        }\n    }\n    int ans = 0;\n    memset(flag, 0, sizeof(flag));\n    for (int a = 1; a < n; a++) {\n        for (int xa = a; xa < n; xa += a) {\n            int yb = n - xa;\n            for (int i = 0; i < divisor[yb].size(); i++) {\n                int t = divisor[yb][i];\n                //让每个t对于每个a只用一次，并且保证t > a\n                if (flag[t] == a || t <= a) continue;\n                flag[t] = a;\n                ans++;\n            }\n        }\n    }\n    cout << ans;\n}\n```","slug":"HackerRank-pairs-again（暴力-预处理）","published":1,"updated":"2017-08-20T05:28:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbw002ly9idyhetlwfx","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://www.hackerrank.com/contests/w26/challenges/pairs-again\" target=\"_blank\" rel=\"external\">https://www.hackerrank.com/contests/w26/challenges/pairs-again</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个数n，问有多少对$a,b$满足$xa+by=n$至少有一个解，$a&lt;b$并且$0 &lt; b, 0 &lt; y$，且$x,y$是整数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛时候的题，当初那场比赛运气还不错，这道题看到一堆人WA了60多发，于是没敢去做，后来去补了，也算是学下如何预处理约数。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这题的时限很奇怪，都能跑到59秒。</p>\n<p>这里要预处理出来前n个数的所有约数。然后枚举$a$和$x$，$n-xa$为$bx$，把$bx$的约数当做$b$，记录下$bx$大于$a$的约数，不过对于$ax+by = cx + by = n$的情况要去一下重。</p>\n<p>预处理约数可以类比下欧拉筛法的思想。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">312345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; divisor[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> flag[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"comment\">//预处理前n个数的约数，类比欧拉筛法</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; n; j += i) &#123;</div><div class=\"line\">            divisor[j].push_back(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(flag, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flag));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>; a &lt; n; a++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> xa = a; xa &lt; n; xa += a) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> yb = n - xa;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; divisor[yb].size(); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t = divisor[yb][i];</div><div class=\"line\">                <span class=\"comment\">//让每个t对于每个a只用一次，并且保证t &gt; a</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (flag[t] == a || t &lt;= a) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                flag[t] = a;</div><div class=\"line\">                ans++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://www.hackerrank.com/contests/w26/challenges/pairs-again\" target=\"_blank\" rel=\"external\">https://www.hackerrank.com/contests/w26/challenges/pairs-again</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个数n，问有多少对$a,b$满足$xa+by=n$至少有一个解，$a&lt;b$并且$0 &lt; b, 0 &lt; y$，且$x,y$是整数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛时候的题，当初那场比赛运气还不错，这道题看到一堆人WA了60多发，于是没敢去做，后来去补了，也算是学下如何预处理约数。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这题的时限很奇怪，都能跑到59秒。</p>\n<p>这里要预处理出来前n个数的所有约数。然后枚举$a$和$x$，$n-xa$为$bx$，把$bx$的约数当做$b$，记录下$bx$大于$a$的约数，不过对于$ax+by = cx + by = n$的情况要去一下重。</p>\n<p>预处理约数可以类比下欧拉筛法的思想。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">312345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; divisor[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> flag[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"comment\">//预处理前n个数的约数，类比欧拉筛法</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; n; j += i) &#123;</div><div class=\"line\">            divisor[j].push_back(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(flag, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flag));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>; a &lt; n; a++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> xa = a; xa &lt; n; xa += a) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> yb = n - xa;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; divisor[yb].size(); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t = divisor[yb][i];</div><div class=\"line\">                <span class=\"comment\">//让每个t对于每个a只用一次，并且保证t &gt; a</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (flag[t] == a || t &lt;= a) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                flag[t] = a;</div><div class=\"line\">                ans++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDUOJ3549 - Flow Problem（网络流+最大流最小割+模板）","date":"2017-05-19T01:43:24.000Z","_content":"# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3549\n\n----------------------------------\n# 题目大意：\n 有向图求最大流\n\n--------------------------------\n# 解题过程：\n\n\n关于为什么增加流量时要增加一个反向负流量的边纠结了很久，最后还是想通了，其他就没难点了。\n\n------------------------------\n# 题目分析：\n\n增广路算法，每一次尽可能的添加一条增广路，直到不能添加增广路为止，不过有个特殊的地方，按照挑战书上的说法是，可以把之前的流推回去。按照我的理解大概是现在的这个新加的增广路用之前流量的路径，然后把之前流的路径推回去，然后之前的流量寻找一个新的路径。\n\n\n\n\n--------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 20, INF = 0x3f3f3f3f;\n\nstruct Node {\n    //to表示要指向的点，cap是剩余流量，rev是指这条边的方向边是to这个点的第几条边\n    int to, rev, cap;\n    Node(int to, int cap, int rev):to(to), cap(cap), rev(rev) {}\n};\n\nvector<Node> edge[MAX];\nint vis[MAX];\n\nvoid add_edge(int u, int v, int w) {\n    //添加边和反向边\n    edge[u].push_back(Node(v, w, edge[v].size()));\n    edge[v].push_back(Node(u, 0, edge[u].size()-1));\n}\n\nint dfs(int u, int end, int f) {\n    if (u == end)\n        return f;\n    vis[u] = 1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        Node& e = edge[u][i];\n        if (!vis[e.to] && e.cap > 0) {\n            int d = dfs(e.to, end, min(f, e.cap));\n            //如果找到了增广路就返回\n            if (d > 0) {\n                //正向边容量减少的时候，反向边要增加容量\n                e.cap -= d;\n                edge[e.to][e.rev].cap += d;\n                return  d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        memset(vis, 0, sizeof(vis));\n        int f = dfs(s, t, INF);\n        //如果找不到增广路了，那么当前就是最大流了，返回\n        if (f == 0)\n            return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int cases = 1; cases <= T; cases++) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n; i++)\n            edge[i].clear();\n\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            add_edge(u, v, w);\n        }\n\n        printf(\"Case %d: %d\\n\", cases, max_flow(1, n));\n    }\n}\n```","source":"_posts/HDUOJ3549-Flow-Problem（网络流-最大流最小割-模板）.md","raw":"---\ntitle: HDUOJ3549 - Flow Problem（网络流+最大流最小割+模板）\ndate: 2017-05-19 09:43:24\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3549\n\n----------------------------------\n# 题目大意：\n 有向图求最大流\n\n--------------------------------\n# 解题过程：\n\n\n关于为什么增加流量时要增加一个反向负流量的边纠结了很久，最后还是想通了，其他就没难点了。\n\n------------------------------\n# 题目分析：\n\n增广路算法，每一次尽可能的添加一条增广路，直到不能添加增广路为止，不过有个特殊的地方，按照挑战书上的说法是，可以把之前的流推回去。按照我的理解大概是现在的这个新加的增广路用之前流量的路径，然后把之前流的路径推回去，然后之前的流量寻找一个新的路径。\n\n\n\n\n--------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 20, INF = 0x3f3f3f3f;\n\nstruct Node {\n    //to表示要指向的点，cap是剩余流量，rev是指这条边的方向边是to这个点的第几条边\n    int to, rev, cap;\n    Node(int to, int cap, int rev):to(to), cap(cap), rev(rev) {}\n};\n\nvector<Node> edge[MAX];\nint vis[MAX];\n\nvoid add_edge(int u, int v, int w) {\n    //添加边和反向边\n    edge[u].push_back(Node(v, w, edge[v].size()));\n    edge[v].push_back(Node(u, 0, edge[u].size()-1));\n}\n\nint dfs(int u, int end, int f) {\n    if (u == end)\n        return f;\n    vis[u] = 1;\n    for (int i = 0; i < edge[u].size(); i++) {\n        Node& e = edge[u][i];\n        if (!vis[e.to] && e.cap > 0) {\n            int d = dfs(e.to, end, min(f, e.cap));\n            //如果找到了增广路就返回\n            if (d > 0) {\n                //正向边容量减少的时候，反向边要增加容量\n                e.cap -= d;\n                edge[e.to][e.rev].cap += d;\n                return  d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        memset(vis, 0, sizeof(vis));\n        int f = dfs(s, t, INF);\n        //如果找不到增广路了，那么当前就是最大流了，返回\n        if (f == 0)\n            return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int cases = 1; cases <= T; cases++) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n; i++)\n            edge[i].clear();\n\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            add_edge(u, v, w);\n        }\n\n        printf(\"Case %d: %d\\n\", cases, max_flow(1, n));\n    }\n}\n```","slug":"HDUOJ3549-Flow-Problem（网络流-最大流最小割-模板）","published":1,"updated":"2017-07-23T02:30:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nbz002ny9idlpgfue9s","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3549\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3549</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有向图求最大流</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>关于为什么增加流量时要增加一个反向负流量的边纠结了很久，最后还是想通了，其他就没难点了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>增广路算法，每一次尽可能的添加一条增广路，直到不能添加增广路为止，不过有个特殊的地方，按照挑战书上的说法是，可以把之前的流推回去。按照我的理解大概是现在的这个新加的增广路用之前流量的路径，然后把之前流的路径推回去，然后之前的流量寻找一个新的路径。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">20</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"comment\">//to表示要指向的点，cap是剩余流量，rev是指这条边的方向边是to这个点的第几条边</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, rev, cap;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> rev):to(to), cap(cap), rev(rev) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//添加边和反向边</span></div><div class=\"line\">    edge[u].push_back(Node(v, w, edge[v].size()));</div><div class=\"line\">    edge[v].push_back(Node(u, <span class=\"number\">0</span>, edge[u].size()<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end)</div><div class=\"line\">        <span class=\"keyword\">return</span> f;</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        Node&amp; e = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> d = dfs(e.to, end, min(f, e.cap));</div><div class=\"line\">            <span class=\"comment\">//如果找到了增广路就返回</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (d &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//正向边容量减少的时候，反向边要增加容量</span></div><div class=\"line\">                e.cap -= d;</div><div class=\"line\">                edge[e.to][e.rev].cap += d;</div><div class=\"line\">                <span class=\"keyword\">return</span>  d;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">        <span class=\"keyword\">int</span> f = dfs(s, t, INF);</div><div class=\"line\">        <span class=\"comment\">//如果找不到增广路了，那么当前就是最大流了，返回</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> flow;</div><div class=\"line\">        flow += f;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= T; cases++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            add_edge(u, v, w);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, cases, max_flow(<span class=\"number\">1</span>, n));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3549\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3549</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有向图求最大流</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>关于为什么增加流量时要增加一个反向负流量的边纠结了很久，最后还是想通了，其他就没难点了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>增广路算法，每一次尽可能的添加一条增广路，直到不能添加增广路为止，不过有个特殊的地方，按照挑战书上的说法是，可以把之前的流推回去。按照我的理解大概是现在的这个新加的增广路用之前流量的路径，然后把之前流的路径推回去，然后之前的流量寻找一个新的路径。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">20</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"comment\">//to表示要指向的点，cap是剩余流量，rev是指这条边的方向边是to这个点的第几条边</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, rev, cap;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> rev):to(to), cap(cap), rev(rev) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//添加边和反向边</span></div><div class=\"line\">    edge[u].push_back(Node(v, w, edge[v].size()));</div><div class=\"line\">    edge[v].push_back(Node(u, <span class=\"number\">0</span>, edge[u].size()<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (u == end)</div><div class=\"line\">        <span class=\"keyword\">return</span> f;</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">        Node&amp; e = edge[u][i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> d = dfs(e.to, end, min(f, e.cap));</div><div class=\"line\">            <span class=\"comment\">//如果找到了增广路就返回</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (d &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//正向边容量减少的时候，反向边要增加容量</span></div><div class=\"line\">                e.cap -= d;</div><div class=\"line\">                edge[e.to][e.rev].cap += d;</div><div class=\"line\">                <span class=\"keyword\">return</span>  d;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flow = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">        <span class=\"keyword\">int</span> f = dfs(s, t, INF);</div><div class=\"line\">        <span class=\"comment\">//如果找不到增广路了，那么当前就是最大流了，返回</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> flow;</div><div class=\"line\">        flow += f;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= T; cases++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            add_edge(u, v, w);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, cases, max_flow(<span class=\"number\">1</span>, n));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HihoCoder1424 - Asa's Chess Problem（有上下流量限制的费用流）","date":"2017-10-15T23:53:42.000Z","_content":"# 题目链接：\n\n[https://vjudge.net/problem/HihoCoder-1424](https://vjudge.net/problem/HihoCoder-1424)\n\n# 题目大意：\n\n参考 [http://www.cnblogs.com/flipped/p/7635420.html](http://www.cnblogs.com/flipped/p/7635420.html)\n\n> 有个 N×N 的棋盘，告诉你每个格子黑色(1)或白色(0)，以及每对能相互交换的同行或同列格子，每个格子只在一对中，即共有N×N/2对。求最少交换次数使得每行每列的黑格子总数满足给出的上下范围：若最终第i行,第j列分别有R[i],C[j]个黑格子，那么需要让Rl[i]≤R[i]≤Rh[i],Cl[j]≤C[i]≤Ch[j]。\n\n\n\n# 题目分析：\n\n这里先介绍一种有流量下限限制的建图方式，参考[这个博客](http://www.cnblogs.com/kane0526/archive/2013/04/05/3001108.html)。\n\n记节点 i 所有流入的流量下限和为 in[i]，所有的流出流入和下限为 out[i]，建一个超级源点 SS，超级汇点 ST。\n\n如果一个节点 in[i] > out[i]，那么建一条 SS 到 i 的边，流量为 in[i] - out[i]。\n\n如果 in[i] < out[i]，那么建一条 i 到 ST 的边，流量为 out[i] - in[i]。\n\n对于无源汇的图来说，上面从 SS 到 ST跑一个最大流，如果上面的从 SS 出发的附加边满流，当前就是一个可行流，否则无解。\n\n对于有源汇的图来说，需要从 T 到 S 连一条流量为无穷的边，然后再从 SS 到 ST 跑最大流。 \n\n\n\n对于这个题，设每一行每一列原有的黑色棋子数量为 R[i] 和 C[i]。\n\n+ 首先从 S 到每一行每一列建一条上下限均为 R[i] 或 C[i] 的边\n+ 每一行每一列对 T 建边，容量上下限为 Rl[i]， Rh[i] 或 Cl[i]，Ch[i]\n+ 然后对于可以交换的棋子，如果他们颜色相同，那么不需要建边，否则如果列相同，黑色所在的行向白色棋子所在的行建流量下限为 0 上限为 1 费用为 1 的边，列相同类似\n+ 从 t 到 s 建一条流量下限为 0，上限为无穷的边。\n\n上述所有边默认费用为 0 。\n\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 600;\n\nint n;\nint data[112][112];\n\nstruct Edge {\n    int u, v, c, w, nxt;\n} edge[MAX * MAX];\n\nint head[MAX], etot;\n\nint in[112], out[112];\n\nvoid add_edge(int u, int v, int low, int up, int w) {\n    edge[etot].u = u;\n    edge[etot].v = v;\n    edge[etot].c = up - low;\n    edge[etot].w = w;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n\n    out[u] += low;\n\n    edge[etot].u = v;\n    edge[etot].v = u;\n    edge[etot].c = 0;\n    edge[etot].w = -w;\n    edge[etot].nxt = head[v];\n    head[v] = etot++;\n\n    in[v] += low;\n}\n\nint dist[MAX], vis[MAX], pre[MAX], flow[MAX];\n\nvoid spfa(int s) {\n    memset(dist, 0x3f, sizeof(dist));\n    queue<int> q;\n    q.push(s);\n    flow[s] = 1e9;\n    vis[s] = 1;\n    dist[s] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            Edge &e = edge[i];\n            if (edge[i].c > 0 && dist[e.v] > dist[e.u] + e.w) {\n                dist[e.v] = dist[e.u] + e.w;\n                pre[e.v] = i;\n                flow[e.v] = min(flow[e.u], e.c);\n                if (!vis[e.v]) {\n                    vis[e.v] = true;\n                    q.push(e.v);\n                }\n            }\n        }\n        vis[u] = false;\n    }\n}\n\npair<int, int> min_cost_flow(int s, int e) {\n    int rst = 0, total = 0;\n    while (true) {\n        spfa(s);\n        if (dist[e] == 0x3f3f3f3f) break;\n        int d = flow[e], u = e;\n        total += d;\n        rst += dist[e] * d;\n        while (u != s) {\n            int last = pre[u];\n            edge[last].c -= d;\n            edge[last ^ 1].c += d;\n            u = edge[last].u;\n        }\n    }\n    return make_pair(total, rst);\n}\n\n\nint Rl[112], Rh[112], Cl[112], Ch[112];\n\nint row[112], col[112];\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n\n        etot = 0;\n        memset(head, -1, sizeof(head));\n        memset(col, 0, sizeof(col));\n        memset(row, 0, sizeof(row));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n\n\n        //源点，汇点，超级源点，超级汇点\n        int s = 0;\n        int e = n * 2 + 1;\n        int ss = e + 1;\n        int se = ss + 1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%d\", &data[i][j]);\n                row[i] += data[i][j];\n                col[j] += data[i][j];\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &Rl[i], &Rh[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &Cl[i], &Ch[i]);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            add_edge(s, i, row[i], row[i], 0);\n            add_edge(s, i + n, col[i], col[i], 0);\n            add_edge(i, e, Rl[i], Rh[i], 0);\n            add_edge(i + n, e, Cl[i], Ch[i], 0);\n        }\n\n        int sum = 0;\n\n        for (int i = 1; i <= n * n / 2; i++) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            if (data[x1][y1] == data[x2][y2]) continue;\n            if (data[x1][y1] == 0) swap(x1, x2), swap(y1, y2);\n            if (x1 == x2) {\n                add_edge(n + y1, n + y2, 0, 1, 1);\n            } else if (y1 == y2) {\n                add_edge(x1, x2, 0, 1, 1);\n            }\n        }\n\n        add_edge(e, s, 0, 1e9, 0);\n\n        //对超级源点，超级汇点建边\n        for (int i = 0; i <= n + n + 1; i++) {\n            int t = in[i] - out[i];\n            if (t < 0) {\n                t = -t;\n                add_edge(i, se, 0, t, 0);\n            } else {\n                sum += t;\n                add_edge(ss, i, 0, t, 0);\n            }\n        }\n\n\n        pair<int, int> ans = min_cost_flow(ss, se);\n\n        if (ans.first != sum) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", ans.second);\n        }\n    }\n}\n```\n# 解题过程：\n\n这个题感觉也不是很难，感觉应该做出来的，关键是比赛的时候漏看了一个条件，只有列或行相同时才可以交换，如果没有这个条件建图就复杂了，当时也想麻烦了。","source":"_posts/HihoCoder1424-Asa-s-Chess-Problem（有上下流量限制的费用流）.md","raw":"---\ntitle: HihoCoder1424 - Asa's Chess Problem（有上下流量限制的费用流）\ndate: 2017-10-16 07:53:42\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\n\n[https://vjudge.net/problem/HihoCoder-1424](https://vjudge.net/problem/HihoCoder-1424)\n\n# 题目大意：\n\n参考 [http://www.cnblogs.com/flipped/p/7635420.html](http://www.cnblogs.com/flipped/p/7635420.html)\n\n> 有个 N×N 的棋盘，告诉你每个格子黑色(1)或白色(0)，以及每对能相互交换的同行或同列格子，每个格子只在一对中，即共有N×N/2对。求最少交换次数使得每行每列的黑格子总数满足给出的上下范围：若最终第i行,第j列分别有R[i],C[j]个黑格子，那么需要让Rl[i]≤R[i]≤Rh[i],Cl[j]≤C[i]≤Ch[j]。\n\n\n\n# 题目分析：\n\n这里先介绍一种有流量下限限制的建图方式，参考[这个博客](http://www.cnblogs.com/kane0526/archive/2013/04/05/3001108.html)。\n\n记节点 i 所有流入的流量下限和为 in[i]，所有的流出流入和下限为 out[i]，建一个超级源点 SS，超级汇点 ST。\n\n如果一个节点 in[i] > out[i]，那么建一条 SS 到 i 的边，流量为 in[i] - out[i]。\n\n如果 in[i] < out[i]，那么建一条 i 到 ST 的边，流量为 out[i] - in[i]。\n\n对于无源汇的图来说，上面从 SS 到 ST跑一个最大流，如果上面的从 SS 出发的附加边满流，当前就是一个可行流，否则无解。\n\n对于有源汇的图来说，需要从 T 到 S 连一条流量为无穷的边，然后再从 SS 到 ST 跑最大流。 \n\n\n\n对于这个题，设每一行每一列原有的黑色棋子数量为 R[i] 和 C[i]。\n\n+ 首先从 S 到每一行每一列建一条上下限均为 R[i] 或 C[i] 的边\n+ 每一行每一列对 T 建边，容量上下限为 Rl[i]， Rh[i] 或 Cl[i]，Ch[i]\n+ 然后对于可以交换的棋子，如果他们颜色相同，那么不需要建边，否则如果列相同，黑色所在的行向白色棋子所在的行建流量下限为 0 上限为 1 费用为 1 的边，列相同类似\n+ 从 t 到 s 建一条流量下限为 0，上限为无穷的边。\n\n上述所有边默认费用为 0 。\n\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 600;\n\nint n;\nint data[112][112];\n\nstruct Edge {\n    int u, v, c, w, nxt;\n} edge[MAX * MAX];\n\nint head[MAX], etot;\n\nint in[112], out[112];\n\nvoid add_edge(int u, int v, int low, int up, int w) {\n    edge[etot].u = u;\n    edge[etot].v = v;\n    edge[etot].c = up - low;\n    edge[etot].w = w;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n\n    out[u] += low;\n\n    edge[etot].u = v;\n    edge[etot].v = u;\n    edge[etot].c = 0;\n    edge[etot].w = -w;\n    edge[etot].nxt = head[v];\n    head[v] = etot++;\n\n    in[v] += low;\n}\n\nint dist[MAX], vis[MAX], pre[MAX], flow[MAX];\n\nvoid spfa(int s) {\n    memset(dist, 0x3f, sizeof(dist));\n    queue<int> q;\n    q.push(s);\n    flow[s] = 1e9;\n    vis[s] = 1;\n    dist[s] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            Edge &e = edge[i];\n            if (edge[i].c > 0 && dist[e.v] > dist[e.u] + e.w) {\n                dist[e.v] = dist[e.u] + e.w;\n                pre[e.v] = i;\n                flow[e.v] = min(flow[e.u], e.c);\n                if (!vis[e.v]) {\n                    vis[e.v] = true;\n                    q.push(e.v);\n                }\n            }\n        }\n        vis[u] = false;\n    }\n}\n\npair<int, int> min_cost_flow(int s, int e) {\n    int rst = 0, total = 0;\n    while (true) {\n        spfa(s);\n        if (dist[e] == 0x3f3f3f3f) break;\n        int d = flow[e], u = e;\n        total += d;\n        rst += dist[e] * d;\n        while (u != s) {\n            int last = pre[u];\n            edge[last].c -= d;\n            edge[last ^ 1].c += d;\n            u = edge[last].u;\n        }\n    }\n    return make_pair(total, rst);\n}\n\n\nint Rl[112], Rh[112], Cl[112], Ch[112];\n\nint row[112], col[112];\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n\n        etot = 0;\n        memset(head, -1, sizeof(head));\n        memset(col, 0, sizeof(col));\n        memset(row, 0, sizeof(row));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n\n\n        //源点，汇点，超级源点，超级汇点\n        int s = 0;\n        int e = n * 2 + 1;\n        int ss = e + 1;\n        int se = ss + 1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%d\", &data[i][j]);\n                row[i] += data[i][j];\n                col[j] += data[i][j];\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &Rl[i], &Rh[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &Cl[i], &Ch[i]);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            add_edge(s, i, row[i], row[i], 0);\n            add_edge(s, i + n, col[i], col[i], 0);\n            add_edge(i, e, Rl[i], Rh[i], 0);\n            add_edge(i + n, e, Cl[i], Ch[i], 0);\n        }\n\n        int sum = 0;\n\n        for (int i = 1; i <= n * n / 2; i++) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            if (data[x1][y1] == data[x2][y2]) continue;\n            if (data[x1][y1] == 0) swap(x1, x2), swap(y1, y2);\n            if (x1 == x2) {\n                add_edge(n + y1, n + y2, 0, 1, 1);\n            } else if (y1 == y2) {\n                add_edge(x1, x2, 0, 1, 1);\n            }\n        }\n\n        add_edge(e, s, 0, 1e9, 0);\n\n        //对超级源点，超级汇点建边\n        for (int i = 0; i <= n + n + 1; i++) {\n            int t = in[i] - out[i];\n            if (t < 0) {\n                t = -t;\n                add_edge(i, se, 0, t, 0);\n            } else {\n                sum += t;\n                add_edge(ss, i, 0, t, 0);\n            }\n        }\n\n\n        pair<int, int> ans = min_cost_flow(ss, se);\n\n        if (ans.first != sum) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", ans.second);\n        }\n    }\n}\n```\n# 解题过程：\n\n这个题感觉也不是很难，感觉应该做出来的，关键是比赛的时候漏看了一个条件，只有列或行相同时才可以交换，如果没有这个条件建图就复杂了，当时也想麻烦了。","slug":"HihoCoder1424-Asa-s-Chess-Problem（有上下流量限制的费用流）","published":1,"updated":"2017-10-16T10:47:42.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nc1002qy9idzcil3mkk","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HihoCoder-1424\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HihoCoder-1424</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>参考 <a href=\"http://www.cnblogs.com/flipped/p/7635420.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/flipped/p/7635420.html</a></p>\n<blockquote>\n<p>有个 N×N 的棋盘，告诉你每个格子黑色(1)或白色(0)，以及每对能相互交换的同行或同列格子，每个格子只在一对中，即共有N×N/2对。求最少交换次数使得每行每列的黑格子总数满足给出的上下范围：若最终第i行,第j列分别有R[i],C[j]个黑格子，那么需要让Rl[i]≤R[i]≤Rh[i],Cl[j]≤C[i]≤Ch[j]。</p>\n</blockquote>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里先介绍一种有流量下限限制的建图方式，参考<a href=\"http://www.cnblogs.com/kane0526/archive/2013/04/05/3001108.html\" target=\"_blank\" rel=\"external\">这个博客</a>。</p>\n<p>记节点 i 所有流入的流量下限和为 in[i]，所有的流出流入和下限为 out[i]，建一个超级源点 SS，超级汇点 ST。</p>\n<p>如果一个节点 in[i] &gt; out[i]，那么建一条 SS 到 i 的边，流量为 in[i] - out[i]。</p>\n<p>如果 in[i] &lt; out[i]，那么建一条 i 到 ST 的边，流量为 out[i] - in[i]。</p>\n<p>对于无源汇的图来说，上面从 SS 到 ST跑一个最大流，如果上面的从 SS 出发的附加边满流，当前就是一个可行流，否则无解。</p>\n<p>对于有源汇的图来说，需要从 T 到 S 连一条流量为无穷的边，然后再从 SS 到 ST 跑最大流。 </p>\n<p>对于这个题，设每一行每一列原有的黑色棋子数量为 R[i] 和 C[i]。</p>\n<ul>\n<li>首先从 S 到每一行每一列建一条上下限均为 R[i] 或 C[i] 的边</li>\n<li>每一行每一列对 T 建边，容量上下限为 Rl[i]， Rh[i] 或 Cl[i]，Ch[i]</li>\n<li>然后对于可以交换的棋子，如果他们颜色相同，那么不需要建边，否则如果列相同，黑色所在的行向白色棋子所在的行建流量下限为 0 上限为 1 费用为 1 的边，列相同类似</li>\n<li>从 t 到 s 建一条流量下限为 0，上限为无穷的边。</li>\n</ul>\n<p>上述所有边默认费用为 0 。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">600</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, c, w, nxt;</div><div class=\"line\">&#125; edge[MAX * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> in[<span class=\"number\">112</span>], out[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> up, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].c = up - low;</div><div class=\"line\">    edge[etot].w = w;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\"></div><div class=\"line\">    out[u] += low;</div><div class=\"line\"></div><div class=\"line\">    edge[etot].u = v;</div><div class=\"line\">    edge[etot].v = u;</div><div class=\"line\">    edge[etot].c = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[etot].w = -w;</div><div class=\"line\">    edge[etot].nxt = head[v];</div><div class=\"line\">    head[v] = etot++;</div><div class=\"line\"></div><div class=\"line\">    in[v] += low;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], pre[MAX], flow[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    flow[s] = <span class=\"number\">1e9</span>;</div><div class=\"line\">    vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            Edge &amp;e = edge[i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].c &gt; <span class=\"number\">0</span> &amp;&amp; dist[e.v] &gt; dist[e.u] + e.w) &#123;</div><div class=\"line\">                dist[e.v] = dist[e.u] + e.w;</div><div class=\"line\">                pre[e.v] = i;</div><div class=\"line\">                flow[e.v] = min(flow[e.u], e.c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.v]) &#123;</div><div class=\"line\">                    vis[e.v] = <span class=\"literal\">true</span>;</div><div class=\"line\">                    q.push(e.v);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        vis[u] = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; min_cost_flow(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>, total = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        spfa(s);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[e] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = flow[e], u = e;</div><div class=\"line\">        total += d;</div><div class=\"line\">        rst += dist[e] * d;</div><div class=\"line\">        <span class=\"keyword\">while</span> (u != s) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = pre[u];</div><div class=\"line\">            edge[last].c -= d;</div><div class=\"line\">            edge[last ^ <span class=\"number\">1</span>].c += d;</div><div class=\"line\">            u = edge[last].u;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> make_pair(total, rst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> Rl[<span class=\"number\">112</span>], Rh[<span class=\"number\">112</span>], Cl[<span class=\"number\">112</span>], Ch[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> row[<span class=\"number\">112</span>], col[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\"></div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(col, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(col));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(row, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(row));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(out, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(out));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//源点，汇点，超级源点，超级汇点</span></div><div class=\"line\">        <span class=\"keyword\">int</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> e = n * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> ss = e + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> se = ss + <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">                row[i] += data[i][j];</div><div class=\"line\">                col[j] += data[i][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;Rl[i], &amp;Rh[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;Cl[i], &amp;Ch[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            add_edge(s, i, row[i], row[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(s, i + n, col[i], col[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(i, e, Rl[i], Rh[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(i + n, e, Cl[i], Ch[i], <span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n * n / <span class=\"number\">2</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x1, y1, x2, y2;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[x1][y1] == data[x2][y2]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[x1][y1] == <span class=\"number\">0</span>) swap(x1, x2), swap(y1, y2);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x1 == x2) &#123;</div><div class=\"line\">                add_edge(n + y1, n + y2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y1 == y2) &#123;</div><div class=\"line\">                add_edge(x1, x2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        add_edge(e, s, <span class=\"number\">0</span>, <span class=\"number\">1e9</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//对超级源点，超级汇点建边</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n + n + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = in[i] - out[i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (t &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                t = -t;</div><div class=\"line\">                add_edge(i, se, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                sum += t;</div><div class=\"line\">                add_edge(ss, i, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; ans = min_cost_flow(ss, se);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans.first != sum) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans.second);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这个题感觉也不是很难，感觉应该做出来的，关键是比赛的时候漏看了一个条件，只有列或行相同时才可以交换，如果没有这个条件建图就复杂了，当时也想麻烦了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/HihoCoder-1424\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/HihoCoder-1424</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>参考 <a href=\"http://www.cnblogs.com/flipped/p/7635420.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/flipped/p/7635420.html</a></p>\n<blockquote>\n<p>有个 N×N 的棋盘，告诉你每个格子黑色(1)或白色(0)，以及每对能相互交换的同行或同列格子，每个格子只在一对中，即共有N×N/2对。求最少交换次数使得每行每列的黑格子总数满足给出的上下范围：若最终第i行,第j列分别有R[i],C[j]个黑格子，那么需要让Rl[i]≤R[i]≤Rh[i],Cl[j]≤C[i]≤Ch[j]。</p>\n</blockquote>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里先介绍一种有流量下限限制的建图方式，参考<a href=\"http://www.cnblogs.com/kane0526/archive/2013/04/05/3001108.html\" target=\"_blank\" rel=\"external\">这个博客</a>。</p>\n<p>记节点 i 所有流入的流量下限和为 in[i]，所有的流出流入和下限为 out[i]，建一个超级源点 SS，超级汇点 ST。</p>\n<p>如果一个节点 in[i] &gt; out[i]，那么建一条 SS 到 i 的边，流量为 in[i] - out[i]。</p>\n<p>如果 in[i] &lt; out[i]，那么建一条 i 到 ST 的边，流量为 out[i] - in[i]。</p>\n<p>对于无源汇的图来说，上面从 SS 到 ST跑一个最大流，如果上面的从 SS 出发的附加边满流，当前就是一个可行流，否则无解。</p>\n<p>对于有源汇的图来说，需要从 T 到 S 连一条流量为无穷的边，然后再从 SS 到 ST 跑最大流。 </p>\n<p>对于这个题，设每一行每一列原有的黑色棋子数量为 R[i] 和 C[i]。</p>\n<ul>\n<li>首先从 S 到每一行每一列建一条上下限均为 R[i] 或 C[i] 的边</li>\n<li>每一行每一列对 T 建边，容量上下限为 Rl[i]， Rh[i] 或 Cl[i]，Ch[i]</li>\n<li>然后对于可以交换的棋子，如果他们颜色相同，那么不需要建边，否则如果列相同，黑色所在的行向白色棋子所在的行建流量下限为 0 上限为 1 费用为 1 的边，列相同类似</li>\n<li>从 t 到 s 建一条流量下限为 0，上限为无穷的边。</li>\n</ul>\n<p>上述所有边默认费用为 0 。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">600</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, c, w, nxt;</div><div class=\"line\">&#125; edge[MAX * MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> in[<span class=\"number\">112</span>], out[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> up, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].c = up - low;</div><div class=\"line\">    edge[etot].w = w;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\"></div><div class=\"line\">    out[u] += low;</div><div class=\"line\"></div><div class=\"line\">    edge[etot].u = v;</div><div class=\"line\">    edge[etot].v = u;</div><div class=\"line\">    edge[etot].c = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[etot].w = -w;</div><div class=\"line\">    edge[etot].nxt = head[v];</div><div class=\"line\">    head[v] = etot++;</div><div class=\"line\"></div><div class=\"line\">    in[v] += low;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], pre[MAX], flow[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    flow[s] = <span class=\"number\">1e9</span>;</div><div class=\"line\">    vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            Edge &amp;e = edge[i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].c &gt; <span class=\"number\">0</span> &amp;&amp; dist[e.v] &gt; dist[e.u] + e.w) &#123;</div><div class=\"line\">                dist[e.v] = dist[e.u] + e.w;</div><div class=\"line\">                pre[e.v] = i;</div><div class=\"line\">                flow[e.v] = min(flow[e.u], e.c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.v]) &#123;</div><div class=\"line\">                    vis[e.v] = <span class=\"literal\">true</span>;</div><div class=\"line\">                    q.push(e.v);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        vis[u] = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; min_cost_flow(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>, total = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        spfa(s);</div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[e] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = flow[e], u = e;</div><div class=\"line\">        total += d;</div><div class=\"line\">        rst += dist[e] * d;</div><div class=\"line\">        <span class=\"keyword\">while</span> (u != s) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = pre[u];</div><div class=\"line\">            edge[last].c -= d;</div><div class=\"line\">            edge[last ^ <span class=\"number\">1</span>].c += d;</div><div class=\"line\">            u = edge[last].u;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> make_pair(total, rst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> Rl[<span class=\"number\">112</span>], Rh[<span class=\"number\">112</span>], Cl[<span class=\"number\">112</span>], Ch[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> row[<span class=\"number\">112</span>], col[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\"></div><div class=\"line\">        etot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(col, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(col));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(row, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(row));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(in, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(in));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(out, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(out));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//源点，汇点，超级源点，超级汇点</span></div><div class=\"line\">        <span class=\"keyword\">int</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> e = n * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> ss = e + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> se = ss + <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">                row[i] += data[i][j];</div><div class=\"line\">                col[j] += data[i][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;Rl[i], &amp;Rh[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;Cl[i], &amp;Ch[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            add_edge(s, i, row[i], row[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(s, i + n, col[i], col[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(i, e, Rl[i], Rh[i], <span class=\"number\">0</span>);</div><div class=\"line\">            add_edge(i + n, e, Cl[i], Ch[i], <span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n * n / <span class=\"number\">2</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x1, y1, x2, y2;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[x1][y1] == data[x2][y2]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[x1][y1] == <span class=\"number\">0</span>) swap(x1, x2), swap(y1, y2);</div><div class=\"line\">            <span class=\"keyword\">if</span> (x1 == x2) &#123;</div><div class=\"line\">                add_edge(n + y1, n + y2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y1 == y2) &#123;</div><div class=\"line\">                add_edge(x1, x2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        add_edge(e, s, <span class=\"number\">0</span>, <span class=\"number\">1e9</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//对超级源点，超级汇点建边</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n + n + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = in[i] - out[i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (t &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                t = -t;</div><div class=\"line\">                add_edge(i, se, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                sum += t;</div><div class=\"line\">                add_edge(ss, i, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; ans = min_cost_flow(ss, se);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans.first != sum) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans.second);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这个题感觉也不是很难，感觉应该做出来的，关键是比赛的时候漏看了一个条件，只有列或行相同时才可以交换，如果没有这个条件建图就复杂了，当时也想麻烦了。</p>\n"},{"title":"LightOJ1197 - Help Hanzo（区间素数筛 + 模板）","date":"2017-07-21T10:01:29.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1197\n\n---------------------------\n# 题目大意：\n给出$a,b$求$[a,b]$内素数个数，保证$b - a < 100000$，$1\\le a\\le b<2^{31}$。\n\n----------------------------\n# 解题过程：\n这题有点可惜，没仔细想就去翻书了，挑战第二版 P121，当初这里看过了，以为只有一个埃氏筛法然后跳过了，有点可惜...\n\n-----------------------------\n# 题目分析：\n首先对于任意的$b$，他的最小质因数一定不会大于$\\sqrt {b}$，那么可以用$[2, \\sqrt b]$的素数表，去筛掉$[a, b]$区间内的倍数，剩下的就是素数了。\n\n然后用了两种差不多的实现。\n\n\n这题要注意$1$不是素数！！！！！\n\n----------------------------\n# AC代码一：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100000;\nconst int MAX_INTERVAL = 200000+100;\n\nvector<int> prime;\nbool not_prime[MAX];\nbool interval[MAX_INTERVAL];\n\n//先筛出小于等于sqrt(b)的素数\nvoid init() {\n    for (int i = 2; i < MAX; i++) {\n        if (not_prime[i]) continue;\n        prime.push_back(i);\n        for (int j = i << 1; j < MAX; j += i)\n            not_prime[j] = true;\n    }\n}\n\nint solve(ll a, ll b) {\n    memset(interval, 0, sizeof(interval));\n    for (int i = 0; i < prime.size(); i++) {\n        if ((ll)prime[i] * prime[i] > b) break;\n        \n        //计算起始的位置，区间内第一个prime[i]的倍数\n        ll s = (a + prime[i] - 1) / prime[i];\n        //如果算出的s是1的话，那么就是这个素数本身，这种情况不应该筛掉\n        if (s < 2) s = 2;\n        \n        s *= prime[i];\n        for (; s <= b; s += prime[i]) {\n            interval[s-a] = true;\n        }\n    }\n    \n    //最后统计答案\n    int ans = 0;\n    for (int i = 0; i <= b - a; i++) {\n        if (!interval[i]) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    init();\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        int ans = solve(a, b);\n        if (a == 1) ans--;\n        printf(\"Case %d: %d\\n\", Case, ans);\n    }\n}\n```\n\n---------------------\n# AC代码二：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100000;\nconst int MAX_INTERVAL = 200000+100;\n\n//这个是最终答案的区间\nbool not_prime[MAX_INTERVAL];\n//这个是小于sqrt(b)的区间\nbool not_prime_small[MAX];\n\nint solve(ll a, ll b) {\n    memset(not_prime, 0, sizeof(not_prime));\n    memset(not_prime_small, 0, sizeof(not_prime_small));\n\n    //枚举所有小于等于sqrt(b)的数\n    for (int i = 2; (ll) i * i < b; i++) {\n        //如果是素数进行下一步\n        if (!not_prime_small[i]) {\n            //筛掉小区间内的倍数\n            for (int j = 2 * i; (ll)j * j < b; j += i) {\n                not_prime_small[j] = true;\n            }\n            //筛掉大区间内的倍数，找起始位置的方法与第一种一样\n            for (ll j = max(2LL, (a + i - 1) / i) * i; j <= b; j += i) {\n                not_prime[j - a] = true;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= b - a; i++) {\n        if (!not_prime[i]) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        int ans = solve(a, b);\n        if (a == 1) ans--;\n        printf(\"Case %d: %d\\n\", Case, ans);\n    }\n}\n```","source":"_posts/LightOJ1197-Help-Hanzo（区间素数筛-模板）.md","raw":"---\ntitle: LightOJ1197 - Help Hanzo（区间素数筛 + 模板）\ndate: 2017-07-21 18:01:29\ntags:\ncategories: [ACM, 数学, 数论]\n---\n# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1197\n\n---------------------------\n# 题目大意：\n给出$a,b$求$[a,b]$内素数个数，保证$b - a < 100000$，$1\\le a\\le b<2^{31}$。\n\n----------------------------\n# 解题过程：\n这题有点可惜，没仔细想就去翻书了，挑战第二版 P121，当初这里看过了，以为只有一个埃氏筛法然后跳过了，有点可惜...\n\n-----------------------------\n# 题目分析：\n首先对于任意的$b$，他的最小质因数一定不会大于$\\sqrt {b}$，那么可以用$[2, \\sqrt b]$的素数表，去筛掉$[a, b]$区间内的倍数，剩下的就是素数了。\n\n然后用了两种差不多的实现。\n\n\n这题要注意$1$不是素数！！！！！\n\n----------------------------\n# AC代码一：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100000;\nconst int MAX_INTERVAL = 200000+100;\n\nvector<int> prime;\nbool not_prime[MAX];\nbool interval[MAX_INTERVAL];\n\n//先筛出小于等于sqrt(b)的素数\nvoid init() {\n    for (int i = 2; i < MAX; i++) {\n        if (not_prime[i]) continue;\n        prime.push_back(i);\n        for (int j = i << 1; j < MAX; j += i)\n            not_prime[j] = true;\n    }\n}\n\nint solve(ll a, ll b) {\n    memset(interval, 0, sizeof(interval));\n    for (int i = 0; i < prime.size(); i++) {\n        if ((ll)prime[i] * prime[i] > b) break;\n        \n        //计算起始的位置，区间内第一个prime[i]的倍数\n        ll s = (a + prime[i] - 1) / prime[i];\n        //如果算出的s是1的话，那么就是这个素数本身，这种情况不应该筛掉\n        if (s < 2) s = 2;\n        \n        s *= prime[i];\n        for (; s <= b; s += prime[i]) {\n            interval[s-a] = true;\n        }\n    }\n    \n    //最后统计答案\n    int ans = 0;\n    for (int i = 0; i <= b - a; i++) {\n        if (!interval[i]) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    init();\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        int ans = solve(a, b);\n        if (a == 1) ans--;\n        printf(\"Case %d: %d\\n\", Case, ans);\n    }\n}\n```\n\n---------------------\n# AC代码二：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100000;\nconst int MAX_INTERVAL = 200000+100;\n\n//这个是最终答案的区间\nbool not_prime[MAX_INTERVAL];\n//这个是小于sqrt(b)的区间\nbool not_prime_small[MAX];\n\nint solve(ll a, ll b) {\n    memset(not_prime, 0, sizeof(not_prime));\n    memset(not_prime_small, 0, sizeof(not_prime_small));\n\n    //枚举所有小于等于sqrt(b)的数\n    for (int i = 2; (ll) i * i < b; i++) {\n        //如果是素数进行下一步\n        if (!not_prime_small[i]) {\n            //筛掉小区间内的倍数\n            for (int j = 2 * i; (ll)j * j < b; j += i) {\n                not_prime_small[j] = true;\n            }\n            //筛掉大区间内的倍数，找起始位置的方法与第一种一样\n            for (ll j = max(2LL, (a + i - 1) / i) * i; j <= b; j += i) {\n                not_prime[j - a] = true;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= b - a; i++) {\n        if (!not_prime[i]) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        int ans = solve(a, b);\n        if (a == 1) ans--;\n        printf(\"Case %d: %d\\n\", Case, ans);\n    }\n}\n```","slug":"LightOJ1197-Help-Hanzo（区间素数筛-模板）","published":1,"updated":"2017-08-20T05:29:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nc4002sy9idukwlynjx","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1197\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1197</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出$a,b$求$[a,b]$内素数个数，保证$b - a &lt; 100000$，$1\\le a\\le b&lt;2^{31}$。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题有点可惜，没仔细想就去翻书了，挑战第二版 P121，当初这里看过了，以为只有一个埃氏筛法然后跳过了，有点可惜…</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对于任意的$b$，他的最小质因数一定不会大于$\\sqrt {b}$，那么可以用$[2, \\sqrt b]$的素数表，去筛掉$[a, b]$区间内的倍数，剩下的就是素数了。</p>\n<p>然后用了两种差不多的实现。</p>\n<p>这题要注意$1$不是素数！！！！！</p>\n<hr>\n<h1 id=\"AC代码一：\"><a href=\"#AC代码一：\" class=\"headerlink\" title=\"AC代码一：\"></a>AC代码一：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_INTERVAL = <span class=\"number\">200000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; prime;</div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> interval[MAX_INTERVAL];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//先筛出小于等于sqrt(b)的素数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (not_prime[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        prime.push_back(i);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span>; j &lt; MAX; j += i)</div><div class=\"line\">            not_prime[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(interval, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(interval));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prime.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((ll)prime[i] * prime[i] &gt; b) <span class=\"keyword\">break</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//计算起始的位置，区间内第一个prime[i]的倍数</span></div><div class=\"line\">        ll s = (a + prime[i] - <span class=\"number\">1</span>) / prime[i];</div><div class=\"line\">        <span class=\"comment\">//如果算出的s是1的话，那么就是这个素数本身，这种情况不应该筛掉</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">2</span>) s = <span class=\"number\">2</span>;</div><div class=\"line\">        </div><div class=\"line\">        s *= prime[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (; s &lt;= b; s += prime[i]) &#123;</div><div class=\"line\">            interval[s-a] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//最后统计答案</span></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= b - a; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!interval[i]) ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll a, b;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;a, &amp;b);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = solve(a, b);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) ans--;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码二：\"><a href=\"#AC代码二：\" class=\"headerlink\" title=\"AC代码二：\"></a>AC代码二：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_INTERVAL = <span class=\"number\">200000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这个是最终答案的区间</span></div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX_INTERVAL];</div><div class=\"line\"><span class=\"comment\">//这个是小于sqrt(b)的区间</span></div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime_small[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(not_prime, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(not_prime));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(not_prime_small, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(not_prime_small));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举所有小于等于sqrt(b)的数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; (ll) i * i &lt; b; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果是素数进行下一步</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!not_prime_small[i]) &#123;</div><div class=\"line\">            <span class=\"comment\">//筛掉小区间内的倍数</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * i; (ll)j * j &lt; b; j += i) &#123;</div><div class=\"line\">                not_prime_small[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//筛掉大区间内的倍数，找起始位置的方法与第一种一样</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (ll j = max(<span class=\"number\">2L</span>L, (a + i - <span class=\"number\">1</span>) / i) * i; j &lt;= b; j += i) &#123;</div><div class=\"line\">                not_prime[j - a] = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= b - a; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!not_prime[i]) ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll a, b;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;a, &amp;b);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = solve(a, b);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) ans--;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1197\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1197</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出$a,b$求$[a,b]$内素数个数，保证$b - a &lt; 100000$，$1\\le a\\le b&lt;2^{31}$。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题有点可惜，没仔细想就去翻书了，挑战第二版 P121，当初这里看过了，以为只有一个埃氏筛法然后跳过了，有点可惜…</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对于任意的$b$，他的最小质因数一定不会大于$\\sqrt {b}$，那么可以用$[2, \\sqrt b]$的素数表，去筛掉$[a, b]$区间内的倍数，剩下的就是素数了。</p>\n<p>然后用了两种差不多的实现。</p>\n<p>这题要注意$1$不是素数！！！！！</p>\n<hr>\n<h1 id=\"AC代码一：\"><a href=\"#AC代码一：\" class=\"headerlink\" title=\"AC代码一：\"></a>AC代码一：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_INTERVAL = <span class=\"number\">200000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; prime;</div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX];</div><div class=\"line\"><span class=\"keyword\">bool</span> interval[MAX_INTERVAL];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//先筛出小于等于sqrt(b)的素数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (not_prime[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        prime.push_back(i);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span>; j &lt; MAX; j += i)</div><div class=\"line\">            not_prime[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(interval, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(interval));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prime.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((ll)prime[i] * prime[i] &gt; b) <span class=\"keyword\">break</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//计算起始的位置，区间内第一个prime[i]的倍数</span></div><div class=\"line\">        ll s = (a + prime[i] - <span class=\"number\">1</span>) / prime[i];</div><div class=\"line\">        <span class=\"comment\">//如果算出的s是1的话，那么就是这个素数本身，这种情况不应该筛掉</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">2</span>) s = <span class=\"number\">2</span>;</div><div class=\"line\">        </div><div class=\"line\">        s *= prime[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (; s &lt;= b; s += prime[i]) &#123;</div><div class=\"line\">            interval[s-a] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//最后统计答案</span></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= b - a; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!interval[i]) ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll a, b;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;a, &amp;b);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = solve(a, b);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) ans--;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码二：\"><a href=\"#AC代码二：\" class=\"headerlink\" title=\"AC代码二：\"></a>AC代码二：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_INTERVAL = <span class=\"number\">200000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这个是最终答案的区间</span></div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX_INTERVAL];</div><div class=\"line\"><span class=\"comment\">//这个是小于sqrt(b)的区间</span></div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime_small[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(not_prime, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(not_prime));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(not_prime_small, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(not_prime_small));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举所有小于等于sqrt(b)的数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; (ll) i * i &lt; b; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果是素数进行下一步</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!not_prime_small[i]) &#123;</div><div class=\"line\">            <span class=\"comment\">//筛掉小区间内的倍数</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * i; (ll)j * j &lt; b; j += i) &#123;</div><div class=\"line\">                not_prime_small[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//筛掉大区间内的倍数，找起始位置的方法与第一种一样</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (ll j = max(<span class=\"number\">2L</span>L, (a + i - <span class=\"number\">1</span>) / i) * i; j &lt;= b; j += i) &#123;</div><div class=\"line\">                not_prime[j - a] = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= b - a; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!not_prime[i]) ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll a, b;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;a, &amp;b);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = solve(a, b);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) ans--;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"LightOJ1214 - Large Division（高精度取模 + 模板）","date":"2017-07-21T09:46:16.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1214\n\n------------------\n# 题目大意：\n两个数$-10^{100}<a<100^{100}$, $b$ 为 32bit范围内(其实并不是)，需要用64位整型才可以。问$a$能否被$b$整除。\n\n--------------------------\n# 解题过程：\n先用 Java 的大数类水过了，然后感觉应该用到数论的知识，想起来之前好像也有一道高精度取模的题，当初用 Python 水过去了，现在认真的学一下高精度取模。\n\n---------------------------\n# 题目分析：\n显然这题正负号和是否整除无关，先忽略掉。\n\n对于每一个整数，可以分解为如下的形式（以$1234$举例）：\n$12345 = ((1\\times 10 + 2)\\times 10+3)\\times10 + 4$\n然后这里可以顺带取模（以模123为例）：\n$12345\\mod 123 = (((1\\times 10 \\mod 123 + 2)\\times 10 \\mod 123+3)\\times10 \\mod 123+ 4)\\mod123$\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nchar str[1123];\nll mod;\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        scanf(\"%s %lld\", str, &mod);\n        int len = strlen(str);\n        ll rst = 0;\n        //忽略掉负号\n        int i = str[0] == '-' ? 1 : 0;\n        for (;i < len; i++) {\n            rst = ((rst * 10) % mod + (str[i] - '0')) % mod;\n        }\n        //取模为0表示可以被整除\n        if (rst == 0) {\n            printf(\"Case %d: divisible\\n\", Case);\n        }\n        else {\n            printf(\"Case %d: not divisible\\n\", Case);\n        }\n    }\n}\n```","source":"_posts/LightOJ1214-Large-Division（高精度取模-模板）.md","raw":"---\ntitle: LightOJ1214 - Large Division（高精度取模 + 模板）\ndate: 2017-07-21 17:46:16\ncategories: [ACM, 数学]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1214\n\n------------------\n# 题目大意：\n两个数$-10^{100}<a<100^{100}$, $b$ 为 32bit范围内(其实并不是)，需要用64位整型才可以。问$a$能否被$b$整除。\n\n--------------------------\n# 解题过程：\n先用 Java 的大数类水过了，然后感觉应该用到数论的知识，想起来之前好像也有一道高精度取模的题，当初用 Python 水过去了，现在认真的学一下高精度取模。\n\n---------------------------\n# 题目分析：\n显然这题正负号和是否整除无关，先忽略掉。\n\n对于每一个整数，可以分解为如下的形式（以$1234$举例）：\n$12345 = ((1\\times 10 + 2)\\times 10+3)\\times10 + 4$\n然后这里可以顺带取模（以模123为例）：\n$12345\\mod 123 = (((1\\times 10 \\mod 123 + 2)\\times 10 \\mod 123+3)\\times10 \\mod 123+ 4)\\mod123$\n\n------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nchar str[1123];\nll mod;\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        scanf(\"%s %lld\", str, &mod);\n        int len = strlen(str);\n        ll rst = 0;\n        //忽略掉负号\n        int i = str[0] == '-' ? 1 : 0;\n        for (;i < len; i++) {\n            rst = ((rst * 10) % mod + (str[i] - '0')) % mod;\n        }\n        //取模为0表示可以被整除\n        if (rst == 0) {\n            printf(\"Case %d: divisible\\n\", Case);\n        }\n        else {\n            printf(\"Case %d: not divisible\\n\", Case);\n        }\n    }\n}\n```","slug":"LightOJ1214-Large-Division（高精度取模-模板）","published":1,"updated":"2017-08-20T05:26:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nc6002vy9id968bor7z","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1214\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1214</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>两个数$-10^{100}&lt;a&lt;100^{100}$, $b$ 为 32bit范围内(其实并不是)，需要用64位整型才可以。问$a$能否被$b$整除。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>先用 Java 的大数类水过了，然后感觉应该用到数论的知识，想起来之前好像也有一道高精度取模的题，当初用 Python 水过去了，现在认真的学一下高精度取模。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>显然这题正负号和是否整除无关，先忽略掉。</p>\n<p>对于每一个整数，可以分解为如下的形式（以$1234$举例）：<br>$12345 = ((1\\times 10 + 2)\\times 10+3)\\times10 + 4$<br>然后这里可以顺带取模（以模123为例）：<br>$12345\\mod 123 = (((1\\times 10 \\mod 123 + 2)\\times 10 \\mod 123+3)\\times10 \\mod 123+ 4)\\mod123$</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">1123</span>];</div><div class=\"line\">ll mod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %lld\"</span>, str, &amp;mod);</div><div class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(str);</div><div class=\"line\">        ll rst = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//忽略掉负号</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = str[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;i &lt; len; i++) &#123;</div><div class=\"line\">            rst = ((rst * <span class=\"number\">10</span>) % mod + (str[i] - <span class=\"string\">'0'</span>)) % mod;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//取模为0表示可以被整除</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (rst == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: divisible\\n\"</span>, Case);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: not divisible\\n\"</span>, Case);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1214\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1214</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>两个数$-10^{100}&lt;a&lt;100^{100}$, $b$ 为 32bit范围内(其实并不是)，需要用64位整型才可以。问$a$能否被$b$整除。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>先用 Java 的大数类水过了，然后感觉应该用到数论的知识，想起来之前好像也有一道高精度取模的题，当初用 Python 水过去了，现在认真的学一下高精度取模。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>显然这题正负号和是否整除无关，先忽略掉。</p>\n<p>对于每一个整数，可以分解为如下的形式（以$1234$举例）：<br>$12345 = ((1\\times 10 + 2)\\times 10+3)\\times10 + 4$<br>然后这里可以顺带取模（以模123为例）：<br>$12345\\mod 123 = (((1\\times 10 \\mod 123 + 2)\\times 10 \\mod 123+3)\\times10 \\mod 123+ 4)\\mod123$</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">1123</span>];</div><div class=\"line\">ll mod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %lld\"</span>, str, &amp;mod);</div><div class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(str);</div><div class=\"line\">        ll rst = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//忽略掉负号</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = str[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;i &lt; len; i++) &#123;</div><div class=\"line\">            rst = ((rst * <span class=\"number\">10</span>) % mod + (str[i] - <span class=\"string\">'0'</span>)) % mod;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//取模为0表示可以被整除</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (rst == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: divisible\\n\"</span>, Case);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: not divisible\\n\"</span>, Case);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"LightOJ1236 - Pairs Forming LCM（LCM+唯一分解定理）","date":"2017-07-21T09:29:52.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1236\n\n----------------------------\n# 题目大意：\n给定一个数$n$，求满足$i \\le j < n \\wedge lcm(i, j) = n$的$(i, j)$对总共有多少个。\n\n------------------------------\n# 解题过程：\n\n想了一会...不会，看的博客，就当是个结论好了。\n\n-------------------------\n# 题目分析：\n对于每一对$(i, j)$，可由唯一分解定理写成如下形式：\n$n = p_1^{e_1} \\cdot p_2^{e_2} \\dots p_k^{e_k}$\n$i = p_1^{a_1} \\cdot p_2^{a_2} \\dots p_k^{a_k}$\n$j = p_1^{b_1} \\cdot p_2^{b_2} \\dots p_k^{b_k}$\n\n要使得$lcm(i, j) = n$的充要条件是满足$max(a_i, b_i) = c_i$。\n那么问题就转化成了找满足上述条件的$(a_i,b_i)$对数，即是 $\\small{2} c_i + 1$。\n\n再根据分步乘法算出的即是答案。不过这样对于除了$i = j$的时候，其他的都分别计算了$(i, j), (j, i)$，这里最后答案要除以二并加一。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234567;\n\ntypedef long long ll;\n\nvector<int> prime;\nbool not_prime[MAX];\n\nvoid get_prime() {\n    for (int i = 2; i < MAX; i++) {\n        if (not_prime[i]) continue;\n        prime.push_back(i);\n        for (int j = i << 1; j < MAX; j += i) {\n            not_prime[j] = true;\n        }\n    }\n}\n\nint main() {\n    get_prime();\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll n;\n        ll ans = 1;\n        scanf(\"%lld\", &n);\n        //进行质因子分解，并计算，但是这里素数表只到sqrt(n)\n        for (int i = 0; i < prime.size(); i++) {\n            if (prime[i] > n) break;\n            if (n % prime[i] != 0) continue;\n            int cnt = 0;\n            while (n % prime[i] == 0) {\n                n /= prime[i];\n                cnt++;\n            }\n            ans *= (2 * cnt + 1);\n        }\n        //如果n不为1，说明还剩下一个大于sqrt(n)的质因子，要当前的结果乘三\n        if (n > 1) ans *= 3;\n        ans = ans / 2 + 1;\n        printf(\"Case %d: %lld\\n\", Case, ans);\n    }\n}\n```","source":"_posts/LightOJ1236-Pairs-Forming-LCM（LCM-唯一分解定理）.md","raw":"---\ntitle: LightOJ1236 - Pairs Forming LCM（LCM+唯一分解定理）\ndate: 2017-07-21 17:29:52\ncategories: [ACM, 数学, 数论]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1236\n\n----------------------------\n# 题目大意：\n给定一个数$n$，求满足$i \\le j < n \\wedge lcm(i, j) = n$的$(i, j)$对总共有多少个。\n\n------------------------------\n# 解题过程：\n\n想了一会...不会，看的博客，就当是个结论好了。\n\n-------------------------\n# 题目分析：\n对于每一对$(i, j)$，可由唯一分解定理写成如下形式：\n$n = p_1^{e_1} \\cdot p_2^{e_2} \\dots p_k^{e_k}$\n$i = p_1^{a_1} \\cdot p_2^{a_2} \\dots p_k^{a_k}$\n$j = p_1^{b_1} \\cdot p_2^{b_2} \\dots p_k^{b_k}$\n\n要使得$lcm(i, j) = n$的充要条件是满足$max(a_i, b_i) = c_i$。\n那么问题就转化成了找满足上述条件的$(a_i,b_i)$对数，即是 $\\small{2} c_i + 1$。\n\n再根据分步乘法算出的即是答案。不过这样对于除了$i = j$的时候，其他的都分别计算了$(i, j), (j, i)$，这里最后答案要除以二并加一。\n\n----------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234567;\n\ntypedef long long ll;\n\nvector<int> prime;\nbool not_prime[MAX];\n\nvoid get_prime() {\n    for (int i = 2; i < MAX; i++) {\n        if (not_prime[i]) continue;\n        prime.push_back(i);\n        for (int j = i << 1; j < MAX; j += i) {\n            not_prime[j] = true;\n        }\n    }\n}\n\nint main() {\n    get_prime();\n    int T;\n    scanf(\"%d\", &T);\n    for (int Case = 1; Case <= T; Case++) {\n        ll n;\n        ll ans = 1;\n        scanf(\"%lld\", &n);\n        //进行质因子分解，并计算，但是这里素数表只到sqrt(n)\n        for (int i = 0; i < prime.size(); i++) {\n            if (prime[i] > n) break;\n            if (n % prime[i] != 0) continue;\n            int cnt = 0;\n            while (n % prime[i] == 0) {\n                n /= prime[i];\n                cnt++;\n            }\n            ans *= (2 * cnt + 1);\n        }\n        //如果n不为1，说明还剩下一个大于sqrt(n)的质因子，要当前的结果乘三\n        if (n > 1) ans *= 3;\n        ans = ans / 2 + 1;\n        printf(\"Case %d: %lld\\n\", Case, ans);\n    }\n}\n```","slug":"LightOJ1236-Pairs-Forming-LCM（LCM-唯一分解定理）","published":1,"updated":"2017-08-20T05:27:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nc9002xy9id61ojgwmg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1236\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1236</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个数$n$，求满足$i \\le j &lt; n \\wedge lcm(i, j) = n$的$(i, j)$对总共有多少个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想了一会…不会，看的博客，就当是个结论好了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对于每一对$(i, j)$，可由唯一分解定理写成如下形式：<br>$n = p_1^{e_1} \\cdot p_2^{e_2} \\dots p_k^{e_k}$<br>$i = p_1^{a_1} \\cdot p_2^{a_2} \\dots p_k^{a_k}$<br>$j = p_1^{b_1} \\cdot p_2^{b_2} \\dots p_k^{b_k}$</p>\n<p>要使得$lcm(i, j) = n$的充要条件是满足$max(a_i, b_i) = c_i$。<br>那么问题就转化成了找满足上述条件的$(a_i,b_i)$对数，即是 $\\small{2} c_i + 1$。</p>\n<p>再根据分步乘法算出的即是答案。不过这样对于除了$i = j$的时候，其他的都分别计算了$(i, j), (j, i)$，这里最后答案要除以二并加一。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234567</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; prime;</div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_prime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (not_prime[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        prime.push_back(i);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span>; j &lt; MAX; j += i) &#123;</div><div class=\"line\">            not_prime[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    get_prime();</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll n;</div><div class=\"line\">        ll ans = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"comment\">//进行质因子分解，并计算，但是这里素数表只到sqrt(n)</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prime.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (prime[i] &gt; n) <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n % prime[i] != <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n % prime[i] == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                n /= prime[i];</div><div class=\"line\">                cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ans *= (<span class=\"number\">2</span> * cnt + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//如果n不为1，说明还剩下一个大于sqrt(n)的质因子，要当前的结果乘三</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>) ans *= <span class=\"number\">3</span>;</div><div class=\"line\">        ans = ans / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1236\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1236</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个数$n$，求满足$i \\le j &lt; n \\wedge lcm(i, j) = n$的$(i, j)$对总共有多少个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>想了一会…不会，看的博客，就当是个结论好了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>对于每一对$(i, j)$，可由唯一分解定理写成如下形式：<br>$n = p_1^{e_1} \\cdot p_2^{e_2} \\dots p_k^{e_k}$<br>$i = p_1^{a_1} \\cdot p_2^{a_2} \\dots p_k^{a_k}$<br>$j = p_1^{b_1} \\cdot p_2^{b_2} \\dots p_k^{b_k}$</p>\n<p>要使得$lcm(i, j) = n$的充要条件是满足$max(a_i, b_i) = c_i$。<br>那么问题就转化成了找满足上述条件的$(a_i,b_i)$对数，即是 $\\small{2} c_i + 1$。</p>\n<p>再根据分步乘法算出的即是答案。不过这样对于除了$i = j$的时候，其他的都分别计算了$(i, j), (j, i)$，这里最后答案要除以二并加一。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234567</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; prime;</div><div class=\"line\"><span class=\"keyword\">bool</span> not_prime[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_prime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (not_prime[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        prime.push_back(i);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span>; j &lt; MAX; j += i) &#123;</div><div class=\"line\">            not_prime[j] = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    get_prime();</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        ll n;</div><div class=\"line\">        ll ans = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"comment\">//进行质因子分解，并计算，但是这里素数表只到sqrt(n)</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prime.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (prime[i] &gt; n) <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n % prime[i] != <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n % prime[i] == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                n /= prime[i];</div><div class=\"line\">                cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ans *= (<span class=\"number\">2</span> * cnt + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//如果n不为1，说明还剩下一个大于sqrt(n)的质因子，要当前的结果乘三</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>) ans *= <span class=\"number\">3</span>;</div><div class=\"line\">        ans = ans / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld\\n\"</span>, Case, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"LightOJ1282 - Leading and Trailing（快速幂+数学）","date":"2017-07-20T09:22:11.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1282\n\n----------------------\n# 题目大意：\n求$n^k$的前3位数和后三位数。$2\\le a<2^{31} , 1\\le k \\le 10^7$。\n\n--------------------------\n# 解题过程：\n\n只让求后三位的话我到是会，用快速幂就好了，但是求前三位感一脸懵逼。于是去翻了博客，发现居然还有这种操作！\n\n--------------------------------\n# 题目分析：\n后三位直接用快速幂取膜就好了，这里说一下前三位。\n\n这里先假设：$n^k = a.bc...\\times 10^m$，即用科学计数法表示，因为只要前三位，那么接下来就忽略掉后面的位。\n\n对于上式两边同时取$\\lg$：$k\\lg n = \\lg a.bc + m$\n这里$m$一定为一个整数，$a.bc$在科学计数法中小于10，那么$\\lg a.bc$一定为一个小于$0$的小数。\n\n那么$\\lg a.bc$ 为 $k\\lg n$ 的小数部分，$m$为$k\\lg n$的整数部分。\n\n然后$abc = 10^{\\lg a.bc} \\times 100$，即为所求的前三位数。\n\n------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1000;\n\n//快速幂+取模\nint pow_mod(int n, int m) {\n    int ans = 1, x = n;\n    while (m > 0) {\n        if (m&1) {\n            ans = (ll)ans * x % mod;\n        }\n        x = (ll) x * x % mod;\n        m >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int T, n, m;\n    cin >> T;\n    for (int Case = 1; Case <= T; Case++) {\n        cin >> n >> m;\n\n        //计算前三位数\n        double t = log10(n) * m;\n        t -= floor(t);\n        int ans1 = pow(10, t)*100;\n\n        int ans2 = pow_mod(n, m);\n        printf(\"Case %d: %d %03d\\n\", Case, ans1, ans2);\n    }\n}\n```","source":"_posts/LightOJ1282-Leading-and-Trailing（快速幂-数学）.md","raw":"---\ntitle: LightOJ1282 - Leading and Trailing（快速幂+数学）\ndate: 2017-07-20 17:22:11\ncategories: [ACM, 数学]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1282\n\n----------------------\n# 题目大意：\n求$n^k$的前3位数和后三位数。$2\\le a<2^{31} , 1\\le k \\le 10^7$。\n\n--------------------------\n# 解题过程：\n\n只让求后三位的话我到是会，用快速幂就好了，但是求前三位感一脸懵逼。于是去翻了博客，发现居然还有这种操作！\n\n--------------------------------\n# 题目分析：\n后三位直接用快速幂取膜就好了，这里说一下前三位。\n\n这里先假设：$n^k = a.bc...\\times 10^m$，即用科学计数法表示，因为只要前三位，那么接下来就忽略掉后面的位。\n\n对于上式两边同时取$\\lg$：$k\\lg n = \\lg a.bc + m$\n这里$m$一定为一个整数，$a.bc$在科学计数法中小于10，那么$\\lg a.bc$一定为一个小于$0$的小数。\n\n那么$\\lg a.bc$ 为 $k\\lg n$ 的小数部分，$m$为$k\\lg n$的整数部分。\n\n然后$abc = 10^{\\lg a.bc} \\times 100$，即为所求的前三位数。\n\n------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1000;\n\n//快速幂+取模\nint pow_mod(int n, int m) {\n    int ans = 1, x = n;\n    while (m > 0) {\n        if (m&1) {\n            ans = (ll)ans * x % mod;\n        }\n        x = (ll) x * x % mod;\n        m >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int T, n, m;\n    cin >> T;\n    for (int Case = 1; Case <= T; Case++) {\n        cin >> n >> m;\n\n        //计算前三位数\n        double t = log10(n) * m;\n        t -= floor(t);\n        int ans1 = pow(10, t)*100;\n\n        int ans2 = pow_mod(n, m);\n        printf(\"Case %d: %d %03d\\n\", Case, ans1, ans2);\n    }\n}\n```","slug":"LightOJ1282-Leading-and-Trailing（快速幂-数学）","published":1,"updated":"2017-08-20T05:27:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncb0030y9idsme2lins","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1282\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1282</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>求$n^k$的前3位数和后三位数。$2\\le a&lt;2^{31} , 1\\le k \\le 10^7$。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>只让求后三位的话我到是会，用快速幂就好了，但是求前三位感一脸懵逼。于是去翻了博客，发现居然还有这种操作！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>后三位直接用快速幂取膜就好了，这里说一下前三位。</p>\n<p>这里先假设：$n^k = a.bc…\\times 10^m$，即用科学计数法表示，因为只要前三位，那么接下来就忽略掉后面的位。</p>\n<p>对于上式两边同时取$\\lg$：$k\\lg n = \\lg a.bc + m$<br>这里$m$一定为一个整数，$a.bc$在科学计数法中小于10，那么$\\lg a.bc$一定为一个小于$0$的小数。</p>\n<p>那么$\\lg a.bc$ 为 $k\\lg n$ 的小数部分，$m$为$k\\lg n$的整数部分。</p>\n<p>然后$abc = 10^{\\lg a.bc} \\times 100$，即为所求的前三位数。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mod = <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//快速幂+取模</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pow_mod</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>, x = n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (m&amp;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            ans = (ll)ans * x % mod;</div><div class=\"line\">        &#125;</div><div class=\"line\">        x = (ll) x * x % mod;</div><div class=\"line\">        m &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T, n, m;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算前三位数</span></div><div class=\"line\">        <span class=\"keyword\">double</span> t = <span class=\"built_in\">log10</span>(n) * m;</div><div class=\"line\">        t -= <span class=\"built_in\">floor</span>(t);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans1 = <span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, t)*<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans2 = pow_mod(n, m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d %03d\\n\"</span>, Case, ans1, ans2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1282\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1282</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>求$n^k$的前3位数和后三位数。$2\\le a&lt;2^{31} , 1\\le k \\le 10^7$。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>只让求后三位的话我到是会，用快速幂就好了，但是求前三位感一脸懵逼。于是去翻了博客，发现居然还有这种操作！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>后三位直接用快速幂取膜就好了，这里说一下前三位。</p>\n<p>这里先假设：$n^k = a.bc…\\times 10^m$，即用科学计数法表示，因为只要前三位，那么接下来就忽略掉后面的位。</p>\n<p>对于上式两边同时取$\\lg$：$k\\lg n = \\lg a.bc + m$<br>这里$m$一定为一个整数，$a.bc$在科学计数法中小于10，那么$\\lg a.bc$一定为一个小于$0$的小数。</p>\n<p>那么$\\lg a.bc$ 为 $k\\lg n$ 的小数部分，$m$为$k\\lg n$的整数部分。</p>\n<p>然后$abc = 10^{\\lg a.bc} \\times 100$，即为所求的前三位数。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mod = <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//快速幂+取模</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pow_mod</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>, x = n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (m&amp;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            ans = (ll)ans * x % mod;</div><div class=\"line\">        &#125;</div><div class=\"line\">        x = (ll) x * x % mod;</div><div class=\"line\">        m &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T, n, m;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> Case = <span class=\"number\">1</span>; Case &lt;= T; Case++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//计算前三位数</span></div><div class=\"line\">        <span class=\"keyword\">double</span> t = <span class=\"built_in\">log10</span>(n) * m;</div><div class=\"line\">        t -= <span class=\"built_in\">floor</span>(t);</div><div class=\"line\">        <span class=\"keyword\">int</span> ans1 = <span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, t)*<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans2 = pow_mod(n, m);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d %03d\\n\"</span>, Case, ans1, ans2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"LightOJ1370 - Bi-shoe and Phi-shoe（欧拉函数+打表）","date":"2017-07-20T08:51:12.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1370\n\n---------------------------\n# 题目大意：\n给出 $N$ 个数$a_1,a_2\\dots a_n$，求对每一个 $a_i$ 找出最小的 $k_i$ 使得 $\\phi(k_i) \\ge a_i$，输出 $\\sum_1^n k_i$ 。\n\n------------------------------\n# 解题过程：\n\n因为是数论的题，显然题目是要用欧拉函数，于是特意去翻了一下紫书的欧拉函数。想假期在家里做的，然后咸鱼了，想在来学校补得，也算是目前数论里面唯一一个自己做出的题了...\n\n-------------------------\n# 题目分析：\n\n首先打表求出欧拉函数的值，用紫书上类似素数筛的方式，可以$O(n\\log \\log n)$的时间内求出。\n\n然后需要解决的问题是，假设对于 2 这个数，那么用欧拉函数值为 $2$ 的 $k$ 并不一定是最优的，可能有一个 $m < k$ 但是 $\\phi(m) > \\phi(k)$。\n这里一个解决方式是，找出每一个$a_i$的$k_i$打一张表，从1开始枚举$k$，先枚举到的k一定比后枚举到的优。\n\n----------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\n\ntypedef long long LL;\n\nint phi[MAX];\nint cost[MAX];\n\nvoid init() {\n    //对欧拉函数打表\n    phi[1] = 0;\n    for (int i = 2; i <= MAX; i++) {\n        if (phi[i]) continue;\n        for (int j = i; j <= MAX; j+= i) {\n            if (!phi[j]) phi[j] = j;\n            phi[j] = phi[j] / i * (i-1);\n        }\n    }\n\n    //枚举每一个的花费k\n    for (int i = 1; i <= MAX; i++) {\n        int x = phi[i];\n        for (int j = x; j >= 1; j--) {\n            //如果当前为空，那么他的花费为i\n            //否则之前已经有更优的解，直接break\n            if (cost[j]) break;\n            cost[j] = i;\n        }\n    }\n}\n\nint main() {\n//    freopen(\"out\", \"w\", stdout);\n    init();\n    int T;\n    scanf(\"%d\", &T);\n    for (int cases = 1; cases <= T; cases++) {\n        int n;\n        LL ans = 0;\n        scanf(\"%d\", &n);\n        while (n--) {\n            int t;\n            scanf(\"%d\", &t);\n            ans += cost[t];\n        }\n        printf(\"Case %d: %lld Xukha\\n\", cases, ans);\n    }\n\n}\n```","source":"_posts/LightOJ1370-Bi-shoe-and-Phi-shoe（欧拉函数-打表）.md","raw":"---\ntitle: LightOJ1370 - Bi-shoe and Phi-shoe（欧拉函数+打表）\ndate: 2017-07-20 16:51:12\ncategories: [ACM, 数学, 数论]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/LightOJ-1370\n\n---------------------------\n# 题目大意：\n给出 $N$ 个数$a_1,a_2\\dots a_n$，求对每一个 $a_i$ 找出最小的 $k_i$ 使得 $\\phi(k_i) \\ge a_i$，输出 $\\sum_1^n k_i$ 。\n\n------------------------------\n# 解题过程：\n\n因为是数论的题，显然题目是要用欧拉函数，于是特意去翻了一下紫书的欧拉函数。想假期在家里做的，然后咸鱼了，想在来学校补得，也算是目前数论里面唯一一个自己做出的题了...\n\n-------------------------\n# 题目分析：\n\n首先打表求出欧拉函数的值，用紫书上类似素数筛的方式，可以$O(n\\log \\log n)$的时间内求出。\n\n然后需要解决的问题是，假设对于 2 这个数，那么用欧拉函数值为 $2$ 的 $k$ 并不一定是最优的，可能有一个 $m < k$ 但是 $\\phi(m) > \\phi(k)$。\n这里一个解决方式是，找出每一个$a_i$的$k_i$打一张表，从1开始枚举$k$，先枚举到的k一定比后枚举到的优。\n\n----------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123456;\n\ntypedef long long LL;\n\nint phi[MAX];\nint cost[MAX];\n\nvoid init() {\n    //对欧拉函数打表\n    phi[1] = 0;\n    for (int i = 2; i <= MAX; i++) {\n        if (phi[i]) continue;\n        for (int j = i; j <= MAX; j+= i) {\n            if (!phi[j]) phi[j] = j;\n            phi[j] = phi[j] / i * (i-1);\n        }\n    }\n\n    //枚举每一个的花费k\n    for (int i = 1; i <= MAX; i++) {\n        int x = phi[i];\n        for (int j = x; j >= 1; j--) {\n            //如果当前为空，那么他的花费为i\n            //否则之前已经有更优的解，直接break\n            if (cost[j]) break;\n            cost[j] = i;\n        }\n    }\n}\n\nint main() {\n//    freopen(\"out\", \"w\", stdout);\n    init();\n    int T;\n    scanf(\"%d\", &T);\n    for (int cases = 1; cases <= T; cases++) {\n        int n;\n        LL ans = 0;\n        scanf(\"%d\", &n);\n        while (n--) {\n            int t;\n            scanf(\"%d\", &t);\n            ans += cost[t];\n        }\n        printf(\"Case %d: %lld Xukha\\n\", cases, ans);\n    }\n\n}\n```","slug":"LightOJ1370-Bi-shoe-and-Phi-shoe（欧拉函数-打表）","published":1,"updated":"2017-08-20T05:27:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncc0032y9idnd98vb6d","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1370\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1370</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 $N$ 个数$a_1,a_2\\dots a_n$，求对每一个 $a_i$ 找出最小的 $k_i$ 使得 $\\phi(k_i) \\ge a_i$，输出 $\\sum_1^n k_i$ 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>因为是数论的题，显然题目是要用欧拉函数，于是特意去翻了一下紫书的欧拉函数。想假期在家里做的，然后咸鱼了，想在来学校补得，也算是目前数论里面唯一一个自己做出的题了…</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先打表求出欧拉函数的值，用紫书上类似素数筛的方式，可以$O(n\\log \\log n)$的时间内求出。</p>\n<p>然后需要解决的问题是，假设对于 2 这个数，那么用欧拉函数值为 $2$ 的 $k$ 并不一定是最优的，可能有一个 $m &lt; k$ 但是 $\\phi(m) &gt; \\phi(k)$。<br>这里一个解决方式是，找出每一个$a_i$的$k_i$打一张表，从1开始枚举$k$，先枚举到的k一定比后枚举到的优。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> phi[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> cost[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//对欧拉函数打表</span></div><div class=\"line\">    phi[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (phi[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= MAX; j+= i) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!phi[j]) phi[j] = j;</div><div class=\"line\">            phi[j] = phi[j] / i * (i<span class=\"number\">-1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举每一个的花费k</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x = phi[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = x; j &gt;= <span class=\"number\">1</span>; j--) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果当前为空，那么他的花费为i</span></div><div class=\"line\">            <span class=\"comment\">//否则之前已经有更优的解，直接break</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (cost[j]) <span class=\"keyword\">break</span>;</div><div class=\"line\">            cost[j] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= T; cases++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            ans += cost[t];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld Xukha\\n\"</span>, cases, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/LightOJ-1370\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/LightOJ-1370</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 $N$ 个数$a_1,a_2\\dots a_n$，求对每一个 $a_i$ 找出最小的 $k_i$ 使得 $\\phi(k_i) \\ge a_i$，输出 $\\sum_1^n k_i$ 。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>因为是数论的题，显然题目是要用欧拉函数，于是特意去翻了一下紫书的欧拉函数。想假期在家里做的，然后咸鱼了，想在来学校补得，也算是目前数论里面唯一一个自己做出的题了…</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先打表求出欧拉函数的值，用紫书上类似素数筛的方式，可以$O(n\\log \\log n)$的时间内求出。</p>\n<p>然后需要解决的问题是，假设对于 2 这个数，那么用欧拉函数值为 $2$ 的 $k$ 并不一定是最优的，可能有一个 $m &lt; k$ 但是 $\\phi(m) &gt; \\phi(k)$。<br>这里一个解决方式是，找出每一个$a_i$的$k_i$打一张表，从1开始枚举$k$，先枚举到的k一定比后枚举到的优。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> phi[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> cost[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//对欧拉函数打表</span></div><div class=\"line\">    phi[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (phi[i]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= MAX; j+= i) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!phi[j]) phi[j] = j;</div><div class=\"line\">            phi[j] = phi[j] / i * (i<span class=\"number\">-1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举每一个的花费k</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x = phi[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = x; j &gt;= <span class=\"number\">1</span>; j--) &#123;</div><div class=\"line\">            <span class=\"comment\">//如果当前为空，那么他的花费为i</span></div><div class=\"line\">            <span class=\"comment\">//否则之前已经有更优的解，直接break</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (cost[j]) <span class=\"keyword\">break</span>;</div><div class=\"line\">            cost[j] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> cases = <span class=\"number\">1</span>; cases &lt;= T; cases++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        LL ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            ans += cost[t];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %lld Xukha\\n\"</span>, cases, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ 3468 - A Simple Problem with Integers（线段树区间更新+模板）","date":"2017-02-10T09:38:30.000Z","_content":"# 题目链接：\n------------------\nhttp://poj.org/problem?id=3468\n# 题目描述：\n------------\n给n个整数，进行m次查询或更新，查询指区间[l ,r]整数的和，更新指区间[l ,r]的整数全部增加z。\n# 解题过程\n-----------------\n题目不难，妥妥的模板题，卡在 pushDown 函数上两次，还不够细心。\n\n首先是lazy标记没处理好，这个提应该是让 **lazy += z**， 我第一次写成了 **lazy = z**，导致标记直接被替换掉了，之前的更新没加上。\n\n第二次卡在了long long上面， 全部检查了一遍， 感觉应该都用 long long 了， 最后又仔细看了一遍， 发现 pushDown 函数里面的 lazy 是和用来标记左右区间的 l, r 一起定义的，改了之后就AC了。\n\n讲道理，这个lazy还真是有点懒，更新的时候，能不更新下一步就坚决不更新下一步，然后所有事都拖到必须要干的时候才干23333。\n# 题目分析：\n------\n+ 首先由于线段树是完全二叉树，建树使用数组就可以。\n+ 要写一个pushDown函数， 用来把lazy标记传给他的两个儿子。\n+ query 和 upDate 函数，每次如果向下递归的时候，都要首先检查下当前节点是不是有lazy标记，如果有的话就传给下一级。\n+ 最后有点要注意的是，本题的更新是数字的值增加，不是直接替换，同理添加或传递lazy标记的时候也要以 += 的形式， 不能直接替换掉原来的。\n\n# AC代码：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nstruct node\n{\n    long long lazy;\n    long long value;\n    int l, r;\n};\n\nnode store[100000*100];\nlong long data[100000*100];\n\nvoid build(int l, int r, int root)\n{\n    store[root].l = l, store[root].r = r;\n    store[root].lazy = 0;\n\n    if (l == r)\n    {\n        store[root].value = data[l];\n        return;\n    }\n\n    int m = (l + r) / 2;\n\n    build(l, m, root*2+1);\n    build(m+1, r, root*2+2);\n\n    store[root].value = store[root*2+1].value + store[root*2+2].value;\n    return;\n}\n\nvoid pushDown(int root)\n{\n    if (store[root].lazy != 0)\n    {\n        long long l, r;\n        long long z;\n        z = store[root].lazy;\n\n        store[root*2+1].lazy += z;\n        l = store[root*2+1].l, r = store[root*2+1].r;\n        store[root*2+1].value += (r - l + 1) * z;\n\n        store[root*2+2].lazy += z;\n        l = store[root*2+2].l, r = store[root*2+2].r;\n        store[root*2+2].value += (r - l + 1) * z;\n\n        store[root].lazy = 0;\n    }\n    return;\n}\n\nvoid upDate(int l, int r, int root, long long z)\n{\n    int nl = store[root].l, nr = store[root].r;\n\n    if (l <= nl && r >= nr)\n    {\n        store[root].lazy += z;\n        store[root].value += (nr - nl + 1) * z;\n        return;\n    }\n\n    pushDown(root);\n\n    int m = (nl + nr) / 2;\n\n    if (l <= m)\n        upDate(l, r, root*2+1, z);\n    if (r > m)\n        upDate(l, r, root*2+2, z);\n\n    store[root].value = store[root*2+1].value + store[root*2+2].value;\n    return;\n}\n\nlong long query(int l, int r, int root)\n{\n    int nl = store[root].l, nr = store[root].r;\n\n    if (l <= nl && r >= nr)\n        return store[root].value;\n\n    pushDown(root);\n    int m = (nl + nr) / 2;\n\n    long long sum = 0;\n    if (l <= m)\n        sum += query(l, r, root*2+1);\n    if (r > m)\n        sum += query(l, r, root*2+2);\n\n    return sum;\n}\n\nint main()\n{\n//    freopen(\"in\", \"r\", stdin);\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld\", data+i);\n\n    build(0, n-1, 0);\n\n    char mode[11];\n    int l, r;\n    long long z;\n    while (q--)\n    {\n        scanf(\"%s %d %d\", mode, &l, &r);\n        if (mode[0] == 'Q')\n            printf(\"%lld\\n\", query(l-1, r-1, 0));\n        else if (mode[0] == 'C')\n        {\n            scanf(\"%lld\", &z);\n            upDate(l-1, r-1, 0, z);\n        }\n    }\n}\n\n\n\n\n\n```","source":"_posts/POJ-3468-A-Simple-Problem-with-Integers（线段树区间更新-模板）.md","raw":"---\ntitle: POJ 3468 - A Simple Problem with Integers（线段树区间更新+模板）\ndate: 2017-02-10 17:38:30\ncategories: [ACM,  数据结构, 线段树]\ntags:\n---\n# 题目链接：\n------------------\nhttp://poj.org/problem?id=3468\n# 题目描述：\n------------\n给n个整数，进行m次查询或更新，查询指区间[l ,r]整数的和，更新指区间[l ,r]的整数全部增加z。\n# 解题过程\n-----------------\n题目不难，妥妥的模板题，卡在 pushDown 函数上两次，还不够细心。\n\n首先是lazy标记没处理好，这个提应该是让 **lazy += z**， 我第一次写成了 **lazy = z**，导致标记直接被替换掉了，之前的更新没加上。\n\n第二次卡在了long long上面， 全部检查了一遍， 感觉应该都用 long long 了， 最后又仔细看了一遍， 发现 pushDown 函数里面的 lazy 是和用来标记左右区间的 l, r 一起定义的，改了之后就AC了。\n\n讲道理，这个lazy还真是有点懒，更新的时候，能不更新下一步就坚决不更新下一步，然后所有事都拖到必须要干的时候才干23333。\n# 题目分析：\n------\n+ 首先由于线段树是完全二叉树，建树使用数组就可以。\n+ 要写一个pushDown函数， 用来把lazy标记传给他的两个儿子。\n+ query 和 upDate 函数，每次如果向下递归的时候，都要首先检查下当前节点是不是有lazy标记，如果有的话就传给下一级。\n+ 最后有点要注意的是，本题的更新是数字的值增加，不是直接替换，同理添加或传递lazy标记的时候也要以 += 的形式， 不能直接替换掉原来的。\n\n# AC代码：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nstruct node\n{\n    long long lazy;\n    long long value;\n    int l, r;\n};\n\nnode store[100000*100];\nlong long data[100000*100];\n\nvoid build(int l, int r, int root)\n{\n    store[root].l = l, store[root].r = r;\n    store[root].lazy = 0;\n\n    if (l == r)\n    {\n        store[root].value = data[l];\n        return;\n    }\n\n    int m = (l + r) / 2;\n\n    build(l, m, root*2+1);\n    build(m+1, r, root*2+2);\n\n    store[root].value = store[root*2+1].value + store[root*2+2].value;\n    return;\n}\n\nvoid pushDown(int root)\n{\n    if (store[root].lazy != 0)\n    {\n        long long l, r;\n        long long z;\n        z = store[root].lazy;\n\n        store[root*2+1].lazy += z;\n        l = store[root*2+1].l, r = store[root*2+1].r;\n        store[root*2+1].value += (r - l + 1) * z;\n\n        store[root*2+2].lazy += z;\n        l = store[root*2+2].l, r = store[root*2+2].r;\n        store[root*2+2].value += (r - l + 1) * z;\n\n        store[root].lazy = 0;\n    }\n    return;\n}\n\nvoid upDate(int l, int r, int root, long long z)\n{\n    int nl = store[root].l, nr = store[root].r;\n\n    if (l <= nl && r >= nr)\n    {\n        store[root].lazy += z;\n        store[root].value += (nr - nl + 1) * z;\n        return;\n    }\n\n    pushDown(root);\n\n    int m = (nl + nr) / 2;\n\n    if (l <= m)\n        upDate(l, r, root*2+1, z);\n    if (r > m)\n        upDate(l, r, root*2+2, z);\n\n    store[root].value = store[root*2+1].value + store[root*2+2].value;\n    return;\n}\n\nlong long query(int l, int r, int root)\n{\n    int nl = store[root].l, nr = store[root].r;\n\n    if (l <= nl && r >= nr)\n        return store[root].value;\n\n    pushDown(root);\n    int m = (nl + nr) / 2;\n\n    long long sum = 0;\n    if (l <= m)\n        sum += query(l, r, root*2+1);\n    if (r > m)\n        sum += query(l, r, root*2+2);\n\n    return sum;\n}\n\nint main()\n{\n//    freopen(\"in\", \"r\", stdin);\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld\", data+i);\n\n    build(0, n-1, 0);\n\n    char mode[11];\n    int l, r;\n    long long z;\n    while (q--)\n    {\n        scanf(\"%s %d %d\", mode, &l, &r);\n        if (mode[0] == 'Q')\n            printf(\"%lld\\n\", query(l-1, r-1, 0));\n        else if (mode[0] == 'C')\n        {\n            scanf(\"%lld\", &z);\n            upDate(l-1, r-1, 0, z);\n        }\n    }\n}\n\n\n\n\n\n```","slug":"POJ-3468-A-Simple-Problem-with-Integers（线段树区间更新-模板）","published":1,"updated":"2017-07-23T03:37:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nce0035y9ideflmqun3","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://poj.org/problem?id=3468\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3468</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>给n个整数，进行m次查询或更新，查询指区间[l ,r]整数的和，更新指区间[l ,r]的整数全部增加z。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>题目不难，妥妥的模板题，卡在 pushDown 函数上两次，还不够细心。</p>\n<p>首先是lazy标记没处理好，这个提应该是让 <strong>lazy += z</strong>， 我第一次写成了 <strong>lazy = z</strong>，导致标记直接被替换掉了，之前的更新没加上。</p>\n<p>第二次卡在了long long上面， 全部检查了一遍， 感觉应该都用 long long 了， 最后又仔细看了一遍， 发现 pushDown 函数里面的 lazy 是和用来标记左右区间的 l, r 一起定义的，改了之后就AC了。</p>\n<p>讲道理，这个lazy还真是有点懒，更新的时候，能不更新下一步就坚决不更新下一步，然后所有事都拖到必须要干的时候才干23333。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>首先由于线段树是完全二叉树，建树使用数组就可以。</li>\n<li>要写一个pushDown函数， 用来把lazy标记传给他的两个儿子。</li>\n<li>query 和 upDate 函数，每次如果向下递归的时候，都要首先检查下当前节点是不是有lazy标记，如果有的话就传给下一级。</li>\n<li>最后有点要注意的是，本题的更新是数字的值增加，不是直接替换，同理添加或传递lazy标记的时候也要以 += 的形式， 不能直接替换掉原来的。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value;</div><div class=\"line\">    <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">node store[<span class=\"number\">100000</span>*<span class=\"number\">100</span>];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> data[<span class=\"number\">100000</span>*<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    store[root].l = l, store[root].r = r;</div><div class=\"line\">    store[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r)</div><div class=\"line\">    &#123;</div><div class=\"line\">        store[root].value = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    build(l, m, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</div><div class=\"line\">    build(m+<span class=\"number\">1</span>, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">    store[root].value = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value + store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushDown</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (store[root].lazy != <span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l, r;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z;</div><div class=\"line\">        z = store[root].lazy;</div><div class=\"line\"></div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].lazy += z;</div><div class=\"line\">        l = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].l, r = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].r;</div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value += (r - l + <span class=\"number\">1</span>) * z;</div><div class=\"line\"></div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].lazy += z;</div><div class=\"line\">        l = store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].l, r = store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].r;</div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value += (r - l + <span class=\"number\">1</span>) * z;</div><div class=\"line\"></div><div class=\"line\">        store[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">upDate</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nl = store[root].l, nr = store[root].r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= nl &amp;&amp; r &gt;= nr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        store[root].lazy += z;</div><div class=\"line\">        store[root].value += (nr - nl + <span class=\"number\">1</span>) * z;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    pushDown(root);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> m = (nl + nr) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= m)</div><div class=\"line\">        upDate(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>, z);</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &gt; m)</div><div class=\"line\">        upDate(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>, z);</div><div class=\"line\"></div><div class=\"line\">    store[root].value = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value + store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nl = store[root].l, nr = store[root].r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= nl &amp;&amp; r &gt;= nr)</div><div class=\"line\">        <span class=\"keyword\">return</span> store[root].value;</div><div class=\"line\"></div><div class=\"line\">    pushDown(root);</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (nl + nr) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= m)</div><div class=\"line\">        sum += query(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &gt; m)</div><div class=\"line\">        sum += query(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\">    <span class=\"keyword\">int</span> n, q;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;q);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, data+i);</div><div class=\"line\"></div><div class=\"line\">    build(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">char</span> mode[<span class=\"number\">11</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z;</div><div class=\"line\">    <span class=\"keyword\">while</span> (q--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %d %d\"</span>, mode, &amp;l, &amp;r);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mode[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(l<span class=\"number\">-1</span>, r<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mode[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;z);</div><div class=\"line\">            upDate(l<span class=\"number\">-1</span>, r<span class=\"number\">-1</span>, <span class=\"number\">0</span>, z);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"http://poj.org/problem?id=3468\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3468</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>给n个整数，进行m次查询或更新，查询指区间[l ,r]整数的和，更新指区间[l ,r]的整数全部增加z。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>题目不难，妥妥的模板题，卡在 pushDown 函数上两次，还不够细心。</p>\n<p>首先是lazy标记没处理好，这个提应该是让 <strong>lazy += z</strong>， 我第一次写成了 <strong>lazy = z</strong>，导致标记直接被替换掉了，之前的更新没加上。</p>\n<p>第二次卡在了long long上面， 全部检查了一遍， 感觉应该都用 long long 了， 最后又仔细看了一遍， 发现 pushDown 函数里面的 lazy 是和用来标记左右区间的 l, r 一起定义的，改了之后就AC了。</p>\n<p>讲道理，这个lazy还真是有点懒，更新的时候，能不更新下一步就坚决不更新下一步，然后所有事都拖到必须要干的时候才干23333。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>首先由于线段树是完全二叉树，建树使用数组就可以。</li>\n<li>要写一个pushDown函数， 用来把lazy标记传给他的两个儿子。</li>\n<li>query 和 upDate 函数，每次如果向下递归的时候，都要首先检查下当前节点是不是有lazy标记，如果有的话就传给下一级。</li>\n<li>最后有点要注意的是，本题的更新是数字的值增加，不是直接替换，同理添加或传递lazy标记的时候也要以 += 的形式， 不能直接替换掉原来的。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value;</div><div class=\"line\">    <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">node store[<span class=\"number\">100000</span>*<span class=\"number\">100</span>];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> data[<span class=\"number\">100000</span>*<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    store[root].l = l, store[root].r = r;</div><div class=\"line\">    store[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r)</div><div class=\"line\">    &#123;</div><div class=\"line\">        store[root].value = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    build(l, m, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</div><div class=\"line\">    build(m+<span class=\"number\">1</span>, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">    store[root].value = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value + store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushDown</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (store[root].lazy != <span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l, r;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z;</div><div class=\"line\">        z = store[root].lazy;</div><div class=\"line\"></div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].lazy += z;</div><div class=\"line\">        l = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].l, r = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].r;</div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value += (r - l + <span class=\"number\">1</span>) * z;</div><div class=\"line\"></div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].lazy += z;</div><div class=\"line\">        l = store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].l, r = store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].r;</div><div class=\"line\">        store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value += (r - l + <span class=\"number\">1</span>) * z;</div><div class=\"line\"></div><div class=\"line\">        store[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">upDate</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nl = store[root].l, nr = store[root].r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= nl &amp;&amp; r &gt;= nr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        store[root].lazy += z;</div><div class=\"line\">        store[root].value += (nr - nl + <span class=\"number\">1</span>) * z;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    pushDown(root);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> m = (nl + nr) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= m)</div><div class=\"line\">        upDate(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>, z);</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &gt; m)</div><div class=\"line\">        upDate(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>, z);</div><div class=\"line\"></div><div class=\"line\">    store[root].value = store[root*<span class=\"number\">2</span>+<span class=\"number\">1</span>].value + store[root*<span class=\"number\">2</span>+<span class=\"number\">2</span>].value;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> root)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nl = store[root].l, nr = store[root].r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= nl &amp;&amp; r &gt;= nr)</div><div class=\"line\">        <span class=\"keyword\">return</span> store[root].value;</div><div class=\"line\"></div><div class=\"line\">    pushDown(root);</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (nl + nr) / <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &lt;= m)</div><div class=\"line\">        sum += query(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (r &gt; m)</div><div class=\"line\">        sum += query(l, r, root*<span class=\"number\">2</span>+<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\">    <span class=\"keyword\">int</span> n, q;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;q);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, data+i);</div><div class=\"line\"></div><div class=\"line\">    build(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">char</span> mode[<span class=\"number\">11</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z;</div><div class=\"line\">    <span class=\"keyword\">while</span> (q--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s %d %d\"</span>, mode, &amp;l, &amp;r);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mode[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(l<span class=\"number\">-1</span>, r<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mode[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;z);</div><div class=\"line\">            upDate(l<span class=\"number\">-1</span>, r<span class=\"number\">-1</span>, <span class=\"number\">0</span>, z);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ1015 - Jury Compromise（DP+计算顺序）","date":"2017-07-02T02:39:08.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=1015\n\n-----------------------------------\n# 题目大意：\n现在两个长度相等的序列，$D$和$P$，现在要构造一个新的序列$A = \\lbrace a_1, a_2, a_3 \\cdots a_k\\rbrace$使得$\\big|\\sum_{i=1}^kD[a_i]-\\sum_{i=1}^kP[a_i]\\big|$尽量的小，如果有多解，要求$\\sum_{i=1}^k(D[a_i]+P[a_i])$尽量的大。\n\n-------------------------------------\n# 解题过程：\n历经两天才A掉的这个题，刚开始定义的三维的状态，果断超时了，后来建去以为，以当前差值的绝对值为状态，但是这样好像会失解，最后看了下博客，发现不用取绝对值可以了。\n\n但是这题要求输出路径，于是纠结好久如何输出路径，要保证一个元素不难重复使用的话，只能从后往前递推，如何这样之前的路径就可能被之后更新掉，原因应该是，以这样DP，不符合最优子结构，全局最优解不是局部最优解，然后局部的解被更新掉之后，输出路径的时候就错了。\n\n最后又去看了下博客，发现别人都是从前往后递推，并且转移的时候检查下当前元素有没有被用过。从前往后推的话，就能保证当前状态向后找的路径是确定不变的了。\n\n\n----------------------------------------\n# 题目分析：\n定义状态$dp[i][j]$为$\\sum_{i=1}^jD[a_i]-\\sum_{i=1}^jP[a_i]$的结果为$i$时最大的$\\sum_{i=1}^kD[a_i]+P[a_i]$。\n\n那么状态之间转移为：\n设当前已选的元素的集合为$D$\n\n$$dp[i+D[k]-P[k]][j+1] = max(dp[i][j]+D[k]+P[k]) \\wedge 1 \\le k \\le n\\wedge k\\notin D$$\n\n\n关键在于如何判断$k\\notin D$，这里只需要去递归访问路径，查看$k$是否在当前状态的路径中。\n\n做这道题的时候，真的意识到写递推$DP$时计算顺序是多么重要，要考虑循环的嵌套顺序，是循环变量从前往后还是从后向前，一个不同，含义就改变了许多。\n\n---------------------------------------\n# AC代码\n```cpp\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint reserve1[3123][30], reserve2[3123][30];\nint (*dp)[30] = reserve1+1512;\nint (*pre)[30] = reserve2+1512;\nint D[212], P[212];\n\n//判断k是否已经被选择\nbool is_select(int i, int j, int k) {\n    while (~pre[i][j]) {\n        int t = pre[i][j];\n        if (t == k)\n            return true;\n        t = D[t]-P[t];\n        i -= t;\n        j--;\n    }\n    return false;\n}\n\nint main() {\n    int n, m, cases = 0;\n    while (~scanf(\"%d %d\", &n, &m) && (n+m)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", D+i, P+i);\n        }\n        memset(reserve1, 0x80, sizeof(reserve1));\n        memset(reserve2, -1, sizeof(reserve2));\n        //初始化边界状态\n        dp[0][0] = 0;\n\n        //记录答案\n        int ans_diff, ans_sum;\n        vector<int> ans_path;\n        ans_diff = INF, ans_sum = -INF;\n\n        for (int i = -1000; i <= 1000; i++) {\n            for (int j = 0; j < m; j++) {\n                //如果当前为负数，表示当前状态不可到达\n                if (dp[i][j] < 0) continue;\n                for (int k = 0; k < n; k++) {\n                    int t1 = D[k]+P[k];\n                    int t2 = D[k]-P[k];\n                    if (!is_select(i, j, k) && (dp[i][j] + t1 > dp[i+t2][j+1])) {\n                        dp[i+t2][j+1] = dp[i][j] + t1;\n                        pre[i+t2][j+1] = k;\n                        //当j等于m时更新答案\n                        if (j+1 == m && (abs(i+t2) < abs(ans_diff) || abs(i+t2) == abs(ans_diff) && dp[i+t2][j+1] > ans_sum)) {\n                            ans_diff = i+t2;\n                            ans_sum = dp[i+t2][j+1];\n                        }\n                    }\n                }\n            }\n        }\n\n        int sum1, sum2;\n        sum1 = sum2 = 0;\n        int pos = m;\n        //递归的去寻找路径\n        while (~pre[ans_diff][pos]) {\n            int t = pre[ans_diff][pos];\n            ans_path.push_back(t);\n            sum1 += D[t];\n            sum2 += P[t];\n            t = D[t]-P[t];\n            ans_diff -= t;\n            pos--;\n        }\n\n        sort(ans_path.begin(), ans_path.end());\n        printf(\"Jury #%d\\n\", ++cases);\n        printf(\"Best jury has value %d for prosecution and value %d for defence:\\n\", sum1, sum2);\n        for (int i = 0; i < ans_path.size(); i++)\n            printf(\" %d\", ans_path[i]+1);\n        printf(\"\\n\\n\");\n    }\n}\n```","source":"_posts/POJ1015-Jury-Compromise（DP-计算顺序）.md","raw":"---\ntitle: POJ1015 - Jury Compromise（DP+计算顺序）\ndate: 2017-07-02 10:39:08\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=1015\n\n-----------------------------------\n# 题目大意：\n现在两个长度相等的序列，$D$和$P$，现在要构造一个新的序列$A = \\lbrace a_1, a_2, a_3 \\cdots a_k\\rbrace$使得$\\big|\\sum_{i=1}^kD[a_i]-\\sum_{i=1}^kP[a_i]\\big|$尽量的小，如果有多解，要求$\\sum_{i=1}^k(D[a_i]+P[a_i])$尽量的大。\n\n-------------------------------------\n# 解题过程：\n历经两天才A掉的这个题，刚开始定义的三维的状态，果断超时了，后来建去以为，以当前差值的绝对值为状态，但是这样好像会失解，最后看了下博客，发现不用取绝对值可以了。\n\n但是这题要求输出路径，于是纠结好久如何输出路径，要保证一个元素不难重复使用的话，只能从后往前递推，如何这样之前的路径就可能被之后更新掉，原因应该是，以这样DP，不符合最优子结构，全局最优解不是局部最优解，然后局部的解被更新掉之后，输出路径的时候就错了。\n\n最后又去看了下博客，发现别人都是从前往后递推，并且转移的时候检查下当前元素有没有被用过。从前往后推的话，就能保证当前状态向后找的路径是确定不变的了。\n\n\n----------------------------------------\n# 题目分析：\n定义状态$dp[i][j]$为$\\sum_{i=1}^jD[a_i]-\\sum_{i=1}^jP[a_i]$的结果为$i$时最大的$\\sum_{i=1}^kD[a_i]+P[a_i]$。\n\n那么状态之间转移为：\n设当前已选的元素的集合为$D$\n\n$$dp[i+D[k]-P[k]][j+1] = max(dp[i][j]+D[k]+P[k]) \\wedge 1 \\le k \\le n\\wedge k\\notin D$$\n\n\n关键在于如何判断$k\\notin D$，这里只需要去递归访问路径，查看$k$是否在当前状态的路径中。\n\n做这道题的时候，真的意识到写递推$DP$时计算顺序是多么重要，要考虑循环的嵌套顺序，是循环变量从前往后还是从后向前，一个不同，含义就改变了许多。\n\n---------------------------------------\n# AC代码\n```cpp\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint reserve1[3123][30], reserve2[3123][30];\nint (*dp)[30] = reserve1+1512;\nint (*pre)[30] = reserve2+1512;\nint D[212], P[212];\n\n//判断k是否已经被选择\nbool is_select(int i, int j, int k) {\n    while (~pre[i][j]) {\n        int t = pre[i][j];\n        if (t == k)\n            return true;\n        t = D[t]-P[t];\n        i -= t;\n        j--;\n    }\n    return false;\n}\n\nint main() {\n    int n, m, cases = 0;\n    while (~scanf(\"%d %d\", &n, &m) && (n+m)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", D+i, P+i);\n        }\n        memset(reserve1, 0x80, sizeof(reserve1));\n        memset(reserve2, -1, sizeof(reserve2));\n        //初始化边界状态\n        dp[0][0] = 0;\n\n        //记录答案\n        int ans_diff, ans_sum;\n        vector<int> ans_path;\n        ans_diff = INF, ans_sum = -INF;\n\n        for (int i = -1000; i <= 1000; i++) {\n            for (int j = 0; j < m; j++) {\n                //如果当前为负数，表示当前状态不可到达\n                if (dp[i][j] < 0) continue;\n                for (int k = 0; k < n; k++) {\n                    int t1 = D[k]+P[k];\n                    int t2 = D[k]-P[k];\n                    if (!is_select(i, j, k) && (dp[i][j] + t1 > dp[i+t2][j+1])) {\n                        dp[i+t2][j+1] = dp[i][j] + t1;\n                        pre[i+t2][j+1] = k;\n                        //当j等于m时更新答案\n                        if (j+1 == m && (abs(i+t2) < abs(ans_diff) || abs(i+t2) == abs(ans_diff) && dp[i+t2][j+1] > ans_sum)) {\n                            ans_diff = i+t2;\n                            ans_sum = dp[i+t2][j+1];\n                        }\n                    }\n                }\n            }\n        }\n\n        int sum1, sum2;\n        sum1 = sum2 = 0;\n        int pos = m;\n        //递归的去寻找路径\n        while (~pre[ans_diff][pos]) {\n            int t = pre[ans_diff][pos];\n            ans_path.push_back(t);\n            sum1 += D[t];\n            sum2 += P[t];\n            t = D[t]-P[t];\n            ans_diff -= t;\n            pos--;\n        }\n\n        sort(ans_path.begin(), ans_path.end());\n        printf(\"Jury #%d\\n\", ++cases);\n        printf(\"Best jury has value %d for prosecution and value %d for defence:\\n\", sum1, sum2);\n        for (int i = 0; i < ans_path.size(); i++)\n            printf(\" %d\", ans_path[i]+1);\n        printf(\"\\n\\n\");\n    }\n}\n```","slug":"POJ1015-Jury-Compromise（DP-计算顺序）","published":1,"updated":"2017-07-23T01:43:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncg0037y9idigwi6o3p","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=1015\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1015</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在两个长度相等的序列，$D$和$P$，现在要构造一个新的序列$A = \\lbrace a_1, a_2, a_3 \\cdots a<em>k\\rbrace$使得$\\big|\\sum</em>{i=1}^kD[a<em>i]-\\sum</em>{i=1}^kP[a<em>i]\\big|$尽量的小，如果有多解，要求$\\sum</em>{i=1}^k(D[a_i]+P[a_i])$尽量的大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>历经两天才A掉的这个题，刚开始定义的三维的状态，果断超时了，后来建去以为，以当前差值的绝对值为状态，但是这样好像会失解，最后看了下博客，发现不用取绝对值可以了。</p>\n<p>但是这题要求输出路径，于是纠结好久如何输出路径，要保证一个元素不难重复使用的话，只能从后往前递推，如何这样之前的路径就可能被之后更新掉，原因应该是，以这样DP，不符合最优子结构，全局最优解不是局部最优解，然后局部的解被更新掉之后，输出路径的时候就错了。</p>\n<p>最后又去看了下博客，发现别人都是从前往后递推，并且转移的时候检查下当前元素有没有被用过。从前往后推的话，就能保证当前状态向后找的路径是确定不变的了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态$dp[i][j]$为$\\sum_{i=1}^jD[a<em>i]-\\sum</em>{i=1}^jP[a<em>i]$的结果为$i$时最大的$\\sum</em>{i=1}^kD[a_i]+P[a_i]$。</p>\n<p>那么状态之间转移为：<br>设当前已选的元素的集合为$D$</p>\n<p>$$dp[i+D[k]-P[k]][j+1] = max(dp[i][j]+D[k]+P[k]) \\wedge 1 \\le k \\le n\\wedge k\\notin D$$</p>\n<p>关键在于如何判断$k\\notin D$，这里只需要去递归访问路径，查看$k$是否在当前状态的路径中。</p>\n<p>做这道题的时候，真的意识到写递推$DP$时计算顺序是多么重要，要考虑循环的嵌套顺序，是循环变量从前往后还是从后向前，一个不同，含义就改变了许多。</p>\n<hr>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> reserve1[<span class=\"number\">3123</span>][<span class=\"number\">30</span>], reserve2[<span class=\"number\">3123</span>][<span class=\"number\">30</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> (*dp)[<span class=\"number\">30</span>] = reserve1+<span class=\"number\">1512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> (*pre)[<span class=\"number\">30</span>] = reserve2+<span class=\"number\">1512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> D[<span class=\"number\">212</span>], P[<span class=\"number\">212</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断k是否已经被选择</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_select</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~pre[i][j]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> t = pre[i][j];</div><div class=\"line\">        <span class=\"keyword\">if</span> (t == k)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        t = D[t]-P[t];</div><div class=\"line\">        i -= t;</div><div class=\"line\">        j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n+m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, D+i, P+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(reserve1, <span class=\"number\">0x80</span>, <span class=\"keyword\">sizeof</span>(reserve1));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(reserve2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(reserve2));</div><div class=\"line\">        <span class=\"comment\">//初始化边界状态</span></div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//记录答案</span></div><div class=\"line\">        <span class=\"keyword\">int</span> ans_diff, ans_sum;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans_path;</div><div class=\"line\">        ans_diff = INF, ans_sum = -INF;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">-1000</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前为负数，表示当前状态不可到达</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> t1 = D[k]+P[k];</div><div class=\"line\">                    <span class=\"keyword\">int</span> t2 = D[k]-P[k];</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!is_select(i, j, k) &amp;&amp; (dp[i][j] + t1 &gt; dp[i+t2][j+<span class=\"number\">1</span>])) &#123;</div><div class=\"line\">                        dp[i+t2][j+<span class=\"number\">1</span>] = dp[i][j] + t1;</div><div class=\"line\">                        pre[i+t2][j+<span class=\"number\">1</span>] = k;</div><div class=\"line\">                        <span class=\"comment\">//当j等于m时更新答案</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (j+<span class=\"number\">1</span> == m &amp;&amp; (<span class=\"built_in\">abs</span>(i+t2) &lt; <span class=\"built_in\">abs</span>(ans_diff) || <span class=\"built_in\">abs</span>(i+t2) == <span class=\"built_in\">abs</span>(ans_diff) &amp;&amp; dp[i+t2][j+<span class=\"number\">1</span>] &gt; ans_sum)) &#123;</div><div class=\"line\">                            ans_diff = i+t2;</div><div class=\"line\">                            ans_sum = dp[i+t2][j+<span class=\"number\">1</span>];</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> sum1, sum2;</div><div class=\"line\">        sum1 = sum2 = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> pos = m;</div><div class=\"line\">        <span class=\"comment\">//递归的去寻找路径</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (~pre[ans_diff][pos]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = pre[ans_diff][pos];</div><div class=\"line\">            ans_path.push_back(t);</div><div class=\"line\">            sum1 += D[t];</div><div class=\"line\">            sum2 += P[t];</div><div class=\"line\">            t = D[t]-P[t];</div><div class=\"line\">            ans_diff -= t;</div><div class=\"line\">            pos--;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        sort(ans_path.begin(), ans_path.end());</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Jury #%d\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Best jury has value %d for prosecution and value %d for defence:\\n\"</span>, sum1, sum2);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans_path.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, ans_path[i]+<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=1015\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1015</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>现在两个长度相等的序列，$D$和$P$，现在要构造一个新的序列$A = \\lbrace a_1, a_2, a_3 \\cdots a<em>k\\rbrace$使得$\\big|\\sum</em>{i=1}^kD[a<em>i]-\\sum</em>{i=1}^kP[a<em>i]\\big|$尽量的小，如果有多解，要求$\\sum</em>{i=1}^k(D[a_i]+P[a_i])$尽量的大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>历经两天才A掉的这个题，刚开始定义的三维的状态，果断超时了，后来建去以为，以当前差值的绝对值为状态，但是这样好像会失解，最后看了下博客，发现不用取绝对值可以了。</p>\n<p>但是这题要求输出路径，于是纠结好久如何输出路径，要保证一个元素不难重复使用的话，只能从后往前递推，如何这样之前的路径就可能被之后更新掉，原因应该是，以这样DP，不符合最优子结构，全局最优解不是局部最优解，然后局部的解被更新掉之后，输出路径的时候就错了。</p>\n<p>最后又去看了下博客，发现别人都是从前往后递推，并且转移的时候检查下当前元素有没有被用过。从前往后推的话，就能保证当前状态向后找的路径是确定不变的了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>定义状态$dp[i][j]$为$\\sum_{i=1}^jD[a<em>i]-\\sum</em>{i=1}^jP[a<em>i]$的结果为$i$时最大的$\\sum</em>{i=1}^kD[a_i]+P[a_i]$。</p>\n<p>那么状态之间转移为：<br>设当前已选的元素的集合为$D$</p>\n<p>$$dp[i+D[k]-P[k]][j+1] = max(dp[i][j]+D[k]+P[k]) \\wedge 1 \\le k \\le n\\wedge k\\notin D$$</p>\n<p>关键在于如何判断$k\\notin D$，这里只需要去递归访问路径，查看$k$是否在当前状态的路径中。</p>\n<p>做这道题的时候，真的意识到写递推$DP$时计算顺序是多么重要，要考虑循环的嵌套顺序，是循环变量从前往后还是从后向前，一个不同，含义就改变了许多。</p>\n<hr>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> reserve1[<span class=\"number\">3123</span>][<span class=\"number\">30</span>], reserve2[<span class=\"number\">3123</span>][<span class=\"number\">30</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> (*dp)[<span class=\"number\">30</span>] = reserve1+<span class=\"number\">1512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> (*pre)[<span class=\"number\">30</span>] = reserve2+<span class=\"number\">1512</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> D[<span class=\"number\">212</span>], P[<span class=\"number\">212</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断k是否已经被选择</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_select</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~pre[i][j]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> t = pre[i][j];</div><div class=\"line\">        <span class=\"keyword\">if</span> (t == k)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        t = D[t]-P[t];</div><div class=\"line\">        i -= t;</div><div class=\"line\">        j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m, cases = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n+m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, D+i, P+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(reserve1, <span class=\"number\">0x80</span>, <span class=\"keyword\">sizeof</span>(reserve1));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(reserve2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(reserve2));</div><div class=\"line\">        <span class=\"comment\">//初始化边界状态</span></div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//记录答案</span></div><div class=\"line\">        <span class=\"keyword\">int</span> ans_diff, ans_sum;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans_path;</div><div class=\"line\">        ans_diff = INF, ans_sum = -INF;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">-1000</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//如果当前为负数，表示当前状态不可到达</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> t1 = D[k]+P[k];</div><div class=\"line\">                    <span class=\"keyword\">int</span> t2 = D[k]-P[k];</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!is_select(i, j, k) &amp;&amp; (dp[i][j] + t1 &gt; dp[i+t2][j+<span class=\"number\">1</span>])) &#123;</div><div class=\"line\">                        dp[i+t2][j+<span class=\"number\">1</span>] = dp[i][j] + t1;</div><div class=\"line\">                        pre[i+t2][j+<span class=\"number\">1</span>] = k;</div><div class=\"line\">                        <span class=\"comment\">//当j等于m时更新答案</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (j+<span class=\"number\">1</span> == m &amp;&amp; (<span class=\"built_in\">abs</span>(i+t2) &lt; <span class=\"built_in\">abs</span>(ans_diff) || <span class=\"built_in\">abs</span>(i+t2) == <span class=\"built_in\">abs</span>(ans_diff) &amp;&amp; dp[i+t2][j+<span class=\"number\">1</span>] &gt; ans_sum)) &#123;</div><div class=\"line\">                            ans_diff = i+t2;</div><div class=\"line\">                            ans_sum = dp[i+t2][j+<span class=\"number\">1</span>];</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> sum1, sum2;</div><div class=\"line\">        sum1 = sum2 = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> pos = m;</div><div class=\"line\">        <span class=\"comment\">//递归的去寻找路径</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (~pre[ans_diff][pos]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = pre[ans_diff][pos];</div><div class=\"line\">            ans_path.push_back(t);</div><div class=\"line\">            sum1 += D[t];</div><div class=\"line\">            sum2 += P[t];</div><div class=\"line\">            t = D[t]-P[t];</div><div class=\"line\">            ans_diff -= t;</div><div class=\"line\">            pos--;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        sort(ans_path.begin(), ans_path.end());</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Jury #%d\\n\"</span>, ++cases);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Best jury has value %d for prosecution and value %d for defence:\\n\"</span>, sum1, sum2);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans_path.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, ans_path[i]+<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ1904 - King's Quest & HDU4685 - Prince and Princess（强连通 + 二分图匹配）","date":"2017-08-18T03:47:34.000Z","_content":"# 题目链接：\n\nhttp://poj.org/problem?id=1904\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4685\n\n\n\n--------------------\n# 题目大意：\n\n#### POJ1904： \n\n一个国王有 N 个儿子，并且有 N 个公主，每个王子可以和一些喜欢公主结婚。公主没有限制。现在给出了一个 王子-公主 的完美匹配。\n\n现在问每个王子，可以和那些公主结婚，结婚后其他的王子仍然可以完美匹配。\n\n\n\n#### HDU4685:\n\n题意和上面一样，不过没给出初始的匹配，不保证完美匹配，公主和王子的数量也有可能不同。\n\n\n\n-------------------\n# 解题过程：\n\n一开始完全没思路，然后去翻了一堆的博客才看懂。\n\n\n\n--------------------\n# 题目分析：\n\n首先以王子和公主为点建图，对每个王子向他们喜欢的公主连一条有向边。\n\n然后进行二分图匹配，对一堆匹配的 王子-公主 从公主向王子建一条有向边。\n\n进行强连通缩点，每个王子对于属于同一强连通分量中喜欢的公主都可以选择。\n\n\n\n为什么这样就这样呢？可以类比网络流的退流或者匈牙利的思想，当一王子选择强连通里的非匹配的公主的话，那么这个公主的原配一定也可以选择另一个公主，并且一定可以经过若干次换妻 play 使得强连通分量内的所有王子都有匹配的公主，这里就不严格的证明了。\n\n\n\n对于第二个题，可能有一些王子或公主一开始就没有匹配，但是他按题意应该是可以选择一些公主或者王子并不影响其他人匹配的。\n\n这时候我们对没有匹配的公主增加一个虚拟的王子并匹配建边，并且这个王子喜欢所有的公主。对于没有匹配的王子新增一个虚拟的公主来匹配，并且这个公主被所有王子喜欢。\n\n为什么要喜欢所有的公主或者被所有王子喜欢，是为了让这个虚拟王子/公主有机会参加所有人的换妻 play 中，注意这里虚拟节点没必要和虚拟节点建边。\n\n\n\n----------------------\n# AC代码：\n\n\n\n####POJ1904：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 500000 + 10;\nconst int MAXN = 4000 + 10;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAXM];\n\nint head[MAXN], etot;\n\n\n//本题的算法复杂度是 O(N+M) 的，读入数据也是 O(N+M) 对总时间影响较大\n//用输入挂加速后由 9s 变成了 500ms\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nvoid Out(int a) {\n    if (a > 9)\n        Out(a / 10);\n    putchar(a % 10 + '0');\n}\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nint n;\n\nint pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;\nstack<int> S;\n\nvoid dfs(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n        } else if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid tarjan() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nvoid init() {\n    memset(head, -1, sizeof(head));\n    etot = 0;\n    n = Scan();\n    for (int u = 1; u <= n; u++) {\n        int k;\n        k = Scan();\n        while (k--) {\n            int v;\n            v = Scan();\n            add_edge(u, v + n);\n        }\n    }\n    for (int u = 1; u <= n; u++) {\n        int v;\n        v = Scan();\n        add_edge(v + n, u);\n    }\n}\n\nvoid solve() {\n    tarjan();\n\n    vector<int> data;\n    for (int u = 1; u <= n; u++) {\n        data.clear();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            //如果属于同一强连通分量，那么可以选择\n            if (mark[u] == mark[v]) data.push_back(v);\n        }\n        Out(data.size());\n        //对答案排序\n        sort(data.begin(), data.end());\n        for (int i = 0; i < data.size(); i++) {\n            putchar(' ');\n            Out(data[i] - n);\n        }\n        putchar('\\n');\n    }\n}\n\nint main() {\n    init();\n    solve();\n}\n```\n####HDU4685\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 500000 + 10;\nconst int MAXN = 4000 + 10;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAXM];\n\nint head[MAXN], etot;\nint n, m, Case, tot;\n\nint pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;\nstack<int> S;\n\nint matching[MAXN];\n\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nvoid Out(int a) {\n    if (a > 9)\n        Out(a / 10);\n    putchar(a % 10 + '0');\n}\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nvoid dfs(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n        } else if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid tarjan() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    for (int i = 1; i <= tot; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nbool find(int u) {\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (pre[v]) continue;\n        pre[v] = true;\n        if (matching[v] == -1 || find(matching[v])) {\n            matching[v] = u;\n            matching[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid match() {\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= n; i++) {\n        memset(pre, 0, sizeof(pre));\n        find(i);\n    }\n}\n\nvoid init() {\n    memset(head, -1, sizeof(head));\n    etot = 0;\n    n = Scan();\n    m = Scan();\n    for (int u = 1; u <= n; u++) {\n        int k;\n        k = Scan();\n        while (k--) {\n            int v;\n            v = Scan();\n            add_edge(u, v + n);\n        }\n    }\n}\n\nvoid solve() {\n    match();\n\n    tot = n + m;\n    for (int i = 1; i <= n; i++) {\n        //如果当前节点未匹配\n        if (matching[i] == -1) {\n            //增加一个虚拟公主，并建边\n            ++tot;\n            add_edge(tot, i);\n            for (int j = 1; j <= n; j++) {\n                add_edge(j, tot);\n            }\n        } else {\n            //如果已匹配，建一条反向边\n            add_edge(matching[i], i);\n        }\n    }\n    for (int i = n + 1; i <= n + m; i++) {\n        //同理增加一个虚拟公主\n        if (matching[i] == -1) {\n            ++tot;\n            add_edge(i, tot);\n            for (int j = n + 1; j <= n + m; j++) {\n                add_edge(tot, j);\n            }\n        }\n    }\n\n    tarjan();\n\n    printf(\"Case #%d:\\n\", ++Case);\n    vector<int> data;\n    for (int u = 1; u <= n; u++) {\n        data.clear();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            //如果是虚拟节点就忽略\n            if (v > n + m) continue;\n            //如果和公主属于同一强连通分量，那么可以选择\n            if (mark[u] == mark[v]) data.push_back(v);\n        }\n        Out(data.size());\n        sort(data.begin(), data.end());\n        for (int i = 0; i < data.size(); i++) {\n            putchar(' ');\n            Out(data[i] - n);\n        }\n        putchar('\\n');\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```\n\n","source":"_posts/POJ1904-King-s-Quest-HDU4685-Prince-and-Princess（强连通-二分图匹配）.md","raw":"---\ntitle: POJ1904 - King's Quest & HDU4685 - Prince and Princess（强连通 + 二分图匹配）\ndate: 2017-08-18 11:47:34\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\n\nhttp://poj.org/problem?id=1904\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=4685\n\n\n\n--------------------\n# 题目大意：\n\n#### POJ1904： \n\n一个国王有 N 个儿子，并且有 N 个公主，每个王子可以和一些喜欢公主结婚。公主没有限制。现在给出了一个 王子-公主 的完美匹配。\n\n现在问每个王子，可以和那些公主结婚，结婚后其他的王子仍然可以完美匹配。\n\n\n\n#### HDU4685:\n\n题意和上面一样，不过没给出初始的匹配，不保证完美匹配，公主和王子的数量也有可能不同。\n\n\n\n-------------------\n# 解题过程：\n\n一开始完全没思路，然后去翻了一堆的博客才看懂。\n\n\n\n--------------------\n# 题目分析：\n\n首先以王子和公主为点建图，对每个王子向他们喜欢的公主连一条有向边。\n\n然后进行二分图匹配，对一堆匹配的 王子-公主 从公主向王子建一条有向边。\n\n进行强连通缩点，每个王子对于属于同一强连通分量中喜欢的公主都可以选择。\n\n\n\n为什么这样就这样呢？可以类比网络流的退流或者匈牙利的思想，当一王子选择强连通里的非匹配的公主的话，那么这个公主的原配一定也可以选择另一个公主，并且一定可以经过若干次换妻 play 使得强连通分量内的所有王子都有匹配的公主，这里就不严格的证明了。\n\n\n\n对于第二个题，可能有一些王子或公主一开始就没有匹配，但是他按题意应该是可以选择一些公主或者王子并不影响其他人匹配的。\n\n这时候我们对没有匹配的公主增加一个虚拟的王子并匹配建边，并且这个王子喜欢所有的公主。对于没有匹配的王子新增一个虚拟的公主来匹配，并且这个公主被所有王子喜欢。\n\n为什么要喜欢所有的公主或者被所有王子喜欢，是为了让这个虚拟王子/公主有机会参加所有人的换妻 play 中，注意这里虚拟节点没必要和虚拟节点建边。\n\n\n\n----------------------\n# AC代码：\n\n\n\n####POJ1904：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 500000 + 10;\nconst int MAXN = 4000 + 10;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAXM];\n\nint head[MAXN], etot;\n\n\n//本题的算法复杂度是 O(N+M) 的，读入数据也是 O(N+M) 对总时间影响较大\n//用输入挂加速后由 9s 变成了 500ms\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nvoid Out(int a) {\n    if (a > 9)\n        Out(a / 10);\n    putchar(a % 10 + '0');\n}\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nint n;\n\nint pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;\nstack<int> S;\n\nvoid dfs(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n        } else if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid tarjan() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nvoid init() {\n    memset(head, -1, sizeof(head));\n    etot = 0;\n    n = Scan();\n    for (int u = 1; u <= n; u++) {\n        int k;\n        k = Scan();\n        while (k--) {\n            int v;\n            v = Scan();\n            add_edge(u, v + n);\n        }\n    }\n    for (int u = 1; u <= n; u++) {\n        int v;\n        v = Scan();\n        add_edge(v + n, u);\n    }\n}\n\nvoid solve() {\n    tarjan();\n\n    vector<int> data;\n    for (int u = 1; u <= n; u++) {\n        data.clear();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            //如果属于同一强连通分量，那么可以选择\n            if (mark[u] == mark[v]) data.push_back(v);\n        }\n        Out(data.size());\n        //对答案排序\n        sort(data.begin(), data.end());\n        for (int i = 0; i < data.size(); i++) {\n            putchar(' ');\n            Out(data[i] - n);\n        }\n        putchar('\\n');\n    }\n}\n\nint main() {\n    init();\n    solve();\n}\n```\n####HDU4685\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 500000 + 10;\nconst int MAXN = 4000 + 10;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAXM];\n\nint head[MAXN], etot;\nint n, m, Case, tot;\n\nint pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;\nstack<int> S;\n\nint matching[MAXN];\n\nint Scan() {\n    int res = 0, ch, flag = 0;\n    if ((ch = getchar()) == '-')\n        flag = 1;\n    else if (ch >= '0' && ch <= '9')\n        res = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9')\n        res = res * 10 + ch - '0';\n    return flag ? -res : res;\n}\n\nvoid Out(int a) {\n    if (a > 9)\n        Out(a / 10);\n    putchar(a % 10 + '0');\n}\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nvoid dfs(int u) {\n    low[u] = pre[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n        } else if (!mark[v]) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        scc_cnt++;\n        int x;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid tarjan() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    for (int i = 1; i <= tot; i++) {\n        if (!pre[i]) dfs(i);\n    }\n}\n\nbool find(int u) {\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (pre[v]) continue;\n        pre[v] = true;\n        if (matching[v] == -1 || find(matching[v])) {\n            matching[v] = u;\n            matching[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid match() {\n    memset(matching, -1, sizeof(matching));\n    for (int i = 1; i <= n; i++) {\n        memset(pre, 0, sizeof(pre));\n        find(i);\n    }\n}\n\nvoid init() {\n    memset(head, -1, sizeof(head));\n    etot = 0;\n    n = Scan();\n    m = Scan();\n    for (int u = 1; u <= n; u++) {\n        int k;\n        k = Scan();\n        while (k--) {\n            int v;\n            v = Scan();\n            add_edge(u, v + n);\n        }\n    }\n}\n\nvoid solve() {\n    match();\n\n    tot = n + m;\n    for (int i = 1; i <= n; i++) {\n        //如果当前节点未匹配\n        if (matching[i] == -1) {\n            //增加一个虚拟公主，并建边\n            ++tot;\n            add_edge(tot, i);\n            for (int j = 1; j <= n; j++) {\n                add_edge(j, tot);\n            }\n        } else {\n            //如果已匹配，建一条反向边\n            add_edge(matching[i], i);\n        }\n    }\n    for (int i = n + 1; i <= n + m; i++) {\n        //同理增加一个虚拟公主\n        if (matching[i] == -1) {\n            ++tot;\n            add_edge(i, tot);\n            for (int j = n + 1; j <= n + m; j++) {\n                add_edge(tot, j);\n            }\n        }\n    }\n\n    tarjan();\n\n    printf(\"Case #%d:\\n\", ++Case);\n    vector<int> data;\n    for (int u = 1; u <= n; u++) {\n        data.clear();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            //如果是虚拟节点就忽略\n            if (v > n + m) continue;\n            //如果和公主属于同一强连通分量，那么可以选择\n            if (mark[u] == mark[v]) data.push_back(v);\n        }\n        Out(data.size());\n        sort(data.begin(), data.end());\n        for (int i = 0; i < data.size(); i++) {\n            putchar(' ');\n            Out(data[i] - n);\n        }\n        putchar('\\n');\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n        solve();\n    }\n}\n```\n\n","slug":"POJ1904-King-s-Quest-HDU4685-Prince-and-Princess（强连通-二分图匹配）","published":1,"updated":"2017-08-19T02:50:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nci003ay9idyznp4nsy","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=1904\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1904</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4685\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4685</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><h4 id=\"POJ1904：\"><a href=\"#POJ1904：\" class=\"headerlink\" title=\"POJ1904：\"></a>POJ1904：</h4><p>一个国王有 N 个儿子，并且有 N 个公主，每个王子可以和一些喜欢公主结婚。公主没有限制。现在给出了一个 王子-公主 的完美匹配。</p>\n<p>现在问每个王子，可以和那些公主结婚，结婚后其他的王子仍然可以完美匹配。</p>\n<h4 id=\"HDU4685\"><a href=\"#HDU4685\" class=\"headerlink\" title=\"HDU4685:\"></a>HDU4685:</h4><p>题意和上面一样，不过没给出初始的匹配，不保证完美匹配，公主和王子的数量也有可能不同。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>一开始完全没思路，然后去翻了一堆的博客才看懂。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先以王子和公主为点建图，对每个王子向他们喜欢的公主连一条有向边。</p>\n<p>然后进行二分图匹配，对一堆匹配的 王子-公主 从公主向王子建一条有向边。</p>\n<p>进行强连通缩点，每个王子对于属于同一强连通分量中喜欢的公主都可以选择。</p>\n<p>为什么这样就这样呢？可以类比网络流的退流或者匈牙利的思想，当一王子选择强连通里的非匹配的公主的话，那么这个公主的原配一定也可以选择另一个公主，并且一定可以经过若干次换妻 play 使得强连通分量内的所有王子都有匹配的公主，这里就不严格的证明了。</p>\n<p>对于第二个题，可能有一些王子或公主一开始就没有匹配，但是他按题意应该是可以选择一些公主或者王子并不影响其他人匹配的。</p>\n<p>这时候我们对没有匹配的公主增加一个虚拟的王子并匹配建边，并且这个王子喜欢所有的公主。对于没有匹配的王子新增一个虚拟的公主来匹配，并且这个公主被所有王子喜欢。</p>\n<p>为什么要喜欢所有的公主或者被所有王子喜欢，是为了让这个虚拟王子/公主有机会参加所有人的换妻 play 中，注意这里虚拟节点没必要和虚拟节点建边。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><p>####POJ1904：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXM = <span class=\"number\">500000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">4000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAXM];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN], etot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//本题的算法复杂度是 O(N+M) 的，读入数据也是 O(N+M) 对总时间影响较大</span></div><div class=\"line\"><span class=\"comment\">//用输入挂加速后由 9s 变成了 500ms</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Out</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">9</span>)</div><div class=\"line\">        Out(a / <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(a % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    etot = <span class=\"number\">0</span>;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        k = Scan();</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v;</div><div class=\"line\">            v = Scan();</div><div class=\"line\">            add_edge(u, v + n);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v;</div><div class=\"line\">        v = Scan();</div><div class=\"line\">        add_edge(v + n, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    tarjan();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"comment\">//如果属于同一强连通分量，那么可以选择</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] == mark[v]) data.push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Out(data.size());</div><div class=\"line\">        <span class=\"comment\">//对答案排序</span></div><div class=\"line\">        sort(data.begin(), data.end());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            Out(data[i] - n);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    solve();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>####HDU4685</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXM = <span class=\"number\">500000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">4000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAXM];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, Case, tot;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> matching[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Out</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">9</span>)</div><div class=\"line\">        Out(a / <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(a % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= tot; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pre[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        pre[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || find(matching[v])) &#123;</div><div class=\"line\">            matching[v] = u;</div><div class=\"line\">            matching[u] = v;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">match</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">        find(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    etot = <span class=\"number\">0</span>;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    m = Scan();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        k = Scan();</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v;</div><div class=\"line\">            v = Scan();</div><div class=\"line\">            add_edge(u, v + n);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    match();</div><div class=\"line\"></div><div class=\"line\">    tot = n + m;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果当前节点未匹配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//增加一个虚拟公主，并建边</span></div><div class=\"line\">            ++tot;</div><div class=\"line\">            add_edge(tot, i);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                add_edge(j, tot);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//如果已匹配，建一条反向边</span></div><div class=\"line\">            add_edge(matching[i], i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n + <span class=\"number\">1</span>; i &lt;= n + m; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//同理增加一个虚拟公主</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            ++tot;</div><div class=\"line\">            add_edge(i, tot);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n + <span class=\"number\">1</span>; j &lt;= n + m; j++) &#123;</div><div class=\"line\">                add_edge(tot, j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    tarjan();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++Case);</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"comment\">//如果是虚拟节点就忽略</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (v &gt; n + m) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"comment\">//如果和公主属于同一强连通分量，那么可以选择</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] == mark[v]) data.push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Out(data.size());</div><div class=\"line\">        sort(data.begin(), data.end());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            Out(data[i] - n);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=1904\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1904</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4685\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=4685</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><h4 id=\"POJ1904：\"><a href=\"#POJ1904：\" class=\"headerlink\" title=\"POJ1904：\"></a>POJ1904：</h4><p>一个国王有 N 个儿子，并且有 N 个公主，每个王子可以和一些喜欢公主结婚。公主没有限制。现在给出了一个 王子-公主 的完美匹配。</p>\n<p>现在问每个王子，可以和那些公主结婚，结婚后其他的王子仍然可以完美匹配。</p>\n<h4 id=\"HDU4685\"><a href=\"#HDU4685\" class=\"headerlink\" title=\"HDU4685:\"></a>HDU4685:</h4><p>题意和上面一样，不过没给出初始的匹配，不保证完美匹配，公主和王子的数量也有可能不同。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>一开始完全没思路，然后去翻了一堆的博客才看懂。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先以王子和公主为点建图，对每个王子向他们喜欢的公主连一条有向边。</p>\n<p>然后进行二分图匹配，对一堆匹配的 王子-公主 从公主向王子建一条有向边。</p>\n<p>进行强连通缩点，每个王子对于属于同一强连通分量中喜欢的公主都可以选择。</p>\n<p>为什么这样就这样呢？可以类比网络流的退流或者匈牙利的思想，当一王子选择强连通里的非匹配的公主的话，那么这个公主的原配一定也可以选择另一个公主，并且一定可以经过若干次换妻 play 使得强连通分量内的所有王子都有匹配的公主，这里就不严格的证明了。</p>\n<p>对于第二个题，可能有一些王子或公主一开始就没有匹配，但是他按题意应该是可以选择一些公主或者王子并不影响其他人匹配的。</p>\n<p>这时候我们对没有匹配的公主增加一个虚拟的王子并匹配建边，并且这个王子喜欢所有的公主。对于没有匹配的王子新增一个虚拟的公主来匹配，并且这个公主被所有王子喜欢。</p>\n<p>为什么要喜欢所有的公主或者被所有王子喜欢，是为了让这个虚拟王子/公主有机会参加所有人的换妻 play 中，注意这里虚拟节点没必要和虚拟节点建边。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><p>####POJ1904：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXM = <span class=\"number\">500000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">4000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAXM];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN], etot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//本题的算法复杂度是 O(N+M) 的，读入数据也是 O(N+M) 对总时间影响较大</span></div><div class=\"line\"><span class=\"comment\">//用输入挂加速后由 9s 变成了 500ms</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Out</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">9</span>)</div><div class=\"line\">        Out(a / <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(a % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    etot = <span class=\"number\">0</span>;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        k = Scan();</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v;</div><div class=\"line\">            v = Scan();</div><div class=\"line\">            add_edge(u, v + n);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v;</div><div class=\"line\">        v = Scan();</div><div class=\"line\">        add_edge(v + n, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    tarjan();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"comment\">//如果属于同一强连通分量，那么可以选择</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] == mark[v]) data.push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Out(data.size());</div><div class=\"line\">        <span class=\"comment\">//对答案排序</span></div><div class=\"line\">        sort(data.begin(), data.end());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            Out(data[i] - n);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    init();</div><div class=\"line\">    solve();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>####HDU4685</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXM = <span class=\"number\">500000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">4000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAXM];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, Case, tot;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAXN], low[MAXN], mark[MAXN], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> matching[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Scan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, ch, flag = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((ch = getchar()) == <span class=\"string\">'-'</span>)</div><div class=\"line\">        flag = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((ch = getchar()) &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>)</div><div class=\"line\">        res = res * <span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag ? -res : res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Out</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; <span class=\"number\">9</span>)</div><div class=\"line\">        Out(a / <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(a % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    low[u] = pre[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mark[v]) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= tot; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pre[v]) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        pre[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[v] == <span class=\"number\">-1</span> || find(matching[v])) &#123;</div><div class=\"line\">            matching[v] = u;</div><div class=\"line\">            matching[u] = v;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">match</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(matching, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(matching));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">        find(i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    etot = <span class=\"number\">0</span>;</div><div class=\"line\">    n = Scan();</div><div class=\"line\">    m = Scan();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        k = Scan();</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v;</div><div class=\"line\">            v = Scan();</div><div class=\"line\">            add_edge(u, v + n);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    match();</div><div class=\"line\"></div><div class=\"line\">    tot = n + m;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果当前节点未匹配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//增加一个虚拟公主，并建边</span></div><div class=\"line\">            ++tot;</div><div class=\"line\">            add_edge(tot, i);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                add_edge(j, tot);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//如果已匹配，建一条反向边</span></div><div class=\"line\">            add_edge(matching[i], i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n + <span class=\"number\">1</span>; i &lt;= n + m; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//同理增加一个虚拟公主</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (matching[i] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">            ++tot;</div><div class=\"line\">            add_edge(i, tot);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n + <span class=\"number\">1</span>; j &lt;= n + m; j++) &#123;</div><div class=\"line\">                add_edge(tot, j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    tarjan();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d:\\n\"</span>, ++Case);</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = <span class=\"number\">1</span>; u &lt;= n; u++) &#123;</div><div class=\"line\">        data.clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"comment\">//如果是虚拟节点就忽略</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (v &gt; n + m) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"comment\">//如果和公主属于同一强连通分量，那么可以选择</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mark[u] == mark[v]) data.push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Out(data.size());</div><div class=\"line\">        sort(data.begin(), data.end());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            Out(data[i] - n);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"POJ1182 - 食物链（带权并查集）","date":"2017-05-13T02:25:41.000Z","_content":"# 题目链接：\n http://poj.org/problem?id=1182\n\n----------------\n\n# 题目大意：\n动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 \n现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 \n有人用两种说法对这N个动物所构成的食物链关系进行描述： \n第一种说法是\"1 X Y\"，表示X和Y是同类。 \n第二种说法是\"2 X Y\"，表示X吃Y。 \n此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 \n1）\t当前的话与前面的某些真的话冲突，就是假话； \n2）\t当前的话中X或Y比N大，就是假话； \n3）\t当前的话表示X吃X，就是假话。 \n你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。 \n\n-------------------------\n\n# 解题过程：\n 这题主要是看的书和博客，之前没接触过带权并查集。\n\n------------------\n# 题目分析：\n\n 这题用两种做法做了下，一种是挑战程序设计竞赛中的，另一种是搜的博客上面的。\n\n 首先说下简单粗暴的第一种方法：\n### 一：\n![这里写图片描述](http://img.blog.csdn.net/20170513100611130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 二：\n\n 对于每个节点有一个 Rank数组表示权值，这里引用两个blog好了：\n http://blog.csdn.net/qq_24451605/article/details/46876121\n http://blog.csdn.net/c0de4fun/article/details/7318642/\n\n------------------------\n\n# AC代码一：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nconst int MAX = 1123456;\n\nint N, K;\n\nint f[MAX];\n\nint root(int t) {\n    if (f[t] == t)\n        return t;\n    else\n        return f[t] = root(f[t]);\n}\n\nint connect(int a, int b) {\n    int fa = root(a);\n    int fb = root(b);\n    f[fa] = fb;\n}\n\nint same(int a, int b) {\n    return root(a) == root(b);\n}\n\nvoid init() {\n    for (int i = 0; i <= N*3; i++)\n        f[i] = i;\n}\n\n\nint main() {\n    int ans = 0;\n    scanf(\"%d %d\", &N, &K);\n    init();\n    for (int i = 0; i < K; i++) {\n        int D, X, Y;\n        scanf(\"%d %d %d\", &D, &X, &Y);\n        if (X > N || X < 1 || Y < 1 || Y > N) {\n            ans++;\n            continue;\n        }\n        else if (D == 1) {\n            if (same(X, Y+N) || same(X, Y+N*2)) {\n                ans++;\n                continue;\n            }\n            connect(X, Y);\n            connect(X+N, Y+N);\n            connect(X+N*2, Y+N*2);\n        }\n        else {\n            if (same(X, Y) || same(X, Y+N*2)) {\n                ans++;\n                continue;\n            }\n            connect(X, Y+N);\n            connect(X+N, Y+N*2);\n            connect(X+N*2, Y);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n```\n-------------------------------\n\n# AC代码二：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint ran[MAX], f[MAX];\nint N, K;\n\n\nvoid init() {\n    for (int i = 0; i <= N; i++)\n        f[i] = i, ran[i] = 0;\n}\n\nint root(int x) {\n    if (x == f[x])\n        return x;\n    int temp = f[x];\n    f[x] = root(f[x]);\n    ran[x] = (ran[x] + ran[temp])%3;\n    return f[x];\n}\n\nvoid connect(int a, int b, int type) {\n    int fa = root(a);\n    int fb = root(b);\n    if (fa == fb)\n        return;\n    f[fa] = fb;\n    ran[fa] = (type+ran[b]-ran[a]+3)%3;\n}\n\nbool check(int a, int b, int type) {\n    if (a > N || b > N)\n        return false;\n    if (type == 1 && a == b)\n        return false;\n    if (root(a) == root(b))\n        return (ran[a]-ran[b]+3)%3 == type;\n    else\n        return true;\n}\n\nint main() {\n    int ans = 0;\n    scanf(\"%d %d\", &N, &K);\n    init();\n    while (K--) {\n        int D, X, Y;\n        scanf(\"%d %d %d\", &D, &X, &Y);\n        D--;\n        if (check(X, Y, D))\n            connect(X, Y, D);\n        else\n            ans++;\n    }\n    printf(\"%d\\n\", ans);\n}\n```","source":"_posts/POJ1182-食物链（带权并查集）.md","raw":"---\ntitle: POJ1182 - 食物链（带权并查集）\ndate: 2017-05-13 10:25:41\ncategories: [ACM, 数据结构, 并查集]\ntags:\n---\n# 题目链接：\n http://poj.org/problem?id=1182\n\n----------------\n\n# 题目大意：\n动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 \n现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 \n有人用两种说法对这N个动物所构成的食物链关系进行描述： \n第一种说法是\"1 X Y\"，表示X和Y是同类。 \n第二种说法是\"2 X Y\"，表示X吃Y。 \n此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 \n1）\t当前的话与前面的某些真的话冲突，就是假话； \n2）\t当前的话中X或Y比N大，就是假话； \n3）\t当前的话表示X吃X，就是假话。 \n你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。 \n\n-------------------------\n\n# 解题过程：\n 这题主要是看的书和博客，之前没接触过带权并查集。\n\n------------------\n# 题目分析：\n\n 这题用两种做法做了下，一种是挑战程序设计竞赛中的，另一种是搜的博客上面的。\n\n 首先说下简单粗暴的第一种方法：\n### 一：\n![这里写图片描述](http://img.blog.csdn.net/20170513100611130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 二：\n\n 对于每个节点有一个 Rank数组表示权值，这里引用两个blog好了：\n http://blog.csdn.net/qq_24451605/article/details/46876121\n http://blog.csdn.net/c0de4fun/article/details/7318642/\n\n------------------------\n\n# AC代码一：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nconst int MAX = 1123456;\n\nint N, K;\n\nint f[MAX];\n\nint root(int t) {\n    if (f[t] == t)\n        return t;\n    else\n        return f[t] = root(f[t]);\n}\n\nint connect(int a, int b) {\n    int fa = root(a);\n    int fb = root(b);\n    f[fa] = fb;\n}\n\nint same(int a, int b) {\n    return root(a) == root(b);\n}\n\nvoid init() {\n    for (int i = 0; i <= N*3; i++)\n        f[i] = i;\n}\n\n\nint main() {\n    int ans = 0;\n    scanf(\"%d %d\", &N, &K);\n    init();\n    for (int i = 0; i < K; i++) {\n        int D, X, Y;\n        scanf(\"%d %d %d\", &D, &X, &Y);\n        if (X > N || X < 1 || Y < 1 || Y > N) {\n            ans++;\n            continue;\n        }\n        else if (D == 1) {\n            if (same(X, Y+N) || same(X, Y+N*2)) {\n                ans++;\n                continue;\n            }\n            connect(X, Y);\n            connect(X+N, Y+N);\n            connect(X+N*2, Y+N*2);\n        }\n        else {\n            if (same(X, Y) || same(X, Y+N*2)) {\n                ans++;\n                continue;\n            }\n            connect(X, Y+N);\n            connect(X+N, Y+N*2);\n            connect(X+N*2, Y);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n```\n-------------------------------\n\n# AC代码二：\n```cpp\n#include<cstdio>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint ran[MAX], f[MAX];\nint N, K;\n\n\nvoid init() {\n    for (int i = 0; i <= N; i++)\n        f[i] = i, ran[i] = 0;\n}\n\nint root(int x) {\n    if (x == f[x])\n        return x;\n    int temp = f[x];\n    f[x] = root(f[x]);\n    ran[x] = (ran[x] + ran[temp])%3;\n    return f[x];\n}\n\nvoid connect(int a, int b, int type) {\n    int fa = root(a);\n    int fb = root(b);\n    if (fa == fb)\n        return;\n    f[fa] = fb;\n    ran[fa] = (type+ran[b]-ran[a]+3)%3;\n}\n\nbool check(int a, int b, int type) {\n    if (a > N || b > N)\n        return false;\n    if (type == 1 && a == b)\n        return false;\n    if (root(a) == root(b))\n        return (ran[a]-ran[b]+3)%3 == type;\n    else\n        return true;\n}\n\nint main() {\n    int ans = 0;\n    scanf(\"%d %d\", &N, &K);\n    init();\n    while (K--) {\n        int D, X, Y;\n        scanf(\"%d %d %d\", &D, &X, &Y);\n        D--;\n        if (check(X, Y, D))\n            connect(X, Y, D);\n        else\n            ans++;\n    }\n    printf(\"%d\\n\", ans);\n}\n```","slug":"POJ1182-食物链（带权并查集）","published":1,"updated":"2017-07-23T02:33:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nck003cy9idbcx6nkh6","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p> <a href=\"http://poj.org/problem?id=1182\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1182</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 </p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这题主要是看的书和博客，之前没接触过带权并查集。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 这题用两种做法做了下，一种是挑战程序设计竞赛中的，另一种是搜的博客上面的。</p>\n<p> 首先说下简单粗暴的第一种方法：</p>\n<h3 id=\"一：\"><a href=\"#一：\" class=\"headerlink\" title=\"一：\"></a>一：</h3><p><img src=\"http://img.blog.csdn.net/20170513100611130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3 id=\"二：\"><a href=\"#二：\" class=\"headerlink\" title=\"二：\"></a>二：</h3><p> 对于每个节点有一个 Rank数组表示权值，这里引用两个blog好了：<br> <a href=\"http://blog.csdn.net/qq_24451605/article/details/46876121\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qq_24451605/article/details/46876121</a><br> <a href=\"http://blog.csdn.net/c0de4fun/article/details/7318642/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/c0de4fun/article/details/7318642/</a></p>\n<hr>\n<h1 id=\"AC代码一：\"><a href=\"#AC代码一：\" class=\"headerlink\" title=\"AC代码一：\"></a>AC代码一：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, K;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> f[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (f[t] == t)</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> f[t] = root(f[t]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = root(a);</div><div class=\"line\">    <span class=\"keyword\">int</span> fb = root(b);</div><div class=\"line\">    f[fa] = fb;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">same</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> root(a) == root(b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N*<span class=\"number\">3</span>; i++)</div><div class=\"line\">        f[i] = i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;K);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; K; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> D, X, Y;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;D, &amp;X, &amp;Y);</div><div class=\"line\">        <span class=\"keyword\">if</span> (X &gt; N || X &lt; <span class=\"number\">1</span> || Y &lt; <span class=\"number\">1</span> || Y &gt; N) &#123;</div><div class=\"line\">            ans++;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (D == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (same(X, Y+N) || same(X, Y+N*<span class=\"number\">2</span>)) &#123;</div><div class=\"line\">                ans++;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            connect(X, Y);</div><div class=\"line\">            connect(X+N, Y+N);</div><div class=\"line\">            connect(X+N*<span class=\"number\">2</span>, Y+N*<span class=\"number\">2</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (same(X, Y) || same(X, Y+N*<span class=\"number\">2</span>)) &#123;</div><div class=\"line\">                ans++;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            connect(X, Y+N);</div><div class=\"line\">            connect(X+N, Y+N*<span class=\"number\">2</span>);</div><div class=\"line\">            connect(X+N*<span class=\"number\">2</span>, Y);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码二：\"><a href=\"#AC代码二：\" class=\"headerlink\" title=\"AC代码二：\"></a>AC代码二：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> ran[MAX], f[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> N, K;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N; i++)</div><div class=\"line\">        f[i] = i, ran[i] = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x == f[x])</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp = f[x];</div><div class=\"line\">    f[x] = root(f[x]);</div><div class=\"line\">    ran[x] = (ran[x] + ran[temp])%<span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> f[x];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = root(a);</div><div class=\"line\">    <span class=\"keyword\">int</span> fb = root(b);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == fb)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    f[fa] = fb;</div><div class=\"line\">    ran[fa] = (type+ran[b]-ran[a]+<span class=\"number\">3</span>)%<span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; N || b &gt; N)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"number\">1</span> &amp;&amp; a == b)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root(a) == root(b))</div><div class=\"line\">        <span class=\"keyword\">return</span> (ran[a]-ran[b]+<span class=\"number\">3</span>)%<span class=\"number\">3</span> == type;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;K);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">while</span> (K--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> D, X, Y;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;D, &amp;X, &amp;Y);</div><div class=\"line\">        D--;</div><div class=\"line\">        <span class=\"keyword\">if</span> (check(X, Y, D))</div><div class=\"line\">            connect(X, Y, D);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p> <a href=\"http://poj.org/problem?id=1182\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1182</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 </p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这题主要是看的书和博客，之前没接触过带权并查集。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 这题用两种做法做了下，一种是挑战程序设计竞赛中的，另一种是搜的博客上面的。</p>\n<p> 首先说下简单粗暴的第一种方法：</p>\n<h3 id=\"一：\"><a href=\"#一：\" class=\"headerlink\" title=\"一：\"></a>一：</h3><p><img src=\"http://img.blog.csdn.net/20170513100611130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3 id=\"二：\"><a href=\"#二：\" class=\"headerlink\" title=\"二：\"></a>二：</h3><p> 对于每个节点有一个 Rank数组表示权值，这里引用两个blog好了：<br> <a href=\"http://blog.csdn.net/qq_24451605/article/details/46876121\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qq_24451605/article/details/46876121</a><br> <a href=\"http://blog.csdn.net/c0de4fun/article/details/7318642/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/c0de4fun/article/details/7318642/</a></p>\n<hr>\n<h1 id=\"AC代码一：\"><a href=\"#AC代码一：\" class=\"headerlink\" title=\"AC代码一：\"></a>AC代码一：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123456</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, K;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> f[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (f[t] == t)</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> f[t] = root(f[t]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = root(a);</div><div class=\"line\">    <span class=\"keyword\">int</span> fb = root(b);</div><div class=\"line\">    f[fa] = fb;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">same</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> root(a) == root(b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N*<span class=\"number\">3</span>; i++)</div><div class=\"line\">        f[i] = i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;K);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; K; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> D, X, Y;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;D, &amp;X, &amp;Y);</div><div class=\"line\">        <span class=\"keyword\">if</span> (X &gt; N || X &lt; <span class=\"number\">1</span> || Y &lt; <span class=\"number\">1</span> || Y &gt; N) &#123;</div><div class=\"line\">            ans++;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (D == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (same(X, Y+N) || same(X, Y+N*<span class=\"number\">2</span>)) &#123;</div><div class=\"line\">                ans++;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            connect(X, Y);</div><div class=\"line\">            connect(X+N, Y+N);</div><div class=\"line\">            connect(X+N*<span class=\"number\">2</span>, Y+N*<span class=\"number\">2</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (same(X, Y) || same(X, Y+N*<span class=\"number\">2</span>)) &#123;</div><div class=\"line\">                ans++;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            connect(X, Y+N);</div><div class=\"line\">            connect(X+N, Y+N*<span class=\"number\">2</span>);</div><div class=\"line\">            connect(X+N*<span class=\"number\">2</span>, Y);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码二：\"><a href=\"#AC代码二：\" class=\"headerlink\" title=\"AC代码二：\"></a>AC代码二：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> ran[MAX], f[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> N, K;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N; i++)</div><div class=\"line\">        f[i] = i, ran[i] = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x == f[x])</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp = f[x];</div><div class=\"line\">    f[x] = root(f[x]);</div><div class=\"line\">    ran[x] = (ran[x] + ran[temp])%<span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> f[x];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fa = root(a);</div><div class=\"line\">    <span class=\"keyword\">int</span> fb = root(b);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fa == fb)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    f[fa] = fb;</div><div class=\"line\">    ran[fa] = (type+ran[b]-ran[a]+<span class=\"number\">3</span>)%<span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (a &gt; N || b &gt; N)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"number\">1</span> &amp;&amp; a == b)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (root(a) == root(b))</div><div class=\"line\">        <span class=\"keyword\">return</span> (ran[a]-ran[b]+<span class=\"number\">3</span>)%<span class=\"number\">3</span> == type;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;K);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">while</span> (K--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> D, X, Y;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;D, &amp;X, &amp;Y);</div><div class=\"line\">        D--;</div><div class=\"line\">        <span class=\"keyword\">if</span> (check(X, Y, D))</div><div class=\"line\">            connect(X, Y, D);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            ans++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ2155 - Matrix （二维树状数组）","date":"2017-04-09T09:00:47.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=2155\n\n----------------------\n# 题目大意：\n 给定一个矩阵，初始化为0，现在可以进行两种操作，一种是查询某个点的值是 0 还是 1。另一种是让这个矩阵的一个子矩阵内的值取反。\n\n-----------------------------\n# 解题过程：\n 省赛选拔赛的题，太难了直接没看………\n 后来补起来，有模板还是挺容易的。\n\n------------------------------\n# 题目分析：\n+ 首先这题虽然看起来像是一个区间修改，单点查询的题，但是可以转化成单点修改，查询区间和。\n\t+   首先考虑一维的情况，我要一段区间取反，假设是 [l, r]。那么我只需要`book[l]+1`，`book[r+1]+1`，假设查询 k 的时候，只需要查询前 k 的和 mod 2 的结果即可。\n\t+ 然后这种方法可以推广到二维，不过这里要用一下容斥原理。假设修改的子矩阵左上角和右下角分别为 x1 y1 x2 y2，首先`book[x1][y1]+1`, `book[x2][y2]+1`，不过这时要 `book[x1][y2+1]+1`, `book[x2+1][y1]+1`。\n\t\n\t+ ![这里写图片描述](http://img.blog.csdn.net/20170409165447611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t\n\t+ 这里红色的就是上面需要标记的点，标记后表示以这个点为左下角的子矩阵内的点全部取反一次。这里绿色代表取反一次，紫色是取反了两次，黄色是取反了四次。最后实际进行取反操作的就是要求取反的子矩阵内的点。\n+ 注意这里的前缀和用二位树状数组维护，进行单点更新，单点查询。\n\n# AC代码：\n```cpp\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int MAX = 1123;\nint data[MAX][MAX], n;\n\nint lowbit(int x) {\n    return x&-x;\n}\n\nvoid Add(int x, int y, int w) {\n    for (int i = x; i <= n; i += lowbit(i)) {\n        for (int j = y; j <= n; j += lowbit(j)) {\n            data[i][j] += w;\n        }\n    }\n}\n\nint Sum(int x, int y) {\n    int ans = 0;\n    for (int i = x; i > 0; i -= lowbit(i)) {\n        for (int j = y; j > 0; j -= lowbit(j)) {\n            ans += data[i][j];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    char str[10];\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int k;\n        scanf(\"%d %d\", &n, &k);\n        memset(data, 0, sizeof(data));\n        while (k--) {\n            scanf(\" %s\", str);\n            if (str[0] == 'C') {\n                int x1, x2, y1, y2;\n                scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n                Add(x1, y1, 1);\n                Add(x2+1, y1, 1);\n                Add(x1, y2+1, 1);\n                Add(x2+1, y2+1, 1);\n            }\n            else {\n                int x, y;\n                scanf(\"%d %d\", &x, &y);\n                printf(\"%d\\n\", Sum(x, y)%2);\n            }\n        }\n        if (T)\n            printf(\"\\n\");\n    }\n}\n```\n","source":"_posts/POJ2155-Matrix-（二维树状数组）.md","raw":"---\ntitle: POJ2155 - Matrix （二维树状数组）\ndate: 2017-04-09 17:00:47\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=2155\n\n----------------------\n# 题目大意：\n 给定一个矩阵，初始化为0，现在可以进行两种操作，一种是查询某个点的值是 0 还是 1。另一种是让这个矩阵的一个子矩阵内的值取反。\n\n-----------------------------\n# 解题过程：\n 省赛选拔赛的题，太难了直接没看………\n 后来补起来，有模板还是挺容易的。\n\n------------------------------\n# 题目分析：\n+ 首先这题虽然看起来像是一个区间修改，单点查询的题，但是可以转化成单点修改，查询区间和。\n\t+   首先考虑一维的情况，我要一段区间取反，假设是 [l, r]。那么我只需要`book[l]+1`，`book[r+1]+1`，假设查询 k 的时候，只需要查询前 k 的和 mod 2 的结果即可。\n\t+ 然后这种方法可以推广到二维，不过这里要用一下容斥原理。假设修改的子矩阵左上角和右下角分别为 x1 y1 x2 y2，首先`book[x1][y1]+1`, `book[x2][y2]+1`，不过这时要 `book[x1][y2+1]+1`, `book[x2+1][y1]+1`。\n\t\n\t+ ![这里写图片描述](http://img.blog.csdn.net/20170409165447611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t\n\t+ 这里红色的就是上面需要标记的点，标记后表示以这个点为左下角的子矩阵内的点全部取反一次。这里绿色代表取反一次，紫色是取反了两次，黄色是取反了四次。最后实际进行取反操作的就是要求取反的子矩阵内的点。\n+ 注意这里的前缀和用二位树状数组维护，进行单点更新，单点查询。\n\n# AC代码：\n```cpp\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int MAX = 1123;\nint data[MAX][MAX], n;\n\nint lowbit(int x) {\n    return x&-x;\n}\n\nvoid Add(int x, int y, int w) {\n    for (int i = x; i <= n; i += lowbit(i)) {\n        for (int j = y; j <= n; j += lowbit(j)) {\n            data[i][j] += w;\n        }\n    }\n}\n\nint Sum(int x, int y) {\n    int ans = 0;\n    for (int i = x; i > 0; i -= lowbit(i)) {\n        for (int j = y; j > 0; j -= lowbit(j)) {\n            ans += data[i][j];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    char str[10];\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int k;\n        scanf(\"%d %d\", &n, &k);\n        memset(data, 0, sizeof(data));\n        while (k--) {\n            scanf(\" %s\", str);\n            if (str[0] == 'C') {\n                int x1, x2, y1, y2;\n                scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n                Add(x1, y1, 1);\n                Add(x2+1, y1, 1);\n                Add(x1, y2+1, 1);\n                Add(x2+1, y2+1, 1);\n            }\n            else {\n                int x, y;\n                scanf(\"%d %d\", &x, &y);\n                printf(\"%d\\n\", Sum(x, y)%2);\n            }\n        }\n        if (T)\n            printf(\"\\n\");\n    }\n}\n```\n","slug":"POJ2155-Matrix-（二维树状数组）","published":1,"updated":"2017-07-23T02:41:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncn003ey9idbzsitk7a","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2155\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2155</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给定一个矩阵，初始化为0，现在可以进行两种操作，一种是查询某个点的值是 0 还是 1。另一种是让这个矩阵的一个子矩阵内的值取反。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 省赛选拔赛的题，太难了直接没看………<br> 后来补起来，有模板还是挺容易的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li><p>首先这题虽然看起来像是一个区间修改，单点查询的题，但是可以转化成单点修改，查询区间和。</p>\n<ul>\n<li>首先考虑一维的情况，我要一段区间取反，假设是 [l, r]。那么我只需要<code>book[l]+1</code>，<code>book[r+1]+1</code>，假设查询 k 的时候，只需要查询前 k 的和 mod 2 的结果即可。</li>\n<li><p>然后这种方法可以推广到二维，不过这里要用一下容斥原理。假设修改的子矩阵左上角和右下角分别为 x1 y1 x2 y2，首先<code>book[x1][y1]+1</code>, <code>book[x2][y2]+1</code>，不过这时要 <code>book[x1][y2+1]+1</code>, <code>book[x2+1][y1]+1</code>。</p>\n</li>\n<li><p><img src=\"http://img.blog.csdn.net/20170409165447611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p>这里红色的就是上面需要标记的点，标记后表示以这个点为左下角的子矩阵内的点全部取反一次。这里绿色代表取反一次，紫色是取反了两次，黄色是取反了四次。最后实际进行取反操作的就是要求取反的子矩阵内的点。</p>\n</li>\n</ul>\n</li>\n<li>注意这里的前缀和用二位树状数组维护，进行单点更新，单点查询。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x&amp;-x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = y; j &lt;= n; j += lowbit(j)) &#123;</div><div class=\"line\">            data[i][j] += w;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = x; i &gt; <span class=\"number\">0</span>; i -= lowbit(i)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = y; j &gt; <span class=\"number\">0</span>; j -= lowbit(j)) &#123;</div><div class=\"line\">            ans += data[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;k);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %s\"</span>, str);</div><div class=\"line\">            <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> x1, x2, y1, y2;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</div><div class=\"line\">                Add(x1, y1, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x2+<span class=\"number\">1</span>, y1, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x1, y2+<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x2+<span class=\"number\">1</span>, y2+<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, Sum(x, y)%<span class=\"number\">2</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (T)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2155\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2155</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给定一个矩阵，初始化为0，现在可以进行两种操作，一种是查询某个点的值是 0 还是 1。另一种是让这个矩阵的一个子矩阵内的值取反。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 省赛选拔赛的题，太难了直接没看………<br> 后来补起来，有模板还是挺容易的。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li><p>首先这题虽然看起来像是一个区间修改，单点查询的题，但是可以转化成单点修改，查询区间和。</p>\n<ul>\n<li>首先考虑一维的情况，我要一段区间取反，假设是 [l, r]。那么我只需要<code>book[l]+1</code>，<code>book[r+1]+1</code>，假设查询 k 的时候，只需要查询前 k 的和 mod 2 的结果即可。</li>\n<li><p>然后这种方法可以推广到二维，不过这里要用一下容斥原理。假设修改的子矩阵左上角和右下角分别为 x1 y1 x2 y2，首先<code>book[x1][y1]+1</code>, <code>book[x2][y2]+1</code>，不过这时要 <code>book[x1][y2+1]+1</code>, <code>book[x2+1][y1]+1</code>。</p>\n</li>\n<li><p><img src=\"http://img.blog.csdn.net/20170409165447611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p>这里红色的就是上面需要标记的点，标记后表示以这个点为左下角的子矩阵内的点全部取反一次。这里绿色代表取反一次，紫色是取反了两次，黄色是取反了四次。最后实际进行取反操作的就是要求取反的子矩阵内的点。</p>\n</li>\n</ul>\n</li>\n<li>注意这里的前缀和用二位树状数组维护，进行单点更新，单点查询。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], n;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x&amp;-x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = y; j &lt;= n; j += lowbit(j)) &#123;</div><div class=\"line\">            data[i][j] += w;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = x; i &gt; <span class=\"number\">0</span>; i -= lowbit(i)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = y; j &gt; <span class=\"number\">0</span>; j -= lowbit(j)) &#123;</div><div class=\"line\">            ans += data[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;k);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %s\"</span>, str);</div><div class=\"line\">            <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> x1, x2, y1, y2;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</div><div class=\"line\">                Add(x1, y1, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x2+<span class=\"number\">1</span>, y1, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x1, y2+<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">                Add(x2+<span class=\"number\">1</span>, y2+<span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;x, &amp;y);</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, Sum(x, y)%<span class=\"number\">2</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (T)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"POJ2135 - Farm Tour（最小费用流 + 模板 + SPFA + Dijstra）","date":"2017-05-22T06:58:41.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=2135\n\n\n--------------------------\n# 题目大意：\n\n 现在有 N 个节点，有M条边，要从 1 走到 N 然后再回到 1 。要求走的边不能重复，求最短路径。\n\n----------------------------------\n# 解题过程：\n\n之前看了最小费用最大流然后一直没有做题，于是找了一个模板题来刷，对着板子敲上去居然一次AC，然后又改了下最短路的算法，AC。\n\n\n-------------------------\n# 题目分析：\n\n 算是一个隐含的最小费用最大流，设每条边的容量为1，花费为路径长度。那么所求的就是一个从起点 1 到终点 N 流量为 2 的流的最小费用流。\n\n这里用的是最短增广路算法。\n\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 1123, INF = 0x3f3f3f3f;\nint N, M;\n\nstruct Node{\n    int to, cap, cost, rev;\n    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<Node> edge[MAX];\nint dist[MAX], vis[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    edge[from].push_back(Node(to, cap, cost, edge[to].size()));\n    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int rst = 0;\n    //循环到到达了f流量\n    while (f > 0) {\n        memset(dist, INF, sizeof(dist));\n        queue<int> q;\n        q.push(s);\n        vis[s] = 1;\n        dist[s] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                Node& e = edge[u][i];\n                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost) {\n                    dist[e.to] = dist[u] + e.cost;\n                    prevv[e.to] = u;\n                    preve[e.to] = i;\n                    if (!vis[e.to]) {\n                        q.push(e.to);\n                        vis[e.to] = 1;\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = 0;\n        }\n        if (dist[t] == INF) return -1;\n\n        //最路径上最小流量\n        int d = f;\n        for (int u = t; u != s; u = prevv[u]) {\n            d = min(d, edge[prevv[u]][preve[u]].cap);\n        }\n        //剩余的流量\n        f -= d;\n        //计算费用\n        rst += d * dist[t];\n        //修改路上所经过的边的容量\n        for (int u = t; u != s; u = prevv[u]) {\n            Node& e = edge[prevv[u]][preve[u]];\n            e.cap -= d;\n            edge[u][e.rev].cap += d;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int from, to, cost;\n        scanf(\"%d %d %d\", &from, &to, &cost);\n        add_edge(from, to, 1, cost);\n        add_edge(to, from, 1, cost);\n    }\n    //求流量为2的最小费用\n    int ans = min_cost_flow(1, N, 2);\n    printf(\"%d\\n\", ans);\n}\n```\n\n#居然可以AC的Dijstra代码：\n```\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 1123, INF = 0x3f3f3f3f;\nint N, M;\n\nstruct Node{\n    int to, cap, cost, rev;\n    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<Node> edge[MAX];\nint dist[MAX], vis[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    edge[from].push_back(Node(to, cap, cost, edge[to].size()));\n    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int rst = 0;\n    while (f > 0) {\n        memset(dist, INF, sizeof(dist));\n        queue<int> q;\n        q.push(s);\n        vis[s] = 1;\n        dist[s] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                Node& e = edge[u][i];\n                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost) {\n                    dist[e.to] = dist[u] + e.cost;\n                    prevv[e.to] = u;\n                    preve[e.to] = i;\n                    if (!vis[e.to]) {\n                        q.push(e.to);\n                        vis[e.to] = 1;\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = 0;\n        }\n        if (dist[t] == INF) return -1;\n\n        int d = f;\n        for (int u = t; u != s; u = prevv[u]) {\n            d = min(d, edge[prevv[u]][preve[u]].cap);\n        }\n        f -= d;\n        rst += d * dist[t];\n        for (int u = t; u != s; u = prevv[u]) {\n            Node& e = edge[prevv[u]][preve[u]];\n            e.cap -= d;\n            edge[u][e.rev].cap += d;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int from, to, cost;\n        scanf(\"%d %d %d\", &from, &to, &cost);\n        add_edge(from, to, 1, cost);\n        add_edge(to, from, 1, cost);\n    }\n    int ans = min_cost_flow(1, N, 2);\n    printf(\"%d\\n\", ans);\n}\n```","source":"_posts/POJ2135-Farm-Tour（最小费用流-模板-SPFA-Dijstra）.md","raw":"---\ntitle: POJ2135 - Farm Tour（最小费用流 + 模板 + SPFA + Dijstra）\ndate: 2017-05-22 14:58:41\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=2135\n\n\n--------------------------\n# 题目大意：\n\n 现在有 N 个节点，有M条边，要从 1 走到 N 然后再回到 1 。要求走的边不能重复，求最短路径。\n\n----------------------------------\n# 解题过程：\n\n之前看了最小费用最大流然后一直没有做题，于是找了一个模板题来刷，对着板子敲上去居然一次AC，然后又改了下最短路的算法，AC。\n\n\n-------------------------\n# 题目分析：\n\n 算是一个隐含的最小费用最大流，设每条边的容量为1，花费为路径长度。那么所求的就是一个从起点 1 到终点 N 流量为 2 的流的最小费用流。\n\n这里用的是最短增广路算法。\n\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 1123, INF = 0x3f3f3f3f;\nint N, M;\n\nstruct Node{\n    int to, cap, cost, rev;\n    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<Node> edge[MAX];\nint dist[MAX], vis[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    edge[from].push_back(Node(to, cap, cost, edge[to].size()));\n    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int rst = 0;\n    //循环到到达了f流量\n    while (f > 0) {\n        memset(dist, INF, sizeof(dist));\n        queue<int> q;\n        q.push(s);\n        vis[s] = 1;\n        dist[s] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                Node& e = edge[u][i];\n                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost) {\n                    dist[e.to] = dist[u] + e.cost;\n                    prevv[e.to] = u;\n                    preve[e.to] = i;\n                    if (!vis[e.to]) {\n                        q.push(e.to);\n                        vis[e.to] = 1;\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = 0;\n        }\n        if (dist[t] == INF) return -1;\n\n        //最路径上最小流量\n        int d = f;\n        for (int u = t; u != s; u = prevv[u]) {\n            d = min(d, edge[prevv[u]][preve[u]].cap);\n        }\n        //剩余的流量\n        f -= d;\n        //计算费用\n        rst += d * dist[t];\n        //修改路上所经过的边的容量\n        for (int u = t; u != s; u = prevv[u]) {\n            Node& e = edge[prevv[u]][preve[u]];\n            e.cap -= d;\n            edge[u][e.rev].cap += d;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int from, to, cost;\n        scanf(\"%d %d %d\", &from, &to, &cost);\n        add_edge(from, to, 1, cost);\n        add_edge(to, from, 1, cost);\n    }\n    //求流量为2的最小费用\n    int ans = min_cost_flow(1, N, 2);\n    printf(\"%d\\n\", ans);\n}\n```\n\n#居然可以AC的Dijstra代码：\n```\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 1123, INF = 0x3f3f3f3f;\nint N, M;\n\nstruct Node{\n    int to, cap, cost, rev;\n    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<Node> edge[MAX];\nint dist[MAX], vis[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    edge[from].push_back(Node(to, cap, cost, edge[to].size()));\n    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int rst = 0;\n    while (f > 0) {\n        memset(dist, INF, sizeof(dist));\n        queue<int> q;\n        q.push(s);\n        vis[s] = 1;\n        dist[s] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                Node& e = edge[u][i];\n                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost) {\n                    dist[e.to] = dist[u] + e.cost;\n                    prevv[e.to] = u;\n                    preve[e.to] = i;\n                    if (!vis[e.to]) {\n                        q.push(e.to);\n                        vis[e.to] = 1;\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = 0;\n        }\n        if (dist[t] == INF) return -1;\n\n        int d = f;\n        for (int u = t; u != s; u = prevv[u]) {\n            d = min(d, edge[prevv[u]][preve[u]].cap);\n        }\n        f -= d;\n        rst += d * dist[t];\n        for (int u = t; u != s; u = prevv[u]) {\n            Node& e = edge[prevv[u]][preve[u]];\n            e.cap -= d;\n            edge[u][e.rev].cap += d;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int from, to, cost;\n        scanf(\"%d %d %d\", &from, &to, &cost);\n        add_edge(from, to, 1, cost);\n        add_edge(to, from, 1, cost);\n    }\n    int ans = min_cost_flow(1, N, 2);\n    printf(\"%d\\n\", ans);\n}\n```","slug":"POJ2135-Farm-Tour（最小费用流-模板-SPFA-Dijstra）","published":1,"updated":"2017-07-23T02:26:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncp003hy9idytetiobz","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2135\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2135</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有 N 个节点，有M条边，要从 1 走到 N 然后再回到 1 。要求走的边不能重复，求最短路径。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前看了最小费用最大流然后一直没有做题，于是找了一个模板题来刷，对着板子敲上去居然一次AC，然后又改了下最短路的算法，AC。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 算是一个隐含的最小费用最大流，设每条边的容量为1，花费为路径长度。那么所求的就是一个从起点 1 到终点 N 流量为 2 的流的最小费用流。</p>\n<p>这里用的是最短增广路算法。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> N, M;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, cap, cost, rev;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> cost, <span class=\"keyword\">int</span> rev):to(to), cap(cap), cost(cost), rev(rev)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], prevv[MAX], preve[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> cost)</span> </span>&#123;</div><div class=\"line\">    edge[from].push_back(Node(to, cap, cost, edge[to].size()));</div><div class=\"line\">    edge[to].push_back(Node(from, <span class=\"number\">0</span>, -cost, edge[from].size()<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//循环到到达了f流量</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (f &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">        dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                Node&amp; e = edge[u][i];</div><div class=\"line\">                <span class=\"keyword\">if</span> (e.cap &gt; <span class=\"number\">0</span> &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;</div><div class=\"line\">                    dist[e.to] = dist[u] + e.cost;</div><div class=\"line\">                    prevv[e.to] = u;</div><div class=\"line\">                    preve[e.to] = i;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!vis[e.to]) &#123;</div><div class=\"line\">                        q.push(e.to);</div><div class=\"line\">                        vis[e.to] = <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[t] == INF) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//最路径上最小流量</span></div><div class=\"line\">        <span class=\"keyword\">int</span> d = f;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            d = min(d, edge[prevv[u]][preve[u]].cap);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//剩余的流量</span></div><div class=\"line\">        f -= d;</div><div class=\"line\">        <span class=\"comment\">//计算费用</span></div><div class=\"line\">        rst += d * dist[t];</div><div class=\"line\">        <span class=\"comment\">//修改路上所经过的边的容量</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            Node&amp; e = edge[prevv[u]][preve[u]];</div><div class=\"line\">            e.cap -= d;</div><div class=\"line\">            edge[u][e.rev].cap += d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> from, to, cost;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;from, &amp;to, &amp;cost);</div><div class=\"line\">        add_edge(from, to, <span class=\"number\">1</span>, cost);</div><div class=\"line\">        add_edge(to, from, <span class=\"number\">1</span>, cost);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//求流量为2的最小费用</span></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = min_cost_flow(<span class=\"number\">1</span>, N, <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#居然可以AC的Dijstra代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;cstdio&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;queue&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">const int MAX = 1123, INF = 0x3f3f3f3f;</div><div class=\"line\">int N, M;</div><div class=\"line\"></div><div class=\"line\">struct Node&#123;</div><div class=\"line\">    int to, cap, cost, rev;</div><div class=\"line\">    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">vector&lt;Node&gt; edge[MAX];</div><div class=\"line\">int dist[MAX], vis[MAX], prevv[MAX], preve[MAX];</div><div class=\"line\"></div><div class=\"line\">void add_edge(int from, int to, int cap, int cost) &#123;</div><div class=\"line\">    edge[from].push_back(Node(to, cap, cost, edge[to].size()));</div><div class=\"line\">    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int min_cost_flow(int s, int t, int f) &#123;</div><div class=\"line\">    int rst = 0;</div><div class=\"line\">    while (f &gt; 0) &#123;</div><div class=\"line\">        memset(dist, INF, sizeof(dist));</div><div class=\"line\">        queue&lt;int&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        vis[s] = 1;</div><div class=\"line\">        dist[s] = 0;</div><div class=\"line\">        while (!q.empty()) &#123;</div><div class=\"line\">            int u = q.front();</div><div class=\"line\">            for (int i = 0; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                Node&amp; e = edge[u][i];</div><div class=\"line\">                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;</div><div class=\"line\">                    dist[e.to] = dist[u] + e.cost;</div><div class=\"line\">                    prevv[e.to] = u;</div><div class=\"line\">                    preve[e.to] = i;</div><div class=\"line\">                    if (!vis[e.to]) &#123;</div><div class=\"line\">                        q.push(e.to);</div><div class=\"line\">                        vis[e.to] = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (dist[t] == INF) return -1;</div><div class=\"line\"></div><div class=\"line\">        int d = f;</div><div class=\"line\">        for (int u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            d = min(d, edge[prevv[u]][preve[u]].cap);</div><div class=\"line\">        &#125;</div><div class=\"line\">        f -= d;</div><div class=\"line\">        rst += d * dist[t];</div><div class=\"line\">        for (int u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            Node&amp; e = edge[prevv[u]][preve[u]];</div><div class=\"line\">            e.cap -= d;</div><div class=\"line\">            edge[u][e.rev].cap += d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main() &#123;</div><div class=\"line\">    scanf(&quot;%d %d&quot;, &amp;N, &amp;M);</div><div class=\"line\">    for (int i = 0; i &lt; M; i++) &#123;</div><div class=\"line\">        int from, to, cost;</div><div class=\"line\">        scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;cost);</div><div class=\"line\">        add_edge(from, to, 1, cost);</div><div class=\"line\">        add_edge(to, from, 1, cost);</div><div class=\"line\">    &#125;</div><div class=\"line\">    int ans = min_cost_flow(1, N, 2);</div><div class=\"line\">    printf(&quot;%d\\n&quot;, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2135\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2135</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有 N 个节点，有M条边，要从 1 走到 N 然后再回到 1 。要求走的边不能重复，求最短路径。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前看了最小费用最大流然后一直没有做题，于是找了一个模板题来刷，对着板子敲上去居然一次AC，然后又改了下最短路的算法，AC。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 算是一个隐含的最小费用最大流，设每条边的容量为1，花费为路径长度。那么所求的就是一个从起点 1 到终点 N 流量为 2 的流的最小费用流。</p>\n<p>这里用的是最短增广路算法。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> N, M;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, cap, cost, rev;</div><div class=\"line\">    Node(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> cost, <span class=\"keyword\">int</span> rev):to(to), cap(cap), cost(cost), rev(rev)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; edge[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], prevv[MAX], preve[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> cost)</span> </span>&#123;</div><div class=\"line\">    edge[from].push_back(Node(to, cap, cost, edge[to].size()));</div><div class=\"line\">    edge[to].push_back(Node(from, <span class=\"number\">0</span>, -cost, edge[from].size()<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//循环到到达了f流量</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (f &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">        dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                Node&amp; e = edge[u][i];</div><div class=\"line\">                <span class=\"keyword\">if</span> (e.cap &gt; <span class=\"number\">0</span> &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;</div><div class=\"line\">                    dist[e.to] = dist[u] + e.cost;</div><div class=\"line\">                    prevv[e.to] = u;</div><div class=\"line\">                    preve[e.to] = i;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!vis[e.to]) &#123;</div><div class=\"line\">                        q.push(e.to);</div><div class=\"line\">                        vis[e.to] = <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[t] == INF) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//最路径上最小流量</span></div><div class=\"line\">        <span class=\"keyword\">int</span> d = f;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            d = min(d, edge[prevv[u]][preve[u]].cap);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//剩余的流量</span></div><div class=\"line\">        f -= d;</div><div class=\"line\">        <span class=\"comment\">//计算费用</span></div><div class=\"line\">        rst += d * dist[t];</div><div class=\"line\">        <span class=\"comment\">//修改路上所经过的边的容量</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            Node&amp; e = edge[prevv[u]][preve[u]];</div><div class=\"line\">            e.cap -= d;</div><div class=\"line\">            edge[u][e.rev].cap += d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;N, &amp;M);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> from, to, cost;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;from, &amp;to, &amp;cost);</div><div class=\"line\">        add_edge(from, to, <span class=\"number\">1</span>, cost);</div><div class=\"line\">        add_edge(to, from, <span class=\"number\">1</span>, cost);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//求流量为2的最小费用</span></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = min_cost_flow(<span class=\"number\">1</span>, N, <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#居然可以AC的Dijstra代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;cstdio&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;queue&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">const int MAX = 1123, INF = 0x3f3f3f3f;</div><div class=\"line\">int N, M;</div><div class=\"line\"></div><div class=\"line\">struct Node&#123;</div><div class=\"line\">    int to, cap, cost, rev;</div><div class=\"line\">    Node(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">vector&lt;Node&gt; edge[MAX];</div><div class=\"line\">int dist[MAX], vis[MAX], prevv[MAX], preve[MAX];</div><div class=\"line\"></div><div class=\"line\">void add_edge(int from, int to, int cap, int cost) &#123;</div><div class=\"line\">    edge[from].push_back(Node(to, cap, cost, edge[to].size()));</div><div class=\"line\">    edge[to].push_back(Node(from, 0, -cost, edge[from].size()-1));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int min_cost_flow(int s, int t, int f) &#123;</div><div class=\"line\">    int rst = 0;</div><div class=\"line\">    while (f &gt; 0) &#123;</div><div class=\"line\">        memset(dist, INF, sizeof(dist));</div><div class=\"line\">        queue&lt;int&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        vis[s] = 1;</div><div class=\"line\">        dist[s] = 0;</div><div class=\"line\">        while (!q.empty()) &#123;</div><div class=\"line\">            int u = q.front();</div><div class=\"line\">            for (int i = 0; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                Node&amp; e = edge[u][i];</div><div class=\"line\">                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;</div><div class=\"line\">                    dist[e.to] = dist[u] + e.cost;</div><div class=\"line\">                    prevv[e.to] = u;</div><div class=\"line\">                    preve[e.to] = i;</div><div class=\"line\">                    if (!vis[e.to]) &#123;</div><div class=\"line\">                        q.push(e.to);</div><div class=\"line\">                        vis[e.to] = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (dist[t] == INF) return -1;</div><div class=\"line\"></div><div class=\"line\">        int d = f;</div><div class=\"line\">        for (int u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            d = min(d, edge[prevv[u]][preve[u]].cap);</div><div class=\"line\">        &#125;</div><div class=\"line\">        f -= d;</div><div class=\"line\">        rst += d * dist[t];</div><div class=\"line\">        for (int u = t; u != s; u = prevv[u]) &#123;</div><div class=\"line\">            Node&amp; e = edge[prevv[u]][preve[u]];</div><div class=\"line\">            e.cap -= d;</div><div class=\"line\">            edge[u][e.rev].cap += d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main() &#123;</div><div class=\"line\">    scanf(&quot;%d %d&quot;, &amp;N, &amp;M);</div><div class=\"line\">    for (int i = 0; i &lt; M; i++) &#123;</div><div class=\"line\">        int from, to, cost;</div><div class=\"line\">        scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;cost);</div><div class=\"line\">        add_edge(from, to, 1, cost);</div><div class=\"line\">        add_edge(to, from, 1, cost);</div><div class=\"line\">    &#125;</div><div class=\"line\">    int ans = min_cost_flow(1, N, 2);</div><div class=\"line\">    printf(&quot;%d\\n&quot;, ans);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"POJ2195 - Going Home（最小费用流+模板）","date":"2017-07-27T01:52:40.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=2195\n\n-----------------------\n# 题目大意：\n给出一张二维的图，每个点距离相邻的点花费为1，图上有相同数量的人和房子，每个房子的容量为1，要使得所有人进入到不同的房子里，最小的花费是多少？\n\n------------------\n# 解题过程：\n就是裸的最小费用流，建图麻烦点，留下来当模板。\n不过这题注意一个坑点是题目描述的数据范围不正确。\n\n------------------------\n# AC代码：\n```cpp\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX = 10012;\nconst int INF = 0x3f3f3f3f;\n\nstruct Info {\n    int x, y;\n    bool flag;\n    Info(int x, int y, bool flag): x(x), y(y), flag(flag) {}\n};\n\nstruct Edge {\n    int u, v, w, cap, nxt;\n}edge[MAX<<2];\n\nvector<Info> point;\nint head[MAX], tot;\nint dist[MAX], vis[MAX], pre[MAX], flow[MAX];\n\nint get_dist(int a, int b) {\n    return abs(point[a].x - point[b].x) + abs(point[a].y - point[b].y);\n}\n\nvoid add_edge(int u, int v, int w) {\n    edge[tot].u = u;\n    edge[tot].v = v;\n    edge[tot].cap = 1;\n    edge[tot].w = w;\n    edge[tot].nxt = head[u];\n    head[u] = tot++;\n\n    edge[tot].u = v;\n    edge[tot].v = u;\n    edge[tot].cap = 0;\n    edge[tot].w = -w;\n    edge[tot].nxt = head[v];\n    head[v] = tot++;\n}\n\nvoid spfa(int s) {\n    memset(dist, INF, sizeof(dist));\n    queue<int> q;\n    q.push(s);\n    //flow记录当前节点允许的最大流量\n    flow[s] = INF;\n    vis[s] = 1;\n    dist[s] = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            if (edge[i].cap > 0 && dist[v] > dist[u] + edge[i].w) {\n                dist[v] = dist[u] + edge[i].w;\n                //pre记录当前节点是又那条边过来的\n                pre[v] = i;\n                flow[v] = min(flow[u], edge[i].cap);\n                if (!vis[v]) { q.push(v); vis[v] = 1; }\n            }\n        }\n        vis[u] = 0;\n    }\n}\n\nint min_cost_flow(int s, int e) {\n    int rst = 0;\n    while (true) {\n        //用spfa求得的最短路增广\n        spfa(s);\n        //如果和终点无法连通，那么结束\n        if (dist[e] == INF) break;\n        int d = flow[e], u = e;\n        //计算花费\n        rst += d * dist[e];\n        //更新残量网络\n        while (u != s) {\n            int last = pre[u];\n            edge[last].cap -= d;\n            edge[last^1].cap += d;\n            u = edge[last].u;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        memset(head, -1, sizeof(head));\n        point.clear();\n        tot = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char ch;\n                scanf(\" %c\", &ch);\n                if (ch == 'H') point.push_back(Info(i, j, true));\n                if (ch == 'm') point.push_back(Info(i, j, false));\n            }\n        }\n        int s = point.size();\n        int e = s + 1;\n        for (int i = 0; i < point.size(); i++) {\n            if (!point[i].flag) {\n                add_edge(s, i, 0);\n                for (int j = 0; j < point.size(); j++) {\n                    if (!point[j].flag) continue;\n                    add_edge(i, j, get_dist(i, j));\n                }\n            }\n            else add_edge(i, e, 0);\n        }\n        printf(\"%d\\n\", min_cost_flow(s, e));\n    }\n}\n\n```","source":"_posts/POJ2195-Going-Home（最小费用流-模板）.md","raw":"---\ntitle: POJ2195 - Going Home（最小费用流+模板）\ndate: 2017-07-27 09:52:40\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=2195\n\n-----------------------\n# 题目大意：\n给出一张二维的图，每个点距离相邻的点花费为1，图上有相同数量的人和房子，每个房子的容量为1，要使得所有人进入到不同的房子里，最小的花费是多少？\n\n------------------\n# 解题过程：\n就是裸的最小费用流，建图麻烦点，留下来当模板。\n不过这题注意一个坑点是题目描述的数据范围不正确。\n\n------------------------\n# AC代码：\n```cpp\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX = 10012;\nconst int INF = 0x3f3f3f3f;\n\nstruct Info {\n    int x, y;\n    bool flag;\n    Info(int x, int y, bool flag): x(x), y(y), flag(flag) {}\n};\n\nstruct Edge {\n    int u, v, w, cap, nxt;\n}edge[MAX<<2];\n\nvector<Info> point;\nint head[MAX], tot;\nint dist[MAX], vis[MAX], pre[MAX], flow[MAX];\n\nint get_dist(int a, int b) {\n    return abs(point[a].x - point[b].x) + abs(point[a].y - point[b].y);\n}\n\nvoid add_edge(int u, int v, int w) {\n    edge[tot].u = u;\n    edge[tot].v = v;\n    edge[tot].cap = 1;\n    edge[tot].w = w;\n    edge[tot].nxt = head[u];\n    head[u] = tot++;\n\n    edge[tot].u = v;\n    edge[tot].v = u;\n    edge[tot].cap = 0;\n    edge[tot].w = -w;\n    edge[tot].nxt = head[v];\n    head[v] = tot++;\n}\n\nvoid spfa(int s) {\n    memset(dist, INF, sizeof(dist));\n    queue<int> q;\n    q.push(s);\n    //flow记录当前节点允许的最大流量\n    flow[s] = INF;\n    vis[s] = 1;\n    dist[s] = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; ~i; i = edge[i].nxt) {\n            int v = edge[i].v;\n            if (edge[i].cap > 0 && dist[v] > dist[u] + edge[i].w) {\n                dist[v] = dist[u] + edge[i].w;\n                //pre记录当前节点是又那条边过来的\n                pre[v] = i;\n                flow[v] = min(flow[u], edge[i].cap);\n                if (!vis[v]) { q.push(v); vis[v] = 1; }\n            }\n        }\n        vis[u] = 0;\n    }\n}\n\nint min_cost_flow(int s, int e) {\n    int rst = 0;\n    while (true) {\n        //用spfa求得的最短路增广\n        spfa(s);\n        //如果和终点无法连通，那么结束\n        if (dist[e] == INF) break;\n        int d = flow[e], u = e;\n        //计算花费\n        rst += d * dist[e];\n        //更新残量网络\n        while (u != s) {\n            int last = pre[u];\n            edge[last].cap -= d;\n            edge[last^1].cap += d;\n            u = edge[last].u;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        memset(head, -1, sizeof(head));\n        point.clear();\n        tot = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char ch;\n                scanf(\" %c\", &ch);\n                if (ch == 'H') point.push_back(Info(i, j, true));\n                if (ch == 'm') point.push_back(Info(i, j, false));\n            }\n        }\n        int s = point.size();\n        int e = s + 1;\n        for (int i = 0; i < point.size(); i++) {\n            if (!point[i].flag) {\n                add_edge(s, i, 0);\n                for (int j = 0; j < point.size(); j++) {\n                    if (!point[j].flag) continue;\n                    add_edge(i, j, get_dist(i, j));\n                }\n            }\n            else add_edge(i, e, 0);\n        }\n        printf(\"%d\\n\", min_cost_flow(s, e));\n    }\n}\n\n```","slug":"POJ2195-Going-Home（最小费用流-模板）","published":1,"updated":"2017-07-27T02:06:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncr003jy9idufsjrzl4","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2195\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2195</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一张二维的图，每个点距离相邻的点花费为1，图上有相同数量的人和房子，每个房子的容量为1，要使得所有人进入到不同的房子里，最小的花费是多少？</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>就是裸的最小费用流，建图麻烦点，留下来当模板。<br>不过这题注意一个坑点是题目描述的数据范围不正确。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10012</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flag;</div><div class=\"line\">    Info(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">bool</span> flag): x(x), y(y), flag(flag) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w, cap, nxt;</div><div class=\"line\">&#125;edge[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Info&gt; point;</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], tot;</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], pre[MAX], flow[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_dist</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(point[a].x - point[b].x) + <span class=\"built_in\">abs</span>(point[a].y - point[b].y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[tot].u = u;</div><div class=\"line\">    edge[tot].v = v;</div><div class=\"line\">    edge[tot].cap = <span class=\"number\">1</span>;</div><div class=\"line\">    edge[tot].w = w;</div><div class=\"line\">    edge[tot].nxt = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\"></div><div class=\"line\">    edge[tot].u = v;</div><div class=\"line\">    edge[tot].v = u;</div><div class=\"line\">    edge[tot].cap = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[tot].w = -w;</div><div class=\"line\">    edge[tot].nxt = head[v];</div><div class=\"line\">    head[v] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    <span class=\"comment\">//flow记录当前节点允许的最大流量</span></div><div class=\"line\">    flow[s] = INF;</div><div class=\"line\">    vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; dist[v] &gt; dist[u] + edge[i].w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + edge[i].w;</div><div class=\"line\">                <span class=\"comment\">//pre记录当前节点是又那条边过来的</span></div><div class=\"line\">                pre[v] = i;</div><div class=\"line\">                flow[v] = min(flow[u], edge[i].cap);</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[v]) &#123; q.push(v); vis[v] = <span class=\"number\">1</span>; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//用spfa求得的最短路增广</span></div><div class=\"line\">        spfa(s);</div><div class=\"line\">        <span class=\"comment\">//如果和终点无法连通，那么结束</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[e] == INF) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = flow[e], u = e;</div><div class=\"line\">        <span class=\"comment\">//计算花费</span></div><div class=\"line\">        rst += d * dist[e];</div><div class=\"line\">        <span class=\"comment\">//更新残量网络</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (u != s) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = pre[u];</div><div class=\"line\">            edge[last].cap -= d;</div><div class=\"line\">            edge[last^<span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            u = edge[last].u;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        point.clear();</div><div class=\"line\">        tot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> ch;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %c\"</span>, &amp;ch);</div><div class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">'H'</span>) point.push_back(Info(i, j, <span class=\"literal\">true</span>));</div><div class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">'m'</span>) point.push_back(Info(i, j, <span class=\"literal\">false</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> s = point.size();</div><div class=\"line\">        <span class=\"keyword\">int</span> e = s + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; point.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!point[i].flag) &#123;</div><div class=\"line\">                add_edge(s, i, <span class=\"number\">0</span>);</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; point.size(); j++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!point[j].flag) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    add_edge(i, j, get_dist(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> add_edge(i, e, <span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, min_cost_flow(s, e));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2195\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2195</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一张二维的图，每个点距离相邻的点花费为1，图上有相同数量的人和房子，每个房子的容量为1，要使得所有人进入到不同的房子里，最小的花费是多少？</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>就是裸的最小费用流，建图麻烦点，留下来当模板。<br>不过这题注意一个坑点是题目描述的数据范围不正确。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10012</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flag;</div><div class=\"line\">    Info(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">bool</span> flag): x(x), y(y), flag(flag) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w, cap, nxt;</div><div class=\"line\">&#125;edge[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Info&gt; point;</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], tot;</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], vis[MAX], pre[MAX], flow[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_dist</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(point[a].x - point[b].x) + <span class=\"built_in\">abs</span>(point[a].y - point[b].y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span> </span>&#123;</div><div class=\"line\">    edge[tot].u = u;</div><div class=\"line\">    edge[tot].v = v;</div><div class=\"line\">    edge[tot].cap = <span class=\"number\">1</span>;</div><div class=\"line\">    edge[tot].w = w;</div><div class=\"line\">    edge[tot].nxt = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\"></div><div class=\"line\">    edge[tot].u = v;</div><div class=\"line\">    edge[tot].v = u;</div><div class=\"line\">    edge[tot].cap = <span class=\"number\">0</span>;</div><div class=\"line\">    edge[tot].w = -w;</div><div class=\"line\">    edge[tot].nxt = head[v];</div><div class=\"line\">    head[v] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    <span class=\"comment\">//flow记录当前节点允许的最大流量</span></div><div class=\"line\">    flow[s] = INF;</div><div class=\"line\">    vis[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge[i].cap &gt; <span class=\"number\">0</span> &amp;&amp; dist[v] &gt; dist[u] + edge[i].w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + edge[i].w;</div><div class=\"line\">                <span class=\"comment\">//pre记录当前节点是又那条边过来的</span></div><div class=\"line\">                pre[v] = i;</div><div class=\"line\">                flow[v] = min(flow[u], edge[i].cap);</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[v]) &#123; q.push(v); vis[v] = <span class=\"number\">1</span>; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//用spfa求得的最短路增广</span></div><div class=\"line\">        spfa(s);</div><div class=\"line\">        <span class=\"comment\">//如果和终点无法连通，那么结束</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (dist[e] == INF) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = flow[e], u = e;</div><div class=\"line\">        <span class=\"comment\">//计算花费</span></div><div class=\"line\">        rst += d * dist[e];</div><div class=\"line\">        <span class=\"comment\">//更新残量网络</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (u != s) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = pre[u];</div><div class=\"line\">            edge[last].cap -= d;</div><div class=\"line\">            edge[last^<span class=\"number\">1</span>].cap += d;</div><div class=\"line\">            u = edge[last].u;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        point.clear();</div><div class=\"line\">        tot = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> ch;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %c\"</span>, &amp;ch);</div><div class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">'H'</span>) point.push_back(Info(i, j, <span class=\"literal\">true</span>));</div><div class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">'m'</span>) point.push_back(Info(i, j, <span class=\"literal\">false</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> s = point.size();</div><div class=\"line\">        <span class=\"keyword\">int</span> e = s + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; point.size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!point[i].flag) &#123;</div><div class=\"line\">                add_edge(s, i, <span class=\"number\">0</span>);</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; point.size(); j++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!point[j].flag) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    add_edge(i, j, get_dist(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> add_edge(i, e, <span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, min_cost_flow(s, e));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ2411 - Mondriaan's Dream （状压DP+轮廓线DP）","date":"2017-05-18T11:31:41.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=2411\n\n----------------------\n# 题目大意：\n 这题题意非常明确，现在有一个 M × N 的矩形，你现在有很多个 2 × 1 大小的方块，现在要用这些方块铺满这个矩形，请问有多少种铺法。\n\n--------------------------\n# 解题过程：\n\n 这题不是遇到卡住的，是学新知识的模板题，然后顺着书的思路做的，理解还是花了一番功夫。先看的挑战那本书，后来又翻了下大白书，还是 LRJ 的书写的详细易读，最后终于看懂了。\n \n 刚开始理解错状态了，书上专门说了下多段图路径问题，然后我顺便把状态理解成每一行的对应 2 ^ M 个状态了，然后状态转移的时候怎么想都不对，最后又看了下复杂度，才发现是 O ( N × M × 2 ^ M )，然后看了下完整代码，发现每一行的每一列都是一个阶段，每个阶段对应 2 ^ M 个状态，然后一个新状态由上一个阶段的状态转移而来。\n\n---------------------------------------\n# 题目分析：\n\n 首先确定状态。\n\n假设我是从左上角开始依次从左至右从上至下的放方块，那么可以得出结论：假设现在要放的点为 (i, j)，大小按照字典序（先按行，后按列）。 那么对于所有的点 (i', j') >= (i, j) 一定是还没有放。对于所有 (i', j') < (i-1, j) 的点一定是已经放了方块的。\n\n\n![这里写图片描述](http://img.blog.csdn.net/20170518180433429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n假设我要放置 (4, 4) 这个点，那么绿色的地方都是已经铺满的，蓝色的地方都是未铺的，黄色的地方是未确定的。接下来只要状态压缩表示黄色的部分好了。用 1 表示已铺，0 表示未铺。\n\n![这里写图片描述](http://img.blog.csdn.net/20170518191727606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n然后放置一个位置 (i, j)的时候有三种方式，分别是不放，向上竖着放，向左横着放。如果是不放，那么 (i-1, j) 位置一定是已经铺了的，否则不可能转移到一个合法的状态。如果是向上竖着放，那么 (i-1, j) 一定要是未铺的。如果向左横着放，那么 (i, j-1) 一定是未铺的。\n\n![这里写图片描述](http://img.blog.csdn.net/20170518191742969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n此外大白书上介绍了多段图的概念。有 n 列节点，每列称一个阶段，每个阶段的节点只会先下一个阶段的节点连有向边。本题就可以转化为从多段图的一个节点到达另一个节点的路径个数，矩形里的每一个方块都是一个阶段。而且递推的时候要求一个阶段只需要用到他的上一个阶段，所以可以用滚动数组实现。\n\n\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 15;\nint n, m, cur;\nll dp[2][1<<MAX];\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n+m)) {\n        if (n < m) swap(n, m);\n        memset(dp, 0, sizeof(dp));\n        cur = 0;\n        //初始化状态，看做第一行的上一行已经全部铺满\n        dp[cur][(1<<m)-1] = 1;\n\n        //枚举每一行每一列\n        for (int i = 0; i < n; i ++) {\n            for (int j = 0; j < m; j++) {\n                //滚动数组\n                cur ^= 1;\n                memset(dp[cur], 0, sizeof(dp[cur]));\n                for (int k = 0; k < (1<<m); k++) {\n                    ll num = dp[cur^1][k];\n                    //判断要放的位置的上面一块是否已铺\n                    if (k&(1<<(m-1))) {\n                        //不放\n                        dp[cur][(k<<1)^(1<<m)] += num;\n                        //判断要放的位置的左边一块是否未铺\n                        if (j && !(k&1)) {\n                            //向左横着放\n                            dp[cur][((k<<1)^(1<<m))+3] += num;\n                        }\n                    }\n                    else if (i) {\n                        //向上竖着放\n                        dp[cur][(k<<1)+1] += num;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", dp[cur][(1<<m)-1]);\n    }\n}\n```","source":"_posts/POJ2411-Mondriaan-s-Dream-（状压DP-轮廓线DP）.md","raw":"---\ntitle: POJ2411 - Mondriaan's Dream （状压DP+轮廓线DP）\ndate: 2017-05-18 19:31:41\ncategories: [ACM, DP, 状压DP]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=2411\n\n----------------------\n# 题目大意：\n 这题题意非常明确，现在有一个 M × N 的矩形，你现在有很多个 2 × 1 大小的方块，现在要用这些方块铺满这个矩形，请问有多少种铺法。\n\n--------------------------\n# 解题过程：\n\n 这题不是遇到卡住的，是学新知识的模板题，然后顺着书的思路做的，理解还是花了一番功夫。先看的挑战那本书，后来又翻了下大白书，还是 LRJ 的书写的详细易读，最后终于看懂了。\n \n 刚开始理解错状态了，书上专门说了下多段图路径问题，然后我顺便把状态理解成每一行的对应 2 ^ M 个状态了，然后状态转移的时候怎么想都不对，最后又看了下复杂度，才发现是 O ( N × M × 2 ^ M )，然后看了下完整代码，发现每一行的每一列都是一个阶段，每个阶段对应 2 ^ M 个状态，然后一个新状态由上一个阶段的状态转移而来。\n\n---------------------------------------\n# 题目分析：\n\n 首先确定状态。\n\n假设我是从左上角开始依次从左至右从上至下的放方块，那么可以得出结论：假设现在要放的点为 (i, j)，大小按照字典序（先按行，后按列）。 那么对于所有的点 (i', j') >= (i, j) 一定是还没有放。对于所有 (i', j') < (i-1, j) 的点一定是已经放了方块的。\n\n\n![这里写图片描述](http://img.blog.csdn.net/20170518180433429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n假设我要放置 (4, 4) 这个点，那么绿色的地方都是已经铺满的，蓝色的地方都是未铺的，黄色的地方是未确定的。接下来只要状态压缩表示黄色的部分好了。用 1 表示已铺，0 表示未铺。\n\n![这里写图片描述](http://img.blog.csdn.net/20170518191727606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n然后放置一个位置 (i, j)的时候有三种方式，分别是不放，向上竖着放，向左横着放。如果是不放，那么 (i-1, j) 位置一定是已经铺了的，否则不可能转移到一个合法的状态。如果是向上竖着放，那么 (i-1, j) 一定要是未铺的。如果向左横着放，那么 (i, j-1) 一定是未铺的。\n\n![这里写图片描述](http://img.blog.csdn.net/20170518191742969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n此外大白书上介绍了多段图的概念。有 n 列节点，每列称一个阶段，每个阶段的节点只会先下一个阶段的节点连有向边。本题就可以转化为从多段图的一个节点到达另一个节点的路径个数，矩形里的每一个方块都是一个阶段。而且递推的时候要求一个阶段只需要用到他的上一个阶段，所以可以用滚动数组实现。\n\n\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 15;\nint n, m, cur;\nll dp[2][1<<MAX];\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n+m)) {\n        if (n < m) swap(n, m);\n        memset(dp, 0, sizeof(dp));\n        cur = 0;\n        //初始化状态，看做第一行的上一行已经全部铺满\n        dp[cur][(1<<m)-1] = 1;\n\n        //枚举每一行每一列\n        for (int i = 0; i < n; i ++) {\n            for (int j = 0; j < m; j++) {\n                //滚动数组\n                cur ^= 1;\n                memset(dp[cur], 0, sizeof(dp[cur]));\n                for (int k = 0; k < (1<<m); k++) {\n                    ll num = dp[cur^1][k];\n                    //判断要放的位置的上面一块是否已铺\n                    if (k&(1<<(m-1))) {\n                        //不放\n                        dp[cur][(k<<1)^(1<<m)] += num;\n                        //判断要放的位置的左边一块是否未铺\n                        if (j && !(k&1)) {\n                            //向左横着放\n                            dp[cur][((k<<1)^(1<<m))+3] += num;\n                        }\n                    }\n                    else if (i) {\n                        //向上竖着放\n                        dp[cur][(k<<1)+1] += num;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", dp[cur][(1<<m)-1]);\n    }\n}\n```","slug":"POJ2411-Mondriaan-s-Dream-（状压DP-轮廓线DP）","published":1,"updated":"2017-07-23T02:31:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncs003my9idm1z7c3a2","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2411\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2411</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 这题题意非常明确，现在有一个 M × N 的矩形，你现在有很多个 2 × 1 大小的方块，现在要用这些方块铺满这个矩形，请问有多少种铺法。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这题不是遇到卡住的，是学新知识的模板题，然后顺着书的思路做的，理解还是花了一番功夫。先看的挑战那本书，后来又翻了下大白书，还是 LRJ 的书写的详细易读，最后终于看懂了。</p>\n<p> 刚开始理解错状态了，书上专门说了下多段图路径问题，然后我顺便把状态理解成每一行的对应 2 ^ M 个状态了，然后状态转移的时候怎么想都不对，最后又看了下复杂度，才发现是 O ( N × M × 2 ^ M )，然后看了下完整代码，发现每一行的每一列都是一个阶段，每个阶段对应 2 ^ M 个状态，然后一个新状态由上一个阶段的状态转移而来。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先确定状态。</p>\n<p>假设我是从左上角开始依次从左至右从上至下的放方块，那么可以得出结论：假设现在要放的点为 (i, j)，大小按照字典序（先按行，后按列）。 那么对于所有的点 (i’, j’) &gt;= (i, j) 一定是还没有放。对于所有 (i’, j’) &lt; (i-1, j) 的点一定是已经放了方块的。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518180433429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>假设我要放置 (4, 4) 这个点，那么绿色的地方都是已经铺满的，蓝色的地方都是未铺的，黄色的地方是未确定的。接下来只要状态压缩表示黄色的部分好了。用 1 表示已铺，0 表示未铺。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518191727606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后放置一个位置 (i, j)的时候有三种方式，分别是不放，向上竖着放，向左横着放。如果是不放，那么 (i-1, j) 位置一定是已经铺了的，否则不可能转移到一个合法的状态。如果是向上竖着放，那么 (i-1, j) 一定要是未铺的。如果向左横着放，那么 (i, j-1) 一定是未铺的。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518191742969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>此外大白书上介绍了多段图的概念。有 n 列节点，每列称一个阶段，每个阶段的节点只会先下一个阶段的节点连有向边。本题就可以转化为从多段图的一个节点到达另一个节点的路径个数，矩形里的每一个方块都是一个阶段。而且递推的时候要求一个阶段只需要用到他的上一个阶段，所以可以用滚动数组实现。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">15</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, cur;</div><div class=\"line\">ll dp[<span class=\"number\">2</span>][<span class=\"number\">1</span>&lt;&lt;MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n+m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n &lt; m) swap(n, m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        cur = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//初始化状态，看做第一行的上一行已经全部铺满</span></div><div class=\"line\">        dp[cur][(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//枚举每一行每一列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//滚动数组</span></div><div class=\"line\">                cur ^= <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"built_in\">memset</span>(dp[cur], <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp[cur]));</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (<span class=\"number\">1</span>&lt;&lt;m); k++) &#123;</div><div class=\"line\">                    ll num = dp[cur^<span class=\"number\">1</span>][k];</div><div class=\"line\">                    <span class=\"comment\">//判断要放的位置的上面一块是否已铺</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (k&amp;(<span class=\"number\">1</span>&lt;&lt;(m<span class=\"number\">-1</span>))) &#123;</div><div class=\"line\">                        <span class=\"comment\">//不放</span></div><div class=\"line\">                        dp[cur][(k&lt;&lt;<span class=\"number\">1</span>)^(<span class=\"number\">1</span>&lt;&lt;m)] += num;</div><div class=\"line\">                        <span class=\"comment\">//判断要放的位置的左边一块是否未铺</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (j &amp;&amp; !(k&amp;<span class=\"number\">1</span>)) &#123;</div><div class=\"line\">                            <span class=\"comment\">//向左横着放</span></div><div class=\"line\">                            dp[cur][((k&lt;&lt;<span class=\"number\">1</span>)^(<span class=\"number\">1</span>&lt;&lt;m))+<span class=\"number\">3</span>] += num;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i) &#123;</div><div class=\"line\">                        <span class=\"comment\">//向上竖着放</span></div><div class=\"line\">                        dp[cur][(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>] += num;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[cur][(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=2411\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=2411</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 这题题意非常明确，现在有一个 M × N 的矩形，你现在有很多个 2 × 1 大小的方块，现在要用这些方块铺满这个矩形，请问有多少种铺法。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这题不是遇到卡住的，是学新知识的模板题，然后顺着书的思路做的，理解还是花了一番功夫。先看的挑战那本书，后来又翻了下大白书，还是 LRJ 的书写的详细易读，最后终于看懂了。</p>\n<p> 刚开始理解错状态了，书上专门说了下多段图路径问题，然后我顺便把状态理解成每一行的对应 2 ^ M 个状态了，然后状态转移的时候怎么想都不对，最后又看了下复杂度，才发现是 O ( N × M × 2 ^ M )，然后看了下完整代码，发现每一行的每一列都是一个阶段，每个阶段对应 2 ^ M 个状态，然后一个新状态由上一个阶段的状态转移而来。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先确定状态。</p>\n<p>假设我是从左上角开始依次从左至右从上至下的放方块，那么可以得出结论：假设现在要放的点为 (i, j)，大小按照字典序（先按行，后按列）。 那么对于所有的点 (i’, j’) &gt;= (i, j) 一定是还没有放。对于所有 (i’, j’) &lt; (i-1, j) 的点一定是已经放了方块的。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518180433429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>假设我要放置 (4, 4) 这个点，那么绿色的地方都是已经铺满的，蓝色的地方都是未铺的，黄色的地方是未确定的。接下来只要状态压缩表示黄色的部分好了。用 1 表示已铺，0 表示未铺。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518191727606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后放置一个位置 (i, j)的时候有三种方式，分别是不放，向上竖着放，向左横着放。如果是不放，那么 (i-1, j) 位置一定是已经铺了的，否则不可能转移到一个合法的状态。如果是向上竖着放，那么 (i-1, j) 一定要是未铺的。如果向左横着放，那么 (i, j-1) 一定是未铺的。</p>\n<p><img src=\"http://img.blog.csdn.net/20170518191742969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>此外大白书上介绍了多段图的概念。有 n 列节点，每列称一个阶段，每个阶段的节点只会先下一个阶段的节点连有向边。本题就可以转化为从多段图的一个节点到达另一个节点的路径个数，矩形里的每一个方块都是一个阶段。而且递推的时候要求一个阶段只需要用到他的上一个阶段，所以可以用滚动数组实现。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">15</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m, cur;</div><div class=\"line\">ll dp[<span class=\"number\">2</span>][<span class=\"number\">1</span>&lt;&lt;MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n+m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n &lt; m) swap(n, m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        cur = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//初始化状态，看做第一行的上一行已经全部铺满</span></div><div class=\"line\">        dp[cur][(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//枚举每一行每一列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//滚动数组</span></div><div class=\"line\">                cur ^= <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"built_in\">memset</span>(dp[cur], <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp[cur]));</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (<span class=\"number\">1</span>&lt;&lt;m); k++) &#123;</div><div class=\"line\">                    ll num = dp[cur^<span class=\"number\">1</span>][k];</div><div class=\"line\">                    <span class=\"comment\">//判断要放的位置的上面一块是否已铺</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (k&amp;(<span class=\"number\">1</span>&lt;&lt;(m<span class=\"number\">-1</span>))) &#123;</div><div class=\"line\">                        <span class=\"comment\">//不放</span></div><div class=\"line\">                        dp[cur][(k&lt;&lt;<span class=\"number\">1</span>)^(<span class=\"number\">1</span>&lt;&lt;m)] += num;</div><div class=\"line\">                        <span class=\"comment\">//判断要放的位置的左边一块是否未铺</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (j &amp;&amp; !(k&amp;<span class=\"number\">1</span>)) &#123;</div><div class=\"line\">                            <span class=\"comment\">//向左横着放</span></div><div class=\"line\">                            dp[cur][((k&lt;&lt;<span class=\"number\">1</span>)^(<span class=\"number\">1</span>&lt;&lt;m))+<span class=\"number\">3</span>] += num;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i) &#123;</div><div class=\"line\">                        <span class=\"comment\">//向上竖着放</span></div><div class=\"line\">                        dp[cur][(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>] += num;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[cur][(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ3259 - Wormholes（连通图判断负环）","date":"2017-06-13T03:10:29.000Z","_content":"# 题目链接；\nhttp://poj.org/problem?id=3259\n\n------------------------\n# 题目大意：\n给出N个图，每个图有两种边，一个是无向的正权边，一种是有向的负权边，保证所给的图为连通图，求是否存在负环。\n\n-----------------------------\n# 解题过程：\n刚开始以为给出的图不连通，然后用Floyd超时，后来问了学长，翻了下POJ的讨论，发现大家都是默认为图连通做的……\n\n然后敲了下Bellman和SPFA判断负环就A了。\n\n\n--------------------------------\n# 题目分析：\n因为保证图联通，那么可以假设从任意一点出发。\n\nBellman：如果松弛操进行N次依然可以松弛，那么存在负环。\nSPFA：如果一个点入队次数大于等于N次，那么处在负环。\n\n\n----------------------------------\n# AC代码：\n## Bellman：\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Node {\n    int u, v, w;\n}edge[2500*10];\n\nLL dist[1123];\n\nint main() {\n    int f;\n    scanf(\"%d\", &f);\n    while (f--) {\n        int n, m, w;\n        scanf(\"%d %d %d\", &n, &m, &w);\n        for (int i = 0; i < m; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[i*2] = {u, v, c};\n            edge[i*2+1] = {v, u, c};\n        }\n        m *= 2;\n        for (int i = 0; i < w; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[i+m] = {u, v, -c};\n        }\n\n        bool flag = false;\n        memset(dist, 0x3f, sizeof(dist));\n        dist[1] = 0;\n        for (int k = 0; k <= n; k++) {\n            for (int j = 0; j < m + w; j++) {\n                int u = edge[j].u;\n                int v = edge[j].v;\n                int w = edge[j].w;\n                if (dist[v] > dist[u] + w) {\n                    if (k == n)\n                        flag = true;\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n\n\n        if (flag)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n}\n```\n\n## SPFA：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef long long LL;\n\n\nvector<pair<int, int> > edge[1123];\nint dist[1123], cnt[1123];\nbool vis[1123];\n\nint main() {\n    int f;\n    scanf(\"%d\", &f);\n    while (f--) {\n        int n, m, w;\n        scanf(\"%d %d %d\", &n, &m, &w);\n        for (int i = 0; i <= n; i++) {\n            edge[i].clear();\n        }\n        for (int i = 0; i < m; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[u].push_back(make_pair(v, c));\n            edge[v].push_back(make_pair(u, c));\n        }\n        for (int i = 0; i < w; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[u].push_back(make_pair(v, -c));\n        }\n\n        bool flag = false;\n        memset(dist, 0x3f, sizeof(dist));\n        memset(cnt, 0, sizeof(cnt));\n        queue<int> q;\n        q.push(1);\n        dist[1] = 0;\n        vis[1] = true;\n\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                int v = edge[u][i].first;\n                int w = edge[u][i].second;\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    if (++cnt[v] >= n) {\n                        flag = true;\n                        break;\n                    }\n                    if (!vis[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = false;\n        }\n\n        if (flag)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n}\n```","source":"_posts/POJ3259-Wormholes（连通图判断负环）.md","raw":"---\ntitle: POJ3259 - Wormholes（连通图判断负环）\ndate: 2017-06-13 11:10:29\ncategories: [ACM, 图论, 最短路]\ntags:\n---\n# 题目链接；\nhttp://poj.org/problem?id=3259\n\n------------------------\n# 题目大意：\n给出N个图，每个图有两种边，一个是无向的正权边，一种是有向的负权边，保证所给的图为连通图，求是否存在负环。\n\n-----------------------------\n# 解题过程：\n刚开始以为给出的图不连通，然后用Floyd超时，后来问了学长，翻了下POJ的讨论，发现大家都是默认为图连通做的……\n\n然后敲了下Bellman和SPFA判断负环就A了。\n\n\n--------------------------------\n# 题目分析：\n因为保证图联通，那么可以假设从任意一点出发。\n\nBellman：如果松弛操进行N次依然可以松弛，那么存在负环。\nSPFA：如果一个点入队次数大于等于N次，那么处在负环。\n\n\n----------------------------------\n# AC代码：\n## Bellman：\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Node {\n    int u, v, w;\n}edge[2500*10];\n\nLL dist[1123];\n\nint main() {\n    int f;\n    scanf(\"%d\", &f);\n    while (f--) {\n        int n, m, w;\n        scanf(\"%d %d %d\", &n, &m, &w);\n        for (int i = 0; i < m; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[i*2] = {u, v, c};\n            edge[i*2+1] = {v, u, c};\n        }\n        m *= 2;\n        for (int i = 0; i < w; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[i+m] = {u, v, -c};\n        }\n\n        bool flag = false;\n        memset(dist, 0x3f, sizeof(dist));\n        dist[1] = 0;\n        for (int k = 0; k <= n; k++) {\n            for (int j = 0; j < m + w; j++) {\n                int u = edge[j].u;\n                int v = edge[j].v;\n                int w = edge[j].w;\n                if (dist[v] > dist[u] + w) {\n                    if (k == n)\n                        flag = true;\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n\n\n        if (flag)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n}\n```\n\n## SPFA：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef long long LL;\n\n\nvector<pair<int, int> > edge[1123];\nint dist[1123], cnt[1123];\nbool vis[1123];\n\nint main() {\n    int f;\n    scanf(\"%d\", &f);\n    while (f--) {\n        int n, m, w;\n        scanf(\"%d %d %d\", &n, &m, &w);\n        for (int i = 0; i <= n; i++) {\n            edge[i].clear();\n        }\n        for (int i = 0; i < m; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[u].push_back(make_pair(v, c));\n            edge[v].push_back(make_pair(u, c));\n        }\n        for (int i = 0; i < w; i++) {\n            int u, v, c;\n            scanf(\"%d %d %d\", &u, &v, &c);\n            edge[u].push_back(make_pair(v, -c));\n        }\n\n        bool flag = false;\n        memset(dist, 0x3f, sizeof(dist));\n        memset(cnt, 0, sizeof(cnt));\n        queue<int> q;\n        q.push(1);\n        dist[1] = 0;\n        vis[1] = true;\n\n        while (!q.empty()) {\n            int u = q.front();\n            for (int i = 0; i < edge[u].size(); i++) {\n                int v = edge[u][i].first;\n                int w = edge[u][i].second;\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    if (++cnt[v] >= n) {\n                        flag = true;\n                        break;\n                    }\n                    if (!vis[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n            q.pop();\n            vis[u] = false;\n        }\n\n        if (flag)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n}\n```","slug":"POJ3259-Wormholes（连通图判断负环）","published":1,"updated":"2017-07-23T02:08:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncv003oy9idgumxaeva","content":"<h1 id=\"题目链接；\"><a href=\"#题目链接；\" class=\"headerlink\" title=\"题目链接；\"></a>题目链接；</h1><p><a href=\"http://poj.org/problem?id=3259\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3259</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出N个图，每个图有两种边，一个是无向的正权边，一种是有向的负权边，保证所给的图为连通图，求是否存在负环。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始以为给出的图不连通，然后用Floyd超时，后来问了学长，翻了下POJ的讨论，发现大家都是默认为图连通做的……</p>\n<p>然后敲了下Bellman和SPFA判断负环就A了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为保证图联通，那么可以假设从任意一点出发。</p>\n<p>Bellman：如果松弛操进行N次依然可以松弛，那么存在负环。<br>SPFA：如果一个点入队次数大于等于N次，那么处在负环。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"Bellman：\"><a href=\"#Bellman：\" class=\"headerlink\" title=\"Bellman：\"></a>Bellman：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">&#125;edge[<span class=\"number\">2500</span>*<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">LL dist[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> f;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;f);</div><div class=\"line\">    <span class=\"keyword\">while</span> (f--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;w);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[i*<span class=\"number\">2</span>] = &#123;u, v, c&#125;;</div><div class=\"line\">            edge[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>] = &#123;v, u, c&#125;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        m *= <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[i+m] = &#123;u, v, -c&#125;;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m + w; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> u = edge[j].u;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edge[j].v;</div><div class=\"line\">                <span class=\"keyword\">int</span> w = edge[j].w;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (k == n)</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                    dist[v] = dist[u] + w;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SPFA：\"><a href=\"#SPFA：\" class=\"headerlink\" title=\"SPFA：\"></a>SPFA：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[<span class=\"number\">1123</span>], cnt[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> f;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;f);</div><div class=\"line\">    <span class=\"keyword\">while</span> (f--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;w);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[u].push_back(make_pair(v, c));</div><div class=\"line\">            edge[v].push_back(make_pair(u, c));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[u].push_back(make_pair(v, -c));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(cnt));</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(<span class=\"number\">1</span>);</div><div class=\"line\">        dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">                <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                    dist[v] = dist[u] + w;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (++cnt[v] &gt;= n) &#123;</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                        q.push(v);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接；\"><a href=\"#题目链接；\" class=\"headerlink\" title=\"题目链接；\"></a>题目链接；</h1><p><a href=\"http://poj.org/problem?id=3259\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3259</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出N个图，每个图有两种边，一个是无向的正权边，一种是有向的负权边，保证所给的图为连通图，求是否存在负环。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>刚开始以为给出的图不连通，然后用Floyd超时，后来问了学长，翻了下POJ的讨论，发现大家都是默认为图连通做的……</p>\n<p>然后敲了下Bellman和SPFA判断负环就A了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为保证图联通，那么可以假设从任意一点出发。</p>\n<p>Bellman：如果松弛操进行N次依然可以松弛，那么存在负环。<br>SPFA：如果一个点入队次数大于等于N次，那么处在负环。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"Bellman：\"><a href=\"#Bellman：\" class=\"headerlink\" title=\"Bellman：\"></a>Bellman：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">&#125;edge[<span class=\"number\">2500</span>*<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">LL dist[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> f;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;f);</div><div class=\"line\">    <span class=\"keyword\">while</span> (f--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;w);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[i*<span class=\"number\">2</span>] = &#123;u, v, c&#125;;</div><div class=\"line\">            edge[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>] = &#123;v, u, c&#125;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        m *= <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[i+m] = &#123;u, v, -c&#125;;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m + w; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> u = edge[j].u;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edge[j].v;</div><div class=\"line\">                <span class=\"keyword\">int</span> w = edge[j].w;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (k == n)</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                    dist[v] = dist[u] + w;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SPFA：\"><a href=\"#SPFA：\" class=\"headerlink\" title=\"SPFA：\"></a>SPFA：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[<span class=\"number\">1123</span>], cnt[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> f;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;f);</div><div class=\"line\">    <span class=\"keyword\">while</span> (f--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m, w;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;n, &amp;m, &amp;w);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            edge[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[u].push_back(make_pair(v, c));</div><div class=\"line\">            edge[v].push_back(make_pair(u, c));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v, c;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;c);</div><div class=\"line\">            edge[u].push_back(make_pair(v, -c));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(cnt));</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(<span class=\"number\">1</span>);</div><div class=\"line\">        dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">                <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                    dist[v] = dist[u] + w;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (++cnt[v] &gt;= n) &#123;</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                        q.push(v);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            q.pop();</div><div class=\"line\">            vis[u] = <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ3169 - Layout （差分约束）","date":"2017-05-15T03:12:44.000Z","_content":"# 题目链接：\nhttps://cn.vjudge.net/problem/POJ-3169\n\n------------------------------\n# 题目大意：\n![这里写图片描述](http://img.blog.csdn.net/20170515103745320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n-----------------------------------\n# 解题过程：\n 刚开始是一脸懵逼的，怎么还有这种题，完全没想法。\n 然后看书上说是差分约束，然后和最短路类比了下，还是没看懂，最后是去网上搜了下博客，然后又自己画了画才弄懂。\n\n http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html\n\n--------------------------------\n# 题目分析：\n\n 关于最短路，设函数 ***d(v)*** 的含义是从起点到节点 v 的最短距离，那么对于任意权值为 ***w*** 的边 ***e = (u, v)*** ，都有 ***d(u) + w >= d(v)*** 成立，公式可化为 ***w >= d(v) - d(u)*** 。最短路就是求解这组方程，变量是 ***d(v/x)*** ，求解这组方程就是意味着求出满足方程的 ***d(v) - d(u)*** 的最大值。\n\n 对于这个题目，有三个约束条件，第一个是牛按编号顺序排，第二个是某两头牛之间的距离不能大于一个值，第三个是某两头牛之间的距离必须不小于一个值。\n\n 假设这两头牛分别是 ***u*** 和 ***v*** ，***(v > u)***，约束距离是 ***w*** ，对于第一个条件， ***d(v) - d(u) >= 0*** 即 ***d(v) + 0 >= d(u)*** ，从***v***向***u***建一条权值为 ***0*** 的边。\n\n 对于第二个条件，***d(u) + w >= d(v)***，即从 ***u*** 向 ***v*** 建一条权值为 ***w*** 的边。\n\n 对于第三个条件，***d(u) + w <= d(v)***， ***d(v) - w >= d(u)***，从 ***v*** 向 ***u*** 建一条权值为 ***-w*** 的边。\n\n 然后对于上面所建立的图，求出从起点到节点的最短距离即是答案。\n\n 如果这个图无法联通，表示没有可行的方案。如果存在负环，那么这个距离是可以无限大的。\n\n\n# AC代码：\n\n```cpp\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nconst int MAX = 11234, INF = 0x3f3f3f3f;\nint frequency[MAX], dist[MAX], vis[MAX];\nint N, ML, MD;\nvector<pair<int, int> > edge[MAX];\n\nint spfa() {\n    memset(dist, INF, sizeof(dist));\n    queue<int> q;\n    q.push(1);\n    dist[1] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i].first;\n            int w = edge[u][i].second;\n\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                if (!vis[v]) {\n                    vis[v] = 1;\n                    frequency[v]++;\n                    if (frequency[v] > N)\n                        return -INF;\n                    q.push(v);\n                }\n            }\n        }\n    }\n\n    return dist[N];\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &ML, &MD);\n\n    int u, v, w;\n    for (int i = 2; i <= N; i++) {\n        edge[i].push_back(make_pair(i-1, 0));\n    }\n    for (int i = 0; i < ML; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        edge[u].push_back(make_pair(v, w));\n    }\n    for (int i = 0; i < MD; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        edge[v].push_back(make_pair(u, -w));\n    }\n\n    int ans = spfa();\n    if (ans <= -INF) {\n        printf(\"-1\\n\");\n    }\n    else if (ans >= INF) {\n        printf(\"-2\\n\");\n    }\n    else {\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```\n","source":"_posts/POJ3169-Layout-（差分约束）.md","raw":"---\ntitle: POJ3169 - Layout （差分约束）\ndate: 2017-05-15 11:12:44\ncategories: [ACM, 图论, 差分约束]\ntags:\n---\n# 题目链接：\nhttps://cn.vjudge.net/problem/POJ-3169\n\n------------------------------\n# 题目大意：\n![这里写图片描述](http://img.blog.csdn.net/20170515103745320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n-----------------------------------\n# 解题过程：\n 刚开始是一脸懵逼的，怎么还有这种题，完全没想法。\n 然后看书上说是差分约束，然后和最短路类比了下，还是没看懂，最后是去网上搜了下博客，然后又自己画了画才弄懂。\n\n http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html\n\n--------------------------------\n# 题目分析：\n\n 关于最短路，设函数 ***d(v)*** 的含义是从起点到节点 v 的最短距离，那么对于任意权值为 ***w*** 的边 ***e = (u, v)*** ，都有 ***d(u) + w >= d(v)*** 成立，公式可化为 ***w >= d(v) - d(u)*** 。最短路就是求解这组方程，变量是 ***d(v/x)*** ，求解这组方程就是意味着求出满足方程的 ***d(v) - d(u)*** 的最大值。\n\n 对于这个题目，有三个约束条件，第一个是牛按编号顺序排，第二个是某两头牛之间的距离不能大于一个值，第三个是某两头牛之间的距离必须不小于一个值。\n\n 假设这两头牛分别是 ***u*** 和 ***v*** ，***(v > u)***，约束距离是 ***w*** ，对于第一个条件， ***d(v) - d(u) >= 0*** 即 ***d(v) + 0 >= d(u)*** ，从***v***向***u***建一条权值为 ***0*** 的边。\n\n 对于第二个条件，***d(u) + w >= d(v)***，即从 ***u*** 向 ***v*** 建一条权值为 ***w*** 的边。\n\n 对于第三个条件，***d(u) + w <= d(v)***， ***d(v) - w >= d(u)***，从 ***v*** 向 ***u*** 建一条权值为 ***-w*** 的边。\n\n 然后对于上面所建立的图，求出从起点到节点的最短距离即是答案。\n\n 如果这个图无法联通，表示没有可行的方案。如果存在负环，那么这个距离是可以无限大的。\n\n\n# AC代码：\n\n```cpp\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nconst int MAX = 11234, INF = 0x3f3f3f3f;\nint frequency[MAX], dist[MAX], vis[MAX];\nint N, ML, MD;\nvector<pair<int, int> > edge[MAX];\n\nint spfa() {\n    memset(dist, INF, sizeof(dist));\n    queue<int> q;\n    q.push(1);\n    dist[1] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n\n        for (int i = 0; i < edge[u].size(); i++) {\n            int v = edge[u][i].first;\n            int w = edge[u][i].second;\n\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                if (!vis[v]) {\n                    vis[v] = 1;\n                    frequency[v]++;\n                    if (frequency[v] > N)\n                        return -INF;\n                    q.push(v);\n                }\n            }\n        }\n    }\n\n    return dist[N];\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &ML, &MD);\n\n    int u, v, w;\n    for (int i = 2; i <= N; i++) {\n        edge[i].push_back(make_pair(i-1, 0));\n    }\n    for (int i = 0; i < ML; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        edge[u].push_back(make_pair(v, w));\n    }\n    for (int i = 0; i < MD; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        edge[v].push_back(make_pair(u, -w));\n    }\n\n    int ans = spfa();\n    if (ans <= -INF) {\n        printf(\"-1\\n\");\n    }\n    else if (ans >= INF) {\n        printf(\"-2\\n\");\n    }\n    else {\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```\n","slug":"POJ3169-Layout-（差分约束）","published":1,"updated":"2017-07-23T02:32:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ncz003ry9iddgzel8jm","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/POJ-3169\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/POJ-3169</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><img src=\"http://img.blog.csdn.net/20170515103745320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始是一脸懵逼的，怎么还有这种题，完全没想法。<br> 然后看书上说是差分约束，然后和最短路类比了下，还是没看懂，最后是去网上搜了下博客，然后又自己画了画才弄懂。</p>\n<p> <a href=\"http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 关于最短路，设函数 <strong><em>d(v)</em></strong> 的含义是从起点到节点 v 的最短距离，那么对于任意权值为 <strong><em>w</em></strong> 的边 <strong><em>e = (u, v)</em></strong> ，都有 <strong><em>d(u) + w &gt;= d(v)</em></strong> 成立，公式可化为 <strong><em>w &gt;= d(v) - d(u)</em></strong> 。最短路就是求解这组方程，变量是 <strong><em>d(v/x)</em></strong> ，求解这组方程就是意味着求出满足方程的 <strong><em>d(v) - d(u)</em></strong> 的最大值。</p>\n<p> 对于这个题目，有三个约束条件，第一个是牛按编号顺序排，第二个是某两头牛之间的距离不能大于一个值，第三个是某两头牛之间的距离必须不小于一个值。</p>\n<p> 假设这两头牛分别是 <strong><em>u</em></strong> 和 <strong><em>v</em></strong> ，<strong><em>(v &gt; u)</em></strong>，约束距离是 <strong><em>w</em></strong> ，对于第一个条件， <strong><em>d(v) - d(u) &gt;= 0</em></strong> 即 <strong><em>d(v) + 0 &gt;= d(u)</em></strong> ，从<strong><em>v</em></strong>向<strong><em>u</em></strong>建一条权值为 <strong><em>0</em></strong> 的边。</p>\n<p> 对于第二个条件，<strong><em>d(u) + w &gt;= d(v)</em></strong>，即从 <strong><em>u</em></strong> 向 <strong><em>v</em></strong> 建一条权值为 <strong><em>w</em></strong> 的边。</p>\n<p> 对于第三个条件，<strong><em>d(u) + w &lt;= d(v)</em></strong>， <strong><em>d(v) - w &gt;= d(u)</em></strong>，从 <strong><em>v</em></strong> 向 <strong><em>u</em></strong> 建一条权值为 <strong><em>-w</em></strong> 的边。</p>\n<p> 然后对于上面所建立的图，求出从起点到节点的最短距离即是答案。</p>\n<p> 如果这个图无法联通，表示没有可行的方案。如果存在负环，那么这个距离是可以无限大的。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> frequency[MAX], dist[MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> N, ML, MD;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(<span class=\"number\">1</span>);</div><div class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">            <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + w;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                    vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                    frequency[v]++;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (frequency[v] &gt; N)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -INF;</div><div class=\"line\">                    q.push(v);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> dist[N];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;ML, &amp;MD);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">        edge[i].push_back(make_pair(i<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ML; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">        edge[u].push_back(make_pair(v, w));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MD; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">        edge[v].push_back(make_pair(u, -w));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = spfa();</div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &lt;= -INF) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ans &gt;= INF) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-2\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/POJ-3169\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/POJ-3169</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><img src=\"http://img.blog.csdn.net/20170515103745320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始是一脸懵逼的，怎么还有这种题，完全没想法。<br> 然后看书上说是差分约束，然后和最短路类比了下，还是没看懂，最后是去网上搜了下博客，然后又自己画了画才弄懂。</p>\n<p> <a href=\"http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 关于最短路，设函数 <strong><em>d(v)</em></strong> 的含义是从起点到节点 v 的最短距离，那么对于任意权值为 <strong><em>w</em></strong> 的边 <strong><em>e = (u, v)</em></strong> ，都有 <strong><em>d(u) + w &gt;= d(v)</em></strong> 成立，公式可化为 <strong><em>w &gt;= d(v) - d(u)</em></strong> 。最短路就是求解这组方程，变量是 <strong><em>d(v/x)</em></strong> ，求解这组方程就是意味着求出满足方程的 <strong><em>d(v) - d(u)</em></strong> 的最大值。</p>\n<p> 对于这个题目，有三个约束条件，第一个是牛按编号顺序排，第二个是某两头牛之间的距离不能大于一个值，第三个是某两头牛之间的距离必须不小于一个值。</p>\n<p> 假设这两头牛分别是 <strong><em>u</em></strong> 和 <strong><em>v</em></strong> ，<strong><em>(v &gt; u)</em></strong>，约束距离是 <strong><em>w</em></strong> ，对于第一个条件， <strong><em>d(v) - d(u) &gt;= 0</em></strong> 即 <strong><em>d(v) + 0 &gt;= d(u)</em></strong> ，从<strong><em>v</em></strong>向<strong><em>u</em></strong>建一条权值为 <strong><em>0</em></strong> 的边。</p>\n<p> 对于第二个条件，<strong><em>d(u) + w &gt;= d(v)</em></strong>，即从 <strong><em>u</em></strong> 向 <strong><em>v</em></strong> 建一条权值为 <strong><em>w</em></strong> 的边。</p>\n<p> 对于第三个条件，<strong><em>d(u) + w &lt;= d(v)</em></strong>， <strong><em>d(v) - w &gt;= d(u)</em></strong>，从 <strong><em>v</em></strong> 向 <strong><em>u</em></strong> 建一条权值为 <strong><em>-w</em></strong> 的边。</p>\n<p> 然后对于上面所建立的图，求出从起点到节点的最短距离即是答案。</p>\n<p> 如果这个图无法联通，表示没有可行的方案。如果存在负环，那么这个距离是可以无限大的。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> frequency[MAX], dist[MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> N, ML, MD;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; edge[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(<span class=\"number\">1</span>);</div><div class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        q.pop();</div><div class=\"line\">        vis[u] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edge[u][i].first;</div><div class=\"line\">            <span class=\"keyword\">int</span> w = edge[u][i].second;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + w) &#123;</div><div class=\"line\">                dist[v] = dist[u] + w;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                    vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                    frequency[v]++;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (frequency[v] &gt; N)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -INF;</div><div class=\"line\">                    q.push(v);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> dist[N];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;ML, &amp;MD);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">        edge[i].push_back(make_pair(i<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ML; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">        edge[u].push_back(make_pair(v, w));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MD; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">        edge[v].push_back(make_pair(u, -w));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = spfa();</div><div class=\"line\">    <span class=\"keyword\">if</span> (ans &lt;= -INF) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ans &gt;= INF) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-2\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"POJ3281 - Dining（EK最大流+模板）","date":"2017-07-26T02:40:33.000Z","_content":"# 题目链接：\nhttp://poj.org/problem?id=3281\n\n--------------------\n# 题目大意：\n有$N$个牛，$D$种饮料，$F$种食物，每种牛有$D_i$种想喝的饮料，$F_i$种想吃的食物，每种饮料和食物只能分配给一只牛，问最大能使多少头牛满足同时得到喜欢的饮料和喜欢的食物。\n\n-------------------------------\n# 解题过程：\n\n还是挺好想的，一下子就想到了，然后2000长度1A美滋滋。\n\n-------------------------------\n# 题目分析：\n\n先把每头牛拆成两个点，一个入点，一个出点，连一个容量为1的边。然后在把每头牛想要的食物与他的入点连上，每头牛想要的饮料和他的出点连上。\n\n再建一个原点和终点，原点连上所有的食物，终点连上所有的饮料，最后跑一个最大流就可以了。上述所有的连边容量都是1。\n\n这样建图保证，对于每一个增广路的流量都为$1$，并且都经过一头牛，一个饮料，一个食物，并且每头牛只得到过一次饮料和食物，保证不会重复计算。\n\n\n----------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX = 112;\nconst int INF = 0x3f3f3f3f;\n\nint N, F, D;\n\nstruct Info {\n    int to, rev, cap;\n    Info(int to, int rev, int cap):to(to), rev(rev), cap(cap){}\n};\n\nvector<Info> edge[MAX<<2];\n\nvoid add_edge(int u, int v) {\n    edge[u].push_back(Info(v, edge[v].size(), 1));\n    edge[v].push_back(Info(u, edge[u].size()-1, 0));\n}\n\nint prevv[MAX<<2]; //存每个节点的前驱节点\nint preve[MAX<<2]; //当前节点是前驱节点的第几条边连接的\nint flow[MAX<<2]; //当前节点的流量\n\nint bfs(int src, int des) {\n    queue<int> q;\n    q.push(src);\n    memset(prevv, -1, sizeof(prevv));\n    memset(preve, -1, sizeof(preve));\n    memset(flow, 0, sizeof(flow));\n    prevv[src] = 0;\n    flow[src] = INF; //初始化起点流量为正无穷\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (u == des) break;\n        for (int i =0; i < edge[u].size(); i++) {\n            Info & e = edge[u][i];\n            //如果有前驱节点，说明已经走过了，就不加入队列了\n            if (e.cap > 0 && prevv[e.to] == -1) {\n                prevv[e.to] = u;\n                preve[e.to] = i;\n                //限制流量\n                flow[e.to] = min(e.cap, flow[u]);\n                q.push(e.to);\n            }\n        }\n    }\n    if (prevv[des] == -1) return -1;\n    else return flow[des];\n}\n\nint max_flow(int src, int des) {\n    int sumflow = 0, aug;\n    while ((aug =bfs(src, des)) != -1) {\n        int k = des;\n        //遍历增广的路径\n        while (k != src) {\n            int last = prevv[k];\n            //让路径上的边的容量减少，反向边流量增加\n            edge[last][preve[k]].cap -= aug;\n            edge[k][edge[last][preve[k]].rev].cap += aug;\n            k = last;\n        }\n        sumflow += aug;\n    }\n    return sumflow;\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &N, &F, &D)) {\n        for (int i = 0; i <= N + F + D + 1; i++) edge[i].clear();\n        for (int i = 1; i <= N; i++) {\n            int f, d, v;\n            scanf(\"%d %d\", &f, &d);\n            for (int j = 1; j <= f; j++) {\n                scanf(\"%d\", &v);\n                v += N*2;\n                add_edge(v, i);\n            }\n            for (int j = 1; j <= d; j++) {\n                scanf(\"%d\", &v);\n                v += N*2 + F;\n                add_edge(i+N, v);\n            }\n        }\n        for (int i = 1; i <= N; i++) {\n            add_edge(i, i+N);\n        }\n        for (int i = 1; i <= F; i++) {\n            int v = i + N*2;\n            add_edge(0, v);\n        }\n        for (int i = 1; i <= D; i++) {\n            int v = i + N*2 + F;\n            add_edge(v, N*2+F+D+1);\n        }\n        printf(\"%d\\n\", max_flow(0, N*2+F+D+1));\n    }\n}\n```","source":"_posts/POJ3281-Dining（EK最大流-模板）.md","raw":"---\ntitle: POJ3281 - Dining（EK最大流+模板）\ndate: 2017-07-26 10:40:33\ncategories: [ACM, 图论, 网络流]\ntags:\n---\n# 题目链接：\nhttp://poj.org/problem?id=3281\n\n--------------------\n# 题目大意：\n有$N$个牛，$D$种饮料，$F$种食物，每种牛有$D_i$种想喝的饮料，$F_i$种想吃的食物，每种饮料和食物只能分配给一只牛，问最大能使多少头牛满足同时得到喜欢的饮料和喜欢的食物。\n\n-------------------------------\n# 解题过程：\n\n还是挺好想的，一下子就想到了，然后2000长度1A美滋滋。\n\n-------------------------------\n# 题目分析：\n\n先把每头牛拆成两个点，一个入点，一个出点，连一个容量为1的边。然后在把每头牛想要的食物与他的入点连上，每头牛想要的饮料和他的出点连上。\n\n再建一个原点和终点，原点连上所有的食物，终点连上所有的饮料，最后跑一个最大流就可以了。上述所有的连边容量都是1。\n\n这样建图保证，对于每一个增广路的流量都为$1$，并且都经过一头牛，一个饮料，一个食物，并且每头牛只得到过一次饮料和食物，保证不会重复计算。\n\n\n----------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX = 112;\nconst int INF = 0x3f3f3f3f;\n\nint N, F, D;\n\nstruct Info {\n    int to, rev, cap;\n    Info(int to, int rev, int cap):to(to), rev(rev), cap(cap){}\n};\n\nvector<Info> edge[MAX<<2];\n\nvoid add_edge(int u, int v) {\n    edge[u].push_back(Info(v, edge[v].size(), 1));\n    edge[v].push_back(Info(u, edge[u].size()-1, 0));\n}\n\nint prevv[MAX<<2]; //存每个节点的前驱节点\nint preve[MAX<<2]; //当前节点是前驱节点的第几条边连接的\nint flow[MAX<<2]; //当前节点的流量\n\nint bfs(int src, int des) {\n    queue<int> q;\n    q.push(src);\n    memset(prevv, -1, sizeof(prevv));\n    memset(preve, -1, sizeof(preve));\n    memset(flow, 0, sizeof(flow));\n    prevv[src] = 0;\n    flow[src] = INF; //初始化起点流量为正无穷\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (u == des) break;\n        for (int i =0; i < edge[u].size(); i++) {\n            Info & e = edge[u][i];\n            //如果有前驱节点，说明已经走过了，就不加入队列了\n            if (e.cap > 0 && prevv[e.to] == -1) {\n                prevv[e.to] = u;\n                preve[e.to] = i;\n                //限制流量\n                flow[e.to] = min(e.cap, flow[u]);\n                q.push(e.to);\n            }\n        }\n    }\n    if (prevv[des] == -1) return -1;\n    else return flow[des];\n}\n\nint max_flow(int src, int des) {\n    int sumflow = 0, aug;\n    while ((aug =bfs(src, des)) != -1) {\n        int k = des;\n        //遍历增广的路径\n        while (k != src) {\n            int last = prevv[k];\n            //让路径上的边的容量减少，反向边流量增加\n            edge[last][preve[k]].cap -= aug;\n            edge[k][edge[last][preve[k]].rev].cap += aug;\n            k = last;\n        }\n        sumflow += aug;\n    }\n    return sumflow;\n}\n\nint main() {\n    while (~scanf(\"%d %d %d\", &N, &F, &D)) {\n        for (int i = 0; i <= N + F + D + 1; i++) edge[i].clear();\n        for (int i = 1; i <= N; i++) {\n            int f, d, v;\n            scanf(\"%d %d\", &f, &d);\n            for (int j = 1; j <= f; j++) {\n                scanf(\"%d\", &v);\n                v += N*2;\n                add_edge(v, i);\n            }\n            for (int j = 1; j <= d; j++) {\n                scanf(\"%d\", &v);\n                v += N*2 + F;\n                add_edge(i+N, v);\n            }\n        }\n        for (int i = 1; i <= N; i++) {\n            add_edge(i, i+N);\n        }\n        for (int i = 1; i <= F; i++) {\n            int v = i + N*2;\n            add_edge(0, v);\n        }\n        for (int i = 1; i <= D; i++) {\n            int v = i + N*2 + F;\n            add_edge(v, N*2+F+D+1);\n        }\n        printf(\"%d\\n\", max_flow(0, N*2+F+D+1));\n    }\n}\n```","slug":"POJ3281-Dining（EK最大流-模板）","published":1,"updated":"2017-07-26T03:19:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nd2003ty9id1vujp0kw","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=3281\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3281</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>有$N$个牛，$D$种饮料，$F$种食物，每种牛有$D_i$种想喝的饮料，$F_i$种想吃的食物，每种饮料和食物只能分配给一只牛，问最大能使多少头牛满足同时得到喜欢的饮料和喜欢的食物。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>还是挺好想的，一下子就想到了，然后2000长度1A美滋滋。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先把每头牛拆成两个点，一个入点，一个出点，连一个容量为1的边。然后在把每头牛想要的食物与他的入点连上，每头牛想要的饮料和他的出点连上。</p>\n<p>再建一个原点和终点，原点连上所有的食物，终点连上所有的饮料，最后跑一个最大流就可以了。上述所有的连边容量都是1。</p>\n<p>这样建图保证，对于每一个增广路的流量都为$1$，并且都经过一头牛，一个饮料，一个食物，并且每头牛只得到过一次饮料和食物，保证不会重复计算。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, F, D;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, rev, cap;</div><div class=\"line\">    Info(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> rev, <span class=\"keyword\">int</span> cap):to(to), rev(rev), cap(cap)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Info&gt; edge[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[u].push_back(Info(v, edge[v].size(), <span class=\"number\">1</span>));</div><div class=\"line\">    edge[v].push_back(Info(u, edge[u].size()<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> prevv[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//存每个节点的前驱节点</span></div><div class=\"line\"><span class=\"keyword\">int</span> preve[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//当前节点是前驱节点的第几条边连接的</span></div><div class=\"line\"><span class=\"keyword\">int</span> flow[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//当前节点的流量</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> src, <span class=\"keyword\">int</span> des)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(src);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(prevv, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(prevv));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(preve, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(preve));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(flow, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flow));</div><div class=\"line\">    prevv[src] = <span class=\"number\">0</span>;</div><div class=\"line\">    flow[src] = INF; <span class=\"comment\">//初始化起点流量为正无穷</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (u == des) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            Info &amp; e = edge[u][i];</div><div class=\"line\">            <span class=\"comment\">//如果有前驱节点，说明已经走过了，就不加入队列了</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (e.cap &gt; <span class=\"number\">0</span> &amp;&amp; prevv[e.to] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                prevv[e.to] = u;</div><div class=\"line\">                preve[e.to] = i;</div><div class=\"line\">                <span class=\"comment\">//限制流量</span></div><div class=\"line\">                flow[e.to] = min(e.cap, flow[u]);</div><div class=\"line\">                q.push(e.to);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prevv[des] == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> flow[des];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> src, <span class=\"keyword\">int</span> des)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sumflow = <span class=\"number\">0</span>, aug;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((aug =bfs(src, des)) != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = des;</div><div class=\"line\">        <span class=\"comment\">//遍历增广的路径</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (k != src) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = prevv[k];</div><div class=\"line\">            <span class=\"comment\">//让路径上的边的容量减少，反向边流量增加</span></div><div class=\"line\">            edge[last][preve[k]].cap -= aug;</div><div class=\"line\">            edge[k][edge[last][preve[k]].rev].cap += aug;</div><div class=\"line\">            k = last;</div><div class=\"line\">        &#125;</div><div class=\"line\">        sumflow += aug;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sumflow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;F, &amp;D)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N + F + D + <span class=\"number\">1</span>; i++) edge[i].clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> f, d, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;f, &amp;d);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= f; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;v);</div><div class=\"line\">                v += N*<span class=\"number\">2</span>;</div><div class=\"line\">                add_edge(v, i);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= d; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;v);</div><div class=\"line\">                v += N*<span class=\"number\">2</span> + F;</div><div class=\"line\">                add_edge(i+N, v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            add_edge(i, i+N);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= F; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = i + N*<span class=\"number\">2</span>;</div><div class=\"line\">            add_edge(<span class=\"number\">0</span>, v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= D; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = i + N*<span class=\"number\">2</span> + F;</div><div class=\"line\">            add_edge(v, N*<span class=\"number\">2</span>+F+D+<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(<span class=\"number\">0</span>, N*<span class=\"number\">2</span>+F+D+<span class=\"number\">1</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=3281\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3281</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>有$N$个牛，$D$种饮料，$F$种食物，每种牛有$D_i$种想喝的饮料，$F_i$种想吃的食物，每种饮料和食物只能分配给一只牛，问最大能使多少头牛满足同时得到喜欢的饮料和喜欢的食物。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>还是挺好想的，一下子就想到了，然后2000长度1A美滋滋。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先把每头牛拆成两个点，一个入点，一个出点，连一个容量为1的边。然后在把每头牛想要的食物与他的入点连上，每头牛想要的饮料和他的出点连上。</p>\n<p>再建一个原点和终点，原点连上所有的食物，终点连上所有的饮料，最后跑一个最大流就可以了。上述所有的连边容量都是1。</p>\n<p>这样建图保证，对于每一个增广路的流量都为$1$，并且都经过一头牛，一个饮料，一个食物，并且每头牛只得到过一次饮料和食物，保证不会重复计算。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> N, F, D;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> to, rev, cap;</div><div class=\"line\">    Info(<span class=\"keyword\">int</span> to, <span class=\"keyword\">int</span> rev, <span class=\"keyword\">int</span> cap):to(to), rev(rev), cap(cap)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Info&gt; edge[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[u].push_back(Info(v, edge[v].size(), <span class=\"number\">1</span>));</div><div class=\"line\">    edge[v].push_back(Info(u, edge[u].size()<span class=\"number\">-1</span>, <span class=\"number\">0</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> prevv[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//存每个节点的前驱节点</span></div><div class=\"line\"><span class=\"keyword\">int</span> preve[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//当前节点是前驱节点的第几条边连接的</span></div><div class=\"line\"><span class=\"keyword\">int</span> flow[MAX&lt;&lt;<span class=\"number\">2</span>]; <span class=\"comment\">//当前节点的流量</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> src, <span class=\"keyword\">int</span> des)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(src);</div><div class=\"line\">    <span class=\"built_in\">memset</span>(prevv, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(prevv));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(preve, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(preve));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(flow, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flow));</div><div class=\"line\">    prevv[src] = <span class=\"number\">0</span>;</div><div class=\"line\">    flow[src] = INF; <span class=\"comment\">//初始化起点流量为正无穷</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front(); q.pop();</div><div class=\"line\">        <span class=\"keyword\">if</span> (u == des) <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>; i &lt; edge[u].size(); i++) &#123;</div><div class=\"line\">            Info &amp; e = edge[u][i];</div><div class=\"line\">            <span class=\"comment\">//如果有前驱节点，说明已经走过了，就不加入队列了</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (e.cap &gt; <span class=\"number\">0</span> &amp;&amp; prevv[e.to] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                prevv[e.to] = u;</div><div class=\"line\">                preve[e.to] = i;</div><div class=\"line\">                <span class=\"comment\">//限制流量</span></div><div class=\"line\">                flow[e.to] = min(e.cap, flow[u]);</div><div class=\"line\">                q.push(e.to);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prevv[des] == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> flow[des];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> src, <span class=\"keyword\">int</span> des)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sumflow = <span class=\"number\">0</span>, aug;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((aug =bfs(src, des)) != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = des;</div><div class=\"line\">        <span class=\"comment\">//遍历增广的路径</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (k != src) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> last = prevv[k];</div><div class=\"line\">            <span class=\"comment\">//让路径上的边的容量减少，反向边流量增加</span></div><div class=\"line\">            edge[last][preve[k]].cap -= aug;</div><div class=\"line\">            edge[k][edge[last][preve[k]].rev].cap += aug;</div><div class=\"line\">            k = last;</div><div class=\"line\">        &#125;</div><div class=\"line\">        sumflow += aug;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sumflow;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;N, &amp;F, &amp;D)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N + F + D + <span class=\"number\">1</span>; i++) edge[i].clear();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> f, d, v;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;f, &amp;d);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= f; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;v);</div><div class=\"line\">                v += N*<span class=\"number\">2</span>;</div><div class=\"line\">                add_edge(v, i);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= d; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;v);</div><div class=\"line\">                v += N*<span class=\"number\">2</span> + F;</div><div class=\"line\">                add_edge(i+N, v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            add_edge(i, i+N);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= F; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = i + N*<span class=\"number\">2</span>;</div><div class=\"line\">            add_edge(<span class=\"number\">0</span>, v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= D; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = i + N*<span class=\"number\">2</span> + F;</div><div class=\"line\">            add_edge(v, N*<span class=\"number\">2</span>+F+D+<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, max_flow(<span class=\"number\">0</span>, N*<span class=\"number\">2</span>+F+D+<span class=\"number\">1</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪)）","date":"2017-01-03T14:53:22.000Z","_content":"# 需求：\n\n - 把自己之前在contest里面的代码提取出来。\n - 实现批量提交contest和problem里面的题目。\n - \n\n\n----------\n# 过程：\n总共大概花了4个小时，一晚上，一个类一个文件的方法写起来真的爽，一晚上没停住手。\n自己首先写的是下载器，首先明确需求。\n\n - 可以模拟登陆。\n - 可以post请求。\n - 可以下载网页。\n - 为了省事，把提交题目的功能也整合里面了。\n\n代码如下，实现起来没啥困难，毕竟已经是轻车熟路了。\n\n```python\n# coding:utf8\nimport  urllib2\nimport cookielib\nimport urllib\n\nclass Down(object):\n\n    def __init__(self):\n        #初始化常用网址\n        self.login_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'\n        self.home_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home'\n        self.submit_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'\n\n        #安装cookie处理\n        cj = cookielib.CookieJar()\n        cookie_support = urllib2.HTTPCookieProcessor(cj)\n        opener = urllib2.build_opener(cookie_support)\n        urllib2.install_opener(opener)\n\n        #初始化cookie\n        home_temp = urllib2.urlopen(self.home_url)\n\n        self.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36',\n            'Referer': 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login',\n            'Host': 'acm.sdut.edu.cn'}\n\n        self.login()\n\n    def post(self, url, post_data = None):\n        #下载网页和POST请求\n        if post_data is None:\n            request = urllib2.Request(url, headers = self.headers)\n            response = urllib2.urlopen(request)\n            return response.read()\n        else:\n            post_data = urllib.urlencode(post_data)\n            request = urllib2.Request(url, post_data, self.headers)\n            response = urllib2.urlopen(request)\n            return  response\n\n    def login(self, user = 'Fish', password = '123456'):\n        #登陆信息\n        post_data = {'user_name': user, 'password':password }\n        self.post(self.login_url, post_data)\n\n    def submit(self, pid, code, language = 'g++', cid = None):\n        if cid == None:\n            post_data = {'pid': pid, 'code': code, 'lang' : language}\n            self.post(self.submit_url, post_data)\n\n\nif __name__ == '__main__':\n    test = Down()\n    print test.post('http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html')\n```\n\n 然后是网页分析器，这里我由内到外的写的，首先需求是给定一个贴着代码的网页，把代码爬下来。\n 下一步需求是给定一个status，把AC的代码记录的链接爬下来发给上一步的爬取代码的函数。\n 最后是给定一个比赛的cid，找到ranklist链接并且找到自己的status页面发给上一步实现的处理。\n\n这样做的好处就是每一步都可以单独调试，每一个函数写起来，它需要调用的函数已经写完调试好了。\n\n这里麻烦点的就是status页面的处理，最后返回数据的时候我按（代码，题号）的二元组构成的列表返回的。\n\n```python\n# coding:utf8\nfrom bs4 import BeautifulSoup\nimport html5lib\nimport Down\nimport time\n\nclass ReadCode(object):\n\n    def __init__(self):\n        self.data = []\n        self.downer = Down.Down()\n\n    def read_code(self, html):\n        soup = BeautifulSoup(html, \"html5lib\")\n        time.sleep(0.01)\n        return soup.find('pre').text\n\n    def read_status(self, html):\n        soup = BeautifulSoup(html, \"html5lib\")\n        table = soup.find_all('tr')\n\n        tdata = []\n\n        #读取每一个提交信息\n        for tr in table:\n            try:\n                tr = tr.find_all('td')\n                if tr[3].text == \"Accepted\" and (tr[6].text == \"g++\" or tr[6].text == \"gcc\"):\n                    temp =  'http://acm.sdut.edu.cn/' + tr[6].a['href'], tr[2].a['href'][-9:-5]\n                    print temp[1]\n                    tdata.append(temp)\n            except:\n                pass\n\n        #读取代码\n        for temp in tdata:\n            html = self.downer.post(temp[0])\n            ans = self.read_code(html)\n            self.data.append((ans,temp[1]))\n\n        #读取下一页\n        try:\n            url = 'http://acm.sdut.edu.cn/' + soup.find(class_ = 'next')['href']\n            html = self.downer.post(url)\n            self.read_status(html)\n        except:\n            pass\n\n    def read_rank(self, cid):\n        html = self.downer.post('http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestranklist/cid/'+str(cid))\n        soup = BeautifulSoup(html, \"html5lib\")\n\n        #找到个人的status页面并读取\n        try:\n            print cid\n            url = 'http://acm.sdut.edu.cn' + soup.find(text = \"jk160801李东庆\").parent.parent.find_all('td')[2].a['href']\n            html = self.downer.post(url)\n            self.read_status(html)\n        except:\n            pass\n\nif __name__ == '__main__':\n    test = ReadCode()\n    print test.data\n```\n\n最后是一个Main调度一下，顺便实现了读写到文件的功能。\n（这里有个玄学的小细节，代码中也备注了）\n\n```python\n# coding:utf8\nimport Down\nimport ReadCode\nimport  urllib2\nimport cookielib\nimport urllib\n\n#改下输出流的编码？玄学\nimport sys\nreload(sys)\nsys.setdefaultencoding( \"utf-8\" )\n\nclass Main(object):\n\n    def __init__(self):\n        self.data = []\n        self.reader = ReadCode.ReadCode()\n        self.cid = 0\n\n    def read_contest(self, cid):\n        self.cid = cid\n        self.reader.read_rank(cid)\n        self.data += self.reader.data\n        self.reader.data = []\n\n    def output(self):\n        for temp in self.data:\n            f = open('code/'+temp[1], 'w')\n            f.write(temp[0])\n            print self.cid, temp[1]\n        self.data = []\n\nif __name__ == '__main__':\n    oj = Main()\n    for cid in range (1828, 1976):\n        oj.read_contest(cid)\n        oj.output()\n```\n\n最后实现批量提交的时候自己又写了一下提交的函数，之前下载器里面的太弱了，当然这里也调用了下载器，比赛提交的代码的时候是暴力了点...\n（当然这个提交器是利用了之前爬下来的代码）\n\n```python\n# coding:utf8\nimport Down\nimport time\n\nclass Submit(object):\n    def __init__(self):\n        self.downer = Down.Down()\n\n    def submit_problem(self, pid ,url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1000.html', cid = 233):\n        try:\n            f = open('code/'+str(pid), \"r\")\n            code = f.read()\n            post_data = {'pid':pid, 'lang':'g++', 'code':code}\n            self.downer.post(url, post_data)\n            post_data = {'pid': pid, 'lang': 'g++', 'code': code, 'cid':cid}\n            self.downer.post(url, post_data)\n\n            print cid,pid\n            time.sleep(0.01)\n        except:\n            pass\n\n    def submit_contest(self, cid):\n        url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestsubmit/cid/' + str(cid) + '/pid/'\n        for pid in range(1000, 3764):\n            try:\n                self.submit_problem(pid, url+ str(pid) + '.html', cid = cid)\n            except:\n                pass\n\nif __name__ == '__main__':\n    submiter = Submit()\n    for cid in range(1875, 1881):\n        submiter.submit_contest(cid)\n```\n#效果：\n![这里写图片描述](http://img.blog.csdn.net/20170103225156166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20170103225322323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n大概就是爬下来了200+个自己的代码，然后给小号刷了一下，一键AC（笑","source":"_posts/Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪-）.md","raw":"---\ntitle: Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪)）\ndate: 2017-01-03 22:53:22\ncategories: [爬虫&数据处理]\ntags:\n---\n# 需求：\n\n - 把自己之前在contest里面的代码提取出来。\n - 实现批量提交contest和problem里面的题目。\n - \n\n\n----------\n# 过程：\n总共大概花了4个小时，一晚上，一个类一个文件的方法写起来真的爽，一晚上没停住手。\n自己首先写的是下载器，首先明确需求。\n\n - 可以模拟登陆。\n - 可以post请求。\n - 可以下载网页。\n - 为了省事，把提交题目的功能也整合里面了。\n\n代码如下，实现起来没啥困难，毕竟已经是轻车熟路了。\n\n```python\n# coding:utf8\nimport  urllib2\nimport cookielib\nimport urllib\n\nclass Down(object):\n\n    def __init__(self):\n        #初始化常用网址\n        self.login_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'\n        self.home_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home'\n        self.submit_url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'\n\n        #安装cookie处理\n        cj = cookielib.CookieJar()\n        cookie_support = urllib2.HTTPCookieProcessor(cj)\n        opener = urllib2.build_opener(cookie_support)\n        urllib2.install_opener(opener)\n\n        #初始化cookie\n        home_temp = urllib2.urlopen(self.home_url)\n\n        self.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36',\n            'Referer': 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login',\n            'Host': 'acm.sdut.edu.cn'}\n\n        self.login()\n\n    def post(self, url, post_data = None):\n        #下载网页和POST请求\n        if post_data is None:\n            request = urllib2.Request(url, headers = self.headers)\n            response = urllib2.urlopen(request)\n            return response.read()\n        else:\n            post_data = urllib.urlencode(post_data)\n            request = urllib2.Request(url, post_data, self.headers)\n            response = urllib2.urlopen(request)\n            return  response\n\n    def login(self, user = 'Fish', password = '123456'):\n        #登陆信息\n        post_data = {'user_name': user, 'password':password }\n        self.post(self.login_url, post_data)\n\n    def submit(self, pid, code, language = 'g++', cid = None):\n        if cid == None:\n            post_data = {'pid': pid, 'code': code, 'lang' : language}\n            self.post(self.submit_url, post_data)\n\n\nif __name__ == '__main__':\n    test = Down()\n    print test.post('http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html')\n```\n\n 然后是网页分析器，这里我由内到外的写的，首先需求是给定一个贴着代码的网页，把代码爬下来。\n 下一步需求是给定一个status，把AC的代码记录的链接爬下来发给上一步的爬取代码的函数。\n 最后是给定一个比赛的cid，找到ranklist链接并且找到自己的status页面发给上一步实现的处理。\n\n这样做的好处就是每一步都可以单独调试，每一个函数写起来，它需要调用的函数已经写完调试好了。\n\n这里麻烦点的就是status页面的处理，最后返回数据的时候我按（代码，题号）的二元组构成的列表返回的。\n\n```python\n# coding:utf8\nfrom bs4 import BeautifulSoup\nimport html5lib\nimport Down\nimport time\n\nclass ReadCode(object):\n\n    def __init__(self):\n        self.data = []\n        self.downer = Down.Down()\n\n    def read_code(self, html):\n        soup = BeautifulSoup(html, \"html5lib\")\n        time.sleep(0.01)\n        return soup.find('pre').text\n\n    def read_status(self, html):\n        soup = BeautifulSoup(html, \"html5lib\")\n        table = soup.find_all('tr')\n\n        tdata = []\n\n        #读取每一个提交信息\n        for tr in table:\n            try:\n                tr = tr.find_all('td')\n                if tr[3].text == \"Accepted\" and (tr[6].text == \"g++\" or tr[6].text == \"gcc\"):\n                    temp =  'http://acm.sdut.edu.cn/' + tr[6].a['href'], tr[2].a['href'][-9:-5]\n                    print temp[1]\n                    tdata.append(temp)\n            except:\n                pass\n\n        #读取代码\n        for temp in tdata:\n            html = self.downer.post(temp[0])\n            ans = self.read_code(html)\n            self.data.append((ans,temp[1]))\n\n        #读取下一页\n        try:\n            url = 'http://acm.sdut.edu.cn/' + soup.find(class_ = 'next')['href']\n            html = self.downer.post(url)\n            self.read_status(html)\n        except:\n            pass\n\n    def read_rank(self, cid):\n        html = self.downer.post('http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestranklist/cid/'+str(cid))\n        soup = BeautifulSoup(html, \"html5lib\")\n\n        #找到个人的status页面并读取\n        try:\n            print cid\n            url = 'http://acm.sdut.edu.cn' + soup.find(text = \"jk160801李东庆\").parent.parent.find_all('td')[2].a['href']\n            html = self.downer.post(url)\n            self.read_status(html)\n        except:\n            pass\n\nif __name__ == '__main__':\n    test = ReadCode()\n    print test.data\n```\n\n最后是一个Main调度一下，顺便实现了读写到文件的功能。\n（这里有个玄学的小细节，代码中也备注了）\n\n```python\n# coding:utf8\nimport Down\nimport ReadCode\nimport  urllib2\nimport cookielib\nimport urllib\n\n#改下输出流的编码？玄学\nimport sys\nreload(sys)\nsys.setdefaultencoding( \"utf-8\" )\n\nclass Main(object):\n\n    def __init__(self):\n        self.data = []\n        self.reader = ReadCode.ReadCode()\n        self.cid = 0\n\n    def read_contest(self, cid):\n        self.cid = cid\n        self.reader.read_rank(cid)\n        self.data += self.reader.data\n        self.reader.data = []\n\n    def output(self):\n        for temp in self.data:\n            f = open('code/'+temp[1], 'w')\n            f.write(temp[0])\n            print self.cid, temp[1]\n        self.data = []\n\nif __name__ == '__main__':\n    oj = Main()\n    for cid in range (1828, 1976):\n        oj.read_contest(cid)\n        oj.output()\n```\n\n最后实现批量提交的时候自己又写了一下提交的函数，之前下载器里面的太弱了，当然这里也调用了下载器，比赛提交的代码的时候是暴力了点...\n（当然这个提交器是利用了之前爬下来的代码）\n\n```python\n# coding:utf8\nimport Down\nimport time\n\nclass Submit(object):\n    def __init__(self):\n        self.downer = Down.Down()\n\n    def submit_problem(self, pid ,url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1000.html', cid = 233):\n        try:\n            f = open('code/'+str(pid), \"r\")\n            code = f.read()\n            post_data = {'pid':pid, 'lang':'g++', 'code':code}\n            self.downer.post(url, post_data)\n            post_data = {'pid': pid, 'lang': 'g++', 'code': code, 'cid':cid}\n            self.downer.post(url, post_data)\n\n            print cid,pid\n            time.sleep(0.01)\n        except:\n            pass\n\n    def submit_contest(self, cid):\n        url = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestsubmit/cid/' + str(cid) + '/pid/'\n        for pid in range(1000, 3764):\n            try:\n                self.submit_problem(pid, url+ str(pid) + '.html', cid = cid)\n            except:\n                pass\n\nif __name__ == '__main__':\n    submiter = Submit()\n    for cid in range(1875, 1881):\n        submiter.submit_contest(cid)\n```\n#效果：\n![这里写图片描述](http://img.blog.csdn.net/20170103225156166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20170103225322323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n大概就是爬下来了200+个自己的代码，然后给小号刷了一下，一键AC（笑","slug":"Python爬取SDUTOJ比赛提交代码及批量提交（爬虫（伪-）","published":1,"updated":"2017-07-23T04:02:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nd5003wy9idm4y63z5y","content":"<h1 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h1><ul>\n<li>把自己之前在contest里面的代码提取出来。</li>\n<li>实现批量提交contest和problem里面的题目。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"过程：\"><a href=\"#过程：\" class=\"headerlink\" title=\"过程：\"></a>过程：</h1><p>总共大概花了4个小时，一晚上，一个类一个文件的方法写起来真的爽，一晚上没停住手。<br>自己首先写的是下载器，首先明确需求。</p>\n<ul>\n<li>可以模拟登陆。</li>\n<li>可以post请求。</li>\n<li>可以下载网页。</li>\n<li>为了省事，把提交题目的功能也整合里面了。</li>\n</ul>\n<p>代码如下，实现起来没啥困难，毕竟已经是轻车熟路了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span>  urllib2</div><div class=\"line\"><span class=\"keyword\">import</span> cookielib</div><div class=\"line\"><span class=\"keyword\">import</span> urllib</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Down</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#初始化常用网址</span></div><div class=\"line\">        self.login_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span></div><div class=\"line\">        self.home_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home'</span></div><div class=\"line\">        self.submit_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#安装cookie处理</span></div><div class=\"line\">        cj = cookielib.CookieJar()</div><div class=\"line\">        cookie_support = urllib2.HTTPCookieProcessor(cj)</div><div class=\"line\">        opener = urllib2.build_opener(cookie_support)</div><div class=\"line\">        urllib2.install_opener(opener)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#初始化cookie</span></div><div class=\"line\">        home_temp = urllib2.urlopen(self.home_url)</div><div class=\"line\"></div><div class=\"line\">        self.headers = &#123;</div><div class=\"line\">            <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36'</span>,</div><div class=\"line\">            <span class=\"string\">'Referer'</span>: <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span>,</div><div class=\"line\">            <span class=\"string\">'Host'</span>: <span class=\"string\">'acm.sdut.edu.cn'</span>&#125;</div><div class=\"line\"></div><div class=\"line\">        self.login()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, url, post_data = None)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#下载网页和POST请求</span></div><div class=\"line\">        <span class=\"keyword\">if</span> post_data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            request = urllib2.Request(url, headers = self.headers)</div><div class=\"line\">            response = urllib2.urlopen(request)</div><div class=\"line\">            <span class=\"keyword\">return</span> response.read()</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            post_data = urllib.urlencode(post_data)</div><div class=\"line\">            request = urllib2.Request(url, post_data, self.headers)</div><div class=\"line\">            response = urllib2.urlopen(request)</div><div class=\"line\">            <span class=\"keyword\">return</span>  response</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(self, user = <span class=\"string\">'Fish'</span>, password = <span class=\"string\">'123456'</span>)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#登陆信息</span></div><div class=\"line\">        post_data = &#123;<span class=\"string\">'user_name'</span>: user, <span class=\"string\">'password'</span>:password &#125;</div><div class=\"line\">        self.post(self.login_url, post_data)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit</span><span class=\"params\">(self, pid, code, language = <span class=\"string\">'g++'</span>, cid = None)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> cid == <span class=\"keyword\">None</span>:</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>: pid, <span class=\"string\">'code'</span>: code, <span class=\"string\">'lang'</span> : language&#125;</div><div class=\"line\">            self.post(self.submit_url, post_data)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    test = Down()</div><div class=\"line\">    <span class=\"keyword\">print</span> test.post(<span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'</span>)</div></pre></td></tr></table></figure>\n<p> 然后是网页分析器，这里我由内到外的写的，首先需求是给定一个贴着代码的网页，把代码爬下来。<br> 下一步需求是给定一个status，把AC的代码记录的链接爬下来发给上一步的爬取代码的函数。<br> 最后是给定一个比赛的cid，找到ranklist链接并且找到自己的status页面发给上一步实现的处理。</p>\n<p>这样做的好处就是每一步都可以单独调试，每一个函数写起来，它需要调用的函数已经写完调试好了。</p>\n<p>这里麻烦点的就是status页面的处理，最后返回数据的时候我按（代码，题号）的二元组构成的列表返回的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</div><div class=\"line\"><span class=\"keyword\">import</span> html5lib</div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadCode</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.data = []</div><div class=\"line\">        self.downer = Down.Down()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_code</span><span class=\"params\">(self, html)</span>:</span></div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\">        time.sleep(<span class=\"number\">0.01</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> soup.find(<span class=\"string\">'pre'</span>).text</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_status</span><span class=\"params\">(self, html)</span>:</span></div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\">        table = soup.find_all(<span class=\"string\">'tr'</span>)</div><div class=\"line\"></div><div class=\"line\">        tdata = []</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取每一个提交信息</span></div><div class=\"line\">        <span class=\"keyword\">for</span> tr <span class=\"keyword\">in</span> table:</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                tr = tr.find_all(<span class=\"string\">'td'</span>)</div><div class=\"line\">                <span class=\"keyword\">if</span> tr[<span class=\"number\">3</span>].text == <span class=\"string\">\"Accepted\"</span> <span class=\"keyword\">and</span> (tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"g++\"</span> <span class=\"keyword\">or</span> tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"gcc\"</span>):</div><div class=\"line\">                    temp =  <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + tr[<span class=\"number\">6</span>].a[<span class=\"string\">'href'</span>], tr[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>][<span class=\"number\">-9</span>:<span class=\"number\">-5</span>]</div><div class=\"line\">                    <span class=\"keyword\">print</span> temp[<span class=\"number\">1</span>]</div><div class=\"line\">                    tdata.append(temp)</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取代码</span></div><div class=\"line\">        <span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> tdata:</div><div class=\"line\">            html = self.downer.post(temp[<span class=\"number\">0</span>])</div><div class=\"line\">            ans = self.read_code(html)</div><div class=\"line\">            self.data.append((ans,temp[<span class=\"number\">1</span>]))</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取下一页</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            url = <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + soup.find(class_ = <span class=\"string\">'next'</span>)[<span class=\"string\">'href'</span>]</div><div class=\"line\">            html = self.downer.post(url)</div><div class=\"line\">            self.read_status(html)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_rank</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        html = self.downer.post(<span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestranklist/cid/'</span>+str(cid))</div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#找到个人的status页面并读取</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">print</span> cid</div><div class=\"line\">            url = <span class=\"string\">'http://acm.sdut.edu.cn'</span> + soup.find(text = <span class=\"string\">\"jk160801李东庆\"</span>).parent.parent.find_all(<span class=\"string\">'td'</span>)[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>]</div><div class=\"line\">            html = self.downer.post(url)</div><div class=\"line\">            self.read_status(html)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    test = ReadCode()</div><div class=\"line\">    <span class=\"keyword\">print</span> test.data</div></pre></td></tr></table></figure>\n<p>最后是一个Main调度一下，顺便实现了读写到文件的功能。<br>（这里有个玄学的小细节，代码中也备注了）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> ReadCode</div><div class=\"line\"><span class=\"keyword\">import</span>  urllib2</div><div class=\"line\"><span class=\"keyword\">import</span> cookielib</div><div class=\"line\"><span class=\"keyword\">import</span> urllib</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#改下输出流的编码？玄学</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">reload(sys)</div><div class=\"line\">sys.setdefaultencoding( <span class=\"string\">\"utf-8\"</span> )</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.data = []</div><div class=\"line\">        self.reader = ReadCode.ReadCode()</div><div class=\"line\">        self.cid = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_contest</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        self.cid = cid</div><div class=\"line\">        self.reader.read_rank(cid)</div><div class=\"line\">        self.data += self.reader.data</div><div class=\"line\">        self.reader.data = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">output</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> self.data:</div><div class=\"line\">            f = open(<span class=\"string\">'code/'</span>+temp[<span class=\"number\">1</span>], <span class=\"string\">'w'</span>)</div><div class=\"line\">            f.write(temp[<span class=\"number\">0</span>])</div><div class=\"line\">            <span class=\"keyword\">print</span> self.cid, temp[<span class=\"number\">1</span>]</div><div class=\"line\">        self.data = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    oj = Main()</div><div class=\"line\">    <span class=\"keyword\">for</span> cid <span class=\"keyword\">in</span> range (<span class=\"number\">1828</span>, <span class=\"number\">1976</span>):</div><div class=\"line\">        oj.read_contest(cid)</div><div class=\"line\">        oj.output()</div></pre></td></tr></table></figure>\n<p>最后实现批量提交的时候自己又写了一下提交的函数，之前下载器里面的太弱了，当然这里也调用了下载器，比赛提交的代码的时候是暴力了点…<br>（当然这个提交器是利用了之前爬下来的代码）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Submit</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.downer = Down.Down()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit_problem</span><span class=\"params\">(self, pid ,url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1000.html'</span>, cid = <span class=\"number\">233</span>)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            f = open(<span class=\"string\">'code/'</span>+str(pid), <span class=\"string\">\"r\"</span>)</div><div class=\"line\">            code = f.read()</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>:pid, <span class=\"string\">'lang'</span>:<span class=\"string\">'g++'</span>, <span class=\"string\">'code'</span>:code&#125;</div><div class=\"line\">            self.downer.post(url, post_data)</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>: pid, <span class=\"string\">'lang'</span>: <span class=\"string\">'g++'</span>, <span class=\"string\">'code'</span>: code, <span class=\"string\">'cid'</span>:cid&#125;</div><div class=\"line\">            self.downer.post(url, post_data)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">print</span> cid,pid</div><div class=\"line\">            time.sleep(<span class=\"number\">0.01</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit_contest</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestsubmit/cid/'</span> + str(cid) + <span class=\"string\">'/pid/'</span></div><div class=\"line\">        <span class=\"keyword\">for</span> pid <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>, <span class=\"number\">3764</span>):</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                self.submit_problem(pid, url+ str(pid) + <span class=\"string\">'.html'</span>, cid = cid)</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    submiter = Submit()</div><div class=\"line\">    <span class=\"keyword\">for</span> cid <span class=\"keyword\">in</span> range(<span class=\"number\">1875</span>, <span class=\"number\">1881</span>):</div><div class=\"line\">        submiter.submit_contest(cid)</div></pre></td></tr></table></figure>\n<p>#效果：<br><img src=\"http://img.blog.csdn.net/20170103225156166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20170103225322323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>大概就是爬下来了200+个自己的代码，然后给小号刷了一下，一键AC（笑</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h1><ul>\n<li>把自己之前在contest里面的代码提取出来。</li>\n<li>实现批量提交contest和problem里面的题目。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"过程：\"><a href=\"#过程：\" class=\"headerlink\" title=\"过程：\"></a>过程：</h1><p>总共大概花了4个小时，一晚上，一个类一个文件的方法写起来真的爽，一晚上没停住手。<br>自己首先写的是下载器，首先明确需求。</p>\n<ul>\n<li>可以模拟登陆。</li>\n<li>可以post请求。</li>\n<li>可以下载网页。</li>\n<li>为了省事，把提交题目的功能也整合里面了。</li>\n</ul>\n<p>代码如下，实现起来没啥困难，毕竟已经是轻车熟路了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span>  urllib2</div><div class=\"line\"><span class=\"keyword\">import</span> cookielib</div><div class=\"line\"><span class=\"keyword\">import</span> urllib</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Down</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#初始化常用网址</span></div><div class=\"line\">        self.login_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span></div><div class=\"line\">        self.home_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home'</span></div><div class=\"line\">        self.submit_url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#安装cookie处理</span></div><div class=\"line\">        cj = cookielib.CookieJar()</div><div class=\"line\">        cookie_support = urllib2.HTTPCookieProcessor(cj)</div><div class=\"line\">        opener = urllib2.build_opener(cookie_support)</div><div class=\"line\">        urllib2.install_opener(opener)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#初始化cookie</span></div><div class=\"line\">        home_temp = urllib2.urlopen(self.home_url)</div><div class=\"line\"></div><div class=\"line\">        self.headers = &#123;</div><div class=\"line\">            <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36'</span>,</div><div class=\"line\">            <span class=\"string\">'Referer'</span>: <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span>,</div><div class=\"line\">            <span class=\"string\">'Host'</span>: <span class=\"string\">'acm.sdut.edu.cn'</span>&#125;</div><div class=\"line\"></div><div class=\"line\">        self.login()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, url, post_data = None)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#下载网页和POST请求</span></div><div class=\"line\">        <span class=\"keyword\">if</span> post_data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            request = urllib2.Request(url, headers = self.headers)</div><div class=\"line\">            response = urllib2.urlopen(request)</div><div class=\"line\">            <span class=\"keyword\">return</span> response.read()</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            post_data = urllib.urlencode(post_data)</div><div class=\"line\">            request = urllib2.Request(url, post_data, self.headers)</div><div class=\"line\">            response = urllib2.urlopen(request)</div><div class=\"line\">            <span class=\"keyword\">return</span>  response</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(self, user = <span class=\"string\">'Fish'</span>, password = <span class=\"string\">'123456'</span>)</span>:</span></div><div class=\"line\">        <span class=\"comment\">#登陆信息</span></div><div class=\"line\">        post_data = &#123;<span class=\"string\">'user_name'</span>: user, <span class=\"string\">'password'</span>:password &#125;</div><div class=\"line\">        self.post(self.login_url, post_data)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit</span><span class=\"params\">(self, pid, code, language = <span class=\"string\">'g++'</span>, cid = None)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> cid == <span class=\"keyword\">None</span>:</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>: pid, <span class=\"string\">'code'</span>: code, <span class=\"string\">'lang'</span> : language&#125;</div><div class=\"line\">            self.post(self.submit_url, post_data)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    test = Down()</div><div class=\"line\">    <span class=\"keyword\">print</span> test.post(<span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1110.html'</span>)</div></pre></td></tr></table></figure>\n<p> 然后是网页分析器，这里我由内到外的写的，首先需求是给定一个贴着代码的网页，把代码爬下来。<br> 下一步需求是给定一个status，把AC的代码记录的链接爬下来发给上一步的爬取代码的函数。<br> 最后是给定一个比赛的cid，找到ranklist链接并且找到自己的status页面发给上一步实现的处理。</p>\n<p>这样做的好处就是每一步都可以单独调试，每一个函数写起来，它需要调用的函数已经写完调试好了。</p>\n<p>这里麻烦点的就是status页面的处理，最后返回数据的时候我按（代码，题号）的二元组构成的列表返回的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</div><div class=\"line\"><span class=\"keyword\">import</span> html5lib</div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadCode</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.data = []</div><div class=\"line\">        self.downer = Down.Down()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_code</span><span class=\"params\">(self, html)</span>:</span></div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\">        time.sleep(<span class=\"number\">0.01</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> soup.find(<span class=\"string\">'pre'</span>).text</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_status</span><span class=\"params\">(self, html)</span>:</span></div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\">        table = soup.find_all(<span class=\"string\">'tr'</span>)</div><div class=\"line\"></div><div class=\"line\">        tdata = []</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取每一个提交信息</span></div><div class=\"line\">        <span class=\"keyword\">for</span> tr <span class=\"keyword\">in</span> table:</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                tr = tr.find_all(<span class=\"string\">'td'</span>)</div><div class=\"line\">                <span class=\"keyword\">if</span> tr[<span class=\"number\">3</span>].text == <span class=\"string\">\"Accepted\"</span> <span class=\"keyword\">and</span> (tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"g++\"</span> <span class=\"keyword\">or</span> tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"gcc\"</span>):</div><div class=\"line\">                    temp =  <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + tr[<span class=\"number\">6</span>].a[<span class=\"string\">'href'</span>], tr[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>][<span class=\"number\">-9</span>:<span class=\"number\">-5</span>]</div><div class=\"line\">                    <span class=\"keyword\">print</span> temp[<span class=\"number\">1</span>]</div><div class=\"line\">                    tdata.append(temp)</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取代码</span></div><div class=\"line\">        <span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> tdata:</div><div class=\"line\">            html = self.downer.post(temp[<span class=\"number\">0</span>])</div><div class=\"line\">            ans = self.read_code(html)</div><div class=\"line\">            self.data.append((ans,temp[<span class=\"number\">1</span>]))</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#读取下一页</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            url = <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + soup.find(class_ = <span class=\"string\">'next'</span>)[<span class=\"string\">'href'</span>]</div><div class=\"line\">            html = self.downer.post(url)</div><div class=\"line\">            self.read_status(html)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_rank</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        html = self.downer.post(<span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestranklist/cid/'</span>+str(cid))</div><div class=\"line\">        soup = BeautifulSoup(html, <span class=\"string\">\"html5lib\"</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">#找到个人的status页面并读取</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">print</span> cid</div><div class=\"line\">            url = <span class=\"string\">'http://acm.sdut.edu.cn'</span> + soup.find(text = <span class=\"string\">\"jk160801李东庆\"</span>).parent.parent.find_all(<span class=\"string\">'td'</span>)[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>]</div><div class=\"line\">            html = self.downer.post(url)</div><div class=\"line\">            self.read_status(html)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    test = ReadCode()</div><div class=\"line\">    <span class=\"keyword\">print</span> test.data</div></pre></td></tr></table></figure>\n<p>最后是一个Main调度一下，顺便实现了读写到文件的功能。<br>（这里有个玄学的小细节，代码中也备注了）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> ReadCode</div><div class=\"line\"><span class=\"keyword\">import</span>  urllib2</div><div class=\"line\"><span class=\"keyword\">import</span> cookielib</div><div class=\"line\"><span class=\"keyword\">import</span> urllib</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#改下输出流的编码？玄学</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">reload(sys)</div><div class=\"line\">sys.setdefaultencoding( <span class=\"string\">\"utf-8\"</span> )</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.data = []</div><div class=\"line\">        self.reader = ReadCode.ReadCode()</div><div class=\"line\">        self.cid = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_contest</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        self.cid = cid</div><div class=\"line\">        self.reader.read_rank(cid)</div><div class=\"line\">        self.data += self.reader.data</div><div class=\"line\">        self.reader.data = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">output</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> self.data:</div><div class=\"line\">            f = open(<span class=\"string\">'code/'</span>+temp[<span class=\"number\">1</span>], <span class=\"string\">'w'</span>)</div><div class=\"line\">            f.write(temp[<span class=\"number\">0</span>])</div><div class=\"line\">            <span class=\"keyword\">print</span> self.cid, temp[<span class=\"number\">1</span>]</div><div class=\"line\">        self.data = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    oj = Main()</div><div class=\"line\">    <span class=\"keyword\">for</span> cid <span class=\"keyword\">in</span> range (<span class=\"number\">1828</span>, <span class=\"number\">1976</span>):</div><div class=\"line\">        oj.read_contest(cid)</div><div class=\"line\">        oj.output()</div></pre></td></tr></table></figure>\n<p>最后实现批量提交的时候自己又写了一下提交的函数，之前下载器里面的太弱了，当然这里也调用了下载器，比赛提交的代码的时候是暴力了点…<br>（当然这个提交器是利用了之前爬下来的代码）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding:utf8</span></div><div class=\"line\"><span class=\"keyword\">import</span> Down</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Submit</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.downer = Down.Down()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit_problem</span><span class=\"params\">(self, pid ,url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Solution/submitsolution/pid/1000.html'</span>, cid = <span class=\"number\">233</span>)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            f = open(<span class=\"string\">'code/'</span>+str(pid), <span class=\"string\">\"r\"</span>)</div><div class=\"line\">            code = f.read()</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>:pid, <span class=\"string\">'lang'</span>:<span class=\"string\">'g++'</span>, <span class=\"string\">'code'</span>:code&#125;</div><div class=\"line\">            self.downer.post(url, post_data)</div><div class=\"line\">            post_data = &#123;<span class=\"string\">'pid'</span>: pid, <span class=\"string\">'lang'</span>: <span class=\"string\">'g++'</span>, <span class=\"string\">'code'</span>: code, <span class=\"string\">'cid'</span>:cid&#125;</div><div class=\"line\">            self.downer.post(url, post_data)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">print</span> cid,pid</div><div class=\"line\">            time.sleep(<span class=\"number\">0.01</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span>:</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">submit_contest</span><span class=\"params\">(self, cid)</span>:</span></div><div class=\"line\">        url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestsubmit/cid/'</span> + str(cid) + <span class=\"string\">'/pid/'</span></div><div class=\"line\">        <span class=\"keyword\">for</span> pid <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>, <span class=\"number\">3764</span>):</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                self.submit_problem(pid, url+ str(pid) + <span class=\"string\">'.html'</span>, cid = cid)</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    submiter = Submit()</div><div class=\"line\">    <span class=\"keyword\">for</span> cid <span class=\"keyword\">in</span> range(<span class=\"number\">1875</span>, <span class=\"number\">1881</span>):</div><div class=\"line\">        submiter.submit_contest(cid)</div></pre></td></tr></table></figure>\n<p>#效果：<br><img src=\"http://img.blog.csdn.net/20170103225156166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20170103225322323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>大概就是爬下来了200+个自己的代码，然后给小号刷了一下，一键AC（笑</p>\n"},{"title":"POJ3494 - Largest Submatrix of All 1’s （单调栈）","date":"2017-04-09T09:45:02.000Z","_content":"# 题目链接：\n http://poj.org/problem?id=3494\n ---------------------\n# 题目大意：\n 给定一个矩阵，里面只包含 0 和 1，求这个矩阵里所有子矩阵中值最大是多少（即矩阵内部所有的 0，1 的和）。\n \n---------------------------\n\n# 解题过程：\n 由于前几天刚做完一个单调栈的题，然后看到这个题就马上往那方面想了，但是还是不太熟练，对着模板才敲出来。\n\n---------------------\n# 题目分析：\n+ 首先处理一下数据，开一个数组，数组 `data[i][j]` 代表着以第 i 行，第 j 列结尾的连续 1 的个数（自上到下的连续，例如`data[0][j], data[1][j]`都是 1 ，那么 `data[0][j] = 1, data[1][j] = 2`）。\n+ 这样我枚举每一行，对于每一行，问题转化成了[一个典型的单调栈问题](http://poj.org/problem?id=2559)，求出所有行的最大值即是答案。\n\n\n+ 这里说一下单调栈，在本题中，如果栈为空或者当前元素直接入栈，否则将栈顶元素出栈并计算栈顶元素的面积。\n\t+ 这里的面积是计算以栈顶元素为最大高度的矩阵面积，那么栈顶元素最左边可到达的是栈中上一个比他小的数（如果栈为空就是左边界了），最右可到达是即将要入栈的数（因为比他小），这里不直接那栈顶元素的下标和当前元素的下标计算是因为可能有大小相同的元素。\n\t\n\t+ 最后栈如果不为空的话要依次出栈并计算大小，计算大小的时候以栈中上一个比他小的数为最左可到达的地方（如果栈为空就是左边界了） ，最右可到达的是有边界，因为每一个栈中的数，都比右边所有的数要小。\n\n# AC代码：\n```cpp\n#include<queue>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nconst int MAX = 2000+100;\n\nint data[MAX][MAX];\n\nint main() {\n    int m, n;\n    while (~scanf(\"%d %d\", &m, &n)) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n                if (data[i][j] != 0 && i != 0)\n                    data[i][j] += data[i-1][j];\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            stack<int> ss;\n            for (int j = 0; j < n; j++) {\n                if (ss.empty() || data[i][j] > data[i][ss.top()]) {\n                    ss.push(j);\n                } else {\n                    int start = ss.top();\n                    ss.pop();\n                    int width = ss.empty() ? j : j - ss.top()-1;\n                    ans = max(ans, data[i][start]*width);\n                    j--;\n                }\n            }\n            while (!ss.empty()) {\n                int start = ss.top();\n                ss.pop();\n                int width = ss.empty() ? n : n - ss.top() - 1;\n                ans = max(ans, data[i][start]*width);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```","source":"_posts/POJ3494-Largest-Submatrix-of-All-1’s-（单调栈）.md","raw":"---\ntitle: POJ3494 - Largest Submatrix of All 1’s （单调栈）\ndate: 2017-04-09 17:45:02\ncategories: [ACM, 数据结构, 栈]\ntags:\n---\n# 题目链接：\n http://poj.org/problem?id=3494\n ---------------------\n# 题目大意：\n 给定一个矩阵，里面只包含 0 和 1，求这个矩阵里所有子矩阵中值最大是多少（即矩阵内部所有的 0，1 的和）。\n \n---------------------------\n\n# 解题过程：\n 由于前几天刚做完一个单调栈的题，然后看到这个题就马上往那方面想了，但是还是不太熟练，对着模板才敲出来。\n\n---------------------\n# 题目分析：\n+ 首先处理一下数据，开一个数组，数组 `data[i][j]` 代表着以第 i 行，第 j 列结尾的连续 1 的个数（自上到下的连续，例如`data[0][j], data[1][j]`都是 1 ，那么 `data[0][j] = 1, data[1][j] = 2`）。\n+ 这样我枚举每一行，对于每一行，问题转化成了[一个典型的单调栈问题](http://poj.org/problem?id=2559)，求出所有行的最大值即是答案。\n\n\n+ 这里说一下单调栈，在本题中，如果栈为空或者当前元素直接入栈，否则将栈顶元素出栈并计算栈顶元素的面积。\n\t+ 这里的面积是计算以栈顶元素为最大高度的矩阵面积，那么栈顶元素最左边可到达的是栈中上一个比他小的数（如果栈为空就是左边界了），最右可到达是即将要入栈的数（因为比他小），这里不直接那栈顶元素的下标和当前元素的下标计算是因为可能有大小相同的元素。\n\t\n\t+ 最后栈如果不为空的话要依次出栈并计算大小，计算大小的时候以栈中上一个比他小的数为最左可到达的地方（如果栈为空就是左边界了） ，最右可到达的是有边界，因为每一个栈中的数，都比右边所有的数要小。\n\n# AC代码：\n```cpp\n#include<queue>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nconst int MAX = 2000+100;\n\nint data[MAX][MAX];\n\nint main() {\n    int m, n;\n    while (~scanf(\"%d %d\", &m, &n)) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n                if (data[i][j] != 0 && i != 0)\n                    data[i][j] += data[i-1][j];\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            stack<int> ss;\n            for (int j = 0; j < n; j++) {\n                if (ss.empty() || data[i][j] > data[i][ss.top()]) {\n                    ss.push(j);\n                } else {\n                    int start = ss.top();\n                    ss.pop();\n                    int width = ss.empty() ? j : j - ss.top()-1;\n                    ans = max(ans, data[i][start]*width);\n                    j--;\n                }\n            }\n            while (!ss.empty()) {\n                int start = ss.top();\n                ss.pop();\n                int width = ss.empty() ? n : n - ss.top() - 1;\n                ans = max(ans, data[i][start]*width);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n\n```","slug":"POJ3494-Largest-Submatrix-of-All-1’s-（单调栈）","published":1,"updated":"2017-07-23T02:40:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nd8003yy9iddoljiy52","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><h2 id=\"http-poj-org-problem-id-3494\"><a href=\"#http-poj-org-problem-id-3494\" class=\"headerlink\" title=\" http://poj.org/problem?id=3494\"></a> <a href=\"http://poj.org/problem?id=3494\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3494</a></h2><h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给定一个矩阵，里面只包含 0 和 1，求这个矩阵里所有子矩阵中值最大是多少（即矩阵内部所有的 0，1 的和）。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 由于前几天刚做完一个单调栈的题，然后看到这个题就马上往那方面想了，但是还是不太熟练，对着模板才敲出来。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>首先处理一下数据，开一个数组，数组 <code>data[i][j]</code> 代表着以第 i 行，第 j 列结尾的连续 1 的个数（自上到下的连续，例如<code>data[0][j], data[1][j]</code>都是 1 ，那么 <code>data[0][j] = 1, data[1][j] = 2</code>）。</li>\n<li>这样我枚举每一行，对于每一行，问题转化成了<a href=\"http://poj.org/problem?id=2559\" target=\"_blank\" rel=\"external\">一个典型的单调栈问题</a>，求出所有行的最大值即是答案。</li>\n</ul>\n<ul>\n<li><p>这里说一下单调栈，在本题中，如果栈为空或者当前元素直接入栈，否则将栈顶元素出栈并计算栈顶元素的面积。</p>\n<ul>\n<li><p>这里的面积是计算以栈顶元素为最大高度的矩阵面积，那么栈顶元素最左边可到达的是栈中上一个比他小的数（如果栈为空就是左边界了），最右可到达是即将要入栈的数（因为比他小），这里不直接那栈顶元素的下标和当前元素的下标计算是因为可能有大小相同的元素。</p>\n</li>\n<li><p>最后栈如果不为空的话要依次出栈并计算大小，计算大小的时候以栈中上一个比他小的数为最左可到达的地方（如果栈为空就是左边界了） ，最右可到达的是有边界，因为每一个栈中的数，都比右边所有的数要小。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m, n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;m, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] != <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</div><div class=\"line\">                    data[i][j] += data[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; ss;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (ss.empty() || data[i][j] &gt; data[i][ss.top()]) &#123;</div><div class=\"line\">                    ss.push(j);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> start = ss.top();</div><div class=\"line\">                    ss.pop();</div><div class=\"line\">                    <span class=\"keyword\">int</span> width = ss.empty() ? j : j - ss.top()<span class=\"number\">-1</span>;</div><div class=\"line\">                    ans = max(ans, data[i][start]*width);</div><div class=\"line\">                    j--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span> (!ss.empty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> start = ss.top();</div><div class=\"line\">                ss.pop();</div><div class=\"line\">                <span class=\"keyword\">int</span> width = ss.empty() ? n : n - ss.top() - <span class=\"number\">1</span>;</div><div class=\"line\">                ans = max(ans, data[i][start]*width);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><h2 id=\"http-poj-org-problem-id-3494\"><a href=\"#http-poj-org-problem-id-3494\" class=\"headerlink\" title=\" http://poj.org/problem?id=3494\"></a> <a href=\"http://poj.org/problem?id=3494\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3494</a></h2><h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给定一个矩阵，里面只包含 0 和 1，求这个矩阵里所有子矩阵中值最大是多少（即矩阵内部所有的 0，1 的和）。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 由于前几天刚做完一个单调栈的题，然后看到这个题就马上往那方面想了，但是还是不太熟练，对着模板才敲出来。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>首先处理一下数据，开一个数组，数组 <code>data[i][j]</code> 代表着以第 i 行，第 j 列结尾的连续 1 的个数（自上到下的连续，例如<code>data[0][j], data[1][j]</code>都是 1 ，那么 <code>data[0][j] = 1, data[1][j] = 2</code>）。</li>\n<li>这样我枚举每一行，对于每一行，问题转化成了<a href=\"http://poj.org/problem?id=2559\" target=\"_blank\" rel=\"external\">一个典型的单调栈问题</a>，求出所有行的最大值即是答案。</li>\n</ul>\n<ul>\n<li><p>这里说一下单调栈，在本题中，如果栈为空或者当前元素直接入栈，否则将栈顶元素出栈并计算栈顶元素的面积。</p>\n<ul>\n<li><p>这里的面积是计算以栈顶元素为最大高度的矩阵面积，那么栈顶元素最左边可到达的是栈中上一个比他小的数（如果栈为空就是左边界了），最右可到达是即将要入栈的数（因为比他小），这里不直接那栈顶元素的下标和当前元素的下标计算是因为可能有大小相同的元素。</p>\n</li>\n<li><p>最后栈如果不为空的话要依次出栈并计算大小，计算大小的时候以栈中上一个比他小的数为最左可到达的地方（如果栈为空就是左边界了） ，最右可到达的是有边界，因为每一个栈中的数，都比右边所有的数要小。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2000</span>+<span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> m, n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;m, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">                <span class=\"keyword\">if</span> (data[i][j] != <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</div><div class=\"line\">                    data[i][j] += data[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; ss;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (ss.empty() || data[i][j] &gt; data[i][ss.top()]) &#123;</div><div class=\"line\">                    ss.push(j);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> start = ss.top();</div><div class=\"line\">                    ss.pop();</div><div class=\"line\">                    <span class=\"keyword\">int</span> width = ss.empty() ? j : j - ss.top()<span class=\"number\">-1</span>;</div><div class=\"line\">                    ans = max(ans, data[i][start]*width);</div><div class=\"line\">                    j--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span> (!ss.empty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> start = ss.top();</div><div class=\"line\">                ss.pop();</div><div class=\"line\">                <span class=\"keyword\">int</span> width = ss.empty() ? n : n - ss.top() - <span class=\"number\">1</span>;</div><div class=\"line\">                ans = max(ans, data[i][start]*width);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"POJ3694 - Network（强连通+LCA）","date":"2017-08-11T03:05:45.000Z","_content":"# 题目链接：\n\nhttp://poj.org/problem?id=3694\n\n\n\n--------------------\n# 题目大意：\n\n给出一个无向图。\n\n有 q 次操作，每次增加一条边，询问图中有多少桥。\n\nq < 1e3, n < 1e5, m < 2e5\n\n\n\n-------------------\n# 解题过程：\n\n不会写，思路到是有，不知道该怎么维护一条路径上的点，并让其缩点成一个点，到时想起来了树链剖分（昨天刚写了一个模板）。\n\n想法是缩成树型图，每个边权值为1，增加一条边就让路径上的所有边的边权置零，每次输出整棵树的权值和即可。\n\n感觉太麻烦了，于是偷偷去看了下讨论区，发现用 LCA（最近公共祖先） 加并查集就很容易解决这个问题\n\n\n\n--------------------\n# 题目分析：\n\n首先缩点成树形图，对于每一次操作，新加的一条边 (u, v) ，让 u，v 两点确定的路径上的所有点的用并查集缩成一个点（包括u，v），缩成的点为u，v的LCA，这样缩掉几个点，原图就减少了几个桥。用一个值来维护答案即可。\n\n\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 100000 + 10;\n\nint n, m, q, Case, sum;\nint head[MAX], etot;\nint deep[MAX], f[MAX], fa[MAX];\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX << 4];\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nvoid dfs(int u, int fat) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v, i);\n            low[u] = min(low[u], low[v]);\n        } else if (i != (fat^1)) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        int x;\n        scc_cnt++;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(head, -1, sizeof(head));\n    scc_cnt = dfs_clock = sum = etot = 0;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n}\n\nvoid tarjan() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i, -1);\n    }\n}\n\nvoid get_deep(int u, int fat, int dep) {\n    deep[u] = dep, f[u] = u;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (v != fat) {\n            fa[v] = u;\n            get_deep(v, u, dep + 1);\n            sum++;\n        }\n    }\n}\n\nvoid rebuild() {\n    int tail = etot;\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < tail; i++) {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        if (mark[u] != mark[v]) {\n            add_edge(mark[u], mark[v]);\n        }\n    }\n}\n\nint root(int t) {\n    if (t == f[t]) return t;\n    return f[t] = root(f[t]);\n}\n\nvoid lca(int u, int v) {\n    u = root(u), v = root(v);\n    stack<int> st;\n    //循环直到找到公共祖先\n    while (u != v) {\n        //让u为较深的节点\n        if (deep[u] < deep[v]) swap(u, v);\n        //通过减少的节点数维护答案\n        sum--;\n        st.push(u);\n        //让u爬到他的父亲节点\n        u = root(fa[u]);\n    }\n\n    //最后让路径上经过的点都缩成LCA一个点\n    while (!st.empty()) {\n        f[st.top()] = u;\n        st.pop();\n    }\n}\n\nvoid solve() {\n    //边双连通划分+缩点\n    tarjan();\n    rebuild();\n\n    //获得新图的每个点的深度和父亲\n    get_deep(1, -1, 1);\n\n    printf(\"Case %d:\\n\", ++Case);\n\n    scanf(\"%d\", &q);\n    while (q--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        //对每次操作通过并查集缩点\n        lca(mark[u], mark[v]);\n        printf(\"%d\\n\", sum);\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        init();\n        solve();\n    }\n}\n```","source":"_posts/POJ3694-Network（强连通-LCA）.md","raw":"---\ntitle: POJ3694 - Network（强连通+LCA）\ndate: 2017-08-11 11:05:45\ncategories: [ACM, 图论, 连通性]\ntags:\n---\n# 题目链接：\n\nhttp://poj.org/problem?id=3694\n\n\n\n--------------------\n# 题目大意：\n\n给出一个无向图。\n\n有 q 次操作，每次增加一条边，询问图中有多少桥。\n\nq < 1e3, n < 1e5, m < 2e5\n\n\n\n-------------------\n# 解题过程：\n\n不会写，思路到是有，不知道该怎么维护一条路径上的点，并让其缩点成一个点，到时想起来了树链剖分（昨天刚写了一个模板）。\n\n想法是缩成树型图，每个边权值为1，增加一条边就让路径上的所有边的边权置零，每次输出整棵树的权值和即可。\n\n感觉太麻烦了，于是偷偷去看了下讨论区，发现用 LCA（最近公共祖先） 加并查集就很容易解决这个问题\n\n\n\n--------------------\n# 题目分析：\n\n首先缩点成树形图，对于每一次操作，新加的一条边 (u, v) ，让 u，v 两点确定的路径上的所有点的用并查集缩成一个点（包括u，v），缩成的点为u，v的LCA，这样缩掉几个点，原图就减少了几个桥。用一个值来维护答案即可。\n\n\n\n\n\n----------------------\n# AC代码：\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 100000 + 10;\n\nint n, m, q, Case, sum;\nint head[MAX], etot;\nint deep[MAX], f[MAX], fa[MAX];\nint pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;\nstack<int> S;\n\nstruct Edge {\n    int u, v, nxt;\n} edge[MAX << 4];\n\nvoid add_edge(int u, int v) {\n    edge[etot].v = v;\n    edge[etot].u = u;\n    edge[etot].nxt = head[u];\n    head[u] = etot++;\n}\n\nvoid dfs(int u, int fat) {\n    pre[u] = low[u] = ++dfs_clock;\n    S.push(u);\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (!pre[v]) {\n            dfs(v, i);\n            low[u] = min(low[u], low[v]);\n        } else if (i != (fat^1)) {\n            low[u] = min(low[u], pre[v]);\n        }\n    }\n    if (low[u] == pre[u]) {\n        int x;\n        scc_cnt++;\n        do {\n            x = S.top();\n            S.pop();\n            mark[x] = scc_cnt;\n        } while (x != u);\n    }\n}\n\nvoid init() {\n    memset(pre, 0, sizeof(pre));\n    memset(mark, 0, sizeof(mark));\n    memset(head, -1, sizeof(head));\n    scc_cnt = dfs_clock = sum = etot = 0;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n}\n\nvoid tarjan() {\n    for (int i = 1; i <= n; i++) {\n        if (!pre[i]) dfs(i, -1);\n    }\n}\n\nvoid get_deep(int u, int fat, int dep) {\n    deep[u] = dep, f[u] = u;\n    for (int i = head[u]; ~i; i = edge[i].nxt) {\n        int v = edge[i].v;\n        if (v != fat) {\n            fa[v] = u;\n            get_deep(v, u, dep + 1);\n            sum++;\n        }\n    }\n}\n\nvoid rebuild() {\n    int tail = etot;\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < tail; i++) {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        if (mark[u] != mark[v]) {\n            add_edge(mark[u], mark[v]);\n        }\n    }\n}\n\nint root(int t) {\n    if (t == f[t]) return t;\n    return f[t] = root(f[t]);\n}\n\nvoid lca(int u, int v) {\n    u = root(u), v = root(v);\n    stack<int> st;\n    //循环直到找到公共祖先\n    while (u != v) {\n        //让u为较深的节点\n        if (deep[u] < deep[v]) swap(u, v);\n        //通过减少的节点数维护答案\n        sum--;\n        st.push(u);\n        //让u爬到他的父亲节点\n        u = root(fa[u]);\n    }\n\n    //最后让路径上经过的点都缩成LCA一个点\n    while (!st.empty()) {\n        f[st.top()] = u;\n        st.pop();\n    }\n}\n\nvoid solve() {\n    //边双连通划分+缩点\n    tarjan();\n    rebuild();\n\n    //获得新图的每个点的深度和父亲\n    get_deep(1, -1, 1);\n\n    printf(\"Case %d:\\n\", ++Case);\n\n    scanf(\"%d\", &q);\n    while (q--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        //对每次操作通过并查集缩点\n        lca(mark[u], mark[v]);\n        printf(\"%d\\n\", sum);\n    }\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &n, &m) && (n + m)) {\n        init();\n        solve();\n    }\n}\n```","slug":"POJ3694-Network（强连通-LCA）","published":1,"updated":"2017-08-11T03:18:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndb0041y9idxbpl0yuv","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=3694\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3694</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个无向图。</p>\n<p>有 q 次操作，每次增加一条边，询问图中有多少桥。</p>\n<p>q &lt; 1e3, n &lt; 1e5, m &lt; 2e5</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>不会写，思路到是有，不知道该怎么维护一条路径上的点，并让其缩点成一个点，到时想起来了树链剖分（昨天刚写了一个模板）。</p>\n<p>想法是缩成树型图，每个边权值为1，增加一条边就让路径上的所有边的边权置零，每次输出整棵树的权值和即可。</p>\n<p>感觉太麻烦了，于是偷偷去看了下讨论区，发现用 LCA（最近公共祖先） 加并查集就很容易解决这个问题</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先缩点成树形图，对于每一次操作，新加的一条边 (u, v) ，让 u，v 两点确定的路径上的所有点的用并查集缩成一个点（包括u，v），缩成的点为u，v的LCA，这样缩掉几个点，原图就减少了几个桥。用一个值来维护答案即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, q, Case, sum;</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> deep[MAX], f[MAX], fa[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">4</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v, i);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i != (fat^<span class=\"number\">1</span>)) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    scc_cnt = dfs_clock = sum = etot = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        add_edge(u, v);</div><div class=\"line\">        add_edge(v, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i, <span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_deep</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> dep)</span> </span>&#123;</div><div class=\"line\">    deep[u] = dep, f[u] = u;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (v != fat) &#123;</div><div class=\"line\">            fa[v] = u;</div><div class=\"line\">            get_deep(v, u, dep + <span class=\"number\">1</span>);</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tail = etot;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tail; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = edge[i].u;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">            add_edge(mark[u], mark[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (t == f[t]) <span class=\"keyword\">return</span> t;</div><div class=\"line\">    <span class=\"keyword\">return</span> f[t] = root(f[t]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    u = root(u), v = root(v);</div><div class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</div><div class=\"line\">    <span class=\"comment\">//循环直到找到公共祖先</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (u != v) &#123;</div><div class=\"line\">        <span class=\"comment\">//让u为较深的节点</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (deep[u] &lt; deep[v]) swap(u, v);</div><div class=\"line\">        <span class=\"comment\">//通过减少的节点数维护答案</span></div><div class=\"line\">        sum--;</div><div class=\"line\">        st.push(u);</div><div class=\"line\">        <span class=\"comment\">//让u爬到他的父亲节点</span></div><div class=\"line\">        u = root(fa[u]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//最后让路径上经过的点都缩成LCA一个点</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (!st.empty()) &#123;</div><div class=\"line\">        f[st.top()] = u;</div><div class=\"line\">        st.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//边双连通划分+缩点</span></div><div class=\"line\">    tarjan();</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//获得新图的每个点的深度和父亲</span></div><div class=\"line\">    get_deep(<span class=\"number\">1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, ++Case);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">    <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        <span class=\"comment\">//对每次操作通过并查集缩点</span></div><div class=\"line\">        lca(mark[u], mark[v]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://poj.org/problem?id=3694\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=3694</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一个无向图。</p>\n<p>有 q 次操作，每次增加一条边，询问图中有多少桥。</p>\n<p>q &lt; 1e3, n &lt; 1e5, m &lt; 2e5</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>不会写，思路到是有，不知道该怎么维护一条路径上的点，并让其缩点成一个点，到时想起来了树链剖分（昨天刚写了一个模板）。</p>\n<p>想法是缩成树型图，每个边权值为1，增加一条边就让路径上的所有边的边权置零，每次输出整棵树的权值和即可。</p>\n<p>感觉太麻烦了，于是偷偷去看了下讨论区，发现用 LCA（最近公共祖先） 加并查集就很容易解决这个问题</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先缩点成树形图，对于每一次操作，新加的一条边 (u, v) ，让 u，v 两点确定的路径上的所有点的用并查集缩成一个点（包括u，v），缩成的点为u，v的LCA，这样缩掉几个点，原图就减少了几个桥。用一个值来维护答案即可。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100000</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, q, Case, sum;</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAX], etot;</div><div class=\"line\"><span class=\"keyword\">int</span> deep[MAX], f[MAX], fa[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> pre[MAX], low[MAX], mark[MAX], dfs_clock, scc_cnt;</div><div class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; S;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> u, v, nxt;</div><div class=\"line\">&#125; edge[MAX &lt;&lt; <span class=\"number\">4</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    edge[etot].v = v;</div><div class=\"line\">    edge[etot].u = u;</div><div class=\"line\">    edge[etot].nxt = head[u];</div><div class=\"line\">    head[u] = etot++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">    pre[u] = low[u] = ++dfs_clock;</div><div class=\"line\">    S.push(u);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[v]) &#123;</div><div class=\"line\">            dfs(v, i);</div><div class=\"line\">            low[u] = min(low[u], low[v]);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i != (fat^<span class=\"number\">1</span>)) &#123;</div><div class=\"line\">            low[u] = min(low[u], pre[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (low[u] == pre[u]) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> x;</div><div class=\"line\">        scc_cnt++;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">            x = S.top();</div><div class=\"line\">            S.pop();</div><div class=\"line\">            mark[x] = scc_cnt;</div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (x != u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(pre));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    scc_cnt = dfs_clock = sum = etot = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        add_edge(u, v);</div><div class=\"line\">        add_edge(v, u);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!pre[i]) dfs(i, <span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_deep</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> dep)</span> </span>&#123;</div><div class=\"line\">    deep[u] = dep, f[u] = u;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (v != fat) &#123;</div><div class=\"line\">            fa[v] = u;</div><div class=\"line\">            get_deep(v, u, dep + <span class=\"number\">1</span>);</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rebuild</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> tail = etot;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tail; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = edge[i].u;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].v;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[u] != mark[v]) &#123;</div><div class=\"line\">            add_edge(mark[u], mark[v]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">root</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (t == f[t]) <span class=\"keyword\">return</span> t;</div><div class=\"line\">    <span class=\"keyword\">return</span> f[t] = root(f[t]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    u = root(u), v = root(v);</div><div class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</div><div class=\"line\">    <span class=\"comment\">//循环直到找到公共祖先</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (u != v) &#123;</div><div class=\"line\">        <span class=\"comment\">//让u为较深的节点</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (deep[u] &lt; deep[v]) swap(u, v);</div><div class=\"line\">        <span class=\"comment\">//通过减少的节点数维护答案</span></div><div class=\"line\">        sum--;</div><div class=\"line\">        st.push(u);</div><div class=\"line\">        <span class=\"comment\">//让u爬到他的父亲节点</span></div><div class=\"line\">        u = root(fa[u]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//最后让路径上经过的点都缩成LCA一个点</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (!st.empty()) &#123;</div><div class=\"line\">        f[st.top()] = u;</div><div class=\"line\">        st.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//边双连通划分+缩点</span></div><div class=\"line\">    tarjan();</div><div class=\"line\">    rebuild();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//获得新图的每个点的深度和父亲</span></div><div class=\"line\">    get_deep(<span class=\"number\">1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, ++Case);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">    <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        <span class=\"comment\">//对每次操作通过并查集缩点</span></div><div class=\"line\">        lca(mark[u], mark[v]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m) &amp;&amp; (n + m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        solve();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Python爬虫基础细节（urllib+cookielib+BeautifulSoup）","date":"2017-01-03T14:25:03.000Z","_content":"# 内容大概：\n\n - 简单介绍python如何下载网页\n - 发送post请求\n - urllib/2模块的方法应用\n - 分析网页的post请求\n - cookie处理\n - 利用BS分析网页\n\n（由于并没有系统的学过http之类的，可能会有错误，希望大家可以指出）\n\n\n----------\n# urllib&cookielib：\n\nurllib模块只用到了urlencode方法，目的是将原来的字典post数据转化成特定的字符串格式，只用到了下面的一行代码。\n```\npost_data = urllib.urlencode(post_data)\n```\n\nurllib2用到的就多了，首先模拟登陆的话需要用到cookie处理。\n主要用到以下代码，固定格式，拿来用就好了。\n\n```python\n        #安装cookie处理\n        cj = cookielib.CookieJar()\n        cookie_support = urllib2.HTTPCookieProcessor(cj)\n        opener = urllib2.build_opener(cookie_support)\n        urllib2.install_opener(opener)\n```\n然后设置一下自己的hears，目的是把自己伪装成一个浏览器。\n导入这里的各种参数可以设置成别的，这里只是例子，具体改成什么可以打开浏览器的开发者模式看一下。\n```python\nself.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36',\n            'Referer': 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login',\n            'Host': 'acm.sdut.edu.cn'}\n```\n![这里写图片描述](http://img.blog.csdn.net/20170103214026395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后设置打开网页时需要的request，需要用到url，post请求的数据，headers，当然这一步也可以跳过，单纯下载网页的话只用url就可以了。\n```python\nrequest = urllib2.Request(url, post_data, headers)\n```\n\n接下来就是重要的打开网页，用到了urllib2的urlopen方法，参数可以是只是网页，也可以是一个之前说到的request。\n\n```python\n#以下两种都可以\nresponse = urllib2.urlopen(request)\nresponse = urllib2.urlopen(url)\n```\n最后一点是response对象使用read方法就可以得到下载的html文本了。\n\n```\nresponse.read()\n```\n\n----------\n# post请求的分析：\n这里拿登陆OJ来做下示范。\n首先打开登陆页面自己打开F12登陆一次。\n然后注意箭头上指的两处，点下login后，右边的Request URL就是接下来将要用python访问的页面。\n![这里写图片描述](http://img.blog.csdn.net/20170103215311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后继续往下滑，下面箭头的部分就是自己提交的数据，也是接下来post_data里要放的内容。\n![这里写图片描述](http://img.blog.csdn.net/20170103215456937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n于是登陆的过程我就可以这样写了（假设安装了cookie处理，定义了headers）\n```python\nurl = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'\npost_data = {'user_name': user, 'password':password }\nrequest = urllib2.Request(url, post_data, headers)\nresponse = urllib2.urlopen(request)\n```\n# BeautifulSoup：\n\n**强烈推荐官方文档，有中文！有中文！！有中文！！！**\nhttps://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n\n首先明确一点，BS就是分析html的文本，按照一种树形的结构，每一个节点都可以拿来当一个bs对象使用。\n首先创建一个bs对象先。\n（这里用了html5lib解析器，具体可以百度去下载安装，另外python装好pip的话安装第三方库很方便的。当然这里也可以不要第二个参数，这样的话就会默认使用python自带的）\n```\nsoup = BeautifulSoup(html, \"html5lib\")\n```\n然后是bs对象的find_all和find方法，find方法返回的是第一个匹配到的节点（bs对象），find_all则是返回一个**列表**（包含bs对象的列表），里面包含所有匹配的节点，如果没用匹配的节点的话，分别是None和[]（空列表）。\n他们都有name, class_, text参数（其实还有很多，这里我只用了这些基本的）\n分别代表是节点名字，节点的class内容，和节点的文本。\n下面只是一个示例，当然可以多个参数放在一起。\n```python\nsoup.find(class_ = 'next')\nsoup.find_all('tr')\nsoup.find(text = \"Fish\")\n\n```\nbs对象还可以直接访问他的节点的属性，父节点和子节点，当前这个节点的文本。\n(假设a是他的子节点的话)\n```python\nsoup['href']\nsoup.parent\nsoup.a\nsoup.text\n```\n介绍了这些，然后以下就是一些综合应用的示例了，总之BS是非常好用，刚开始我以为得用到正则表达式...\n\n```python\n#从ranklist找到自己的status\nurl = 'http://acm.sdut.edu.cn' + soup.find(text = \"Fish\").parent.parent.find_all('td')[2].a['href']\n#找到页面的下一页的超链接\nurl = 'http://acm.sdut.edu.cn/' + soup.find(class_ = 'next')['href']\n#找到每一个AC记录的代码链接\ntr = tr.find_all('td')\n                if tr[3].text == \"Accepted\" and (tr[6].text == \"g++\" or tr[6].text == \"gcc\"):\n                    temp =  'http://acm.sdut.edu.cn/' + tr[6].a['href'], tr[2].a['href'][-9:-5]\n```\n\n","source":"_posts/Python爬虫基础细节（urllib-cookielib-BeautifulSoup）.md","raw":"---\ntitle: Python爬虫基础细节（urllib+cookielib+BeautifulSoup）\ndate: 2017-01-03 22:25:03\ncategories: [爬虫&数据处理]\ntags:\n---\n# 内容大概：\n\n - 简单介绍python如何下载网页\n - 发送post请求\n - urllib/2模块的方法应用\n - 分析网页的post请求\n - cookie处理\n - 利用BS分析网页\n\n（由于并没有系统的学过http之类的，可能会有错误，希望大家可以指出）\n\n\n----------\n# urllib&cookielib：\n\nurllib模块只用到了urlencode方法，目的是将原来的字典post数据转化成特定的字符串格式，只用到了下面的一行代码。\n```\npost_data = urllib.urlencode(post_data)\n```\n\nurllib2用到的就多了，首先模拟登陆的话需要用到cookie处理。\n主要用到以下代码，固定格式，拿来用就好了。\n\n```python\n        #安装cookie处理\n        cj = cookielib.CookieJar()\n        cookie_support = urllib2.HTTPCookieProcessor(cj)\n        opener = urllib2.build_opener(cookie_support)\n        urllib2.install_opener(opener)\n```\n然后设置一下自己的hears，目的是把自己伪装成一个浏览器。\n导入这里的各种参数可以设置成别的，这里只是例子，具体改成什么可以打开浏览器的开发者模式看一下。\n```python\nself.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36',\n            'Referer': 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login',\n            'Host': 'acm.sdut.edu.cn'}\n```\n![这里写图片描述](http://img.blog.csdn.net/20170103214026395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后设置打开网页时需要的request，需要用到url，post请求的数据，headers，当然这一步也可以跳过，单纯下载网页的话只用url就可以了。\n```python\nrequest = urllib2.Request(url, post_data, headers)\n```\n\n接下来就是重要的打开网页，用到了urllib2的urlopen方法，参数可以是只是网页，也可以是一个之前说到的request。\n\n```python\n#以下两种都可以\nresponse = urllib2.urlopen(request)\nresponse = urllib2.urlopen(url)\n```\n最后一点是response对象使用read方法就可以得到下载的html文本了。\n\n```\nresponse.read()\n```\n\n----------\n# post请求的分析：\n这里拿登陆OJ来做下示范。\n首先打开登陆页面自己打开F12登陆一次。\n然后注意箭头上指的两处，点下login后，右边的Request URL就是接下来将要用python访问的页面。\n![这里写图片描述](http://img.blog.csdn.net/20170103215311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后继续往下滑，下面箭头的部分就是自己提交的数据，也是接下来post_data里要放的内容。\n![这里写图片描述](http://img.blog.csdn.net/20170103215456937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n于是登陆的过程我就可以这样写了（假设安装了cookie处理，定义了headers）\n```python\nurl = 'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'\npost_data = {'user_name': user, 'password':password }\nrequest = urllib2.Request(url, post_data, headers)\nresponse = urllib2.urlopen(request)\n```\n# BeautifulSoup：\n\n**强烈推荐官方文档，有中文！有中文！！有中文！！！**\nhttps://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n\n首先明确一点，BS就是分析html的文本，按照一种树形的结构，每一个节点都可以拿来当一个bs对象使用。\n首先创建一个bs对象先。\n（这里用了html5lib解析器，具体可以百度去下载安装，另外python装好pip的话安装第三方库很方便的。当然这里也可以不要第二个参数，这样的话就会默认使用python自带的）\n```\nsoup = BeautifulSoup(html, \"html5lib\")\n```\n然后是bs对象的find_all和find方法，find方法返回的是第一个匹配到的节点（bs对象），find_all则是返回一个**列表**（包含bs对象的列表），里面包含所有匹配的节点，如果没用匹配的节点的话，分别是None和[]（空列表）。\n他们都有name, class_, text参数（其实还有很多，这里我只用了这些基本的）\n分别代表是节点名字，节点的class内容，和节点的文本。\n下面只是一个示例，当然可以多个参数放在一起。\n```python\nsoup.find(class_ = 'next')\nsoup.find_all('tr')\nsoup.find(text = \"Fish\")\n\n```\nbs对象还可以直接访问他的节点的属性，父节点和子节点，当前这个节点的文本。\n(假设a是他的子节点的话)\n```python\nsoup['href']\nsoup.parent\nsoup.a\nsoup.text\n```\n介绍了这些，然后以下就是一些综合应用的示例了，总之BS是非常好用，刚开始我以为得用到正则表达式...\n\n```python\n#从ranklist找到自己的status\nurl = 'http://acm.sdut.edu.cn' + soup.find(text = \"Fish\").parent.parent.find_all('td')[2].a['href']\n#找到页面的下一页的超链接\nurl = 'http://acm.sdut.edu.cn/' + soup.find(class_ = 'next')['href']\n#找到每一个AC记录的代码链接\ntr = tr.find_all('td')\n                if tr[3].text == \"Accepted\" and (tr[6].text == \"g++\" or tr[6].text == \"gcc\"):\n                    temp =  'http://acm.sdut.edu.cn/' + tr[6].a['href'], tr[2].a['href'][-9:-5]\n```\n\n","slug":"Python爬虫基础细节（urllib-cookielib-BeautifulSoup）","published":1,"updated":"2017-07-23T04:04:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndc0043y9id90ssxuqu","content":"<h1 id=\"内容大概：\"><a href=\"#内容大概：\" class=\"headerlink\" title=\"内容大概：\"></a>内容大概：</h1><ul>\n<li>简单介绍python如何下载网页</li>\n<li>发送post请求</li>\n<li>urllib/2模块的方法应用</li>\n<li>分析网页的post请求</li>\n<li>cookie处理</li>\n<li>利用BS分析网页</li>\n</ul>\n<p>（由于并没有系统的学过http之类的，可能会有错误，希望大家可以指出）</p>\n<hr>\n<h1 id=\"urllib-amp-cookielib：\"><a href=\"#urllib-amp-cookielib：\" class=\"headerlink\" title=\"urllib&amp;cookielib：\"></a>urllib&amp;cookielib：</h1><p>urllib模块只用到了urlencode方法，目的是将原来的字典post数据转化成特定的字符串格式，只用到了下面的一行代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">post_data = urllib.urlencode(post_data)</div></pre></td></tr></table></figure></p>\n<p>urllib2用到的就多了，首先模拟登陆的话需要用到cookie处理。<br>主要用到以下代码，固定格式，拿来用就好了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#安装cookie处理</span></div><div class=\"line\">cj = cookielib.CookieJar()</div><div class=\"line\">cookie_support = urllib2.HTTPCookieProcessor(cj)</div><div class=\"line\">opener = urllib2.build_opener(cookie_support)</div><div class=\"line\">urllib2.install_opener(opener)</div></pre></td></tr></table></figure>\n<p>然后设置一下自己的hears，目的是把自己伪装成一个浏览器。<br>导入这里的各种参数可以设置成别的，这里只是例子，具体改成什么可以打开浏览器的开发者模式看一下。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.headers = &#123;</div><div class=\"line\">            <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36'</span>,</div><div class=\"line\">            <span class=\"string\">'Referer'</span>: <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span>,</div><div class=\"line\">            <span class=\"string\">'Host'</span>: <span class=\"string\">'acm.sdut.edu.cn'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20170103214026395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后设置打开网页时需要的request，需要用到url，post请求的数据，headers，当然这一步也可以跳过，单纯下载网页的话只用url就可以了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">request = urllib2.Request(url, post_data, headers)</div></pre></td></tr></table></figure></p>\n<p>接下来就是重要的打开网页，用到了urllib2的urlopen方法，参数可以是只是网页，也可以是一个之前说到的request。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#以下两种都可以</span></div><div class=\"line\">response = urllib2.urlopen(request)</div><div class=\"line\">response = urllib2.urlopen(url)</div></pre></td></tr></table></figure>\n<p>最后一点是response对象使用read方法就可以得到下载的html文本了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">response.read()</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"post请求的分析：\"><a href=\"#post请求的分析：\" class=\"headerlink\" title=\"post请求的分析：\"></a>post请求的分析：</h1><p>这里拿登陆OJ来做下示范。<br>首先打开登陆页面自己打开F12登陆一次。<br>然后注意箭头上指的两处，点下login后，右边的Request URL就是接下来将要用python访问的页面。<br><img src=\"http://img.blog.csdn.net/20170103215311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后继续往下滑，下面箭头的部分就是自己提交的数据，也是接下来post_data里要放的内容。<br><img src=\"http://img.blog.csdn.net/20170103215456937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>于是登陆的过程我就可以这样写了（假设安装了cookie处理，定义了headers）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span></div><div class=\"line\">post_data = &#123;<span class=\"string\">'user_name'</span>: user, <span class=\"string\">'password'</span>:password &#125;</div><div class=\"line\">request = urllib2.Request(url, post_data, headers)</div><div class=\"line\">response = urllib2.urlopen(request)</div></pre></td></tr></table></figure></p>\n<h1 id=\"BeautifulSoup：\"><a href=\"#BeautifulSoup：\" class=\"headerlink\" title=\"BeautifulSoup：\"></a>BeautifulSoup：</h1><p><strong>强烈推荐官方文档，有中文！有中文！！有中文！！！</strong><br><a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\" target=\"_blank\" rel=\"external\">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>\n<p>首先明确一点，BS就是分析html的文本，按照一种树形的结构，每一个节点都可以拿来当一个bs对象使用。<br>首先创建一个bs对象先。<br>（这里用了html5lib解析器，具体可以百度去下载安装，另外python装好pip的话安装第三方库很方便的。当然这里也可以不要第二个参数，这样的话就会默认使用python自带的）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup = BeautifulSoup(html, &quot;html5lib&quot;)</div></pre></td></tr></table></figure></p>\n<p>然后是bs对象的find_all和find方法，find方法返回的是第一个匹配到的节点（bs对象），find<em>all则是返回一个<strong>列表</strong>（包含bs对象的列表），里面包含所有匹配的节点，如果没用匹配的节点的话，分别是None和[]（空列表）。<br>他们都有name, class</em>, text参数（其实还有很多，这里我只用了这些基本的）<br>分别代表是节点名字，节点的class内容，和节点的文本。<br>下面只是一个示例，当然可以多个参数放在一起。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup.find(class_ = <span class=\"string\">'next'</span>)</div><div class=\"line\">soup.find_all(<span class=\"string\">'tr'</span>)</div><div class=\"line\">soup.find(text = <span class=\"string\">\"Fish\"</span>)</div></pre></td></tr></table></figure></p>\n<p>bs对象还可以直接访问他的节点的属性，父节点和子节点，当前这个节点的文本。<br>(假设a是他的子节点的话)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup[<span class=\"string\">'href'</span>]</div><div class=\"line\">soup.parent</div><div class=\"line\">soup.a</div><div class=\"line\">soup.text</div></pre></td></tr></table></figure></p>\n<p>介绍了这些，然后以下就是一些综合应用的示例了，总之BS是非常好用，刚开始我以为得用到正则表达式…</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#从ranklist找到自己的status</span></div><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn'</span> + soup.find(text = <span class=\"string\">\"Fish\"</span>).parent.parent.find_all(<span class=\"string\">'td'</span>)[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>]</div><div class=\"line\"><span class=\"comment\">#找到页面的下一页的超链接</span></div><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + soup.find(class_ = <span class=\"string\">'next'</span>)[<span class=\"string\">'href'</span>]</div><div class=\"line\"><span class=\"comment\">#找到每一个AC记录的代码链接</span></div><div class=\"line\">tr = tr.find_all(<span class=\"string\">'td'</span>)</div><div class=\"line\">                <span class=\"keyword\">if</span> tr[<span class=\"number\">3</span>].text == <span class=\"string\">\"Accepted\"</span> <span class=\"keyword\">and</span> (tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"g++\"</span> <span class=\"keyword\">or</span> tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"gcc\"</span>):</div><div class=\"line\">                    temp =  <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + tr[<span class=\"number\">6</span>].a[<span class=\"string\">'href'</span>], tr[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>][<span class=\"number\">-9</span>:<span class=\"number\">-5</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内容大概：\"><a href=\"#内容大概：\" class=\"headerlink\" title=\"内容大概：\"></a>内容大概：</h1><ul>\n<li>简单介绍python如何下载网页</li>\n<li>发送post请求</li>\n<li>urllib/2模块的方法应用</li>\n<li>分析网页的post请求</li>\n<li>cookie处理</li>\n<li>利用BS分析网页</li>\n</ul>\n<p>（由于并没有系统的学过http之类的，可能会有错误，希望大家可以指出）</p>\n<hr>\n<h1 id=\"urllib-amp-cookielib：\"><a href=\"#urllib-amp-cookielib：\" class=\"headerlink\" title=\"urllib&amp;cookielib：\"></a>urllib&amp;cookielib：</h1><p>urllib模块只用到了urlencode方法，目的是将原来的字典post数据转化成特定的字符串格式，只用到了下面的一行代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">post_data = urllib.urlencode(post_data)</div></pre></td></tr></table></figure></p>\n<p>urllib2用到的就多了，首先模拟登陆的话需要用到cookie处理。<br>主要用到以下代码，固定格式，拿来用就好了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#安装cookie处理</span></div><div class=\"line\">cj = cookielib.CookieJar()</div><div class=\"line\">cookie_support = urllib2.HTTPCookieProcessor(cj)</div><div class=\"line\">opener = urllib2.build_opener(cookie_support)</div><div class=\"line\">urllib2.install_opener(opener)</div></pre></td></tr></table></figure>\n<p>然后设置一下自己的hears，目的是把自己伪装成一个浏览器。<br>导入这里的各种参数可以设置成别的，这里只是例子，具体改成什么可以打开浏览器的开发者模式看一下。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.headers = &#123;</div><div class=\"line\">            <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36'</span>,</div><div class=\"line\">            <span class=\"string\">'Referer'</span>: <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span>,</div><div class=\"line\">            <span class=\"string\">'Host'</span>: <span class=\"string\">'acm.sdut.edu.cn'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20170103214026395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后设置打开网页时需要的request，需要用到url，post请求的数据，headers，当然这一步也可以跳过，单纯下载网页的话只用url就可以了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">request = urllib2.Request(url, post_data, headers)</div></pre></td></tr></table></figure></p>\n<p>接下来就是重要的打开网页，用到了urllib2的urlopen方法，参数可以是只是网页，也可以是一个之前说到的request。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#以下两种都可以</span></div><div class=\"line\">response = urllib2.urlopen(request)</div><div class=\"line\">response = urllib2.urlopen(url)</div></pre></td></tr></table></figure>\n<p>最后一点是response对象使用read方法就可以得到下载的html文本了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">response.read()</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"post请求的分析：\"><a href=\"#post请求的分析：\" class=\"headerlink\" title=\"post请求的分析：\"></a>post请求的分析：</h1><p>这里拿登陆OJ来做下示范。<br>首先打开登陆页面自己打开F12登陆一次。<br>然后注意箭头上指的两处，点下login后，右边的Request URL就是接下来将要用python访问的页面。<br><img src=\"http://img.blog.csdn.net/20170103215311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后继续往下滑，下面箭头的部分就是自己提交的数据，也是接下来post_data里要放的内容。<br><img src=\"http://img.blog.csdn.net/20170103215456937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>于是登陆的过程我就可以这样写了（假设安装了cookie处理，定义了headers）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Login/login'</span></div><div class=\"line\">post_data = &#123;<span class=\"string\">'user_name'</span>: user, <span class=\"string\">'password'</span>:password &#125;</div><div class=\"line\">request = urllib2.Request(url, post_data, headers)</div><div class=\"line\">response = urllib2.urlopen(request)</div></pre></td></tr></table></figure></p>\n<h1 id=\"BeautifulSoup：\"><a href=\"#BeautifulSoup：\" class=\"headerlink\" title=\"BeautifulSoup：\"></a>BeautifulSoup：</h1><p><strong>强烈推荐官方文档，有中文！有中文！！有中文！！！</strong><br><a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\" target=\"_blank\" rel=\"external\">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>\n<p>首先明确一点，BS就是分析html的文本，按照一种树形的结构，每一个节点都可以拿来当一个bs对象使用。<br>首先创建一个bs对象先。<br>（这里用了html5lib解析器，具体可以百度去下载安装，另外python装好pip的话安装第三方库很方便的。当然这里也可以不要第二个参数，这样的话就会默认使用python自带的）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup = BeautifulSoup(html, &quot;html5lib&quot;)</div></pre></td></tr></table></figure></p>\n<p>然后是bs对象的find_all和find方法，find方法返回的是第一个匹配到的节点（bs对象），find<em>all则是返回一个<strong>列表</strong>（包含bs对象的列表），里面包含所有匹配的节点，如果没用匹配的节点的话，分别是None和[]（空列表）。<br>他们都有name, class</em>, text参数（其实还有很多，这里我只用了这些基本的）<br>分别代表是节点名字，节点的class内容，和节点的文本。<br>下面只是一个示例，当然可以多个参数放在一起。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup.find(class_ = <span class=\"string\">'next'</span>)</div><div class=\"line\">soup.find_all(<span class=\"string\">'tr'</span>)</div><div class=\"line\">soup.find(text = <span class=\"string\">\"Fish\"</span>)</div></pre></td></tr></table></figure></p>\n<p>bs对象还可以直接访问他的节点的属性，父节点和子节点，当前这个节点的文本。<br>(假设a是他的子节点的话)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">soup[<span class=\"string\">'href'</span>]</div><div class=\"line\">soup.parent</div><div class=\"line\">soup.a</div><div class=\"line\">soup.text</div></pre></td></tr></table></figure></p>\n<p>介绍了这些，然后以下就是一些综合应用的示例了，总之BS是非常好用，刚开始我以为得用到正则表达式…</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#从ranklist找到自己的status</span></div><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn'</span> + soup.find(text = <span class=\"string\">\"Fish\"</span>).parent.parent.find_all(<span class=\"string\">'td'</span>)[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>]</div><div class=\"line\"><span class=\"comment\">#找到页面的下一页的超链接</span></div><div class=\"line\">url = <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + soup.find(class_ = <span class=\"string\">'next'</span>)[<span class=\"string\">'href'</span>]</div><div class=\"line\"><span class=\"comment\">#找到每一个AC记录的代码链接</span></div><div class=\"line\">tr = tr.find_all(<span class=\"string\">'td'</span>)</div><div class=\"line\">                <span class=\"keyword\">if</span> tr[<span class=\"number\">3</span>].text == <span class=\"string\">\"Accepted\"</span> <span class=\"keyword\">and</span> (tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"g++\"</span> <span class=\"keyword\">or</span> tr[<span class=\"number\">6</span>].text == <span class=\"string\">\"gcc\"</span>):</div><div class=\"line\">                    temp =  <span class=\"string\">'http://acm.sdut.edu.cn/'</span> + tr[<span class=\"number\">6</span>].a[<span class=\"string\">'href'</span>], tr[<span class=\"number\">2</span>].a[<span class=\"string\">'href'</span>][<span class=\"number\">-9</span>:<span class=\"number\">-5</span>]</div></pre></td></tr></table></figure>\n"},{"title":"SDUT 2622 - 最短路径（SPFA+二维）","date":"2017-02-16T07:14:13.000Z","_content":"# 题目链接\n-------------------\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html\n\n# 题目大意\n------------------\n有一个有向图，给定一个终点和起点，求起点到终点的最短路径，并且路径经过的边数是 x 的倍数。\n\n# 解题过程\n--------------\n想了好长时间，最初是想把每次的步数一起装到队列里面，用 SPFA 。\n然后 WA ， 只好去搜了下博客，原来是多了个维度，和之前做的一个题神似，[UVA1600](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4475) ，这个是多了一个维度的BFS，以后得想起来这个加一个维度解决问题的方法了，要不遇到就卡死。\n\n# 题目分析\n------------------\n+ 大体思路是用 SPFA ，增加一个维度，储存步数对 x 取模，最后输出对 x 取模后是 0 的终点距离即可。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node\n{\n    int v;\n    long long w;\n    node(int v, long long w):v(v),w(w){}\n};\n\nvector<node> edges[112];\nbool book[112];\nlong long dis[112][11];\nint s, e, x;\nint n, m;\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        scanf(\"%d %d\", &n, &m);\n        memset(book, 0, sizeof(book));\n        memset(dis, -1, sizeof(dis));\n        for (int i = 0; i < n; i++)\n            edges[i].clear();\n\n        for (int i = 0; i < m; i++)\n        {\n            int u, v;\n            long long w;\n            scanf(\"%d %d %lld\", &u, &v, &w);\n            edges[u].push_back(node(v,w));\n        }\n\n        scanf(\"%d %d %d\", &s, &e, &x);\n        queue<int> q;\n        q.push(s);\n        dis[s][0] = 0;\n\n        while (!q.empty())\n        {\n            int u = q.front();\n\n            for (int i = 0; i < edges[u].size(); i++)\n            {\n                int v = edges[u][i].v;\n                long long w = edges[u][i].w;\n                for (int k = 0; k < x; k++)\n                {\n                    if (dis[u][k] != -1 && (dis[v][(k+1)%x] > dis[u][k] + w || dis[v][(k+1)%x] == -1))\n                    {\n                        dis[v][(k+1)%x] = dis[u][k] + w;\n                        if (!book[v])\n                        {\n                            q.push(v);\n                            book[v] = 1;\n                        }\n                    }\n                }\n            }\n            book[u] = 0;\n            q.pop();\n        }\n\n        if (dis[e][0] == -1)\n            printf(\"No Answer!\\n\");\n        else\n            printf(\"%lld\\n\", dis[e][0]);\n    }\n}\n```","source":"_posts/SDUT-2622-最短路径（SPFA-二维）.md","raw":"---\ntitle: SDUT 2622 - 最短路径（SPFA+二维）\ndate: 2017-02-16 15:14:13\ncategories: [ACM, 图论, 最短路]\ntags:\n---\n# 题目链接\n-------------------\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html\n\n# 题目大意\n------------------\n有一个有向图，给定一个终点和起点，求起点到终点的最短路径，并且路径经过的边数是 x 的倍数。\n\n# 解题过程\n--------------\n想了好长时间，最初是想把每次的步数一起装到队列里面，用 SPFA 。\n然后 WA ， 只好去搜了下博客，原来是多了个维度，和之前做的一个题神似，[UVA1600](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4475) ，这个是多了一个维度的BFS，以后得想起来这个加一个维度解决问题的方法了，要不遇到就卡死。\n\n# 题目分析\n------------------\n+ 大体思路是用 SPFA ，增加一个维度，储存步数对 x 取模，最后输出对 x 取模后是 0 的终点距离即可。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node\n{\n    int v;\n    long long w;\n    node(int v, long long w):v(v),w(w){}\n};\n\nvector<node> edges[112];\nbool book[112];\nlong long dis[112][11];\nint s, e, x;\nint n, m;\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        scanf(\"%d %d\", &n, &m);\n        memset(book, 0, sizeof(book));\n        memset(dis, -1, sizeof(dis));\n        for (int i = 0; i < n; i++)\n            edges[i].clear();\n\n        for (int i = 0; i < m; i++)\n        {\n            int u, v;\n            long long w;\n            scanf(\"%d %d %lld\", &u, &v, &w);\n            edges[u].push_back(node(v,w));\n        }\n\n        scanf(\"%d %d %d\", &s, &e, &x);\n        queue<int> q;\n        q.push(s);\n        dis[s][0] = 0;\n\n        while (!q.empty())\n        {\n            int u = q.front();\n\n            for (int i = 0; i < edges[u].size(); i++)\n            {\n                int v = edges[u][i].v;\n                long long w = edges[u][i].w;\n                for (int k = 0; k < x; k++)\n                {\n                    if (dis[u][k] != -1 && (dis[v][(k+1)%x] > dis[u][k] + w || dis[v][(k+1)%x] == -1))\n                    {\n                        dis[v][(k+1)%x] = dis[u][k] + w;\n                        if (!book[v])\n                        {\n                            q.push(v);\n                            book[v] = 1;\n                        }\n                    }\n                }\n            }\n            book[u] = 0;\n            q.pop();\n        }\n\n        if (dis[e][0] == -1)\n            printf(\"No Answer!\\n\");\n        else\n            printf(\"%lld\\n\", dis[e][0]);\n    }\n}\n```","slug":"SDUT-2622-最短路径（SPFA-二维）","published":1,"updated":"2017-07-23T03:06:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nde0046y9idyp87te8z","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有一个有向图，给定一个终点和起点，求起点到终点的最短路径，并且路径经过的边数是 x 的倍数。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>想了好长时间，最初是想把每次的步数一起装到队列里面，用 SPFA 。<br>然后 WA ， 只好去搜了下博客，原来是多了个维度，和之前做的一个题神似，<a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4475\" target=\"_blank\" rel=\"external\">UVA1600</a> ，这个是多了一个维度的BFS，以后得想起来这个加一个维度解决问题的方法了，要不遇到就卡死。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li>大体思路是用 SPFA ，增加一个维度，储存步数对 x 取模，最后输出对 x 取模后是 0 的终点距离即可。</li>\n</ul>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w;</div><div class=\"line\">    node(<span class=\"keyword\">int</span> v, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w):v(v),w(w)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;node&gt; edges[<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> book[<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dis[<span class=\"number\">112</span>][<span class=\"number\">11</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> s, e, x;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dis, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dis));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">            edges[i].clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %lld\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            edges[u].push_back(node(v,w));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;s, &amp;e, &amp;x);</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        dis[s][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edges[u][i].v;</div><div class=\"line\">                <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w = edges[u][i].w;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; x; k++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (dis[u][k] != <span class=\"number\">-1</span> &amp;&amp; (dis[v][(k+<span class=\"number\">1</span>)%x] &gt; dis[u][k] + w || dis[v][(k+<span class=\"number\">1</span>)%x] == <span class=\"number\">-1</span>))</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        dis[v][(k+<span class=\"number\">1</span>)%x] = dis[u][k] + w;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!book[v])</div><div class=\"line\">                        &#123;</div><div class=\"line\">                            q.push(v);</div><div class=\"line\">                            book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            book[u] = <span class=\"number\">0</span>;</div><div class=\"line\">            q.pop();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (dis[e][<span class=\"number\">0</span>] == <span class=\"number\">-1</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Answer!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dis[e][<span class=\"number\">0</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2622.html</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有一个有向图，给定一个终点和起点，求起点到终点的最短路径，并且路径经过的边数是 x 的倍数。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>想了好长时间，最初是想把每次的步数一起装到队列里面，用 SPFA 。<br>然后 WA ， 只好去搜了下博客，原来是多了个维度，和之前做的一个题神似，<a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4475\" target=\"_blank\" rel=\"external\">UVA1600</a> ，这个是多了一个维度的BFS，以后得想起来这个加一个维度解决问题的方法了，要不遇到就卡死。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li>大体思路是用 SPFA ，增加一个维度，储存步数对 x 取模，最后输出对 x 取模后是 0 的终点距离即可。</li>\n</ul>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w;</div><div class=\"line\">    node(<span class=\"keyword\">int</span> v, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w):v(v),w(w)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;node&gt; edges[<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">bool</span> book[<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dis[<span class=\"number\">112</span>][<span class=\"number\">11</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> s, e, x;</div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dis, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dis));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">            edges[i].clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %lld\"</span>, &amp;u, &amp;v, &amp;w);</div><div class=\"line\">            edges[u].push_back(node(v,w));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;s, &amp;e, &amp;x);</div><div class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">        q.push(s);</div><div class=\"line\">        dis[s][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (!q.empty())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> v = edges[u][i].v;</div><div class=\"line\">                <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w = edges[u][i].w;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; x; k++)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (dis[u][k] != <span class=\"number\">-1</span> &amp;&amp; (dis[v][(k+<span class=\"number\">1</span>)%x] &gt; dis[u][k] + w || dis[v][(k+<span class=\"number\">1</span>)%x] == <span class=\"number\">-1</span>))</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        dis[v][(k+<span class=\"number\">1</span>)%x] = dis[u][k] + w;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!book[v])</div><div class=\"line\">                        &#123;</div><div class=\"line\">                            q.push(v);</div><div class=\"line\">                            book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            book[u] = <span class=\"number\">0</span>;</div><div class=\"line\">            q.pop();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (dis[e][<span class=\"number\">0</span>] == <span class=\"number\">-1</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Answer!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dis[e][<span class=\"number\">0</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"SDUT Problem_5 二哥的狗（水题）","date":"2016-12-26T14:45:59.000Z","_content":"# 题目链接：\n[二哥的狗](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1970/pid/3420.html)\n（在重现比赛里，可能随时消失，题目也找不到，这里把题目描述发一下好了）\n\n第一学期已经接近尾声了，通往寒假的大门由八位Exam把守。\n作为Exam大家族里的二哥，当然要比之前那些Exam们要凶恶的多。\n二哥养了一群恶犬，如果你能战胜他们，二哥就放你过去。\n当然不是让你赤手空搏，二哥也给你准备了同样数目的几只恶犬。\n已知你的每只恶犬只能攻击二哥对应位置的恶犬，\n当你的某只恶犬进行攻击时，会同时遭受敌方和其左右两只恶犬的攻击，如果某侧没有恶犬或者已被消灭，则该侧不会对你的恶犬造成伤害。\n已知每只斗犬的攻击力，如果你的当前进行攻击的恶犬攻击力大于等于对方及左右两侧恶犬造成的总攻击力，就可以消灭掉敌方对应的那一只恶犬，否则不能消灭对方。\n\n\n----------\n# 题目大意：\n就是输入来个等长的数组，然后把两个数组相同位置的数比较，假设输入a, b两个数组，如果b[i] >= a[i-1]+a[i]+a[i+1]，那么第一个数组的a[i]就会被攻击掉，不再提供战斗力了。\n\n\n----------\n# 解题过程：\n\n - 做这个题的曲线也是比较曲折的，花了将近半小时，如果考试的时候就GG了。\n - 刚开始一个思路时，从两部逐渐比较，比如定义head=0，tail定义尾部，然后先比较head，然后head++，再比较tail，tail--。\n - 这么想也是因为边界只有两条恶犬，赢得概率大点23333.\n - 然后WA了。\n - ![这里写图片描述](http://img.blog.csdn.net/20161226231423761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n - 显然是不对的，随便可以出一组数据就GG了，比如\n\t - 1 2 1\n\t - 1 4 1\n - 如果这样先从两边往中间凑的话，两边都无法操纵就GG了，当初是为了O(n)的结果来的。\n - 然后就开始暴力两个for遍历就好了，显然是可以的，不过不知道我那里写错了，最后TLE，不过这样不太优雅~正好突然想起来一个思路，就是接下来题目分析上说的了，虽然TLE了一次，是因为已经攻击的狗又攻击了一次，处理一下就AC了。\n - \n\n\n----------\n# 题目分析：\n\n - 首先一个循环把每个恶犬都遍历一遍。\n - 每条狗都尝试去进攻一下。\n\t - 如果攻击成功的话就去让这条狗的左右两条狗去攻击下，因为一条狗攻击成功的话，那么它左右两条狗攻击成功所需要的攻击力就会刷新（减少）了。\n\t - 如果不成功的话继续尝试下一条狗。\n - 最后结束上面的尝试后，再来一个for检查下二哥的狗是不是全部被咬死了就可以了。\n - 这样虽然最差的情况是O（n^2+n），但是感觉平均起来要好不少。\n\n----------\n# AC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint n;\nint data1[11234], data2[11234];\n\nvoid attack(int i)\n{\n    if (data1[i] == 0)\n        return;\n\n    int temp = data1[i]+data1[i+1]+data1[i-1];\n    if (data2[i] >= temp && temp)\n    {\n        data1[i] = 0;\n        if (i-1 >= 1)\n            attack(i-1);\n        if (i+1 <= n)\n            attack(i+1);\n    }\n}\n\nint judge()\n{\n    for (int i = 1; i <= n; i++)\n        attack(i);\n\n    for (int i = 0; i <= n; i++)\n        if (data1[i])\n            return 0;\n\n    return 1;\n}\n\nint main()\n{\n    while (cin >> n)\n    {\n        memset(data1,0,sizeof(data1));\n        memset(data2,0,sizeof(data2));\n\n        for (int i = 1; i <= n; i++)\n            cin >> data1[i];\n        for (int i = 1; i <= n; i++)\n            cin >> data2[i];\n\n        if (judge())\n            cout << \"Fighting!!!\" << endl;\n        else\n            cout << \"QAQ!!!\" << endl;\n    }\n}\n```","source":"_posts/SDUT-Problem-5-二哥的狗（水题）.md","raw":"---\ntitle: SDUT Problem_5 二哥的狗（水题）\ndate: 2016-12-26 22:45:59\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接：\n[二哥的狗](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1970/pid/3420.html)\n（在重现比赛里，可能随时消失，题目也找不到，这里把题目描述发一下好了）\n\n第一学期已经接近尾声了，通往寒假的大门由八位Exam把守。\n作为Exam大家族里的二哥，当然要比之前那些Exam们要凶恶的多。\n二哥养了一群恶犬，如果你能战胜他们，二哥就放你过去。\n当然不是让你赤手空搏，二哥也给你准备了同样数目的几只恶犬。\n已知你的每只恶犬只能攻击二哥对应位置的恶犬，\n当你的某只恶犬进行攻击时，会同时遭受敌方和其左右两只恶犬的攻击，如果某侧没有恶犬或者已被消灭，则该侧不会对你的恶犬造成伤害。\n已知每只斗犬的攻击力，如果你的当前进行攻击的恶犬攻击力大于等于对方及左右两侧恶犬造成的总攻击力，就可以消灭掉敌方对应的那一只恶犬，否则不能消灭对方。\n\n\n----------\n# 题目大意：\n就是输入来个等长的数组，然后把两个数组相同位置的数比较，假设输入a, b两个数组，如果b[i] >= a[i-1]+a[i]+a[i+1]，那么第一个数组的a[i]就会被攻击掉，不再提供战斗力了。\n\n\n----------\n# 解题过程：\n\n - 做这个题的曲线也是比较曲折的，花了将近半小时，如果考试的时候就GG了。\n - 刚开始一个思路时，从两部逐渐比较，比如定义head=0，tail定义尾部，然后先比较head，然后head++，再比较tail，tail--。\n - 这么想也是因为边界只有两条恶犬，赢得概率大点23333.\n - 然后WA了。\n - ![这里写图片描述](http://img.blog.csdn.net/20161226231423761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n - 显然是不对的，随便可以出一组数据就GG了，比如\n\t - 1 2 1\n\t - 1 4 1\n - 如果这样先从两边往中间凑的话，两边都无法操纵就GG了，当初是为了O(n)的结果来的。\n - 然后就开始暴力两个for遍历就好了，显然是可以的，不过不知道我那里写错了，最后TLE，不过这样不太优雅~正好突然想起来一个思路，就是接下来题目分析上说的了，虽然TLE了一次，是因为已经攻击的狗又攻击了一次，处理一下就AC了。\n - \n\n\n----------\n# 题目分析：\n\n - 首先一个循环把每个恶犬都遍历一遍。\n - 每条狗都尝试去进攻一下。\n\t - 如果攻击成功的话就去让这条狗的左右两条狗去攻击下，因为一条狗攻击成功的话，那么它左右两条狗攻击成功所需要的攻击力就会刷新（减少）了。\n\t - 如果不成功的话继续尝试下一条狗。\n - 最后结束上面的尝试后，再来一个for检查下二哥的狗是不是全部被咬死了就可以了。\n - 这样虽然最差的情况是O（n^2+n），但是感觉平均起来要好不少。\n\n----------\n# AC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint n;\nint data1[11234], data2[11234];\n\nvoid attack(int i)\n{\n    if (data1[i] == 0)\n        return;\n\n    int temp = data1[i]+data1[i+1]+data1[i-1];\n    if (data2[i] >= temp && temp)\n    {\n        data1[i] = 0;\n        if (i-1 >= 1)\n            attack(i-1);\n        if (i+1 <= n)\n            attack(i+1);\n    }\n}\n\nint judge()\n{\n    for (int i = 1; i <= n; i++)\n        attack(i);\n\n    for (int i = 0; i <= n; i++)\n        if (data1[i])\n            return 0;\n\n    return 1;\n}\n\nint main()\n{\n    while (cin >> n)\n    {\n        memset(data1,0,sizeof(data1));\n        memset(data2,0,sizeof(data2));\n\n        for (int i = 1; i <= n; i++)\n            cin >> data1[i];\n        for (int i = 1; i <= n; i++)\n            cin >> data2[i];\n\n        if (judge())\n            cout << \"Fighting!!!\" << endl;\n        else\n            cout << \"QAQ!!!\" << endl;\n    }\n}\n```","slug":"SDUT-Problem-5-二哥的狗（水题）","published":1,"updated":"2017-07-23T04:05:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndg0048y9id2irq134t","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1970/pid/3420.html\" target=\"_blank\" rel=\"external\">二哥的狗</a><br>（在重现比赛里，可能随时消失，题目也找不到，这里把题目描述发一下好了）</p>\n<p>第一学期已经接近尾声了，通往寒假的大门由八位Exam把守。<br>作为Exam大家族里的二哥，当然要比之前那些Exam们要凶恶的多。<br>二哥养了一群恶犬，如果你能战胜他们，二哥就放你过去。<br>当然不是让你赤手空搏，二哥也给你准备了同样数目的几只恶犬。<br>已知你的每只恶犬只能攻击二哥对应位置的恶犬，<br>当你的某只恶犬进行攻击时，会同时遭受敌方和其左右两只恶犬的攻击，如果某侧没有恶犬或者已被消灭，则该侧不会对你的恶犬造成伤害。<br>已知每只斗犬的攻击力，如果你的当前进行攻击的恶犬攻击力大于等于对方及左右两侧恶犬造成的总攻击力，就可以消灭掉敌方对应的那一只恶犬，否则不能消灭对方。</p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>就是输入来个等长的数组，然后把两个数组相同位置的数比较，假设输入a, b两个数组，如果b[i] &gt;= a[i-1]+a[i]+a[i+1]，那么第一个数组的a[i]就会被攻击掉，不再提供战斗力了。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>做这个题的曲线也是比较曲折的，花了将近半小时，如果考试的时候就GG了。</li>\n<li>刚开始一个思路时，从两部逐渐比较，比如定义head=0，tail定义尾部，然后先比较head，然后head++，再比较tail，tail–。</li>\n<li>这么想也是因为边界只有两条恶犬，赢得概率大点23333.</li>\n<li>然后WA了。</li>\n<li><img src=\"http://img.blog.csdn.net/20161226231423761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></li>\n<li>显然是不对的，随便可以出一组数据就GG了，比如<ul>\n<li>1 2 1</li>\n<li>1 4 1</li>\n</ul>\n</li>\n<li>如果这样先从两边往中间凑的话，两边都无法操纵就GG了，当初是为了O(n)的结果来的。</li>\n<li>然后就开始暴力两个for遍历就好了，显然是可以的，不过不知道我那里写错了，最后TLE，不过这样不太优雅~正好突然想起来一个思路，就是接下来题目分析上说的了，虽然TLE了一次，是因为已经攻击的狗又攻击了一次，处理一下就AC了。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>首先一个循环把每个恶犬都遍历一遍。</li>\n<li>每条狗都尝试去进攻一下。<ul>\n<li>如果攻击成功的话就去让这条狗的左右两条狗去攻击下，因为一条狗攻击成功的话，那么它左右两条狗攻击成功所需要的攻击力就会刷新（减少）了。</li>\n<li>如果不成功的话继续尝试下一条狗。</li>\n</ul>\n</li>\n<li>最后结束上面的尝试后，再来一个for检查下二哥的狗是不是全部被咬死了就可以了。</li>\n<li>这样虽然最差的情况是O（n^2+n），但是感觉平均起来要好不少。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> data1[<span class=\"number\">11234</span>], data2[<span class=\"number\">11234</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (data1[i] == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> temp = data1[i]+data1[i+<span class=\"number\">1</span>]+data1[i<span class=\"number\">-1</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (data2[i] &gt;= temp &amp;&amp; temp)</div><div class=\"line\">    &#123;</div><div class=\"line\">        data1[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i<span class=\"number\">-1</span> &gt;= <span class=\"number\">1</span>)</div><div class=\"line\">            attack(i<span class=\"number\">-1</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (i+<span class=\"number\">1</span> &lt;= n)</div><div class=\"line\">            attack(i+<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">        attack(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (data1[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data1,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(data1));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data2,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(data2));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; data1[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; data2[i];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (judge())</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Fighting!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"QAQ!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/1970/pid/3420.html\" target=\"_blank\" rel=\"external\">二哥的狗</a><br>（在重现比赛里，可能随时消失，题目也找不到，这里把题目描述发一下好了）</p>\n<p>第一学期已经接近尾声了，通往寒假的大门由八位Exam把守。<br>作为Exam大家族里的二哥，当然要比之前那些Exam们要凶恶的多。<br>二哥养了一群恶犬，如果你能战胜他们，二哥就放你过去。<br>当然不是让你赤手空搏，二哥也给你准备了同样数目的几只恶犬。<br>已知你的每只恶犬只能攻击二哥对应位置的恶犬，<br>当你的某只恶犬进行攻击时，会同时遭受敌方和其左右两只恶犬的攻击，如果某侧没有恶犬或者已被消灭，则该侧不会对你的恶犬造成伤害。<br>已知每只斗犬的攻击力，如果你的当前进行攻击的恶犬攻击力大于等于对方及左右两侧恶犬造成的总攻击力，就可以消灭掉敌方对应的那一只恶犬，否则不能消灭对方。</p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>就是输入来个等长的数组，然后把两个数组相同位置的数比较，假设输入a, b两个数组，如果b[i] &gt;= a[i-1]+a[i]+a[i+1]，那么第一个数组的a[i]就会被攻击掉，不再提供战斗力了。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>做这个题的曲线也是比较曲折的，花了将近半小时，如果考试的时候就GG了。</li>\n<li>刚开始一个思路时，从两部逐渐比较，比如定义head=0，tail定义尾部，然后先比较head，然后head++，再比较tail，tail–。</li>\n<li>这么想也是因为边界只有两条恶犬，赢得概率大点23333.</li>\n<li>然后WA了。</li>\n<li><img src=\"http://img.blog.csdn.net/20161226231423761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></li>\n<li>显然是不对的，随便可以出一组数据就GG了，比如<ul>\n<li>1 2 1</li>\n<li>1 4 1</li>\n</ul>\n</li>\n<li>如果这样先从两边往中间凑的话，两边都无法操纵就GG了，当初是为了O(n)的结果来的。</li>\n<li>然后就开始暴力两个for遍历就好了，显然是可以的，不过不知道我那里写错了，最后TLE，不过这样不太优雅~正好突然想起来一个思路，就是接下来题目分析上说的了，虽然TLE了一次，是因为已经攻击的狗又攻击了一次，处理一下就AC了。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>首先一个循环把每个恶犬都遍历一遍。</li>\n<li>每条狗都尝试去进攻一下。<ul>\n<li>如果攻击成功的话就去让这条狗的左右两条狗去攻击下，因为一条狗攻击成功的话，那么它左右两条狗攻击成功所需要的攻击力就会刷新（减少）了。</li>\n<li>如果不成功的话继续尝试下一条狗。</li>\n</ul>\n</li>\n<li>最后结束上面的尝试后，再来一个for检查下二哥的狗是不是全部被咬死了就可以了。</li>\n<li>这样虽然最差的情况是O（n^2+n），但是感觉平均起来要好不少。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">int</span> data1[<span class=\"number\">11234</span>], data2[<span class=\"number\">11234</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (data1[i] == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> temp = data1[i]+data1[i+<span class=\"number\">1</span>]+data1[i<span class=\"number\">-1</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (data2[i] &gt;= temp &amp;&amp; temp)</div><div class=\"line\">    &#123;</div><div class=\"line\">        data1[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i<span class=\"number\">-1</span> &gt;= <span class=\"number\">1</span>)</div><div class=\"line\">            attack(i<span class=\"number\">-1</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (i+<span class=\"number\">1</span> &lt;= n)</div><div class=\"line\">            attack(i+<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">        attack(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (data1[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data1,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(data1));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data2,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(data2));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; data1[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; data2[i];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (judge())</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Fighting!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"QAQ!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"SDUTOJ - 2781 二分练习（二分）","date":"2017-04-17T08:21:20.000Z","_content":"# 题目链接：\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html\n\n-------------------------------\n# 题目大意：\n 给你一个序列，然后给你m个元素，让你从序列中找出与每个元素最接近的数字输出来，如果有两个就输出两个。\n\n--------------------------------\n# 解题过程：\n 刚开始是 WA 了好久，看了博客，听学长讲完才知道做法，这里当作一个二分的模板。\n\n----------------------\n# 题目分析：\n+ 本题主要是找二分的下界和上界。\n+ 假设要查找一个数 n，上界是大于等于 n 的数中最小的。下界是小于等于 n 的数中最大的。\n\n------------------------------\n# AC代码：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint data[10000000+10];\n\nint find_left(int l, int r, int k) {\n    int rst = 0;\n    while (l <= r) {\n        int m = (l+r) >> 1;\n        if (data[m] <= k) {\n            rst = m;\n            l = m+1;\n        } else {\n            r = m-1;\n        }\n    }\n    return rst;\n}\n\nint find_right(int l, int r, int k) {\n    int rst = 0;\n    while (l <= r) {\n        int m = (l+r) >> 1;\n        if (data[m] >= k) {\n            rst = m;\n            r = m-1;\n        } else {\n            l = m+1;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", data+i);\n        }\n        sort(data, data+n);\n        while (m--) {\n            int k;\n            scanf(\"%d\", &k);\n            int left = find_left(0, n-1, k);\n            int right = find_right(0, n-1, k);\n\n            if (abs(k-data[left]) != abs(k-data[right])) {\n                if (abs(k-data[left]) < abs(k-data[right]))\n                    printf(\"%d\\n\", data[left]);\n                else\n                    printf(\"%d\\n\", data[right]);\n            }\n            else if (data[left] == data[right]) {\n                printf(\"%d\\n\", data[left]);\n            }\n            else {\n                printf(\"%d %d\\n\", data[left], data[right]);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```\n","source":"_posts/SDUTOJ-2781-二分练习（二分）.md","raw":"---\ntitle: SDUTOJ - 2781 二分练习（二分）\ndate: 2017-04-17 16:21:20\ncategories: [ACM, 二分]\ntags:\n---\n# 题目链接：\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html\n\n-------------------------------\n# 题目大意：\n 给你一个序列，然后给你m个元素，让你从序列中找出与每个元素最接近的数字输出来，如果有两个就输出两个。\n\n--------------------------------\n# 解题过程：\n 刚开始是 WA 了好久，看了博客，听学长讲完才知道做法，这里当作一个二分的模板。\n\n----------------------\n# 题目分析：\n+ 本题主要是找二分的下界和上界。\n+ 假设要查找一个数 n，上界是大于等于 n 的数中最小的。下界是小于等于 n 的数中最大的。\n\n------------------------------\n# AC代码：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint data[10000000+10];\n\nint find_left(int l, int r, int k) {\n    int rst = 0;\n    while (l <= r) {\n        int m = (l+r) >> 1;\n        if (data[m] <= k) {\n            rst = m;\n            l = m+1;\n        } else {\n            r = m-1;\n        }\n    }\n    return rst;\n}\n\nint find_right(int l, int r, int k) {\n    int rst = 0;\n    while (l <= r) {\n        int m = (l+r) >> 1;\n        if (data[m] >= k) {\n            rst = m;\n            r = m-1;\n        } else {\n            l = m+1;\n        }\n    }\n    return rst;\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", data+i);\n        }\n        sort(data, data+n);\n        while (m--) {\n            int k;\n            scanf(\"%d\", &k);\n            int left = find_left(0, n-1, k);\n            int right = find_right(0, n-1, k);\n\n            if (abs(k-data[left]) != abs(k-data[right])) {\n                if (abs(k-data[left]) < abs(k-data[right]))\n                    printf(\"%d\\n\", data[left]);\n                else\n                    printf(\"%d\\n\", data[right]);\n            }\n            else if (data[left] == data[right]) {\n                printf(\"%d\\n\", data[left]);\n            }\n            else {\n                printf(\"%d %d\\n\", data[left], data[right]);\n            }\n        }\n        putchar('\\n');\n    }\n}\n```\n","slug":"SDUTOJ-2781-二分练习（二分）","published":1,"updated":"2017-07-23T02:39:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndh004ay9idvw39uhnm","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给你一个序列，然后给你m个元素，让你从序列中找出与每个元素最接近的数字输出来，如果有两个就输出两个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始是 WA 了好久，看了博客，听学长讲完才知道做法，这里当作一个二分的模板。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>本题主要是找二分的下界和上界。</li>\n<li>假设要查找一个数 n，上界是大于等于 n 的数中最小的。下界是小于等于 n 的数中最大的。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">10000000</span>+<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_left</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = (l+r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[m] &lt;= k) &#123;</div><div class=\"line\">            rst = m;</div><div class=\"line\">            l = m+<span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            r = m<span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_right</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = (l+r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[m] &gt;= k) &#123;</div><div class=\"line\">            rst = m;</div><div class=\"line\">            r = m<span class=\"number\">-1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            l = m+<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(data, data+n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> k;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">            <span class=\"keyword\">int</span> left = find_left(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, k);</div><div class=\"line\">            <span class=\"keyword\">int</span> right = find_right(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, k);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(k-data[left]) != <span class=\"built_in\">abs</span>(k-data[right])) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(k-data[left]) &lt; <span class=\"built_in\">abs</span>(k-data[right]))</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[left]);</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[right]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[left] == data[right]) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[left]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, data[left], data[right]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2781.html</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 给你一个序列，然后给你m个元素，让你从序列中找出与每个元素最接近的数字输出来，如果有两个就输出两个。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始是 WA 了好久，看了博客，听学长讲完才知道做法，这里当作一个二分的模板。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li>本题主要是找二分的下界和上界。</li>\n<li>假设要查找一个数 n，上界是大于等于 n 的数中最小的。下界是小于等于 n 的数中最大的。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">10000000</span>+<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_left</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = (l+r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[m] &lt;= k) &#123;</div><div class=\"line\">            rst = m;</div><div class=\"line\">            l = m+<span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            r = m<span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_right</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = (l+r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[m] &gt;= k) &#123;</div><div class=\"line\">            rst = m;</div><div class=\"line\">            r = m<span class=\"number\">-1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            l = m+<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(data, data+n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> k;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">            <span class=\"keyword\">int</span> left = find_left(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, k);</div><div class=\"line\">            <span class=\"keyword\">int</span> right = find_right(<span class=\"number\">0</span>, n<span class=\"number\">-1</span>, k);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(k-data[left]) != <span class=\"built_in\">abs</span>(k-data[right])) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(k-data[left]) &lt; <span class=\"built_in\">abs</span>(k-data[right]))</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[left]);</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[right]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[left] == data[right]) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, data[left]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, data[left], data[right]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"STL在使用算法竞赛中的使用方法 （教程+未完成）","date":"2017-03-17T11:34:30.000Z","_content":"# 前言：\n+ 本文面向已有 C 语言和部分算法基础的同学。\n+ 内容均是个人总结，由于还没有系统的学习过 C++ 的面向对象，也没有翻过 STL 的代码，均以实用的角度来讲，可能不严谨些。\n+ 接下来介绍的将是一些 C++ STL 容器的使用，特性及一些常用函数。然后还有部分好用的函数。都会以介绍加代码样例的方式写出。\n\n-----------------------------\n# STL:\n------------------------\n## Vector：\n------------------\n### 简介：\nVector 可以看做是一个不定长数组，可以对其进行插入元素，删除元素，按下标访问等基本操作。\n\n**重要的一点 Vector 是一个数组 而不是一个链表**，例如对 Vector 进行插入操作，是基于元素的移位进行的，是 O（n）的复杂度而不是链表的 O（1），但是在其尾部添加元素时是 O（1），应该是内部可以自动优化。\n\nvector 包含在 `<vector>` 头文件中。\n\n---------------------\n### 基本操作：\n首先创建一个 装着 int 类型元素的 vector。\nps：`<int>`这里其实是使用了模板，具体看概念中的模板部分。\n```cpp\nvector<int> data;\n```\n\n接下来给 vector 添加元素，这里先向尾部添加元素，也是最常用的添加元素方式。\nps：这里添加是O（1）\n```cpp\ndata.push_back(1);\ndata.push_back(2);\ndata.push_back(3);\n```\n\n接下来可以用下标访问 vector 里面的元素，和数组类似，输出之前插入的1,2,3\n```cpp\ncout << data[0] << endl;\ncout << data[1] << endl;\ncout << data[2] << endl;\n```\n接下来是插入元素和删除元素。下面的插入是**把 t 插入到 下标为 i 的位置上，原来 i 位置及其后面的元素，都往后移一位**。删除是**删除掉下标为 i 的元素，后面的元素全部前移一位**。\nps：时间复杂度O（n）\n```cpp\ndata.insert(data.begin() + i, t);\ndata.erase(data.begin() + i);\n```\n定义 vector 数组时和普通类型一样使用即可\n```cpp\nvector<int> example[112345];\nexample[233].push_back(666);\n```\n\n接下来是是一些常用的函数，将直接给出代码，代码中加入注释。\n```cpp\n    //返回 data 的大小，有 n 个元素即返回 n\n    data.size();\n    \n    //清空 data，恢复 data 的初始状态\n    data.clear();\n    \n    //重新设置 data 的长度，可用来直接截短\n    data.resize(len);\n```\n-----------------------\n### 进阶技巧：\n了解 vector 使用了模板后，其实 vector 可以用来存 vector 的，例如：\n```cpp\n\tvector<vector<int> > example;\n    example.push_back(vector<int>());\n    example[0].push_back(1);\n```\n这里定义时 >> 用空格分开是编译器可能会把这里当成其他的关键字。\n`vector<int>()` 表示定义一个空的储存 int 类型的 vector。\n这里可能和 vector 数组有点类似，概念上是不同的，使用方法上也有差异。\n 同理 vector 也可以储存本文将要介绍的其他 STL 容器。\n\n----------------------\n## Map：\n-------------------\n### 简介：\n map容器常用来做映射，map的实现是用了数据结构的红黑树，通常来说是O（logn）比 hash 慢些，在一些时间限制不太紧的题中还是够用。\n  map 实现的是一种映射关系，详细见概念部分。\n  map 包含在头文件 `<map>` 中。\n ----------------------------\n### 基本使用：\n 首先创建一个map，这里需要给定两个类型，一个是用来当做访问下标（暂且这样将）的，另一个是储存的数据类型。\n\n\n# 部分概念：\n\n**本部分内容较啰嗦仅供读者更好的理解后面的 STL 如何工作，只希望了解 STL 用法可以直接略过。**\n\n## 模板：\n关于模板这个概念。举个例子，大概意思是，如果要定义一个求两个函数和的函数，需要两个参数 a 和 b，然后返回他们的和。通常来讲我定义函数时如果参数设为 int，那么我这个函数就不可以为 double 类型求和。这时候我需要再为 double 定义一个求和函数。但是你会发现，无不需要关什么 int double 类型，只要输入进来的两个变量，只要定义了他们类型之间的加法应该是什么样子就可以了。\n\n比如说输入两个整型和浮点型，直接返回他们的和就可以了。有了模板这个概念后，我甚至可以给这两个函数输入两个矩阵 a = [1,2,3,4], b = [2,2,3,4]，求这两个矩阵的和，只要我定义好两个矩阵相加应该是什么样的规则就好了。\n\n这样以后更深入的话，就可以知道，这样可以实现类的多态。\n意思是给我两个你自己定义的 结构体/对象 我要求他的和，你只要定义好这个数据类型相加应该是什么样的就好了，不用再去定义一个函数。\n\n接下来的 STL 容器都用了模板的概念，大概是 **[容器名]<类型名>** 这样的形式，然后类型那里可以随便填了（前提是有），int 也好，自己定义的结构体也好，运用上面的概念，STL 容器不关心他存的是上面类型，只要这个类型定义了某些运算应该符合什么样的规则就可以了。\n\n## 迭代器：\n这里可以当做指针对待，不再作详细介绍，**[容器名].begin()** 返回指向某容器首部的迭代器。\n\n## 映射：\n 这里用数学里面的概念好了，意思是给定一个 x，对应一个唯一的 y。\n \n 亦可把 map 理解成一个下标为任意类型的数组，比如我可以用一个字符串当下标来储存一个整数。\n\n 这里用一下 Python 字典的概念好了，map 大概也是这个东西，map 中储存的是无数个 key：value 这样的键值对，不可存在同样的 key，访问 value，通过输入他的 key 来访问。","source":"_posts/STL在使用算法竞赛中的使用方法-（教程-未完成）.md","raw":"---\ntitle: STL在使用算法竞赛中的使用方法 （教程+未完成）\ndate: 2017-03-17 19:34:30\ncategories: [编程语言, C++]\ntags:\n---\n# 前言：\n+ 本文面向已有 C 语言和部分算法基础的同学。\n+ 内容均是个人总结，由于还没有系统的学习过 C++ 的面向对象，也没有翻过 STL 的代码，均以实用的角度来讲，可能不严谨些。\n+ 接下来介绍的将是一些 C++ STL 容器的使用，特性及一些常用函数。然后还有部分好用的函数。都会以介绍加代码样例的方式写出。\n\n-----------------------------\n# STL:\n------------------------\n## Vector：\n------------------\n### 简介：\nVector 可以看做是一个不定长数组，可以对其进行插入元素，删除元素，按下标访问等基本操作。\n\n**重要的一点 Vector 是一个数组 而不是一个链表**，例如对 Vector 进行插入操作，是基于元素的移位进行的，是 O（n）的复杂度而不是链表的 O（1），但是在其尾部添加元素时是 O（1），应该是内部可以自动优化。\n\nvector 包含在 `<vector>` 头文件中。\n\n---------------------\n### 基本操作：\n首先创建一个 装着 int 类型元素的 vector。\nps：`<int>`这里其实是使用了模板，具体看概念中的模板部分。\n```cpp\nvector<int> data;\n```\n\n接下来给 vector 添加元素，这里先向尾部添加元素，也是最常用的添加元素方式。\nps：这里添加是O（1）\n```cpp\ndata.push_back(1);\ndata.push_back(2);\ndata.push_back(3);\n```\n\n接下来可以用下标访问 vector 里面的元素，和数组类似，输出之前插入的1,2,3\n```cpp\ncout << data[0] << endl;\ncout << data[1] << endl;\ncout << data[2] << endl;\n```\n接下来是插入元素和删除元素。下面的插入是**把 t 插入到 下标为 i 的位置上，原来 i 位置及其后面的元素，都往后移一位**。删除是**删除掉下标为 i 的元素，后面的元素全部前移一位**。\nps：时间复杂度O（n）\n```cpp\ndata.insert(data.begin() + i, t);\ndata.erase(data.begin() + i);\n```\n定义 vector 数组时和普通类型一样使用即可\n```cpp\nvector<int> example[112345];\nexample[233].push_back(666);\n```\n\n接下来是是一些常用的函数，将直接给出代码，代码中加入注释。\n```cpp\n    //返回 data 的大小，有 n 个元素即返回 n\n    data.size();\n    \n    //清空 data，恢复 data 的初始状态\n    data.clear();\n    \n    //重新设置 data 的长度，可用来直接截短\n    data.resize(len);\n```\n-----------------------\n### 进阶技巧：\n了解 vector 使用了模板后，其实 vector 可以用来存 vector 的，例如：\n```cpp\n\tvector<vector<int> > example;\n    example.push_back(vector<int>());\n    example[0].push_back(1);\n```\n这里定义时 >> 用空格分开是编译器可能会把这里当成其他的关键字。\n`vector<int>()` 表示定义一个空的储存 int 类型的 vector。\n这里可能和 vector 数组有点类似，概念上是不同的，使用方法上也有差异。\n 同理 vector 也可以储存本文将要介绍的其他 STL 容器。\n\n----------------------\n## Map：\n-------------------\n### 简介：\n map容器常用来做映射，map的实现是用了数据结构的红黑树，通常来说是O（logn）比 hash 慢些，在一些时间限制不太紧的题中还是够用。\n  map 实现的是一种映射关系，详细见概念部分。\n  map 包含在头文件 `<map>` 中。\n ----------------------------\n### 基本使用：\n 首先创建一个map，这里需要给定两个类型，一个是用来当做访问下标（暂且这样将）的，另一个是储存的数据类型。\n\n\n# 部分概念：\n\n**本部分内容较啰嗦仅供读者更好的理解后面的 STL 如何工作，只希望了解 STL 用法可以直接略过。**\n\n## 模板：\n关于模板这个概念。举个例子，大概意思是，如果要定义一个求两个函数和的函数，需要两个参数 a 和 b，然后返回他们的和。通常来讲我定义函数时如果参数设为 int，那么我这个函数就不可以为 double 类型求和。这时候我需要再为 double 定义一个求和函数。但是你会发现，无不需要关什么 int double 类型，只要输入进来的两个变量，只要定义了他们类型之间的加法应该是什么样子就可以了。\n\n比如说输入两个整型和浮点型，直接返回他们的和就可以了。有了模板这个概念后，我甚至可以给这两个函数输入两个矩阵 a = [1,2,3,4], b = [2,2,3,4]，求这两个矩阵的和，只要我定义好两个矩阵相加应该是什么样的规则就好了。\n\n这样以后更深入的话，就可以知道，这样可以实现类的多态。\n意思是给我两个你自己定义的 结构体/对象 我要求他的和，你只要定义好这个数据类型相加应该是什么样的就好了，不用再去定义一个函数。\n\n接下来的 STL 容器都用了模板的概念，大概是 **[容器名]<类型名>** 这样的形式，然后类型那里可以随便填了（前提是有），int 也好，自己定义的结构体也好，运用上面的概念，STL 容器不关心他存的是上面类型，只要这个类型定义了某些运算应该符合什么样的规则就可以了。\n\n## 迭代器：\n这里可以当做指针对待，不再作详细介绍，**[容器名].begin()** 返回指向某容器首部的迭代器。\n\n## 映射：\n 这里用数学里面的概念好了，意思是给定一个 x，对应一个唯一的 y。\n \n 亦可把 map 理解成一个下标为任意类型的数组，比如我可以用一个字符串当下标来储存一个整数。\n\n 这里用一下 Python 字典的概念好了，map 大概也是这个东西，map 中储存的是无数个 key：value 这样的键值对，不可存在同样的 key，访问 value，通过输入他的 key 来访问。","slug":"STL在使用算法竞赛中的使用方法-（教程-未完成）","published":1,"updated":"2017-07-23T02:48:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndj004dy9idfdnv7lys","content":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><ul>\n<li>本文面向已有 C 语言和部分算法基础的同学。</li>\n<li>内容均是个人总结，由于还没有系统的学习过 C++ 的面向对象，也没有翻过 STL 的代码，均以实用的角度来讲，可能不严谨些。</li>\n<li>接下来介绍的将是一些 C++ STL 容器的使用，特性及一些常用函数。然后还有部分好用的函数。都会以介绍加代码样例的方式写出。</li>\n</ul>\n<hr>\n<h1 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL:\"></a>STL:</h1><hr>\n<h2 id=\"Vector：\"><a href=\"#Vector：\" class=\"headerlink\" title=\"Vector：\"></a>Vector：</h2><hr>\n<h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>Vector 可以看做是一个不定长数组，可以对其进行插入元素，删除元素，按下标访问等基本操作。</p>\n<p><strong>重要的一点 Vector 是一个数组 而不是一个链表</strong>，例如对 Vector 进行插入操作，是基于元素的移位进行的，是 O（n）的复杂度而不是链表的 O（1），但是在其尾部添加元素时是 O（1），应该是内部可以自动优化。</p>\n<p>vector 包含在 <code>&lt;vector&gt;</code> 头文件中。</p>\n<hr>\n<h3 id=\"基本操作：\"><a href=\"#基本操作：\" class=\"headerlink\" title=\"基本操作：\"></a>基本操作：</h3><p>首先创建一个 装着 int 类型元素的 vector。<br>ps：<code>&lt;int&gt;</code>这里其实是使用了模板，具体看概念中的模板部分。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div></pre></td></tr></table></figure></p>\n<p>接下来给 vector 添加元素，这里先向尾部添加元素，也是最常用的添加元素方式。<br>ps：这里添加是O（1）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">data.push_back(<span class=\"number\">1</span>);</div><div class=\"line\">data.push_back(<span class=\"number\">2</span>);</div><div class=\"line\">data.push_back(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>接下来可以用下标访问 vector 里面的元素，和数组类似，输出之前插入的1,2,3<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">2</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>接下来是插入元素和删除元素。下面的插入是<strong>把 t 插入到 下标为 i 的位置上，原来 i 位置及其后面的元素，都往后移一位</strong>。删除是<strong>删除掉下标为 i 的元素，后面的元素全部前移一位</strong>。<br>ps：时间复杂度O（n）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">data.insert(data.begin() + i, t);</div><div class=\"line\">data.erase(data.begin() + i);</div></pre></td></tr></table></figure></p>\n<p>定义 vector 数组时和普通类型一样使用即可<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; example[<span class=\"number\">112345</span>];</div><div class=\"line\">example[<span class=\"number\">233</span>].push_back(<span class=\"number\">666</span>);</div></pre></td></tr></table></figure></p>\n<p>接下来是是一些常用的函数，将直接给出代码，代码中加入注释。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回 data 的大小，有 n 个元素即返回 n</span></div><div class=\"line\">data.size();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//清空 data，恢复 data 的初始状态</span></div><div class=\"line\">data.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//重新设置 data 的长度，可用来直接截短</span></div><div class=\"line\">data.resize(len);</div></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"进阶技巧：\"><a href=\"#进阶技巧：\" class=\"headerlink\" title=\"进阶技巧：\"></a>进阶技巧：</h3><p>了解 vector 使用了模板后，其实 vector 可以用来存 vector 的，例如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; example;</div><div class=\"line\">   example.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</div><div class=\"line\">   example[<span class=\"number\">0</span>].push_back(<span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>这里定义时 &gt;&gt; 用空格分开是编译器可能会把这里当成其他的关键字。<br><code>vector&lt;int&gt;()</code> 表示定义一个空的储存 int 类型的 vector。<br>这里可能和 vector 数组有点类似，概念上是不同的，使用方法上也有差异。<br> 同理 vector 也可以储存本文将要介绍的其他 STL 容器。</p>\n<hr>\n<h2 id=\"Map：\"><a href=\"#Map：\" class=\"headerlink\" title=\"Map：\"></a>Map：</h2><hr>\n<h3 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p> map容器常用来做映射，map的实现是用了数据结构的红黑树，通常来说是O（logn）比 hash 慢些，在一些时间限制不太紧的题中还是够用。<br>  map 实现的是一种映射关系，详细见概念部分。</p>\n<h2 id=\"map-包含在头文件-lt-map-gt-中。\"><a href=\"#map-包含在头文件-lt-map-gt-中。\" class=\"headerlink\" title=\"  map 包含在头文件 &lt;map&gt; 中。\"></a>  map 包含在头文件 <code>&lt;map&gt;</code> 中。</h2><h3 id=\"基本使用：\"><a href=\"#基本使用：\" class=\"headerlink\" title=\"基本使用：\"></a>基本使用：</h3><p> 首先创建一个map，这里需要给定两个类型，一个是用来当做访问下标（暂且这样将）的，另一个是储存的数据类型。</p>\n<h1 id=\"部分概念：\"><a href=\"#部分概念：\" class=\"headerlink\" title=\"部分概念：\"></a>部分概念：</h1><p><strong>本部分内容较啰嗦仅供读者更好的理解后面的 STL 如何工作，只希望了解 STL 用法可以直接略过。</strong></p>\n<h2 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h2><p>关于模板这个概念。举个例子，大概意思是，如果要定义一个求两个函数和的函数，需要两个参数 a 和 b，然后返回他们的和。通常来讲我定义函数时如果参数设为 int，那么我这个函数就不可以为 double 类型求和。这时候我需要再为 double 定义一个求和函数。但是你会发现，无不需要关什么 int double 类型，只要输入进来的两个变量，只要定义了他们类型之间的加法应该是什么样子就可以了。</p>\n<p>比如说输入两个整型和浮点型，直接返回他们的和就可以了。有了模板这个概念后，我甚至可以给这两个函数输入两个矩阵 a = [1,2,3,4], b = [2,2,3,4]，求这两个矩阵的和，只要我定义好两个矩阵相加应该是什么样的规则就好了。</p>\n<p>这样以后更深入的话，就可以知道，这样可以实现类的多态。<br>意思是给我两个你自己定义的 结构体/对象 我要求他的和，你只要定义好这个数据类型相加应该是什么样的就好了，不用再去定义一个函数。</p>\n<p>接下来的 STL 容器都用了模板的概念，大概是 <strong>[容器名]&lt;类型名&gt;</strong> 这样的形式，然后类型那里可以随便填了（前提是有），int 也好，自己定义的结构体也好，运用上面的概念，STL 容器不关心他存的是上面类型，只要这个类型定义了某些运算应该符合什么样的规则就可以了。</p>\n<h2 id=\"迭代器：\"><a href=\"#迭代器：\" class=\"headerlink\" title=\"迭代器：\"></a>迭代器：</h2><p>这里可以当做指针对待，不再作详细介绍，<strong>[容器名].begin()</strong> 返回指向某容器首部的迭代器。</p>\n<h2 id=\"映射：\"><a href=\"#映射：\" class=\"headerlink\" title=\"映射：\"></a>映射：</h2><p> 这里用数学里面的概念好了，意思是给定一个 x，对应一个唯一的 y。</p>\n<p> 亦可把 map 理解成一个下标为任意类型的数组，比如我可以用一个字符串当下标来储存一个整数。</p>\n<p> 这里用一下 Python 字典的概念好了，map 大概也是这个东西，map 中储存的是无数个 key：value 这样的键值对，不可存在同样的 key，访问 value，通过输入他的 key 来访问。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><ul>\n<li>本文面向已有 C 语言和部分算法基础的同学。</li>\n<li>内容均是个人总结，由于还没有系统的学习过 C++ 的面向对象，也没有翻过 STL 的代码，均以实用的角度来讲，可能不严谨些。</li>\n<li>接下来介绍的将是一些 C++ STL 容器的使用，特性及一些常用函数。然后还有部分好用的函数。都会以介绍加代码样例的方式写出。</li>\n</ul>\n<hr>\n<h1 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL:\"></a>STL:</h1><hr>\n<h2 id=\"Vector：\"><a href=\"#Vector：\" class=\"headerlink\" title=\"Vector：\"></a>Vector：</h2><hr>\n<h3 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p>Vector 可以看做是一个不定长数组，可以对其进行插入元素，删除元素，按下标访问等基本操作。</p>\n<p><strong>重要的一点 Vector 是一个数组 而不是一个链表</strong>，例如对 Vector 进行插入操作，是基于元素的移位进行的，是 O（n）的复杂度而不是链表的 O（1），但是在其尾部添加元素时是 O（1），应该是内部可以自动优化。</p>\n<p>vector 包含在 <code>&lt;vector&gt;</code> 头文件中。</p>\n<hr>\n<h3 id=\"基本操作：\"><a href=\"#基本操作：\" class=\"headerlink\" title=\"基本操作：\"></a>基本操作：</h3><p>首先创建一个 装着 int 类型元素的 vector。<br>ps：<code>&lt;int&gt;</code>这里其实是使用了模板，具体看概念中的模板部分。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; data;</div></pre></td></tr></table></figure></p>\n<p>接下来给 vector 添加元素，这里先向尾部添加元素，也是最常用的添加元素方式。<br>ps：这里添加是O（1）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">data.push_back(<span class=\"number\">1</span>);</div><div class=\"line\">data.push_back(<span class=\"number\">2</span>);</div><div class=\"line\">data.push_back(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>接下来可以用下标访问 vector 里面的元素，和数组类似，输出之前插入的1,2,3<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; data[<span class=\"number\">2</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>接下来是插入元素和删除元素。下面的插入是<strong>把 t 插入到 下标为 i 的位置上，原来 i 位置及其后面的元素，都往后移一位</strong>。删除是<strong>删除掉下标为 i 的元素，后面的元素全部前移一位</strong>。<br>ps：时间复杂度O（n）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">data.insert(data.begin() + i, t);</div><div class=\"line\">data.erase(data.begin() + i);</div></pre></td></tr></table></figure></p>\n<p>定义 vector 数组时和普通类型一样使用即可<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; example[<span class=\"number\">112345</span>];</div><div class=\"line\">example[<span class=\"number\">233</span>].push_back(<span class=\"number\">666</span>);</div></pre></td></tr></table></figure></p>\n<p>接下来是是一些常用的函数，将直接给出代码，代码中加入注释。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回 data 的大小，有 n 个元素即返回 n</span></div><div class=\"line\">data.size();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//清空 data，恢复 data 的初始状态</span></div><div class=\"line\">data.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//重新设置 data 的长度，可用来直接截短</span></div><div class=\"line\">data.resize(len);</div></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"进阶技巧：\"><a href=\"#进阶技巧：\" class=\"headerlink\" title=\"进阶技巧：\"></a>进阶技巧：</h3><p>了解 vector 使用了模板后，其实 vector 可以用来存 vector 的，例如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; example;</div><div class=\"line\">   example.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;());</div><div class=\"line\">   example[<span class=\"number\">0</span>].push_back(<span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>这里定义时 &gt;&gt; 用空格分开是编译器可能会把这里当成其他的关键字。<br><code>vector&lt;int&gt;()</code> 表示定义一个空的储存 int 类型的 vector。<br>这里可能和 vector 数组有点类似，概念上是不同的，使用方法上也有差异。<br> 同理 vector 也可以储存本文将要介绍的其他 STL 容器。</p>\n<hr>\n<h2 id=\"Map：\"><a href=\"#Map：\" class=\"headerlink\" title=\"Map：\"></a>Map：</h2><hr>\n<h3 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h3><p> map容器常用来做映射，map的实现是用了数据结构的红黑树，通常来说是O（logn）比 hash 慢些，在一些时间限制不太紧的题中还是够用。<br>  map 实现的是一种映射关系，详细见概念部分。</p>\n<h2 id=\"map-包含在头文件-lt-map-gt-中。\"><a href=\"#map-包含在头文件-lt-map-gt-中。\" class=\"headerlink\" title=\"  map 包含在头文件 &lt;map&gt; 中。\"></a>  map 包含在头文件 <code>&lt;map&gt;</code> 中。</h2><h3 id=\"基本使用：\"><a href=\"#基本使用：\" class=\"headerlink\" title=\"基本使用：\"></a>基本使用：</h3><p> 首先创建一个map，这里需要给定两个类型，一个是用来当做访问下标（暂且这样将）的，另一个是储存的数据类型。</p>\n<h1 id=\"部分概念：\"><a href=\"#部分概念：\" class=\"headerlink\" title=\"部分概念：\"></a>部分概念：</h1><p><strong>本部分内容较啰嗦仅供读者更好的理解后面的 STL 如何工作，只希望了解 STL 用法可以直接略过。</strong></p>\n<h2 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h2><p>关于模板这个概念。举个例子，大概意思是，如果要定义一个求两个函数和的函数，需要两个参数 a 和 b，然后返回他们的和。通常来讲我定义函数时如果参数设为 int，那么我这个函数就不可以为 double 类型求和。这时候我需要再为 double 定义一个求和函数。但是你会发现，无不需要关什么 int double 类型，只要输入进来的两个变量，只要定义了他们类型之间的加法应该是什么样子就可以了。</p>\n<p>比如说输入两个整型和浮点型，直接返回他们的和就可以了。有了模板这个概念后，我甚至可以给这两个函数输入两个矩阵 a = [1,2,3,4], b = [2,2,3,4]，求这两个矩阵的和，只要我定义好两个矩阵相加应该是什么样的规则就好了。</p>\n<p>这样以后更深入的话，就可以知道，这样可以实现类的多态。<br>意思是给我两个你自己定义的 结构体/对象 我要求他的和，你只要定义好这个数据类型相加应该是什么样的就好了，不用再去定义一个函数。</p>\n<p>接下来的 STL 容器都用了模板的概念，大概是 <strong>[容器名]&lt;类型名&gt;</strong> 这样的形式，然后类型那里可以随便填了（前提是有），int 也好，自己定义的结构体也好，运用上面的概念，STL 容器不关心他存的是上面类型，只要这个类型定义了某些运算应该符合什么样的规则就可以了。</p>\n<h2 id=\"迭代器：\"><a href=\"#迭代器：\" class=\"headerlink\" title=\"迭代器：\"></a>迭代器：</h2><p>这里可以当做指针对待，不再作详细介绍，<strong>[容器名].begin()</strong> 返回指向某容器首部的迭代器。</p>\n<h2 id=\"映射：\"><a href=\"#映射：\" class=\"headerlink\" title=\"映射：\"></a>映射：</h2><p> 这里用数学里面的概念好了，意思是给定一个 x，对应一个唯一的 y。</p>\n<p> 亦可把 map 理解成一个下标为任意类型的数组，比如我可以用一个字符串当下标来储存一个整数。</p>\n<p> 这里用一下 Python 字典的概念好了，map 大概也是这个东西，map 中储存的是无数个 key：value 这样的键值对，不可存在同样的 key，访问 value，通过输入他的 key 来访问。</p>\n"},{"title":"SDUTOJ. LCS问题.(DP)","date":"2016-12-05T09:50:22.000Z","_content":"# 题目链接：\n\n[CodeForces255C.](http://codeforces.com/contest/255/problem/C)\n\n\n----------\n# 题目大意：\n看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.\n数据小于4000.\n\n\n----------\n# 解题过程：\n\n - 看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。\n \n - 比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。\n错误的状态转移方程：\t\t\t\t ***a[i] = a[j] + 1 (a[i] == b[i])***\n  显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。\n  \n - 于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：[题解](http://blog.csdn.net/qq_24451605/article/details/48659235)\n 可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……\n\n\n----------\n# 分析过程：\n\n - 用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。\n - 状态转移方程：***dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])***\n - 看巨巨的题解K在状态转移的过程中就可以找到了。\n\n----------\n# AC代码：\n\n```cpp\n#include <iostream>\n#define MAX 4123\nusing namespace std;\n\nint data[MAX];\nint dp[MAX][MAX];\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> data[i];\n    }\n\n    int ans = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = -1;\n        for (int j = 1; j < i; j++)\n        {\n            if (k == -1)\n                dp[i][j] = 2;\n            else\n                dp[i][j] = dp[j][k] + 1;\n            if (data[i] == data[j])\n                k = j;\n            if (ans < dp[i][j])\n                ans = dp[i][j];\n        }\n    }\n    cout << ans;\n}\n```\n#暴力遍历代码：\n看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nset<int> check;\nvector<int> store;\nint data[41234];\nint n;\n\nint scan(int a, int b)\n{\n    int judge = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (judge == 0 && (data[i] == a || data[i] == b) || data[i] == judge)\n        {\n            if (data[i] == a)\n            {\n                judge = b;\n            }\n            if (data[i] == b)\n            {\n                judge = a;\n            }\n            sum++;\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> data[i];\n        if (check.count(data[i]) == 0)\n        {\n            check.insert(data[i]);\n            store.push_back(data[i]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < store.size(); i++)\n    {\n        for (int j = i; j < store.size(); j++)\n        {\n            int t = scan(data[i], data[j]);\n            ans = ans > t? ans:t;\n        }\n    }\n    cout << ans;\n}\n```","source":"_posts/SDUTOJ-LCS问题-DP.md","raw":"---\ntitle: SDUTOJ. LCS问题.(DP)\ndate: 2016-12-05 17:50:22\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\n[CodeForces255C.](http://codeforces.com/contest/255/problem/C)\n\n\n----------\n# 题目大意：\n看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.\n数据小于4000.\n\n\n----------\n# 解题过程：\n\n - 看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。\n \n - 比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。\n错误的状态转移方程：\t\t\t\t ***a[i] = a[j] + 1 (a[i] == b[i])***\n  显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。\n  \n - 于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：[题解](http://blog.csdn.net/qq_24451605/article/details/48659235)\n 可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……\n\n\n----------\n# 分析过程：\n\n - 用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。\n - 状态转移方程：***dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])***\n - 看巨巨的题解K在状态转移的过程中就可以找到了。\n\n----------\n# AC代码：\n\n```cpp\n#include <iostream>\n#define MAX 4123\nusing namespace std;\n\nint data[MAX];\nint dp[MAX][MAX];\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> data[i];\n    }\n\n    int ans = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        int k = -1;\n        for (int j = 1; j < i; j++)\n        {\n            if (k == -1)\n                dp[i][j] = 2;\n            else\n                dp[i][j] = dp[j][k] + 1;\n            if (data[i] == data[j])\n                k = j;\n            if (ans < dp[i][j])\n                ans = dp[i][j];\n        }\n    }\n    cout << ans;\n}\n```\n#暴力遍历代码：\n看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nset<int> check;\nvector<int> store;\nint data[41234];\nint n;\n\nint scan(int a, int b)\n{\n    int judge = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (judge == 0 && (data[i] == a || data[i] == b) || data[i] == judge)\n        {\n            if (data[i] == a)\n            {\n                judge = b;\n            }\n            if (data[i] == b)\n            {\n                judge = a;\n            }\n            sum++;\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> data[i];\n        if (check.count(data[i]) == 0)\n        {\n            check.insert(data[i]);\n            store.push_back(data[i]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < store.size(); i++)\n    {\n        for (int j = i; j < store.size(); j++)\n        {\n            int t = scan(data[i], data[j]);\n            ans = ans > t? ans:t;\n        }\n    }\n    cout << ans;\n}\n```","slug":"SDUTOJ-LCS问题-DP","published":1,"updated":"2017-07-23T04:14:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndq004fy9idtflmmhdq","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/255/problem/C\" target=\"_blank\" rel=\"external\">CodeForces255C.</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.<br>数据小于4000.</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li><p>看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。</p>\n</li>\n<li><p>比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。<br>错误的状态转移方程：                 <strong><em>a[i] = a[j] + 1 (a[i] == b[i])</em></strong><br>显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。</p>\n</li>\n<li><p>于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：<a href=\"http://blog.csdn.net/qq_24451605/article/details/48659235\" target=\"_blank\" rel=\"external\">题解</a><br>可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h1><ul>\n<li>用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。</li>\n<li>状态转移方程：<strong><em>dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])</em></strong></li>\n<li>看巨巨的题解K在状态转移的过程中就可以找到了。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 4123</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">-1</span>)</div><div class=\"line\">                dp[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[i][j] = dp[j][k] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == data[j])</div><div class=\"line\">                k = j;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans &lt; dp[i][j])</div><div class=\"line\">                ans = dp[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#暴力遍历代码：<br>看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;algorithm&gt;</div><div class=\"line\">#include &lt;set&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">set&lt;int&gt; check;</div><div class=\"line\">vector&lt;int&gt; store;</div><div class=\"line\">int data[41234];</div><div class=\"line\">int n;</div><div class=\"line\"></div><div class=\"line\">int scan(int a, int b)</div><div class=\"line\">&#123;</div><div class=\"line\">    int judge = 0;</div><div class=\"line\">    int sum = 0;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (judge == 0 &amp;&amp; (data[i] == a || data[i] == b) || data[i] == judge)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (data[i] == a)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = b;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (data[i] == b)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = a;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    cin &gt;&gt; n;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        cin &gt;&gt; data[i];</div><div class=\"line\">        if (check.count(data[i]) == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">            check.insert(data[i]);</div><div class=\"line\">            store.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int ans = 0;</div><div class=\"line\">    for (int i = 0; i &lt; store.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = i; j &lt; store.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            int t = scan(data[i], data[j]);</div><div class=\"line\">            ans = ans &gt; t? ans:t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://codeforces.com/contest/255/problem/C\" target=\"_blank\" rel=\"external\">CodeForces255C.</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>看起来题目给的公式很复杂，其实就是找最长的 1,2,1,2 类似这样的最长子序列.<br>数据小于4000.</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li><p>看到这个题首先就想到了用DP来做，毕竟正在刷DP的专题，刚开始想着这个题类似最长公共子序列那样，然后想了一个多小时也没结果，最后比赛快结束的半小时想起来这个和最长上升子序列有点像（后来发现也不是）。</p>\n</li>\n<li><p>比赛完后想到了一个状态转移方程（错误的）用两个一维数组，一个用来记录以每一个数为最后一个数的最大长度，另一个储存最大长度的情况下的上一个数。<br>错误的状态转移方程：                 <strong><em>a[i] = a[j] + 1 (a[i] == b[i])</em></strong><br>显然是错误的，于是我还考虑了下最长有多种情况的情况，用set储存上一个数，还是错误（毕竟想法就不太对）。</p>\n</li>\n<li><p>于是隔了一天还是没想起来，于是百度了下题解，找到了一个不错的博客：<a href=\"http://blog.csdn.net/qq_24451605/article/details/48659235\" target=\"_blank\" rel=\"external\">题解</a><br>可以看出来这篇博客风格也照抄了一下233，分析的很清楚，然后自己拿纸模拟了一遍，感觉这么简单的题怎么没想出来……</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h1><ul>\n<li>用a[i][j]二维数组储存状态，i代表以第几个数结束，j代表倒数第二个数。</li>\n<li>状态转移方程：<strong><em>dp[i][j]  =  dp[j][k] + 1 (a[k]==a[i])</em></strong></li>\n<li>看巨巨的题解K在状态转移的过程中就可以找到了。</li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 4123</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">-1</span>)</div><div class=\"line\">                dp[i][j] = <span class=\"number\">2</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[i][j] = dp[j][k] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i] == data[j])</div><div class=\"line\">                k = j;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans &lt; dp[i][j])</div><div class=\"line\">                ans = dp[i][j];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#暴力遍历代码：<br>看题解之前想碰碰运气写的暴力代码，时间复杂度O(n^3)，当然TLE啦……</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;algorithm&gt;</div><div class=\"line\">#include &lt;set&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">set&lt;int&gt; check;</div><div class=\"line\">vector&lt;int&gt; store;</div><div class=\"line\">int data[41234];</div><div class=\"line\">int n;</div><div class=\"line\"></div><div class=\"line\">int scan(int a, int b)</div><div class=\"line\">&#123;</div><div class=\"line\">    int judge = 0;</div><div class=\"line\">    int sum = 0;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (judge == 0 &amp;&amp; (data[i] == a || data[i] == b) || data[i] == judge)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (data[i] == a)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = b;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (data[i] == b)</div><div class=\"line\">            &#123;</div><div class=\"line\">                judge = a;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    cin &gt;&gt; n;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        cin &gt;&gt; data[i];</div><div class=\"line\">        if (check.count(data[i]) == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">            check.insert(data[i]);</div><div class=\"line\">            store.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int ans = 0;</div><div class=\"line\">    for (int i = 0; i &lt; store.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = i; j &lt; store.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            int t = scan(data[i], data[j]);</div><div class=\"line\">            ans = ans &gt; t? ans:t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"ShadowSocks配置（Linux）","date":"2017-02-03T12:54:07.000Z","_content":"# 参考教程：\n\n**强烈推荐教程[教程](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#comment-4188)！！！**\n========================================================================\n\n\n----------\n# 服务端配置：\n\nLinux 直接 ssh 服务器：\n\nssh [ 用户名]@[IP]\n\n*例如：\n```\nssh root@45.76.206.109\n```\n\n\n----------\n\n\n安装ShadowSocks：\n使用Python原版，Ubuntu下直接输入：\n\n```\napt install python-setuptools && easy_install pip\npip install shadowsocks\n```\n用来安装Python的组件和shadowsocks。\n\n\n----------\n\n\nShadowSocks的配置：\n创建配置文件：\n\n```\nvim /etc/shadowsocks.json\n```\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n\n----------\n\n\n参数说明：\n\n名称 |说明\n--------|-------------\nserver \t|填入你的服务器 IP ，即当前操作的 VPS 的 IP 地址，必须修改\nserver_port| \t服务器端口，可以根据实际需要修改，或者保持默认\nlocal_address| \t本地监听地址，建议保持默认\nlocal_port \t|本地端口，这个参数一般保持默认即可\npassword \t|用来加密的密码，可以根据实际需要修改\ntimeout \t|单位秒，一般保持默认即可\nmethod \t|默认的是”aes-256-cfb”，一般保持默认即可\nfast_open \t|使用TCP_FASTOPEN, 参数选项true / false，一般保持默认即可\nworkers \t|worker的数量, 在 Unix/Linux 上有效，一般不用加此项\n\n\n----------\n\n\n启动SS服务：\n```\nnohup ssserver -c shadowsocks.json start &\n```\n\n\n----------\n#客户端配置：\n使用ShadowSocks-qt：\n[官网下载&Wiki](https://github.com/shadowsocks/shadowsocks-qt5)\n\n\n----------\n配置客户端：\n按照服务器的配置文件配置即可。\n\n","source":"_posts/ShadowSocks配置（Linux）.md","raw":"---\ntitle: ShadowSocks配置（Linux）\ndate: 2017-02-03 20:54:07\ncategories:\ntags:\n---\n# 参考教程：\n\n**强烈推荐教程[教程](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#comment-4188)！！！**\n========================================================================\n\n\n----------\n# 服务端配置：\n\nLinux 直接 ssh 服务器：\n\nssh [ 用户名]@[IP]\n\n*例如：\n```\nssh root@45.76.206.109\n```\n\n\n----------\n\n\n安装ShadowSocks：\n使用Python原版，Ubuntu下直接输入：\n\n```\napt install python-setuptools && easy_install pip\npip install shadowsocks\n```\n用来安装Python的组件和shadowsocks。\n\n\n----------\n\n\nShadowSocks的配置：\n创建配置文件：\n\n```\nvim /etc/shadowsocks.json\n```\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n\n----------\n\n\n参数说明：\n\n名称 |说明\n--------|-------------\nserver \t|填入你的服务器 IP ，即当前操作的 VPS 的 IP 地址，必须修改\nserver_port| \t服务器端口，可以根据实际需要修改，或者保持默认\nlocal_address| \t本地监听地址，建议保持默认\nlocal_port \t|本地端口，这个参数一般保持默认即可\npassword \t|用来加密的密码，可以根据实际需要修改\ntimeout \t|单位秒，一般保持默认即可\nmethod \t|默认的是”aes-256-cfb”，一般保持默认即可\nfast_open \t|使用TCP_FASTOPEN, 参数选项true / false，一般保持默认即可\nworkers \t|worker的数量, 在 Unix/Linux 上有效，一般不用加此项\n\n\n----------\n\n\n启动SS服务：\n```\nnohup ssserver -c shadowsocks.json start &\n```\n\n\n----------\n#客户端配置：\n使用ShadowSocks-qt：\n[官网下载&Wiki](https://github.com/shadowsocks/shadowsocks-qt5)\n\n\n----------\n配置客户端：\n按照服务器的配置文件配置即可。\n\n","slug":"ShadowSocks配置（Linux）","published":1,"updated":"2017-07-23T04:00:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nds004iy9idumnn1fyu","content":"<h1 id=\"参考教程：\"><a href=\"#参考教程：\" class=\"headerlink\" title=\"参考教程：\"></a>参考教程：</h1><h1 id=\"强烈推荐教程教程！！！\"><a href=\"#强烈推荐教程教程！！！\" class=\"headerlink\" title=\"强烈推荐教程教程！！！\"></a><strong>强烈推荐教程<a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#comment-4188\" target=\"_blank\" rel=\"external\">教程</a>！！！</strong></h1><hr>\n<h1 id=\"服务端配置：\"><a href=\"#服务端配置：\" class=\"headerlink\" title=\"服务端配置：\"></a>服务端配置：</h1><p>Linux 直接 ssh 服务器：</p>\n<p>ssh [ 用户名]@[IP]</p>\n<p>*例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh root@45.76.206.109</div></pre></td></tr></table></figure></p>\n<hr>\n<p>安装ShadowSocks：<br>使用Python原版，Ubuntu下直接输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>用来安装Python的组件和shadowsocks。</p>\n<hr>\n<p>ShadowSocks的配置：<br>创建配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim /etc/shadowsocks.json</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>server</td>\n<td>填入你的服务器 IP ，即当前操作的 VPS 的 IP 地址，必须修改</td>\n</tr>\n<tr>\n<td>server_port</td>\n<td>服务器端口，可以根据实际需要修改，或者保持默认</td>\n</tr>\n<tr>\n<td>local_address</td>\n<td>本地监听地址，建议保持默认</td>\n</tr>\n<tr>\n<td>local_port</td>\n<td>本地端口，这个参数一般保持默认即可</td>\n</tr>\n<tr>\n<td>password</td>\n<td>用来加密的密码，可以根据实际需要修改</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>单位秒，一般保持默认即可</td>\n</tr>\n<tr>\n<td>method</td>\n<td>默认的是”aes-256-cfb”，一般保持默认即可</td>\n</tr>\n<tr>\n<td>fast_open</td>\n<td>使用TCP_FASTOPEN, 参数选项true / false，一般保持默认即可</td>\n</tr>\n<tr>\n<td>workers</td>\n<td>worker的数量, 在 Unix/Linux 上有效，一般不用加此项</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>启动SS服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup ssserver -c shadowsocks.json start &amp;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>#客户端配置：<br>使用ShadowSocks-qt：<br><a href=\"https://github.com/shadowsocks/shadowsocks-qt5\" target=\"_blank\" rel=\"external\">官网下载&amp;Wiki</a></p>\n<hr>\n<p>配置客户端：<br>按照服务器的配置文件配置即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"参考教程：\"><a href=\"#参考教程：\" class=\"headerlink\" title=\"参考教程：\"></a>参考教程：</h1><h1 id=\"强烈推荐教程教程！！！\"><a href=\"#强烈推荐教程教程！！！\" class=\"headerlink\" title=\"强烈推荐教程教程！！！\"></a><strong>强烈推荐教程<a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#comment-4188\" target=\"_blank\" rel=\"external\">教程</a>！！！</strong></h1><hr>\n<h1 id=\"服务端配置：\"><a href=\"#服务端配置：\" class=\"headerlink\" title=\"服务端配置：\"></a>服务端配置：</h1><p>Linux 直接 ssh 服务器：</p>\n<p>ssh [ 用户名]@[IP]</p>\n<p>*例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh root@45.76.206.109</div></pre></td></tr></table></figure></p>\n<hr>\n<p>安装ShadowSocks：<br>使用Python原版，Ubuntu下直接输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>用来安装Python的组件和shadowsocks。</p>\n<hr>\n<p>ShadowSocks的配置：<br>创建配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim /etc/shadowsocks.json</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>server</td>\n<td>填入你的服务器 IP ，即当前操作的 VPS 的 IP 地址，必须修改</td>\n</tr>\n<tr>\n<td>server_port</td>\n<td>服务器端口，可以根据实际需要修改，或者保持默认</td>\n</tr>\n<tr>\n<td>local_address</td>\n<td>本地监听地址，建议保持默认</td>\n</tr>\n<tr>\n<td>local_port</td>\n<td>本地端口，这个参数一般保持默认即可</td>\n</tr>\n<tr>\n<td>password</td>\n<td>用来加密的密码，可以根据实际需要修改</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>单位秒，一般保持默认即可</td>\n</tr>\n<tr>\n<td>method</td>\n<td>默认的是”aes-256-cfb”，一般保持默认即可</td>\n</tr>\n<tr>\n<td>fast_open</td>\n<td>使用TCP_FASTOPEN, 参数选项true / false，一般保持默认即可</td>\n</tr>\n<tr>\n<td>workers</td>\n<td>worker的数量, 在 Unix/Linux 上有效，一般不用加此项</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>启动SS服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup ssserver -c shadowsocks.json start &amp;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>#客户端配置：<br>使用ShadowSocks-qt：<br><a href=\"https://github.com/shadowsocks/shadowsocks-qt5\" target=\"_blank\" rel=\"external\">官网下载&amp;Wiki</a></p>\n<hr>\n<p>配置客户端：<br>按照服务器的配置文件配置即可。</p>\n"},{"title":"SDUTOJ3475 - 最后の汤圆","date":"2017-07-24T12:32:57.000Z","_content":"# 题目链接：\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html\n\n------------------------\n# 题目大意：\n给定一个序列$a_1, a_2 \\dots a_n$，这个序列构成一个环，首先删掉第$k$个元素，然后从第$k$个元素开始，继续数$a_k$个元素删除掉下一个元素，求最后剩余的一个数的原始下标。\n\n\n---------------------------------\n# 解题过程：\n\n类似约瑟夫环，之前你做过一个非常大的约瑟夫环直接套公式就好了，然后这一个仔细想了一下，删除每一个元素之后，下一个元素的位置不容易确定，感觉不能直接套公式那种，于是朴素的推了一下，还真的是线段树。\n\n-----------------------------\n# 题目分析：\n\n刚开始每一个数的下标就对应他是第几个数比如$1,2,3,4,5$。\n这里我如果删除第二个数，并且将第二个数及后面的数减一。\n得到这个序列$1,1,2,3,4$，这里第一次出现的$1$，依然是第一个数。\n假设我这时候再删除第一个数，那么就变成了$0,0,1,2,3$，依然符合上述的规律。\n\n那么我们就可以这样模拟了，维护一个序列，初始化序列的值为对应的下标，每删除一个数，让这个数及后面的数的值减一。\n\n然后找首个出现的时候用二分查找一下就可以，序列操作后也一直都是有序的，在线段树上也容易进行二分。\n\n-----------------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l+r)>>1\n\nconst int MAX = 500000+50;\n\nstruct Info {\n    int v, lazy;\n};\n\nInfo tree[MAX<<2];\nint data[MAX];\n\nInfo operator + (const Info &a, const Info &b) {\n    Info rst;\n    rst.lazy = 0;\n    //让根的值为右儿子的值，目的是让根节点的v是维护的这段区间的最大的\n    rst.v = b.v;\n    return rst;\n}\n\nvoid push_down(int root) {\n    if (tree[root].lazy) {\n        int lazy = tree[root].lazy;\n        tree[lson].lazy += lazy;\n        tree[rson].lazy += lazy;\n        tree[lson].v -= lazy;\n        tree[rson].v -= lazy;\n        tree[root].lazy = 0;\n    }\n}\n\nvoid build(int root, int l, int r) {\n    tree[root].lazy = 0;\n    if (l == r) {\n        tree[root].v = l;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    if (ul > r || l > ur) return;\n    //对区间进行减一\n    if (ul <= l && r <= ur) {\n        tree[root].lazy ++;\n        tree[root].v --;\n        return;\n    }\n    push_down(root);\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m+1, r, ul, ur);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nint query(int root, int l, int r, int pos) {\n    //如果到了叶子节点，那么到找到了答案\n    if (l == r) return l;\n    push_down(root);\n    MID;\n    //如果当前位置比左儿子区间内最大的还要大，那么只能去右儿子找\n    if (pos > tree[lson].v) return query(rson, m+1, r, pos);\n    else return query(lson, l, m, pos);\n}\n\nint main() {\n    int n, k;\n    while (~scanf(\"%d %d\", &n, &k)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data+i);\n        }\n        build(1, 1, n);\n\n        //num表示为当前剩余的数字个数\n        int num = n;\n        //删除到只剩一个数\n        while (num > 1) {\n            //可能需要数的数字大于当前总共的，进行取模\n            k = k % num;\n            if (k == 0) k = num;\n\n            //找到当前第k个数字的原始下标\n            int index = query(1, 1, n, k);\n\n            //将index及后面的值减一\n            updata(1, 1, n, index, n);\n\n            //接下来需要数从第k个数继续数data[index]个数\n            //这等价于从第一个数开始数data[index]+k-1个数\n            k = data[index] + k - 1;\n            num--;\n        }\n\n        //最后查找一下剩余的最后一个数的下标并输出\n        printf(\"%d\\n\", query(1, 1, n, 1));\n    }\n}\n```","source":"_posts/SDUTOJ3475-最后の汤圆.md","raw":"---\ntitle: SDUTOJ3475 - 最后の汤圆\ndate: 2017-07-24 20:32:57\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttp://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html\n\n------------------------\n# 题目大意：\n给定一个序列$a_1, a_2 \\dots a_n$，这个序列构成一个环，首先删掉第$k$个元素，然后从第$k$个元素开始，继续数$a_k$个元素删除掉下一个元素，求最后剩余的一个数的原始下标。\n\n\n---------------------------------\n# 解题过程：\n\n类似约瑟夫环，之前你做过一个非常大的约瑟夫环直接套公式就好了，然后这一个仔细想了一下，删除每一个元素之后，下一个元素的位置不容易确定，感觉不能直接套公式那种，于是朴素的推了一下，还真的是线段树。\n\n-----------------------------\n# 题目分析：\n\n刚开始每一个数的下标就对应他是第几个数比如$1,2,3,4,5$。\n这里我如果删除第二个数，并且将第二个数及后面的数减一。\n得到这个序列$1,1,2,3,4$，这里第一次出现的$1$，依然是第一个数。\n假设我这时候再删除第一个数，那么就变成了$0,0,1,2,3$，依然符合上述的规律。\n\n那么我们就可以这样模拟了，维护一个序列，初始化序列的值为对应的下标，每删除一个数，让这个数及后面的数的值减一。\n\n然后找首个出现的时候用二分查找一下就可以，序列操作后也一直都是有序的，在线段树上也容易进行二分。\n\n-----------------------------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l+r)>>1\n\nconst int MAX = 500000+50;\n\nstruct Info {\n    int v, lazy;\n};\n\nInfo tree[MAX<<2];\nint data[MAX];\n\nInfo operator + (const Info &a, const Info &b) {\n    Info rst;\n    rst.lazy = 0;\n    //让根的值为右儿子的值，目的是让根节点的v是维护的这段区间的最大的\n    rst.v = b.v;\n    return rst;\n}\n\nvoid push_down(int root) {\n    if (tree[root].lazy) {\n        int lazy = tree[root].lazy;\n        tree[lson].lazy += lazy;\n        tree[rson].lazy += lazy;\n        tree[lson].v -= lazy;\n        tree[rson].v -= lazy;\n        tree[root].lazy = 0;\n    }\n}\n\nvoid build(int root, int l, int r) {\n    tree[root].lazy = 0;\n    if (l == r) {\n        tree[root].v = l;\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nvoid updata(int root, int l, int r, int ul, int ur) {\n    if (ul > r || l > ur) return;\n    //对区间进行减一\n    if (ul <= l && r <= ur) {\n        tree[root].lazy ++;\n        tree[root].v --;\n        return;\n    }\n    push_down(root);\n    MID;\n    updata(lson, l, m, ul, ur);\n    updata(rson, m+1, r, ul, ur);\n    tree[root] = tree[lson] + tree[rson];\n}\n\nint query(int root, int l, int r, int pos) {\n    //如果到了叶子节点，那么到找到了答案\n    if (l == r) return l;\n    push_down(root);\n    MID;\n    //如果当前位置比左儿子区间内最大的还要大，那么只能去右儿子找\n    if (pos > tree[lson].v) return query(rson, m+1, r, pos);\n    else return query(lson, l, m, pos);\n}\n\nint main() {\n    int n, k;\n    while (~scanf(\"%d %d\", &n, &k)) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data+i);\n        }\n        build(1, 1, n);\n\n        //num表示为当前剩余的数字个数\n        int num = n;\n        //删除到只剩一个数\n        while (num > 1) {\n            //可能需要数的数字大于当前总共的，进行取模\n            k = k % num;\n            if (k == 0) k = num;\n\n            //找到当前第k个数字的原始下标\n            int index = query(1, 1, n, k);\n\n            //将index及后面的值减一\n            updata(1, 1, n, index, n);\n\n            //接下来需要数从第k个数继续数data[index]个数\n            //这等价于从第一个数开始数data[index]+k-1个数\n            k = data[index] + k - 1;\n            num--;\n        }\n\n        //最后查找一下剩余的最后一个数的下标并输出\n        printf(\"%d\\n\", query(1, 1, n, 1));\n    }\n}\n```","slug":"SDUTOJ3475-最后の汤圆","published":1,"updated":"2017-07-25T00:17:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndu004ky9id8ueazrbg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个序列$a_1, a_2 \\dots a_n$，这个序列构成一个环，首先删掉第$k$个元素，然后从第$k$个元素开始，继续数$a_k$个元素删除掉下一个元素，求最后剩余的一个数的原始下标。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>类似约瑟夫环，之前你做过一个非常大的约瑟夫环直接套公式就好了，然后这一个仔细想了一下，删除每一个元素之后，下一个元素的位置不容易确定，感觉不能直接套公式那种，于是朴素的推了一下，还真的是线段树。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>刚开始每一个数的下标就对应他是第几个数比如$1,2,3,4,5$。<br>这里我如果删除第二个数，并且将第二个数及后面的数减一。<br>得到这个序列$1,1,2,3,4$，这里第一次出现的$1$，依然是第一个数。<br>假设我这时候再删除第一个数，那么就变成了$0,0,1,2,3$，依然符合上述的规律。</p>\n<p>那么我们就可以这样模拟了，维护一个序列，初始化序列的值为对应的下标，每删除一个数，让这个数及后面的数的值减一。</p>\n<p>然后找首个出现的时候用二分查找一下就可以，序列操作后也一直都是有序的，在线段树上也容易进行二分。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)&gt;&gt;1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">500000</span>+<span class=\"number\">50</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, lazy;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Info tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"></div><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp;a, <span class=\"keyword\">const</span> Info &amp;b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//让根的值为右儿子的值，目的是让根节点的v是维护的这段区间的最大的</span></div><div class=\"line\">    rst.v = b.v;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[root].lazy) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> lazy = tree[root].lazy;</div><div class=\"line\">        tree[lson].lazy += lazy;</div><div class=\"line\">        tree[rson].lazy += lazy;</div><div class=\"line\">        tree[lson].v -= lazy;</div><div class=\"line\">        tree[rson].v -= lazy;</div><div class=\"line\">        tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].v = l;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &gt; r || l &gt; ur) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//对区间进行减一</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        tree[root].lazy ++;</div><div class=\"line\">        tree[root].v --;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果到了叶子节点，那么到找到了答案</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"comment\">//如果当前位置比左儿子区间内最大的还要大，那么只能去右儿子找</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &gt; tree[lson].v) <span class=\"keyword\">return</span> query(rson, m+<span class=\"number\">1</span>, r, pos);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> query(lson, l, m, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, k;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;k)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//num表示为当前剩余的数字个数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> num = n;</div><div class=\"line\">        <span class=\"comment\">//删除到只剩一个数</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (num &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//可能需要数的数字大于当前总共的，进行取模</span></div><div class=\"line\">            k = k % num;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span>) k = num;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//找到当前第k个数字的原始下标</span></div><div class=\"line\">            <span class=\"keyword\">int</span> index = query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, k);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//将index及后面的值减一</span></div><div class=\"line\">            updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, index, n);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//接下来需要数从第k个数继续数data[index]个数</span></div><div class=\"line\">            <span class=\"comment\">//这等价于从第一个数开始数data[index]+k-1个数</span></div><div class=\"line\">            k = data[index] + k - <span class=\"number\">1</span>;</div><div class=\"line\">            num--;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//最后查找一下剩余的最后一个数的下标并输出</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, <span class=\"number\">1</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html\" target=\"_blank\" rel=\"external\">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3475.html</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个序列$a_1, a_2 \\dots a_n$，这个序列构成一个环，首先删掉第$k$个元素，然后从第$k$个元素开始，继续数$a_k$个元素删除掉下一个元素，求最后剩余的一个数的原始下标。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>类似约瑟夫环，之前你做过一个非常大的约瑟夫环直接套公式就好了，然后这一个仔细想了一下，删除每一个元素之后，下一个元素的位置不容易确定，感觉不能直接套公式那种，于是朴素的推了一下，还真的是线段树。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>刚开始每一个数的下标就对应他是第几个数比如$1,2,3,4,5$。<br>这里我如果删除第二个数，并且将第二个数及后面的数减一。<br>得到这个序列$1,1,2,3,4$，这里第一次出现的$1$，依然是第一个数。<br>假设我这时候再删除第一个数，那么就变成了$0,0,1,2,3$，依然符合上述的规律。</p>\n<p>那么我们就可以这样模拟了，维护一个序列，初始化序列的值为对应的下标，每删除一个数，让这个数及后面的数的值减一。</p>\n<p>然后找首个出现的时候用二分查找一下就可以，序列操作后也一直都是有序的，在线段树上也容易进行二分。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)&gt;&gt;1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">500000</span>+<span class=\"number\">50</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v, lazy;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Info tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"></div><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp;a, <span class=\"keyword\">const</span> Info &amp;b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">//让根的值为右儿子的值，目的是让根节点的v是维护的这段区间的最大的</span></div><div class=\"line\">    rst.v = b.v;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tree[root].lazy) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> lazy = tree[root].lazy;</div><div class=\"line\">        tree[lson].lazy += lazy;</div><div class=\"line\">        tree[rson].lazy += lazy;</div><div class=\"line\">        tree[lson].v -= lazy;</div><div class=\"line\">        tree[rson].v -= lazy;</div><div class=\"line\">        tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    tree[root].lazy = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].v = l;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ul, <span class=\"keyword\">int</span> ur)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &gt; r || l &gt; ur) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"comment\">//对区间进行减一</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</div><div class=\"line\">        tree[root].lazy ++;</div><div class=\"line\">        tree[root].v --;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, ul, ur);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, ul, ur);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//如果到了叶子节点，那么到找到了答案</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</div><div class=\"line\">    push_down(root);</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"comment\">//如果当前位置比左儿子区间内最大的还要大，那么只能去右儿子找</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &gt; tree[lson].v) <span class=\"keyword\">return</span> query(rson, m+<span class=\"number\">1</span>, r, pos);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> query(lson, l, m, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, k;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;k)) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//num表示为当前剩余的数字个数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> num = n;</div><div class=\"line\">        <span class=\"comment\">//删除到只剩一个数</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (num &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//可能需要数的数字大于当前总共的，进行取模</span></div><div class=\"line\">            k = k % num;</div><div class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span>) k = num;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//找到当前第k个数字的原始下标</span></div><div class=\"line\">            <span class=\"keyword\">int</span> index = query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, k);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//将index及后面的值减一</span></div><div class=\"line\">            updata(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, index, n);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//接下来需要数从第k个数继续数data[index]个数</span></div><div class=\"line\">            <span class=\"comment\">//这等价于从第一个数开始数data[index]+k-1个数</span></div><div class=\"line\">            k = data[index] + k - <span class=\"number\">1</span>;</div><div class=\"line\">            num--;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//最后查找一下剩余的最后一个数的下标并输出</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, <span class=\"number\">1</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"URAL1167 - Bicolored Horses（DP）","date":"2017-10-12T01:11:53.000Z","_content":"# 题目链接：\n\n[http://acm.timus.ru/problem.aspx?space=1&num=1167](http://acm.timus.ru/problem.aspx?space=1&num=1167)\n\n\n\n# 题目大意：\n\n给出一段 0 和 1 的串，要求将其划分成 k 个连续的部分（一定要划分成 k 个连续的部分，并且某一部分不能为 0，任一 0 或 1 一定要分到一分组里），记某一分组有 i 个 0 和 j 个 1，那么这一组的值为 $i \\cdot j$ ，现在要求划分 k 组，使得这 k 组的值和最小，输出最小值。\n\n$1 \\le N \\le 500, 1\\le K \\le N$\n\n\n\n# 解题过程：\n\n先是从四维降到了三维，然后还是 MLE，最后类比了一下 M 子段和的题，还是不对，然后翻的别人博客，看到状态转移方程后感觉好像也不是太难...\n\n\n\n# 题目分析：\n\n设 $dp[i][j]$ 的含义是划分了前 i 组以第 j 个元素为结尾的最小值。\n\n那么状态转移方程是:\n\n$$dp[i][j] = min(dp[i - 1][k] + v | k = 0 \\dots j - 1)$$\n\n含义是，因为分组是连续的第 i 组以 j 结尾可以枚举第 i - 1 组以谁结尾来转移。\n\n这里的 v 是前缀和，含义是 $[k + 1 , j]$ 这段区间的值。\n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 500 + 5;\n\nint dp[MAX][MAX];\nint data[MAX];\nint one[MAX];\nint zero[MAX];\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        memset(zero, 0, sizeof(zero));\n        memset(one, 0, sizeof(one));\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data + i);\n            if (data[i]) one[i] += 1;\n            else zero[i] += 1;\n            one[i] += one[i - 1];\n            zero[i] += zero[i - 1];\n        }\n        memset(dp, 0x3f, sizeof(dp));\n        dp[0][0] = 0;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = i; j <= n; j++) {\n                for (int k = i - 1; k < j; k++) {\n                    int v;\n                    v = zero[j] - zero[k];\n                    v *= one[j] - one[k];\n                    dp[i][j] = min(dp[i - 1][k] + v, dp[i][j]);\n                }\n            }\n        }\n        printf(\"%d\\n\", dp[m][n]);\n    }\n}\n```","source":"_posts/URAL1167-Bicolored-Horses（DP）.md","raw":"---\ntitle: URAL1167 - Bicolored Horses（DP）\ndate: 2017-10-12 09:11:53\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\n[http://acm.timus.ru/problem.aspx?space=1&num=1167](http://acm.timus.ru/problem.aspx?space=1&num=1167)\n\n\n\n# 题目大意：\n\n给出一段 0 和 1 的串，要求将其划分成 k 个连续的部分（一定要划分成 k 个连续的部分，并且某一部分不能为 0，任一 0 或 1 一定要分到一分组里），记某一分组有 i 个 0 和 j 个 1，那么这一组的值为 $i \\cdot j$ ，现在要求划分 k 组，使得这 k 组的值和最小，输出最小值。\n\n$1 \\le N \\le 500, 1\\le K \\le N$\n\n\n\n# 解题过程：\n\n先是从四维降到了三维，然后还是 MLE，最后类比了一下 M 子段和的题，还是不对，然后翻的别人博客，看到状态转移方程后感觉好像也不是太难...\n\n\n\n# 题目分析：\n\n设 $dp[i][j]$ 的含义是划分了前 i 组以第 j 个元素为结尾的最小值。\n\n那么状态转移方程是:\n\n$$dp[i][j] = min(dp[i - 1][k] + v | k = 0 \\dots j - 1)$$\n\n含义是，因为分组是连续的第 i 组以 j 结尾可以枚举第 i - 1 组以谁结尾来转移。\n\n这里的 v 是前缀和，含义是 $[k + 1 , j]$ 这段区间的值。\n\n\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 500 + 5;\n\nint dp[MAX][MAX];\nint data[MAX];\nint one[MAX];\nint zero[MAX];\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        memset(zero, 0, sizeof(zero));\n        memset(one, 0, sizeof(one));\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", data + i);\n            if (data[i]) one[i] += 1;\n            else zero[i] += 1;\n            one[i] += one[i - 1];\n            zero[i] += zero[i - 1];\n        }\n        memset(dp, 0x3f, sizeof(dp));\n        dp[0][0] = 0;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = i; j <= n; j++) {\n                for (int k = i - 1; k < j; k++) {\n                    int v;\n                    v = zero[j] - zero[k];\n                    v *= one[j] - one[k];\n                    dp[i][j] = min(dp[i - 1][k] + v, dp[i][j]);\n                }\n            }\n        }\n        printf(\"%d\\n\", dp[m][n]);\n    }\n}\n```","slug":"URAL1167-Bicolored-Horses（DP）","published":1,"updated":"2017-10-12T01:27:24.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndv004ny9idsjht8mvh","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1167\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1167</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一段 0 和 1 的串，要求将其划分成 k 个连续的部分（一定要划分成 k 个连续的部分，并且某一部分不能为 0，任一 0 或 1 一定要分到一分组里），记某一分组有 i 个 0 和 j 个 1，那么这一组的值为 $i \\cdot j$ ，现在要求划分 k 组，使得这 k 组的值和最小，输出最小值。</p>\n<p>$1 \\le N \\le 500, 1\\le K \\le N$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>先是从四维降到了三维，然后还是 MLE，最后类比了一下 M 子段和的题，还是不对，然后翻的别人博客，看到状态转移方程后感觉好像也不是太难…</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>设 $dp[i][j]$ 的含义是划分了前 i 组以第 j 个元素为结尾的最小值。</p>\n<p>那么状态转移方程是:</p>\n<p>$$dp[i][j] = min(dp[i - 1][k] + v | k = 0 \\dots j - 1)$$</p>\n<p>含义是，因为分组是连续的第 i 组以 j 结尾可以枚举第 i - 1 组以谁结尾来转移。</p>\n<p>这里的 v 是前缀和，含义是 $[k + 1 , j]$ 这段区间的值。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">500</span> + <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> one[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> zero[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(zero, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(zero));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(one, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(one));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i]) one[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> zero[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            one[i] += one[i - <span class=\"number\">1</span>];</div><div class=\"line\">            zero[i] += zero[i - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i - <span class=\"number\">1</span>; k &lt; j; k++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> v;</div><div class=\"line\">                    v = zero[j] - zero[k];</div><div class=\"line\">                    v *= one[j] - one[k];</div><div class=\"line\">                    dp[i][j] = min(dp[i - <span class=\"number\">1</span>][k] + v, dp[i][j]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[m][n]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1167\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1167</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一段 0 和 1 的串，要求将其划分成 k 个连续的部分（一定要划分成 k 个连续的部分，并且某一部分不能为 0，任一 0 或 1 一定要分到一分组里），记某一分组有 i 个 0 和 j 个 1，那么这一组的值为 $i \\cdot j$ ，现在要求划分 k 组，使得这 k 组的值和最小，输出最小值。</p>\n<p>$1 \\le N \\le 500, 1\\le K \\le N$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>先是从四维降到了三维，然后还是 MLE，最后类比了一下 M 子段和的题，还是不对，然后翻的别人博客，看到状态转移方程后感觉好像也不是太难…</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>设 $dp[i][j]$ 的含义是划分了前 i 组以第 j 个元素为结尾的最小值。</p>\n<p>那么状态转移方程是:</p>\n<p>$$dp[i][j] = min(dp[i - 1][k] + v | k = 0 \\dots j - 1)$$</p>\n<p>含义是，因为分组是连续的第 i 组以 j 结尾可以枚举第 i - 1 组以谁结尾来转移。</p>\n<p>这里的 v 是前缀和，含义是 $[k + 1 , j]$ 这段区间的值。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">500</span> + <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> one[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> zero[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(zero, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(zero));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(one, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(one));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, data + i);</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i]) one[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> zero[i] += <span class=\"number\">1</span>;</div><div class=\"line\">            one[i] += one[i - <span class=\"number\">1</span>];</div><div class=\"line\">            zero[i] += zero[i - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i - <span class=\"number\">1</span>; k &lt; j; k++) &#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> v;</div><div class=\"line\">                    v = zero[j] - zero[k];</div><div class=\"line\">                    v *= one[j] - one[k];</div><div class=\"line\">                    dp[i][j] = min(dp[i - <span class=\"number\">1</span>][k] + v, dp[i][j]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[m][n]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"URAL1183 - Brackets Sequence（区间DP）","date":"2017-10-16T01:01:19.000Z","_content":"# 题目链接：\n\nhttp://acm.timus.ru/problem.aspx?space=1&num=1183\n\n# 题目大意：\n\n[参考博客](http://blog.csdn.net/jiange_zh/article/details/49994207)\n\n> 定义正规的括号序列如下: \n>\n> 1. 空序列是一个正规的括号序列 \n> 2. 如果S是一个正规的括号序列, 那么(S) 和[S] 也都是正规的括号序列。 \n> 3. 如果A和B是正规的括号序列, 那么AB也是一个正规的括号序列。 \n>\n> 现给定一个括号序列A（只包含小括号和中括号，可能为空序列），求一个正规括号序列B，使得A包含于B，而且B的长度是满足条件的序列中最小的。\n\n# 题目分析：\n\n设 $dp[i][j]$ 为使得 [i, j] 这段区间括号匹配所需要的最小花费，那么根据题意，$dp[i][j]$可由两种方式转移而来：\n\n+ 如果 i 与 j 可以匹配的话$dp[i][j] = dp[i + 1][j - 1]$\n+ 不关 i 与 j 是否匹配 $dp[i][k] = dp[i][k] + dp[k + 1][j]$\n\n\n\n最后递归的打印答案，转移的时候标记一下，当前是否分为两个子序列。\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nchar s[1123];\n\nint dp[112][112];\nint mark[112][112];\n\nvoid print(int l, int r) {\n    if (l > r) return;\n    if (l == r) {\n        if (s[l] == '(' || s[l] == ')') cout << \"()\";\n        else cout << \"[]\";\n        return;\n    }\n    if (mark[l][r] == -1) {\n        if (s[l] == '(') {\n            cout << \"(\";\n            print(l + 1, r - 1);\n            cout << \")\";\n        } else {\n            cout << \"[\";\n            print(l + 1, r - 1);\n            cout << \"]\";\n        }\n    } else {\n        print(l, mark[l][r]);\n        print(mark[l][r] + 1, r);\n    }\n}\n\nint main() {\n    gets(s + 1);\n    int n = strlen(s + 1);\n    if (!n) {\n        cout << endl;\n        return 0;\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= n; i++) dp[i][i] = 1;\n    for (int l = 2; l <= n; l++) {\n        for (int i = 1; i <= n - l + 1; i++) {\n            int j = i + l - 1;\n            dp[i][j] = INF;\n            if (s[i] == '(' && s[j] == ')' || s[i] == '[' && s[j] == ']') {\n                dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);\n            }\n            mark[i][j] = -1;\n            for (int k = i; k < j; k++) {\n                if (dp[i][k] + dp[k + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                    mark[i][j] = k;\n                }\n            }\n        }\n    }\n    print(1, n);\n    cout << endl;\n}\n```\n# 解题过程：\n\n这题卡了好久ORZ，之前了解过一点区间DP，结果还是不会做。","source":"_posts/URAL1183-Brackets-Sequence（区间DP）.md","raw":"---\ntitle: URAL1183 - Brackets Sequence（区间DP）\ndate: 2017-10-16 09:01:19\ncategories: [ACM, DP, 区间DP]\ntags:\n---\n# 题目链接：\n\nhttp://acm.timus.ru/problem.aspx?space=1&num=1183\n\n# 题目大意：\n\n[参考博客](http://blog.csdn.net/jiange_zh/article/details/49994207)\n\n> 定义正规的括号序列如下: \n>\n> 1. 空序列是一个正规的括号序列 \n> 2. 如果S是一个正规的括号序列, 那么(S) 和[S] 也都是正规的括号序列。 \n> 3. 如果A和B是正规的括号序列, 那么AB也是一个正规的括号序列。 \n>\n> 现给定一个括号序列A（只包含小括号和中括号，可能为空序列），求一个正规括号序列B，使得A包含于B，而且B的长度是满足条件的序列中最小的。\n\n# 题目分析：\n\n设 $dp[i][j]$ 为使得 [i, j] 这段区间括号匹配所需要的最小花费，那么根据题意，$dp[i][j]$可由两种方式转移而来：\n\n+ 如果 i 与 j 可以匹配的话$dp[i][j] = dp[i + 1][j - 1]$\n+ 不关 i 与 j 是否匹配 $dp[i][k] = dp[i][k] + dp[k + 1][j]$\n\n\n\n最后递归的打印答案，转移的时候标记一下，当前是否分为两个子序列。\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nchar s[1123];\n\nint dp[112][112];\nint mark[112][112];\n\nvoid print(int l, int r) {\n    if (l > r) return;\n    if (l == r) {\n        if (s[l] == '(' || s[l] == ')') cout << \"()\";\n        else cout << \"[]\";\n        return;\n    }\n    if (mark[l][r] == -1) {\n        if (s[l] == '(') {\n            cout << \"(\";\n            print(l + 1, r - 1);\n            cout << \")\";\n        } else {\n            cout << \"[\";\n            print(l + 1, r - 1);\n            cout << \"]\";\n        }\n    } else {\n        print(l, mark[l][r]);\n        print(mark[l][r] + 1, r);\n    }\n}\n\nint main() {\n    gets(s + 1);\n    int n = strlen(s + 1);\n    if (!n) {\n        cout << endl;\n        return 0;\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= n; i++) dp[i][i] = 1;\n    for (int l = 2; l <= n; l++) {\n        for (int i = 1; i <= n - l + 1; i++) {\n            int j = i + l - 1;\n            dp[i][j] = INF;\n            if (s[i] == '(' && s[j] == ')' || s[i] == '[' && s[j] == ']') {\n                dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);\n            }\n            mark[i][j] = -1;\n            for (int k = i; k < j; k++) {\n                if (dp[i][k] + dp[k + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                    mark[i][j] = k;\n                }\n            }\n        }\n    }\n    print(1, n);\n    cout << endl;\n}\n```\n# 解题过程：\n\n这题卡了好久ORZ，之前了解过一点区间DP，结果还是不会做。","slug":"URAL1183-Brackets-Sequence（区间DP）","published":1,"updated":"2017-10-16T01:11:25.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndx004py9id0vp9hy86","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1183\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1183</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><a href=\"http://blog.csdn.net/jiange_zh/article/details/49994207\" target=\"_blank\" rel=\"external\">参考博客</a></p>\n<blockquote>\n<p>定义正规的括号序列如下: </p>\n<ol>\n<li>空序列是一个正规的括号序列 </li>\n<li>如果S是一个正规的括号序列, 那么(S) 和[S] 也都是正规的括号序列。 </li>\n<li>如果A和B是正规的括号序列, 那么AB也是一个正规的括号序列。 </li>\n</ol>\n<p>现给定一个括号序列A（只包含小括号和中括号，可能为空序列），求一个正规括号序列B，使得A包含于B，而且B的长度是满足条件的序列中最小的。</p>\n</blockquote>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>设 $dp[i][j]$ 为使得 [i, j] 这段区间括号匹配所需要的最小花费，那么根据题意，$dp[i][j]$可由两种方式转移而来：</p>\n<ul>\n<li>如果 i 与 j 可以匹配的话$dp[i][j] = dp[i + 1][j - 1]$</li>\n<li>不关 i 与 j 是否匹配 $dp[i][k] = dp[i][k] + dp[k + 1][j]$</li>\n</ul>\n<p>最后递归的打印答案，转移的时候标记一下，当前是否分为两个子序列。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> mark[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s[l] == <span class=\"string\">'('</span> || s[l] == <span class=\"string\">')'</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"()\"</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[]\"</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mark[l][r] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s[l] == <span class=\"string\">'('</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span>;</div><div class=\"line\">            print(l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[\"</span>;</div><div class=\"line\">            print(l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"]\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        print(l, mark[l][r]);</div><div class=\"line\">        print(mark[l][r] + <span class=\"number\">1</span>, r);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    gets(s + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!n) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) dp[i][i] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">2</span>; l &lt;= n; l++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> j = i + l - <span class=\"number\">1</span>;</div><div class=\"line\">            dp[i][j] = INF;</div><div class=\"line\">            <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">'('</span> &amp;&amp; s[j] == <span class=\"string\">')'</span> || s[i] == <span class=\"string\">'['</span> &amp;&amp; s[j] == <span class=\"string\">']'</span>) &#123;</div><div class=\"line\">                dp[i][j] = min(dp[i][j], dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mark[i][j] = <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i; k &lt; j; k++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[i][k] + dp[k + <span class=\"number\">1</span>][j] &lt; dp[i][j]) &#123;</div><div class=\"line\">                    dp[i][j] = dp[i][k] + dp[k + <span class=\"number\">1</span>][j];</div><div class=\"line\">                    mark[i][j] = k;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    print(<span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题卡了好久ORZ，之前了解过一点区间DP，结果还是不会做。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1183\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1183</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p><a href=\"http://blog.csdn.net/jiange_zh/article/details/49994207\" target=\"_blank\" rel=\"external\">参考博客</a></p>\n<blockquote>\n<p>定义正规的括号序列如下: </p>\n<ol>\n<li>空序列是一个正规的括号序列 </li>\n<li>如果S是一个正规的括号序列, 那么(S) 和[S] 也都是正规的括号序列。 </li>\n<li>如果A和B是正规的括号序列, 那么AB也是一个正规的括号序列。 </li>\n</ol>\n<p>现给定一个括号序列A（只包含小括号和中括号，可能为空序列），求一个正规括号序列B，使得A包含于B，而且B的长度是满足条件的序列中最小的。</p>\n</blockquote>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>设 $dp[i][j]$ 为使得 [i, j] 这段区间括号匹配所需要的最小花费，那么根据题意，$dp[i][j]$可由两种方式转移而来：</p>\n<ul>\n<li>如果 i 与 j 可以匹配的话$dp[i][j] = dp[i + 1][j - 1]$</li>\n<li>不关 i 与 j 是否匹配 $dp[i][k] = dp[i][k] + dp[k + 1][j]$</li>\n</ul>\n<p>最后递归的打印答案，转移的时候标记一下，当前是否分为两个子序列。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">1123</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> mark[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s[l] == <span class=\"string\">'('</span> || s[l] == <span class=\"string\">')'</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"()\"</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[]\"</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mark[l][r] == <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s[l] == <span class=\"string\">'('</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span>;</div><div class=\"line\">            print(l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[\"</span>;</div><div class=\"line\">            print(l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"]\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        print(l, mark[l][r]);</div><div class=\"line\">        print(mark[l][r] + <span class=\"number\">1</span>, r);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    gets(s + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!n) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) dp[i][i] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">2</span>; l &lt;= n; l++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> j = i + l - <span class=\"number\">1</span>;</div><div class=\"line\">            dp[i][j] = INF;</div><div class=\"line\">            <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">'('</span> &amp;&amp; s[j] == <span class=\"string\">')'</span> || s[i] == <span class=\"string\">'['</span> &amp;&amp; s[j] == <span class=\"string\">']'</span>) &#123;</div><div class=\"line\">                dp[i][j] = min(dp[i][j], dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mark[i][j] = <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = i; k &lt; j; k++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (dp[i][k] + dp[k + <span class=\"number\">1</span>][j] &lt; dp[i][j]) &#123;</div><div class=\"line\">                    dp[i][j] = dp[i][k] + dp[k + <span class=\"number\">1</span>][j];</div><div class=\"line\">                    mark[i][j] = k;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    print(<span class=\"number\">1</span>, n);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>这题卡了好久ORZ，之前了解过一点区间DP，结果还是不会做。</p>\n"},{"title":"URAL1260 - Nudnik Photographer（DP+递推）","date":"2017-10-11T04:48:43.000Z","_content":"# 题目链接：\n\n[http://acm.timus.ru/problem.aspx?space=1&num=1260](http://acm.timus.ru/problem.aspx?space=1&num=1260)\n\n# 题目大意：\n\n给出 1 ～ N 的 N 个数，进行排列，要求 1 一定要为第一个元素，并且任意两个相邻的元素之间的差不能超过 2，输出有多少种这样的排列。\n\n$1\\le N \\le 55$\n\n# 解题过程：\n\n感觉是和程设课上的递推题差不多，然后卡了我了两个小时也没想出来...看来数据结构刷多了真的能刷傻。\n\n# 题目分析：\n\n$dp[i]$的含义是，i 个数有多少个符合上述要求排列。那么状态转移方程是：\n\n$$dp[i] = dp[i - 3] + dp[i - 1] + 1$$\n\n这样分情况考虑：\n\n首先第一个位置肯定是要放 1 的（因为题目要求），然后\n\n+ 第二个位置放 2，那么现在的排列的个数等价于 $dp[i - 1]$，你可以当做把 1 扔掉，然后剩下的数都减一\n+ 第二个位置放 3\n  + 第三个位置放 2，那么第四个位置一定是要放 4，那么当前情况的排列总数是等价于$dp[i - 3]$的\n  + 如果第三个位置不放 2，那么只有一种情况，假设 n = 8， 那么是1 3 5 7 8 6 4 2\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[60];\n\nint main() {\n    int n;\n    dp[1] = 1;\n    dp[2] = 1;\n    dp[3] = 2;\n    for (int i = 4; i <= 55; i++) {\n        dp[i] = dp[i - 1] + dp[i - 3] + 1;\n    }\n    while (~scanf(\"%d\", &n)) {\n        printf(\"%lld\\n\", dp[n]);\n    }\n}\n```","source":"_posts/URAL1260-Nudnik-Photographer（DP-递推）.md","raw":"---\ntitle: URAL1260 - Nudnik Photographer（DP+递推）\ndate: 2017-10-11 12:48:43\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n\n[http://acm.timus.ru/problem.aspx?space=1&num=1260](http://acm.timus.ru/problem.aspx?space=1&num=1260)\n\n# 题目大意：\n\n给出 1 ～ N 的 N 个数，进行排列，要求 1 一定要为第一个元素，并且任意两个相邻的元素之间的差不能超过 2，输出有多少种这样的排列。\n\n$1\\le N \\le 55$\n\n# 解题过程：\n\n感觉是和程设课上的递推题差不多，然后卡了我了两个小时也没想出来...看来数据结构刷多了真的能刷傻。\n\n# 题目分析：\n\n$dp[i]$的含义是，i 个数有多少个符合上述要求排列。那么状态转移方程是：\n\n$$dp[i] = dp[i - 3] + dp[i - 1] + 1$$\n\n这样分情况考虑：\n\n首先第一个位置肯定是要放 1 的（因为题目要求），然后\n\n+ 第二个位置放 2，那么现在的排列的个数等价于 $dp[i - 1]$，你可以当做把 1 扔掉，然后剩下的数都减一\n+ 第二个位置放 3\n  + 第三个位置放 2，那么第四个位置一定是要放 4，那么当前情况的排列总数是等价于$dp[i - 3]$的\n  + 如果第三个位置不放 2，那么只有一种情况，假设 n = 8， 那么是1 3 5 7 8 6 4 2\n\n\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[60];\n\nint main() {\n    int n;\n    dp[1] = 1;\n    dp[2] = 1;\n    dp[3] = 2;\n    for (int i = 4; i <= 55; i++) {\n        dp[i] = dp[i - 1] + dp[i - 3] + 1;\n    }\n    while (~scanf(\"%d\", &n)) {\n        printf(\"%lld\\n\", dp[n]);\n    }\n}\n```","slug":"URAL1260-Nudnik-Photographer（DP-递推）","published":1,"updated":"2017-10-11T05:00:48.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ndy004sy9idke9p8ixb","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1260\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1260</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 1 ～ N 的 N 个数，进行排列，要求 1 一定要为第一个元素，并且任意两个相邻的元素之间的差不能超过 2，输出有多少种这样的排列。</p>\n<p>$1\\le N \\le 55$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>感觉是和程设课上的递推题差不多，然后卡了我了两个小时也没想出来…看来数据结构刷多了真的能刷傻。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>$dp[i]$的含义是，i 个数有多少个符合上述要求排列。那么状态转移方程是：</p>\n<p>$$dp[i] = dp[i - 3] + dp[i - 1] + 1$$</p>\n<p>这样分情况考虑：</p>\n<p>首先第一个位置肯定是要放 1 的（因为题目要求），然后</p>\n<ul>\n<li>第二个位置放 2，那么现在的排列的个数等价于 $dp[i - 1]$，你可以当做把 1 扔掉，然后剩下的数都减一</li>\n<li>第二个位置放 3<ul>\n<li>第三个位置放 2，那么第四个位置一定是要放 4，那么当前情况的排列总数是等价于$dp[i - 3]$的</li>\n<li>如果第三个位置不放 2，那么只有一种情况，假设 n = 8， 那么是1 3 5 7 8 6 4 2</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\">ll dp[<span class=\"number\">60</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dp[<span class=\"number\">3</span>] = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &lt;= <span class=\"number\">55</span>; i++) &#123;</div><div class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">3</span>] + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.timus.ru/problem.aspx?space=1&amp;num=1260\" target=\"_blank\" rel=\"external\">http://acm.timus.ru/problem.aspx?space=1&amp;num=1260</a></p>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出 1 ～ N 的 N 个数，进行排列，要求 1 一定要为第一个元素，并且任意两个相邻的元素之间的差不能超过 2，输出有多少种这样的排列。</p>\n<p>$1\\le N \\le 55$</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>感觉是和程设课上的递推题差不多，然后卡了我了两个小时也没想出来…看来数据结构刷多了真的能刷傻。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>$dp[i]$的含义是，i 个数有多少个符合上述要求排列。那么状态转移方程是：</p>\n<p>$$dp[i] = dp[i - 3] + dp[i - 1] + 1$$</p>\n<p>这样分情况考虑：</p>\n<p>首先第一个位置肯定是要放 1 的（因为题目要求），然后</p>\n<ul>\n<li>第二个位置放 2，那么现在的排列的个数等价于 $dp[i - 1]$，你可以当做把 1 扔掉，然后剩下的数都减一</li>\n<li>第二个位置放 3<ul>\n<li>第三个位置放 2，那么第四个位置一定是要放 4，那么当前情况的排列总数是等价于$dp[i - 3]$的</li>\n<li>如果第三个位置不放 2，那么只有一种情况，假设 n = 8， 那么是1 3 5 7 8 6 4 2</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\">ll dp[<span class=\"number\">60</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    dp[<span class=\"number\">3</span>] = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &lt;= <span class=\"number\">55</span>; i++) &#123;</div><div class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">3</span>] + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n)) &#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVA 10603 - Fill（dijkstra + 状态图）","date":"2017-02-18T08:28:33.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1544\n\n# 题目大意\n------------------\n有三个水杯，容量分别为 a, b, c 刚开始 c 水杯注满水，其他是空的，然后求经过 n 次操作后可不可以得到 d 升水。如果可以的话，转移的水量尽量少，如果无法得到 d 升的话，就输出 d' 升，**d'< d** 并且 **d'** 尽量的大。\n\n这里的转移水量指，总共转移了多少升水，比如 a 向 b 注了五升水，那么转移水量为五升。\n\n\n# 解题过程\n--------------\n照着紫书示例敲得，看作者代码学到了好多东西。\n\n# 题目分析\n------------------\n+ 首先是进行枚举操作的时候，虽然总共三个杯子，作者还是把数据放到了数组里面，简化不少代码，如果是我的话，就直接写9个if了。\n\n+ 然后是代码的思想是 dijkstra，求最短路。\n\t+ 把整个问题当做一个状态图，每个点由三个水杯里面的水确定。\n\t+ 两个点之间的边的权值，是由两个状态转化所需要转移的水量。（注意一点是这里是有向图）\n\t+ 另外三个水杯里面的水合不变，给定两个水杯里水的体积，就可以确定另一个，所以储存状态时，只需要记录两个水杯的体积即可。\n+ 经过上面的解析，这个问题就抽象成了，求一个有向图的最短路径，然后使用了优先队列优化的 dijkstra 。\n\n+ 另外memcpy的使用值得一学，使用方法如下：\n`memset(&a, &b, sizeof(a));`\n把 b 复制给a，直接复制的内存，效率比直接循环快。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 200+10;\n\nstruct Node\n{\n    int v[3], dist;\n};\n\nbool operator < (const struct Node& a, const struct Node& b)\n{\n    return a.dist > b.dist;\n}\n\nint vis[MAX][MAX], ans[MAX];\n\nvoid update_ans(Node u)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        int d = u.v[i];\n        if (ans[d] < 0 || ans[d] > u.dist)\n            ans[d] = u.dist;\n    }\n}\n\nvoid solve(int a, int b, int c, int d)\n{\n    int cap[3] = {a,b,c};\n    memset(vis, 0, sizeof(vis));\n    memset(ans, -1, sizeof(ans));\n    Node start;\n    start.v[0] = 0, start.v[1] = 0, start.v[2] = c;\n    start.dist = 0;\n    priority_queue<Node> q;\n    q.push(start);\n    vis[0][0] = 1;\n\n    while (!q.empty())\n    {\n        Node u = q.top(); q.pop();\n        update_ans(u);\n\n        if (ans[d] >= 0)\n            break;\n\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                if (i == j)\n                    continue;\n                if (u.v[i] == 0 || u.v[j] == cap[j])\n                    continue;\n\n                int amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];\n                Node u2;\n                memcpy(&u2, &u, sizeof(u));\n                u2.dist = u.dist + amount;\n                u2.v[i] -= amount;\n                u2.v[j] += amount;\n                if (!vis[u2.v[1]][u2.v[0]])\n                {\n                    vis[u2.v[1]][u2.v[0]] = 1;\n                    q.push(u2);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        solve(a, b, c, d);\n        while (d >= 0)\n        {\n            if (ans[d] >= 0)\n            {\n                printf(\"%d %d\\n\", ans[d], d);\n                break;\n            }\n            d--;\n        }\n    }\n}\n```\n","source":"_posts/UVA-10603-Fill（dijkstra-状态图）.md","raw":"---\ntitle: UVA 10603 - Fill（dijkstra + 状态图）\ndate: 2017-02-18 16:28:33\ncategories: [ACM, 图论, 最短路]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1544\n\n# 题目大意\n------------------\n有三个水杯，容量分别为 a, b, c 刚开始 c 水杯注满水，其他是空的，然后求经过 n 次操作后可不可以得到 d 升水。如果可以的话，转移的水量尽量少，如果无法得到 d 升的话，就输出 d' 升，**d'< d** 并且 **d'** 尽量的大。\n\n这里的转移水量指，总共转移了多少升水，比如 a 向 b 注了五升水，那么转移水量为五升。\n\n\n# 解题过程\n--------------\n照着紫书示例敲得，看作者代码学到了好多东西。\n\n# 题目分析\n------------------\n+ 首先是进行枚举操作的时候，虽然总共三个杯子，作者还是把数据放到了数组里面，简化不少代码，如果是我的话，就直接写9个if了。\n\n+ 然后是代码的思想是 dijkstra，求最短路。\n\t+ 把整个问题当做一个状态图，每个点由三个水杯里面的水确定。\n\t+ 两个点之间的边的权值，是由两个状态转化所需要转移的水量。（注意一点是这里是有向图）\n\t+ 另外三个水杯里面的水合不变，给定两个水杯里水的体积，就可以确定另一个，所以储存状态时，只需要记录两个水杯的体积即可。\n+ 经过上面的解析，这个问题就抽象成了，求一个有向图的最短路径，然后使用了优先队列优化的 dijkstra 。\n\n+ 另外memcpy的使用值得一学，使用方法如下：\n`memset(&a, &b, sizeof(a));`\n把 b 复制给a，直接复制的内存，效率比直接循环快。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 200+10;\n\nstruct Node\n{\n    int v[3], dist;\n};\n\nbool operator < (const struct Node& a, const struct Node& b)\n{\n    return a.dist > b.dist;\n}\n\nint vis[MAX][MAX], ans[MAX];\n\nvoid update_ans(Node u)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        int d = u.v[i];\n        if (ans[d] < 0 || ans[d] > u.dist)\n            ans[d] = u.dist;\n    }\n}\n\nvoid solve(int a, int b, int c, int d)\n{\n    int cap[3] = {a,b,c};\n    memset(vis, 0, sizeof(vis));\n    memset(ans, -1, sizeof(ans));\n    Node start;\n    start.v[0] = 0, start.v[1] = 0, start.v[2] = c;\n    start.dist = 0;\n    priority_queue<Node> q;\n    q.push(start);\n    vis[0][0] = 1;\n\n    while (!q.empty())\n    {\n        Node u = q.top(); q.pop();\n        update_ans(u);\n\n        if (ans[d] >= 0)\n            break;\n\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                if (i == j)\n                    continue;\n                if (u.v[i] == 0 || u.v[j] == cap[j])\n                    continue;\n\n                int amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];\n                Node u2;\n                memcpy(&u2, &u, sizeof(u));\n                u2.dist = u.dist + amount;\n                u2.v[i] -= amount;\n                u2.v[j] += amount;\n                if (!vis[u2.v[1]][u2.v[0]])\n                {\n                    vis[u2.v[1]][u2.v[0]] = 1;\n                    q.push(u2);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        solve(a, b, c, d);\n        while (d >= 0)\n        {\n            if (ans[d] >= 0)\n            {\n                printf(\"%d %d\\n\", ans[d], d);\n                break;\n            }\n            d--;\n        }\n    }\n}\n```\n","slug":"UVA-10603-Fill（dijkstra-状态图）","published":1,"updated":"2017-07-23T02:58:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ne0004uy9id1kag624e","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1544\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1544</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有三个水杯，容量分别为 a, b, c 刚开始 c 水杯注满水，其他是空的，然后求经过 n 次操作后可不可以得到 d 升水。如果可以的话，转移的水量尽量少，如果无法得到 d 升的话，就输出 d’ 升，<strong>d’&lt; d</strong> 并且 <strong>d’</strong> 尽量的大。</p>\n<p>这里的转移水量指，总共转移了多少升水，比如 a 向 b 注了五升水，那么转移水量为五升。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>照着紫书示例敲得，看作者代码学到了好多东西。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li><p>首先是进行枚举操作的时候，虽然总共三个杯子，作者还是把数据放到了数组里面，简化不少代码，如果是我的话，就直接写9个if了。</p>\n</li>\n<li><p>然后是代码的思想是 dijkstra，求最短路。</p>\n<ul>\n<li>把整个问题当做一个状态图，每个点由三个水杯里面的水确定。</li>\n<li>两个点之间的边的权值，是由两个状态转化所需要转移的水量。（注意一点是这里是有向图）</li>\n<li>另外三个水杯里面的水合不变，给定两个水杯里水的体积，就可以确定另一个，所以储存状态时，只需要记录两个水杯的体积即可。</li>\n</ul>\n</li>\n<li><p>经过上面的解析，这个问题就抽象成了，求一个有向图的最短路径，然后使用了优先队列优化的 dijkstra 。</p>\n</li>\n<li><p>另外memcpy的使用值得一学，使用方法如下：<br><code>memset(&amp;a, &amp;b, sizeof(a));</code><br>把 b 复制给a，直接复制的内存，效率比直接循环快。</p>\n</li>\n</ul>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">200</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v[<span class=\"number\">3</span>], dist;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node&amp; a, <span class=\"keyword\">const</span> struct Node&amp; b)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.dist &gt; b.dist;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX][MAX], ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_ans</span><span class=\"params\">(Node u)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = u.v[i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[d] &lt; <span class=\"number\">0</span> || ans[d] &gt; u.dist)</div><div class=\"line\">            ans[d] = u.dist;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cap[<span class=\"number\">3</span>] = &#123;a,b,c&#125;;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">    Node start;</div><div class=\"line\">    start.v[<span class=\"number\">0</span>] = <span class=\"number\">0</span>, start.v[<span class=\"number\">1</span>] = <span class=\"number\">0</span>, start.v[<span class=\"number\">2</span>] = c;</div><div class=\"line\">    start.dist = <span class=\"number\">0</span>;</div><div class=\"line\">    priority_queue&lt;Node&gt; q;</div><div class=\"line\">    q.push(start);</div><div class=\"line\">    vis[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty())</div><div class=\"line\">    &#123;</div><div class=\"line\">        Node u = q.top(); q.pop();</div><div class=\"line\">        update_ans(u);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[d] &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (u.v[i] == <span class=\"number\">0</span> || u.v[j] == cap[j])</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">int</span> amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];</div><div class=\"line\">                Node u2;</div><div class=\"line\">                <span class=\"built_in\">memcpy</span>(&amp;u2, &amp;u, <span class=\"keyword\">sizeof</span>(u));</div><div class=\"line\">                u2.dist = u.dist + amount;</div><div class=\"line\">                u2.v[i] -= amount;</div><div class=\"line\">                u2.v[j] += amount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[u2.v[<span class=\"number\">1</span>]][u2.v[<span class=\"number\">0</span>]])</div><div class=\"line\">                &#123;</div><div class=\"line\">                    vis[u2.v[<span class=\"number\">1</span>]][u2.v[<span class=\"number\">0</span>]] = <span class=\"number\">1</span>;</div><div class=\"line\">                    q.push(u2);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, c, d;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</div><div class=\"line\">        solve(a, b, c, d);</div><div class=\"line\">        <span class=\"keyword\">while</span> (d &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans[d] &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, ans[d], d);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            d--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1544\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1544</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有三个水杯，容量分别为 a, b, c 刚开始 c 水杯注满水，其他是空的，然后求经过 n 次操作后可不可以得到 d 升水。如果可以的话，转移的水量尽量少，如果无法得到 d 升的话，就输出 d’ 升，<strong>d’&lt; d</strong> 并且 <strong>d’</strong> 尽量的大。</p>\n<p>这里的转移水量指，总共转移了多少升水，比如 a 向 b 注了五升水，那么转移水量为五升。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>照着紫书示例敲得，看作者代码学到了好多东西。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<ul>\n<li><p>首先是进行枚举操作的时候，虽然总共三个杯子，作者还是把数据放到了数组里面，简化不少代码，如果是我的话，就直接写9个if了。</p>\n</li>\n<li><p>然后是代码的思想是 dijkstra，求最短路。</p>\n<ul>\n<li>把整个问题当做一个状态图，每个点由三个水杯里面的水确定。</li>\n<li>两个点之间的边的权值，是由两个状态转化所需要转移的水量。（注意一点是这里是有向图）</li>\n<li>另外三个水杯里面的水合不变，给定两个水杯里水的体积，就可以确定另一个，所以储存状态时，只需要记录两个水杯的体积即可。</li>\n</ul>\n</li>\n<li><p>经过上面的解析，这个问题就抽象成了，求一个有向图的最短路径，然后使用了优先队列优化的 dijkstra 。</p>\n</li>\n<li><p>另外memcpy的使用值得一学，使用方法如下：<br><code>memset(&amp;a, &amp;b, sizeof(a));</code><br>把 b 复制给a，直接复制的内存，效率比直接循环快。</p>\n</li>\n</ul>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">200</span>+<span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> v[<span class=\"number\">3</span>], dist;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node&amp; a, <span class=\"keyword\">const</span> struct Node&amp; b)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.dist &gt; b.dist;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> vis[MAX][MAX], ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_ans</span><span class=\"params\">(Node u)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> d = u.v[i];</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[d] &lt; <span class=\"number\">0</span> || ans[d] &gt; u.dist)</div><div class=\"line\">            ans[d] = u.dist;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cap[<span class=\"number\">3</span>] = &#123;a,b,c&#125;;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(ans, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(ans));</div><div class=\"line\">    Node start;</div><div class=\"line\">    start.v[<span class=\"number\">0</span>] = <span class=\"number\">0</span>, start.v[<span class=\"number\">1</span>] = <span class=\"number\">0</span>, start.v[<span class=\"number\">2</span>] = c;</div><div class=\"line\">    start.dist = <span class=\"number\">0</span>;</div><div class=\"line\">    priority_queue&lt;Node&gt; q;</div><div class=\"line\">    q.push(start);</div><div class=\"line\">    vis[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty())</div><div class=\"line\">    &#123;</div><div class=\"line\">        Node u = q.top(); q.pop();</div><div class=\"line\">        update_ans(u);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[d] &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (u.v[i] == <span class=\"number\">0</span> || u.v[j] == cap[j])</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">int</span> amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];</div><div class=\"line\">                Node u2;</div><div class=\"line\">                <span class=\"built_in\">memcpy</span>(&amp;u2, &amp;u, <span class=\"keyword\">sizeof</span>(u));</div><div class=\"line\">                u2.dist = u.dist + amount;</div><div class=\"line\">                u2.v[i] -= amount;</div><div class=\"line\">                u2.v[j] += amount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!vis[u2.v[<span class=\"number\">1</span>]][u2.v[<span class=\"number\">0</span>]])</div><div class=\"line\">                &#123;</div><div class=\"line\">                    vis[u2.v[<span class=\"number\">1</span>]][u2.v[<span class=\"number\">0</span>]] = <span class=\"number\">1</span>;</div><div class=\"line\">                    q.push(u2);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a, b, c, d;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</div><div class=\"line\">        solve(a, b, c, d);</div><div class=\"line\">        <span class=\"keyword\">while</span> (d &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (ans[d] &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, ans[d], d);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            d--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"UVA - 11212 Editing a Book（迭代加深搜索 IDA* + 模板）","date":"2017-02-21T12:53:02.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2153\n# 题目大意\n------------------\n给定一个长度 1 ～ 9 的整数序列，每个整数 1 ～ 9 。\n\n序列是无序的，你有两种操作，剪切和粘贴，两种操作均可以处理任意长度。\n\n求至少经过多少次操作，可以使序列有序（递增）。\n\n# 解题过程\n--------------\n本来感觉处理数组比较麻烦，每次都要开辟空间传递指针，然后赋值。\n\n看了一个博客，可以用 string 类处理，然后感觉有现成的类，比手动辅助数组方便太多！！！\n\n本题可以做一个迭代加深搜索的模板。\n\n# 题目分析\n------------------\n\n#### 迭代加深搜索（IDA*）：\n+ 适用范围：可用回溯法，但解答树没有明显上限的问题。\n+ 从 0 开始枚举最大迭代深度，然后使用函数迭代求解，如果在当前最大迭代深度下有解，即是答案（处理最少步骤等问题）。\n+ 切记，迭代加深搜索，解答树节点一般比较多，尽可能考虑剪枝。\n+ 核心代码\n```cpp\nfor (maxd = 0; ; maxd++)\n{\n\tif (solve(0))\n\t\tbreak;\n}\n\nbool solve(int d)\n{\n\tif (d == maxd)\n\t\treturn judge();\n\t\n\tif (solve(d+1))\n\t\treturn true;\n\t\t\n\treturn false;\n}\n\t\n```\n另外强调下 string 的 substr 方法。\nsubstr(pos, len);\n从 pos 开始， len 长度的子串，如果忽略 len ，则一直到结尾。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n, step, maxd;\n\nstring goal;\n\nbool solve(int d, string now)\n{\n    if (d == maxd)\n    {\n        step = d;\n        return now == goal;\n    }\n\n    int h = 0;\n    for (int i = 0; i < n - 1; i++)\n        if (now[i+1] - now[i] != 1)\n            h++;\n\n    if (h > 3 * (maxd - d))\n        return false;\n\n    for (int l = 0; l < n; l++)\n    {\n        for (int r = l; r < n; r++)\n        {\n            string slt = now.substr(l, r-l+1);\n            string tail = now.substr(r+1);\n            for (int k = 0; k < l; k++)\n            {\n                string il = now.substr(0, k);\n                string ir = now.substr(k, l-k);\n                if (solve(d+1, il+slt+ir+tail))\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    int testCase = 0;\n    while (~scanf(\"%d\", &n) && n)\n    {\n        string data;\n        for (int i = 0; i < n; i++)\n        {\n            int t;\n            scanf(\"%d\", &t);\n            data += (char) t + '0';\n        }\n\n        goal = \"\";\n        for (int i = '1'; i <= '0'+n; i++)\n            goal += i;\n\n        for (maxd = 0; maxd < n; maxd++)\n            if (solve(0, data))\n            {\n                printf(\"Case %d: %d\\n\", ++testCase, maxd);\n                break;\n            }\n    }\n}\n\n```\n","source":"_posts/UVA-11212-Editing-a-Book（迭代加深搜索-IDA-模板）.md","raw":"---\ntitle: UVA - 11212 Editing a Book（迭代加深搜索 IDA* + 模板）\ndate: 2017-02-21 20:53:02\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2153\n# 题目大意\n------------------\n给定一个长度 1 ～ 9 的整数序列，每个整数 1 ～ 9 。\n\n序列是无序的，你有两种操作，剪切和粘贴，两种操作均可以处理任意长度。\n\n求至少经过多少次操作，可以使序列有序（递增）。\n\n# 解题过程\n--------------\n本来感觉处理数组比较麻烦，每次都要开辟空间传递指针，然后赋值。\n\n看了一个博客，可以用 string 类处理，然后感觉有现成的类，比手动辅助数组方便太多！！！\n\n本题可以做一个迭代加深搜索的模板。\n\n# 题目分析\n------------------\n\n#### 迭代加深搜索（IDA*）：\n+ 适用范围：可用回溯法，但解答树没有明显上限的问题。\n+ 从 0 开始枚举最大迭代深度，然后使用函数迭代求解，如果在当前最大迭代深度下有解，即是答案（处理最少步骤等问题）。\n+ 切记，迭代加深搜索，解答树节点一般比较多，尽可能考虑剪枝。\n+ 核心代码\n```cpp\nfor (maxd = 0; ; maxd++)\n{\n\tif (solve(0))\n\t\tbreak;\n}\n\nbool solve(int d)\n{\n\tif (d == maxd)\n\t\treturn judge();\n\t\n\tif (solve(d+1))\n\t\treturn true;\n\t\t\n\treturn false;\n}\n\t\n```\n另外强调下 string 的 substr 方法。\nsubstr(pos, len);\n从 pos 开始， len 长度的子串，如果忽略 len ，则一直到结尾。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n, step, maxd;\n\nstring goal;\n\nbool solve(int d, string now)\n{\n    if (d == maxd)\n    {\n        step = d;\n        return now == goal;\n    }\n\n    int h = 0;\n    for (int i = 0; i < n - 1; i++)\n        if (now[i+1] - now[i] != 1)\n            h++;\n\n    if (h > 3 * (maxd - d))\n        return false;\n\n    for (int l = 0; l < n; l++)\n    {\n        for (int r = l; r < n; r++)\n        {\n            string slt = now.substr(l, r-l+1);\n            string tail = now.substr(r+1);\n            for (int k = 0; k < l; k++)\n            {\n                string il = now.substr(0, k);\n                string ir = now.substr(k, l-k);\n                if (solve(d+1, il+slt+ir+tail))\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    int testCase = 0;\n    while (~scanf(\"%d\", &n) && n)\n    {\n        string data;\n        for (int i = 0; i < n; i++)\n        {\n            int t;\n            scanf(\"%d\", &t);\n            data += (char) t + '0';\n        }\n\n        goal = \"\";\n        for (int i = '1'; i <= '0'+n; i++)\n            goal += i;\n\n        for (maxd = 0; maxd < n; maxd++)\n            if (solve(0, data))\n            {\n                printf(\"Case %d: %d\\n\", ++testCase, maxd);\n                break;\n            }\n    }\n}\n\n```\n","slug":"UVA-11212-Editing-a-Book（迭代加深搜索-IDA-模板）","published":1,"updated":"2017-07-23T02:55:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ne2004xy9id9h2wkm79","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2153\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2153</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定一个长度 1 ～ 9 的整数序列，每个整数 1 ～ 9 。</p>\n<p>序列是无序的，你有两种操作，剪切和粘贴，两种操作均可以处理任意长度。</p>\n<p>求至少经过多少次操作，可以使序列有序（递增）。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>本来感觉处理数组比较麻烦，每次都要开辟空间传递指针，然后赋值。</p>\n<p>看了一个博客，可以用 string 类处理，然后感觉有现成的类，比手动辅助数组方便太多！！！</p>\n<p>本题可以做一个迭代加深搜索的模板。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<h4 id=\"迭代加深搜索（IDA-）：\"><a href=\"#迭代加深搜索（IDA-）：\" class=\"headerlink\" title=\"迭代加深搜索（IDA*）：\"></a>迭代加深搜索（IDA*）：</h4><ul>\n<li>适用范围：可用回溯法，但解答树没有明显上限的问题。</li>\n<li>从 0 开始枚举最大迭代深度，然后使用函数迭代求解，如果在当前最大迭代深度下有解，即是答案（处理最少步骤等问题）。</li>\n<li>切记，迭代加深搜索，解答树节点一般比较多，尽可能考虑剪枝。</li>\n<li>核心代码<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (maxd = <span class=\"number\">0</span>; ; maxd++)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (solve(<span class=\"number\">0</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (d == maxd)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> judge();</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span> (solve(d+<span class=\"number\">1</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">\t\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>另外强调下 string 的 substr 方法。<br>substr(pos, len);<br>从 pos 开始， len 长度的子串，如果忽略 len ，则一直到结尾。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, step, maxd;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">string</span> goal;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> d, <span class=\"built_in\">string</span> now)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d == maxd)</div><div class=\"line\">    &#123;</div><div class=\"line\">        step = d;</div><div class=\"line\">        <span class=\"keyword\">return</span> now == goal;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (now[i+<span class=\"number\">1</span>] - now[i] != <span class=\"number\">1</span>)</div><div class=\"line\">            h++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (h &gt; <span class=\"number\">3</span> * (maxd - d))</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt; n; l++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = l; r &lt; n; r++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">string</span> slt = now.substr(l, r-l+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">string</span> tail = now.substr(r+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; l; k++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">string</span> il = now.substr(<span class=\"number\">0</span>, k);</div><div class=\"line\">                <span class=\"built_in\">string</span> ir = now.substr(k, l-k);</div><div class=\"line\">                <span class=\"keyword\">if</span> (solve(d+<span class=\"number\">1</span>, il+slt+ir+tail))</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> testCase = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> data;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            data += (<span class=\"keyword\">char</span>) t + <span class=\"string\">'0'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        goal = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"string\">'1'</span>; i &lt;= <span class=\"string\">'0'</span>+n; i++)</div><div class=\"line\">            goal += i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (maxd = <span class=\"number\">0</span>; maxd &lt; n; maxd++)</div><div class=\"line\">            <span class=\"keyword\">if</span> (solve(<span class=\"number\">0</span>, data))</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, ++testCase, maxd);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2153\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2153</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定一个长度 1 ～ 9 的整数序列，每个整数 1 ～ 9 。</p>\n<p>序列是无序的，你有两种操作，剪切和粘贴，两种操作均可以处理任意长度。</p>\n<p>求至少经过多少次操作，可以使序列有序（递增）。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>本来感觉处理数组比较麻烦，每次都要开辟空间传递指针，然后赋值。</p>\n<p>看了一个博客，可以用 string 类处理，然后感觉有现成的类，比手动辅助数组方便太多！！！</p>\n<p>本题可以做一个迭代加深搜索的模板。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<h4 id=\"迭代加深搜索（IDA-）：\"><a href=\"#迭代加深搜索（IDA-）：\" class=\"headerlink\" title=\"迭代加深搜索（IDA*）：\"></a>迭代加深搜索（IDA*）：</h4><ul>\n<li>适用范围：可用回溯法，但解答树没有明显上限的问题。</li>\n<li>从 0 开始枚举最大迭代深度，然后使用函数迭代求解，如果在当前最大迭代深度下有解，即是答案（处理最少步骤等问题）。</li>\n<li>切记，迭代加深搜索，解答树节点一般比较多，尽可能考虑剪枝。</li>\n<li>核心代码<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (maxd = <span class=\"number\">0</span>; ; maxd++)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (solve(<span class=\"number\">0</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (d == maxd)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> judge();</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span> (solve(d+<span class=\"number\">1</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">\t\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>另外强调下 string 的 substr 方法。<br>substr(pos, len);<br>从 pos 开始， len 长度的子串，如果忽略 len ，则一直到结尾。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, step, maxd;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">string</span> goal;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> d, <span class=\"built_in\">string</span> now)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d == maxd)</div><div class=\"line\">    &#123;</div><div class=\"line\">        step = d;</div><div class=\"line\">        <span class=\"keyword\">return</span> now == goal;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (now[i+<span class=\"number\">1</span>] - now[i] != <span class=\"number\">1</span>)</div><div class=\"line\">            h++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (h &gt; <span class=\"number\">3</span> * (maxd - d))</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt; n; l++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = l; r &lt; n; r++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">string</span> slt = now.substr(l, r-l+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"built_in\">string</span> tail = now.substr(r+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; l; k++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">string</span> il = now.substr(<span class=\"number\">0</span>, k);</div><div class=\"line\">                <span class=\"built_in\">string</span> ir = now.substr(k, l-k);</div><div class=\"line\">                <span class=\"keyword\">if</span> (solve(d+<span class=\"number\">1</span>, il+slt+ir+tail))</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> testCase = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> data;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            data += (<span class=\"keyword\">char</span>) t + <span class=\"string\">'0'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        goal = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"string\">'1'</span>; i &lt;= <span class=\"string\">'0'</span>+n; i++)</div><div class=\"line\">            goal += i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (maxd = <span class=\"number\">0</span>; maxd &lt; n; maxd++)</div><div class=\"line\">            <span class=\"keyword\">if</span> (solve(<span class=\"number\">0</span>, data))</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d: %d\\n\"</span>, ++testCase, maxd);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"UVA - 1606 Amphiphilic Carbon Molecules（极角排序+扫描法+计算几何）","date":"2017-04-03T08:27:26.000Z","_content":"# 题目链接：\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4481\n\n---------------------------------------\n# 题目大意：\n 平面上有 n 个点， 每个点为白点或黑点。现在需要放置一条隔板，使得隔板一侧的黑色点数加上另一侧白色点数的和最大。\n\n------------------------------------\n# 解题过程：\n 这是人生第一道 AC 的计算几何题！\n 由于之前一直没接触过这种题，紫书上的分析也看不懂，一言不合就让我极角排序、叉乘，根本没学过啊QAQ。\n 然后翻了很多博客，重学了一下极坐标，可算是弄明白了。\n\n------------------------------------------\n# 题目分析：\n 首先这题最简单的想法是枚举所有可能的挡板，这样需要枚举两个点，然后统计两端的点。枚举是 n×n， 统计也是 n，总共时间复杂度是 n^3。显然是超时的。\n\n 然后扫描法的思想是，按照一定顺序枚举，这样可以动态的维护一个量，省去了扫描时的 n。\n\n 所以这题正解是枚举每一个点当作基点，然后计算每个点相对于基点的极角，进行极角排序。然后按极角的大小进行旋转时的枚举。每旋转一次可以根据之前统计的点的个数进行动态的更新（这就是“维护”）。\n\n 这题有个可以优化的地方，如果一个点是黑点的话，可以把他映射到关于基点对称的地方去，视为白点。这样扫描的时候只需要统计白点就够了。然后扫描的时候只从扫描 180 度即可。\n\n 判断是否超过 180 度用叉乘，**a**×**b** = `|a| * |b| * sin<a,b>`，两个点叉乘用坐标计算是，`x1*y2 - y1*x2` 因为向量的模一定是正的，所以只要判断这个叉乘正负，就可以判断 sin 的正负了，即是否超过 180 度。\n\n----------------------------------\n\n# AC代码：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1005;\n\nstruct Node {\n    int x, y;\n    int color;\n    double rad;\n}raw_data[MAX], data[MAX];\n\nbool operator < (const struct Node &a, const struct Node &b) {\n    return a.rad < b.rad;\n}\n\nint n, ans;\n\n//用叉乘判断角度是否大于180度，即sin值。\nbool Turn(Node &a, Node &b) {\n    return a.x * b.y >= a.y * b.x;\n}\n\nvoid solve() {\n    if (n <= 3) {\n        ans = n;\n        return;\n    }\n    ans = 0;\n\n    //枚举每一个点当多基点\n    for (int i = 0; i < n; i++) {\n        int k = 0;\n        for (int j = 0; j < n; j++) {\n            if (i == j)\n                continue;\n\n            //计算每个点关于基点的相对坐标。\n            data[k].x = raw_data[j].x - raw_data[i].x;\n            data[k].y = raw_data[j].y - raw_data[i].y;\n\n            //如果是黑点的话，那么映射到关于基点对称的地方，这样扫描的时候只记录白点就够了。\n            if (raw_data[j].color) {\n                data[k].x *= -1;\n                data[k].y *= -1;\n            }\n            //求极角\n            data[k].rad = atan2(data[k].y, data[k].x);\n            k++;\n        }\n\n        //极角排序\n        sort(data, data + k);\n\n        //L为与基点相连的点，R为扫描线。\n        int L = 0, R = 0, cnt = 1;\n\n        //枚举每一个点与基点相连当作挡板。\n        while (L < k) {\n            if (L == R) {\n                R = (R + 1) % k;\n                cnt++;\n            }\n\n            //扫描的时候只扫描一侧，保证扫描线与挡板的夹角不超过180度。\n            while (L != R && Turn(data[L], data[R])) {\n                cnt++;\n                R = (R + 1) % k;\n            }\n            ans = max(ans, cnt);\n            //挡板旋转。\n            L++;\n            //由于挡板旋转，与基点相连的点不在挡板上了，减去1。\n            cnt--;\n        }\n    }\n}\n\nint main() {\n    while (cin >> n && n) {\n        for (int i = 0; i < n; i++) {\n            cin >> raw_data[i].x >> raw_data[i].y >> raw_data[i].color;\n        }\n        solve();\n        cout << ans << endl;\n    }\n}\n\n```","source":"_posts/UVA-1606-Amphiphilic-Carbon-Molecules（极角排序-扫描法-计算几何）.md","raw":"---\ntitle: UVA - 1606 Amphiphilic Carbon Molecules（极角排序+扫描法+计算几何）\ndate: 2017-04-03 16:27:26\ncategories: [ACM, 计算几何]\ntags:\n---\n# 题目链接：\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4481\n\n---------------------------------------\n# 题目大意：\n 平面上有 n 个点， 每个点为白点或黑点。现在需要放置一条隔板，使得隔板一侧的黑色点数加上另一侧白色点数的和最大。\n\n------------------------------------\n# 解题过程：\n 这是人生第一道 AC 的计算几何题！\n 由于之前一直没接触过这种题，紫书上的分析也看不懂，一言不合就让我极角排序、叉乘，根本没学过啊QAQ。\n 然后翻了很多博客，重学了一下极坐标，可算是弄明白了。\n\n------------------------------------------\n# 题目分析：\n 首先这题最简单的想法是枚举所有可能的挡板，这样需要枚举两个点，然后统计两端的点。枚举是 n×n， 统计也是 n，总共时间复杂度是 n^3。显然是超时的。\n\n 然后扫描法的思想是，按照一定顺序枚举，这样可以动态的维护一个量，省去了扫描时的 n。\n\n 所以这题正解是枚举每一个点当作基点，然后计算每个点相对于基点的极角，进行极角排序。然后按极角的大小进行旋转时的枚举。每旋转一次可以根据之前统计的点的个数进行动态的更新（这就是“维护”）。\n\n 这题有个可以优化的地方，如果一个点是黑点的话，可以把他映射到关于基点对称的地方去，视为白点。这样扫描的时候只需要统计白点就够了。然后扫描的时候只从扫描 180 度即可。\n\n 判断是否超过 180 度用叉乘，**a**×**b** = `|a| * |b| * sin<a,b>`，两个点叉乘用坐标计算是，`x1*y2 - y1*x2` 因为向量的模一定是正的，所以只要判断这个叉乘正负，就可以判断 sin 的正负了，即是否超过 180 度。\n\n----------------------------------\n\n# AC代码：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1005;\n\nstruct Node {\n    int x, y;\n    int color;\n    double rad;\n}raw_data[MAX], data[MAX];\n\nbool operator < (const struct Node &a, const struct Node &b) {\n    return a.rad < b.rad;\n}\n\nint n, ans;\n\n//用叉乘判断角度是否大于180度，即sin值。\nbool Turn(Node &a, Node &b) {\n    return a.x * b.y >= a.y * b.x;\n}\n\nvoid solve() {\n    if (n <= 3) {\n        ans = n;\n        return;\n    }\n    ans = 0;\n\n    //枚举每一个点当多基点\n    for (int i = 0; i < n; i++) {\n        int k = 0;\n        for (int j = 0; j < n; j++) {\n            if (i == j)\n                continue;\n\n            //计算每个点关于基点的相对坐标。\n            data[k].x = raw_data[j].x - raw_data[i].x;\n            data[k].y = raw_data[j].y - raw_data[i].y;\n\n            //如果是黑点的话，那么映射到关于基点对称的地方，这样扫描的时候只记录白点就够了。\n            if (raw_data[j].color) {\n                data[k].x *= -1;\n                data[k].y *= -1;\n            }\n            //求极角\n            data[k].rad = atan2(data[k].y, data[k].x);\n            k++;\n        }\n\n        //极角排序\n        sort(data, data + k);\n\n        //L为与基点相连的点，R为扫描线。\n        int L = 0, R = 0, cnt = 1;\n\n        //枚举每一个点与基点相连当作挡板。\n        while (L < k) {\n            if (L == R) {\n                R = (R + 1) % k;\n                cnt++;\n            }\n\n            //扫描的时候只扫描一侧，保证扫描线与挡板的夹角不超过180度。\n            while (L != R && Turn(data[L], data[R])) {\n                cnt++;\n                R = (R + 1) % k;\n            }\n            ans = max(ans, cnt);\n            //挡板旋转。\n            L++;\n            //由于挡板旋转，与基点相连的点不在挡板上了，减去1。\n            cnt--;\n        }\n    }\n}\n\nint main() {\n    while (cin >> n && n) {\n        for (int i = 0; i < n; i++) {\n            cin >> raw_data[i].x >> raw_data[i].y >> raw_data[i].color;\n        }\n        solve();\n        cout << ans << endl;\n    }\n}\n\n```","slug":"UVA-1606-Amphiphilic-Carbon-Molecules（极角排序-扫描法-计算几何）","published":1,"updated":"2017-07-23T02:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ne4004zy9idycixlrya","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 平面上有 n 个点， 每个点为白点或黑点。现在需要放置一条隔板，使得隔板一侧的黑色点数加上另一侧白色点数的和最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这是人生第一道 AC 的计算几何题！<br> 由于之前一直没接触过这种题，紫书上的分析也看不懂，一言不合就让我极角排序、叉乘，根本没学过啊QAQ。<br> 然后翻了很多博客，重学了一下极坐标，可算是弄明白了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先这题最简单的想法是枚举所有可能的挡板，这样需要枚举两个点，然后统计两端的点。枚举是 n×n， 统计也是 n，总共时间复杂度是 n^3。显然是超时的。</p>\n<p> 然后扫描法的思想是，按照一定顺序枚举，这样可以动态的维护一个量，省去了扫描时的 n。</p>\n<p> 所以这题正解是枚举每一个点当作基点，然后计算每个点相对于基点的极角，进行极角排序。然后按极角的大小进行旋转时的枚举。每旋转一次可以根据之前统计的点的个数进行动态的更新（这就是“维护”）。</p>\n<p> 这题有个可以优化的地方，如果一个点是黑点的话，可以把他映射到关于基点对称的地方去，视为白点。这样扫描的时候只需要统计白点就够了。然后扫描的时候只从扫描 180 度即可。</p>\n<p> 判断是否超过 180 度用叉乘，<strong>a</strong>×<strong>b</strong> = <code>|a| * |b| * sin&lt;a,b&gt;</code>，两个点叉乘用坐标计算是，<code>x1*y2 - y1*x2</code> 因为向量的模一定是正的，所以只要判断这个叉乘正负，就可以判断 sin 的正负了，即是否超过 180 度。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1005</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"keyword\">int</span> color;</div><div class=\"line\">    <span class=\"keyword\">double</span> rad;</div><div class=\"line\">&#125;raw_data[MAX], data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node &amp;a, <span class=\"keyword\">const</span> struct Node &amp;b) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.rad &lt; b.rad;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, ans;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用叉乘判断角度是否大于180度，即sin值。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Turn</span><span class=\"params\">(Node &amp;a, Node &amp;b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.x * b.y &gt;= a.y * b.x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        ans = n;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举每一个点当多基点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//计算每个点关于基点的相对坐标。</span></div><div class=\"line\">            data[k].x = raw_data[j].x - raw_data[i].x;</div><div class=\"line\">            data[k].y = raw_data[j].y - raw_data[i].y;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果是黑点的话，那么映射到关于基点对称的地方，这样扫描的时候只记录白点就够了。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (raw_data[j].color) &#123;</div><div class=\"line\">                data[k].x *= <span class=\"number\">-1</span>;</div><div class=\"line\">                data[k].y *= <span class=\"number\">-1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//求极角</span></div><div class=\"line\">            data[k].rad = <span class=\"built_in\">atan2</span>(data[k].y, data[k].x);</div><div class=\"line\">            k++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//极角排序</span></div><div class=\"line\">        sort(data, data + k);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//L为与基点相连的点，R为扫描线。</span></div><div class=\"line\">        <span class=\"keyword\">int</span> L = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>, cnt = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//枚举每一个点与基点相连当作挡板。</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (L &lt; k) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (L == R) &#123;</div><div class=\"line\">                R = (R + <span class=\"number\">1</span>) % k;</div><div class=\"line\">                cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//扫描的时候只扫描一侧，保证扫描线与挡板的夹角不超过180度。</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (L != R &amp;&amp; Turn(data[L], data[R])) &#123;</div><div class=\"line\">                cnt++;</div><div class=\"line\">                R = (R + <span class=\"number\">1</span>) % k;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ans = max(ans, cnt);</div><div class=\"line\">            <span class=\"comment\">//挡板旋转。</span></div><div class=\"line\">            L++;</div><div class=\"line\">            <span class=\"comment\">//由于挡板旋转，与基点相连的点不在挡板上了，减去1。</span></div><div class=\"line\">            cnt--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; raw_data[i].x &gt;&gt; raw_data[i].y &gt;&gt; raw_data[i].color;</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 平面上有 n 个点， 每个点为白点或黑点。现在需要放置一条隔板，使得隔板一侧的黑色点数加上另一侧白色点数的和最大。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 这是人生第一道 AC 的计算几何题！<br> 由于之前一直没接触过这种题，紫书上的分析也看不懂，一言不合就让我极角排序、叉乘，根本没学过啊QAQ。<br> 然后翻了很多博客，重学了一下极坐标，可算是弄明白了。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先这题最简单的想法是枚举所有可能的挡板，这样需要枚举两个点，然后统计两端的点。枚举是 n×n， 统计也是 n，总共时间复杂度是 n^3。显然是超时的。</p>\n<p> 然后扫描法的思想是，按照一定顺序枚举，这样可以动态的维护一个量，省去了扫描时的 n。</p>\n<p> 所以这题正解是枚举每一个点当作基点，然后计算每个点相对于基点的极角，进行极角排序。然后按极角的大小进行旋转时的枚举。每旋转一次可以根据之前统计的点的个数进行动态的更新（这就是“维护”）。</p>\n<p> 这题有个可以优化的地方，如果一个点是黑点的话，可以把他映射到关于基点对称的地方去，视为白点。这样扫描的时候只需要统计白点就够了。然后扫描的时候只从扫描 180 度即可。</p>\n<p> 判断是否超过 180 度用叉乘，<strong>a</strong>×<strong>b</strong> = <code>|a| * |b| * sin&lt;a,b&gt;</code>，两个点叉乘用坐标计算是，<code>x1*y2 - y1*x2</code> 因为向量的模一定是正的，所以只要判断这个叉乘正负，就可以判断 sin 的正负了，即是否超过 180 度。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1005</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> x, y;</div><div class=\"line\">    <span class=\"keyword\">int</span> color;</div><div class=\"line\">    <span class=\"keyword\">double</span> rad;</div><div class=\"line\">&#125;raw_data[MAX], data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> struct Node &amp;a, <span class=\"keyword\">const</span> struct Node &amp;b) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.rad &lt; b.rad;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, ans;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用叉乘判断角度是否大于180度，即sin值。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Turn</span><span class=\"params\">(Node &amp;a, Node &amp;b)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a.x * b.y &gt;= a.y * b.x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        ans = n;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//枚举每一个点当多基点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//计算每个点关于基点的相对坐标。</span></div><div class=\"line\">            data[k].x = raw_data[j].x - raw_data[i].x;</div><div class=\"line\">            data[k].y = raw_data[j].y - raw_data[i].y;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果是黑点的话，那么映射到关于基点对称的地方，这样扫描的时候只记录白点就够了。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (raw_data[j].color) &#123;</div><div class=\"line\">                data[k].x *= <span class=\"number\">-1</span>;</div><div class=\"line\">                data[k].y *= <span class=\"number\">-1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//求极角</span></div><div class=\"line\">            data[k].rad = <span class=\"built_in\">atan2</span>(data[k].y, data[k].x);</div><div class=\"line\">            k++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//极角排序</span></div><div class=\"line\">        sort(data, data + k);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//L为与基点相连的点，R为扫描线。</span></div><div class=\"line\">        <span class=\"keyword\">int</span> L = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>, cnt = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//枚举每一个点与基点相连当作挡板。</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (L &lt; k) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (L == R) &#123;</div><div class=\"line\">                R = (R + <span class=\"number\">1</span>) % k;</div><div class=\"line\">                cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//扫描的时候只扫描一侧，保证扫描线与挡板的夹角不超过180度。</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (L != R &amp;&amp; Turn(data[L], data[R])) &#123;</div><div class=\"line\">                cnt++;</div><div class=\"line\">                R = (R + <span class=\"number\">1</span>) % k;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ans = max(ans, cnt);</div><div class=\"line\">            <span class=\"comment\">//挡板旋转。</span></div><div class=\"line\">            L++;</div><div class=\"line\">            <span class=\"comment\">//由于挡板旋转，与基点相连的点不在挡板上了，减去1。</span></div><div class=\"line\">            cnt--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; raw_data[i].x &gt;&gt; raw_data[i].y &gt;&gt; raw_data[i].color;</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve();</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVA10129-Play on Words（欧拉道路）","date":"2016-12-15T08:32:06.000Z","_content":"# 题目链接：\n\n\n[UVA10129-Play on Words](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1070)\n\n----------\n# 题目大意：\n给出一些单词，如果一个单词的首部字母和另一个单词的尾部字母相同，则可以首尾连接，每个单词只能使用一次，判断这些字母是否可以全部连接成一个串。\n\n\n----------\n# 解题过程：\n\n - 刚开始没弄清有向图和无向图欧拉路的定义，以为只判断边就可以了，于是简单写了一个只判读边的。\n - 显然是错误的，自己试了几组数据就不对。\n [我这样想可能是被这个题带偏了节奏（误](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3683.html)\n \n - 然后仔细看了下书上的定义，还要保证图必须是连同的才可以，于是写了下，一发AC。\n - \n\n\n----------\n# 题目分析：\n\n - **首先明确欧拉路的充要条件：**\n -  对于无向图，最多只有两个点的度为1，则一定存在欧拉回路。\n - 对于有向图，最多只能有两个点的入度不等于出度，而且一个是入度恰好比出度大1，另一个是出度比入度大1。\n - 以上两个图都要保证**底图**（忽略边的方向后得到的图）是连通的。\n - 如果一个图不存在**奇点**（度数为奇数的点）则构成欧拉回路，否则为欧拉路。\n \n\n\n----------\n\n - 题目是有向图，把每个字母当做点，用两个数组统计每个点入度和出度，并判断。\n - 用dfs的方法把图遍历一遍，看是否每个点都到达过，是的话则是连通的图。\n - 两个判断条件与运算即是结果。\n - \n\n\n----------\n# AC代码：\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint head[26], tail[26], data[26][26], mark[26];\n\nbool dfs(int k)\n{\n    mark[k] = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (data[k][i])\n        {\n            data[k][i] = 0;\n            data[i][k] = 0;\n            dfs(i);\n        }\n    }\n}\n\nbool judge()\n{\n    int k;\n    for (int i = 0; i < 26; i++)\n    {\n        if (mark[i] != 0)\n        {\n            k = i;\n            break;\n        }\n    }\n    dfs(k);\n    for (int i = 0; i < 26; i++)\n        if (mark[i])\n            return false;\n    return true;\n}\n\nint main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        memset(head, 0, sizeof(head));\n        memset(tail, 0, sizeof(tail));\n        memset(data, 0, sizeof(data));\n        memset(mark, 0, sizeof(mark));\n        int n, flag = 1;\n        cin >> n;\n        string str;\n        while (n--)\n        {\n            cin >> str;\n            head[str[0]-'a']++;\n            tail[str[str.size()-1]-'a']++;\n\n            data[str[0]-'a'][str[str.size()-1]-'a'] = 1;\n            data[str[str.size()-1]-'a'][str[0]-'a'] = 1;\n\n            mark[str[0]-'a'] = 1;\n            mark[str[str.size()-1]-'a'] = 1;\n        }\n        int a = 0, b = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            if (head[i]-tail[i] == 1)\n                a++;\n            if (tail[i]-head[i] == 1)\n                b++;\n            if (abs(head[i]-tail[i]) > 1)\n                flag = 0;\n        }\n        if (flag && a == b && a <= 1 && judge())\n            cout << \"Ordering is possible.\" << endl;\n        else\n            cout << \"The door cannot be opened.\" << endl;\n    }\n}\n\n```\n\n\n----------\n# 扩展应用：\n按书上的说法欧拉回路的来源好像就是为了解决一笔画问题，于是写了一个有意思的程序，给定一个含有欧拉路的图，求如何打印欧拉路。\n\n\n----------\n# 功能用法：\n首先打开一个游戏\n![这里写图片描述](http://img.blog.csdn.net/20161215170447246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后分析出有几条边和点。\n![这里写图片描述](http://img.blog.csdn.net/20161215170542887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n输入数据，即可得出结果。\n![这里写图片描述](http://img.blog.csdn.net/20161215170612992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n----------\n# 源代码：\n```\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\n\nconst int MAX = 1123;\n\nint m, n;\nint data[MAX][MAX];\nstack<int> ans;\n\nvoid dfs(int pos)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        if (data[pos][i])\n        {\n            data[pos][i] = 0;\n            data[i][pos] = 0;\n            dfs(i);\n        }\n    }\n    ans.push(pos);\n}\n\nvoid put()\n{\n    while (!ans.empty())\n    {\n        cout << \"->\" << ans.top();\n        ans.pop();\n    }\n    cout << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m)\n    {\n        memset(data, 0, sizeof(data));\n        int a, b;\n        for (int i = 0; i < m; i++)\n        {\n            cin >> a >> b;\n            data[a][b] = 1;\n            data[b][a] = 1;\n        }\n        dfs(1);\n        put();\n    }\n}\n```","source":"_posts/UVA10129-Play-on-Words（欧拉道路）.md","raw":"---\ntitle: UVA10129-Play on Words（欧拉道路）\ndate: 2016-12-15 16:32:06\ncategories: [ACM, 图论]\ntags:\n---\n# 题目链接：\n\n\n[UVA10129-Play on Words](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1070)\n\n----------\n# 题目大意：\n给出一些单词，如果一个单词的首部字母和另一个单词的尾部字母相同，则可以首尾连接，每个单词只能使用一次，判断这些字母是否可以全部连接成一个串。\n\n\n----------\n# 解题过程：\n\n - 刚开始没弄清有向图和无向图欧拉路的定义，以为只判断边就可以了，于是简单写了一个只判读边的。\n - 显然是错误的，自己试了几组数据就不对。\n [我这样想可能是被这个题带偏了节奏（误](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3683.html)\n \n - 然后仔细看了下书上的定义，还要保证图必须是连同的才可以，于是写了下，一发AC。\n - \n\n\n----------\n# 题目分析：\n\n - **首先明确欧拉路的充要条件：**\n -  对于无向图，最多只有两个点的度为1，则一定存在欧拉回路。\n - 对于有向图，最多只能有两个点的入度不等于出度，而且一个是入度恰好比出度大1，另一个是出度比入度大1。\n - 以上两个图都要保证**底图**（忽略边的方向后得到的图）是连通的。\n - 如果一个图不存在**奇点**（度数为奇数的点）则构成欧拉回路，否则为欧拉路。\n \n\n\n----------\n\n - 题目是有向图，把每个字母当做点，用两个数组统计每个点入度和出度，并判断。\n - 用dfs的方法把图遍历一遍，看是否每个点都到达过，是的话则是连通的图。\n - 两个判断条件与运算即是结果。\n - \n\n\n----------\n# AC代码：\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint head[26], tail[26], data[26][26], mark[26];\n\nbool dfs(int k)\n{\n    mark[k] = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (data[k][i])\n        {\n            data[k][i] = 0;\n            data[i][k] = 0;\n            dfs(i);\n        }\n    }\n}\n\nbool judge()\n{\n    int k;\n    for (int i = 0; i < 26; i++)\n    {\n        if (mark[i] != 0)\n        {\n            k = i;\n            break;\n        }\n    }\n    dfs(k);\n    for (int i = 0; i < 26; i++)\n        if (mark[i])\n            return false;\n    return true;\n}\n\nint main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        memset(head, 0, sizeof(head));\n        memset(tail, 0, sizeof(tail));\n        memset(data, 0, sizeof(data));\n        memset(mark, 0, sizeof(mark));\n        int n, flag = 1;\n        cin >> n;\n        string str;\n        while (n--)\n        {\n            cin >> str;\n            head[str[0]-'a']++;\n            tail[str[str.size()-1]-'a']++;\n\n            data[str[0]-'a'][str[str.size()-1]-'a'] = 1;\n            data[str[str.size()-1]-'a'][str[0]-'a'] = 1;\n\n            mark[str[0]-'a'] = 1;\n            mark[str[str.size()-1]-'a'] = 1;\n        }\n        int a = 0, b = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            if (head[i]-tail[i] == 1)\n                a++;\n            if (tail[i]-head[i] == 1)\n                b++;\n            if (abs(head[i]-tail[i]) > 1)\n                flag = 0;\n        }\n        if (flag && a == b && a <= 1 && judge())\n            cout << \"Ordering is possible.\" << endl;\n        else\n            cout << \"The door cannot be opened.\" << endl;\n    }\n}\n\n```\n\n\n----------\n# 扩展应用：\n按书上的说法欧拉回路的来源好像就是为了解决一笔画问题，于是写了一个有意思的程序，给定一个含有欧拉路的图，求如何打印欧拉路。\n\n\n----------\n# 功能用法：\n首先打开一个游戏\n![这里写图片描述](http://img.blog.csdn.net/20161215170447246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后分析出有几条边和点。\n![这里写图片描述](http://img.blog.csdn.net/20161215170542887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n输入数据，即可得出结果。\n![这里写图片描述](http://img.blog.csdn.net/20161215170612992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n----------\n# 源代码：\n```\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\n\nconst int MAX = 1123;\n\nint m, n;\nint data[MAX][MAX];\nstack<int> ans;\n\nvoid dfs(int pos)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        if (data[pos][i])\n        {\n            data[pos][i] = 0;\n            data[i][pos] = 0;\n            dfs(i);\n        }\n    }\n    ans.push(pos);\n}\n\nvoid put()\n{\n    while (!ans.empty())\n    {\n        cout << \"->\" << ans.top();\n        ans.pop();\n    }\n    cout << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m)\n    {\n        memset(data, 0, sizeof(data));\n        int a, b;\n        for (int i = 0; i < m; i++)\n        {\n            cin >> a >> b;\n            data[a][b] = 1;\n            data[b][a] = 1;\n        }\n        dfs(1);\n        put();\n    }\n}\n```","slug":"UVA10129-Play-on-Words（欧拉道路）","published":1,"updated":"2017-07-23T04:06:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ne60052y9idrxjq7pqg","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1070\" target=\"_blank\" rel=\"external\">UVA10129-Play on Words</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一些单词，如果一个单词的首部字母和另一个单词的尾部字母相同，则可以首尾连接，每个单词只能使用一次，判断这些字母是否可以全部连接成一个串。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>刚开始没弄清有向图和无向图欧拉路的定义，以为只判断边就可以了，于是简单写了一个只判读边的。</li>\n<li><p>显然是错误的，自己试了几组数据就不对。<br><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3683.html\" target=\"_blank\" rel=\"external\">我这样想可能是被这个题带偏了节奏（误</a></p>\n</li>\n<li><p>然后仔细看了下书上的定义，还要保证图必须是连同的才可以，于是写了下，一发AC。</p>\n</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li><strong>首先明确欧拉路的充要条件：</strong></li>\n<li>对于无向图，最多只有两个点的度为1，则一定存在欧拉回路。</li>\n<li>对于有向图，最多只能有两个点的入度不等于出度，而且一个是入度恰好比出度大1，另一个是出度比入度大1。</li>\n<li>以上两个图都要保证<strong>底图</strong>（忽略边的方向后得到的图）是连通的。</li>\n<li>如果一个图不存在<strong>奇点</strong>（度数为奇数的点）则构成欧拉回路，否则为欧拉路。</li>\n</ul>\n<hr>\n<ul>\n<li>题目是有向图，把每个字母当做点，用两个数组统计每个点入度和出度，并判断。</li>\n<li>用dfs的方法把图遍历一遍，看是否每个点都到达过，是的话则是连通的图。</li>\n<li>两个判断条件与运算即是结果。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">26</span>], tail[<span class=\"number\">26</span>], data[<span class=\"number\">26</span>][<span class=\"number\">26</span>], mark[<span class=\"number\">26</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    mark[k] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[k][i])</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[k][i] = <span class=\"number\">0</span>;</div><div class=\"line\">            data[i][k] = <span class=\"number\">0</span>;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[i] != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    dfs(k);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T;</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(tail, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tail));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">        <span class=\"keyword\">int</span> n, flag = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">        <span class=\"built_in\">string</span> str;</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; str;</div><div class=\"line\">            head[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>]++;</div><div class=\"line\">            tail[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>]++;</div><div class=\"line\"></div><div class=\"line\">            data[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>][str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            data[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>][str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">            mark[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            mark[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (head[i]-tail[i] == <span class=\"number\">1</span>)</div><div class=\"line\">                a++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (tail[i]-head[i] == <span class=\"number\">1</span>)</div><div class=\"line\">                b++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(head[i]-tail[i]) &gt; <span class=\"number\">1</span>)</div><div class=\"line\">                flag = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (flag &amp;&amp; a == b &amp;&amp; a &lt;= <span class=\"number\">1</span> &amp;&amp; judge())</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Ordering is possible.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"扩展应用：\"><a href=\"#扩展应用：\" class=\"headerlink\" title=\"扩展应用：\"></a>扩展应用：</h1><p>按书上的说法欧拉回路的来源好像就是为了解决一笔画问题，于是写了一个有意思的程序，给定一个含有欧拉路的图，求如何打印欧拉路。</p>\n<hr>\n<h1 id=\"功能用法：\"><a href=\"#功能用法：\" class=\"headerlink\" title=\"功能用法：\"></a>功能用法：</h1><p>首先打开一个游戏<br><img src=\"http://img.blog.csdn.net/20161215170447246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后分析出有几条边和点。<br><img src=\"http://img.blog.csdn.net/20161215170542887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>输入数据，即可得出结果。<br><img src=\"http://img.blog.csdn.net/20161215170612992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">#include &lt;stack&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">const int MAX = 1123;</div><div class=\"line\"></div><div class=\"line\">int m, n;</div><div class=\"line\">int data[MAX][MAX];</div><div class=\"line\">stack&lt;int&gt; ans;</div><div class=\"line\"></div><div class=\"line\">void dfs(int pos)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (data[pos][i])</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[pos][i] = 0;</div><div class=\"line\">            data[i][pos] = 0;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans.push(pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void put()</div><div class=\"line\">&#123;</div><div class=\"line\">    while (!ans.empty())</div><div class=\"line\">    &#123;</div><div class=\"line\">        cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ans.top();</div><div class=\"line\">        ans.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; endl;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    while (cin &gt;&gt; n &gt;&gt; m)</div><div class=\"line\">    &#123;</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        int a, b;</div><div class=\"line\">        for (int i = 0; i &lt; m; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cin &gt;&gt; a &gt;&gt; b;</div><div class=\"line\">            data[a][b] = 1;</div><div class=\"line\">            data[b][a] = 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dfs(1);</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1070\" target=\"_blank\" rel=\"external\">UVA10129-Play on Words</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给出一些单词，如果一个单词的首部字母和另一个单词的尾部字母相同，则可以首尾连接，每个单词只能使用一次，判断这些字母是否可以全部连接成一个串。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><ul>\n<li>刚开始没弄清有向图和无向图欧拉路的定义，以为只判断边就可以了，于是简单写了一个只判读边的。</li>\n<li><p>显然是错误的，自己试了几组数据就不对。<br><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3683.html\" target=\"_blank\" rel=\"external\">我这样想可能是被这个题带偏了节奏（误</a></p>\n</li>\n<li><p>然后仔细看了下书上的定义，还要保证图必须是连同的才可以，于是写了下，一发AC。</p>\n</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><ul>\n<li><strong>首先明确欧拉路的充要条件：</strong></li>\n<li>对于无向图，最多只有两个点的度为1，则一定存在欧拉回路。</li>\n<li>对于有向图，最多只能有两个点的入度不等于出度，而且一个是入度恰好比出度大1，另一个是出度比入度大1。</li>\n<li>以上两个图都要保证<strong>底图</strong>（忽略边的方向后得到的图）是连通的。</li>\n<li>如果一个图不存在<strong>奇点</strong>（度数为奇数的点）则构成欧拉回路，否则为欧拉路。</li>\n</ul>\n<hr>\n<ul>\n<li>题目是有向图，把每个字母当做点，用两个数组统计每个点入度和出度，并判断。</li>\n<li>用dfs的方法把图遍历一遍，看是否每个点都到达过，是的话则是连通的图。</li>\n<li>两个判断条件与运算即是结果。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> head[<span class=\"number\">26</span>], tail[<span class=\"number\">26</span>], data[<span class=\"number\">26</span>][<span class=\"number\">26</span>], mark[<span class=\"number\">26</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    mark[k] = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[k][i])</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[k][i] = <span class=\"number\">0</span>;</div><div class=\"line\">            data[i][k] = <span class=\"number\">0</span>;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[i] != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    dfs(k);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (mark[i])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T;</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(tail, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(tail));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        <span class=\"built_in\">memset</span>(mark, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mark));</div><div class=\"line\">        <span class=\"keyword\">int</span> n, flag = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</div><div class=\"line\">        <span class=\"built_in\">string</span> str;</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; str;</div><div class=\"line\">            head[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>]++;</div><div class=\"line\">            tail[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>]++;</div><div class=\"line\"></div><div class=\"line\">            data[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>][str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            data[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>][str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">            mark[str[<span class=\"number\">0</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            mark[str[str.size()<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (head[i]-tail[i] == <span class=\"number\">1</span>)</div><div class=\"line\">                a++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (tail[i]-head[i] == <span class=\"number\">1</span>)</div><div class=\"line\">                b++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(head[i]-tail[i]) &gt; <span class=\"number\">1</span>)</div><div class=\"line\">                flag = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (flag &amp;&amp; a == b &amp;&amp; a &lt;= <span class=\"number\">1</span> &amp;&amp; judge())</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Ordering is possible.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"扩展应用：\"><a href=\"#扩展应用：\" class=\"headerlink\" title=\"扩展应用：\"></a>扩展应用：</h1><p>按书上的说法欧拉回路的来源好像就是为了解决一笔画问题，于是写了一个有意思的程序，给定一个含有欧拉路的图，求如何打印欧拉路。</p>\n<hr>\n<h1 id=\"功能用法：\"><a href=\"#功能用法：\" class=\"headerlink\" title=\"功能用法：\"></a>功能用法：</h1><p>首先打开一个游戏<br><img src=\"http://img.blog.csdn.net/20161215170447246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>然后分析出有几条边和点。<br><img src=\"http://img.blog.csdn.net/20161215170542887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>输入数据，即可得出结果。<br><img src=\"http://img.blog.csdn.net/20161215170612992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">#include &lt;stack&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">const int MAX = 1123;</div><div class=\"line\"></div><div class=\"line\">int m, n;</div><div class=\"line\">int data[MAX][MAX];</div><div class=\"line\">stack&lt;int&gt; ans;</div><div class=\"line\"></div><div class=\"line\">void dfs(int pos)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (data[pos][i])</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[pos][i] = 0;</div><div class=\"line\">            data[i][pos] = 0;</div><div class=\"line\">            dfs(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ans.push(pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void put()</div><div class=\"line\">&#123;</div><div class=\"line\">    while (!ans.empty())</div><div class=\"line\">    &#123;</div><div class=\"line\">        cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ans.top();</div><div class=\"line\">        ans.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; endl;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    while (cin &gt;&gt; n &gt;&gt; m)</div><div class=\"line\">    &#123;</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        int a, b;</div><div class=\"line\">        for (int i = 0; i &lt; m; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cin &gt;&gt; a &gt;&gt; b;</div><div class=\"line\">            data[a][b] = 1;</div><div class=\"line\">            data[b][a] = 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dfs(1);</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVA12511 - Virus（DP+最长公共上升子序列）","date":"2017-06-11T13:22:11.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/UVA-12511\n\n----------------------------------\n# 题目大意：\n给定两个序列，求出两个序列的最长公共上升子序列（严格上升）。\n\n\n-----------------------------------------\n# 解题过程：\n比赛的时候没有做出来，非常咸鱼的一场比赛，当时是想错了状态。当时想的状态是定义$dp[i][j]$，意味以第一个串第前i个元素，第二个串前j个元素的最长公共上升子序列长度。\n\n但是这样定义状态有后效性，比如当前我知道$dp[i][j]$要以这个状态进行转移的话，需要他是以那个状态转移而来的，换句话说，我转移的时候要知道他是以前j个数中那一个结尾的。\n\n如果换一种方式，$dp[i][j]$代表以第一个序列前i个元素并且以第i个结束，第二个序列前j个元素并且以第j个元素结尾的最长上升子序列的长度。\n\n这样加入的限制太多，不容易找出状态转移方程，或者转移起来太麻烦。\n\n--------------------------\n# 题目分析：\n这里以$dp[i][j]$表示第一个序列中前i个元素，第二个序列前j个元素并且以第j个元素为结尾的最长上升子序列。\n\n这样对比前两种状态表示方式有两种好处，一是无后效性，$dp[i][j]$的第二维就确定了这个序列是以那一个元素结尾。二是容易进行转移，对于$dp[i][j]$可由两种方式转移而来：\n\n\n$$\ndp[i][j] = \t\n\\begin{cases}\ndp[i-1][j] , &a[i]  \\ne b[i] \\\\\nmax(dp[i-1][k])+1, &k \\in [1, j-1] \\wedge b[k] < b[j] \\wedge a[i] = b[i]\n\\end{cases}\n$$\n\n这里的k可以在循环中找出，时间复杂度为$O(n^2)$.\n\n-----------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123;\n\nint dp[MAX][MAX], a[MAX], b[MAX];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        scanf(\"%d\", &m);\n        for (int i = 1; i <= m; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        memset(dp, 0, sizeof(dp));\n        for (int i = 1; i <= n; i++) {\n            int maxn = 0;\n            for (int j = 1; j <= m; j++) {\n                //不相等时的转移\n                dp[i][j] = dp[i-1][j];\n                //更新maxn变量，表示当前小于a[i]的dp[i-1][k]的最大值\n                if (a[i] > b[j] && maxn < dp[i-1][j])\n                    maxn = dp[i-1][j];\n                //相等的话\n                if (a[i] == b[j])\n                    dp[i][j] = maxn+1;\n            }\n        }\n        int ans = 0;\n        for (int i = 1; i <= m; i++) {\n            ans = max(ans, dp[n][i]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```\n\n\n","source":"_posts/UVA12511-Virus（DP-最长公共上升子序列）.md","raw":"---\ntitle: UVA12511 - Virus（DP+最长公共上升子序列）\ndate: 2017-06-11 21:22:11\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/UVA-12511\n\n----------------------------------\n# 题目大意：\n给定两个序列，求出两个序列的最长公共上升子序列（严格上升）。\n\n\n-----------------------------------------\n# 解题过程：\n比赛的时候没有做出来，非常咸鱼的一场比赛，当时是想错了状态。当时想的状态是定义$dp[i][j]$，意味以第一个串第前i个元素，第二个串前j个元素的最长公共上升子序列长度。\n\n但是这样定义状态有后效性，比如当前我知道$dp[i][j]$要以这个状态进行转移的话，需要他是以那个状态转移而来的，换句话说，我转移的时候要知道他是以前j个数中那一个结尾的。\n\n如果换一种方式，$dp[i][j]$代表以第一个序列前i个元素并且以第i个结束，第二个序列前j个元素并且以第j个元素结尾的最长上升子序列的长度。\n\n这样加入的限制太多，不容易找出状态转移方程，或者转移起来太麻烦。\n\n--------------------------\n# 题目分析：\n这里以$dp[i][j]$表示第一个序列中前i个元素，第二个序列前j个元素并且以第j个元素为结尾的最长上升子序列。\n\n这样对比前两种状态表示方式有两种好处，一是无后效性，$dp[i][j]$的第二维就确定了这个序列是以那一个元素结尾。二是容易进行转移，对于$dp[i][j]$可由两种方式转移而来：\n\n\n$$\ndp[i][j] = \t\n\\begin{cases}\ndp[i-1][j] , &a[i]  \\ne b[i] \\\\\nmax(dp[i-1][k])+1, &k \\in [1, j-1] \\wedge b[k] < b[j] \\wedge a[i] = b[i]\n\\end{cases}\n$$\n\n这里的k可以在循环中找出，时间复杂度为$O(n^2)$.\n\n-----------------------------\n# AC代码：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1123;\n\nint dp[MAX][MAX], a[MAX], b[MAX];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        scanf(\"%d\", &m);\n        for (int i = 1; i <= m; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        memset(dp, 0, sizeof(dp));\n        for (int i = 1; i <= n; i++) {\n            int maxn = 0;\n            for (int j = 1; j <= m; j++) {\n                //不相等时的转移\n                dp[i][j] = dp[i-1][j];\n                //更新maxn变量，表示当前小于a[i]的dp[i-1][k]的最大值\n                if (a[i] > b[j] && maxn < dp[i-1][j])\n                    maxn = dp[i-1][j];\n                //相等的话\n                if (a[i] == b[j])\n                    dp[i][j] = maxn+1;\n            }\n        }\n        int ans = 0;\n        for (int i = 1; i <= m; i++) {\n            ans = max(ans, dp[n][i]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```\n\n\n","slug":"UVA12511-Virus（DP-最长公共上升子序列）","published":1,"updated":"2017-07-23T02:12:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nea0054y9idggr7sway","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/UVA-12511\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/UVA-12511</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定两个序列，求出两个序列的最长公共上升子序列（严格上升）。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候没有做出来，非常咸鱼的一场比赛，当时是想错了状态。当时想的状态是定义$dp[i][j]$，意味以第一个串第前i个元素，第二个串前j个元素的最长公共上升子序列长度。</p>\n<p>但是这样定义状态有后效性，比如当前我知道$dp[i][j]$要以这个状态进行转移的话，需要他是以那个状态转移而来的，换句话说，我转移的时候要知道他是以前j个数中那一个结尾的。</p>\n<p>如果换一种方式，$dp[i][j]$代表以第一个序列前i个元素并且以第i个结束，第二个序列前j个元素并且以第j个元素结尾的最长上升子序列的长度。</p>\n<p>这样加入的限制太多，不容易找出状态转移方程，或者转移起来太麻烦。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里以$dp[i][j]$表示第一个序列中前i个元素，第二个序列前j个元素并且以第j个元素为结尾的最长上升子序列。</p>\n<p>这样对比前两种状态表示方式有两种好处，一是无后效性，$dp[i][j]$的第二维就确定了这个序列是以那一个元素结尾。二是容易进行转移，对于$dp[i][j]$可由两种方式转移而来：</p>\n<p>$$<br>dp[i][j] =<br>\\begin{cases}<br>dp[i-1][j] , &amp;a[i]  \\ne b[i] \\<br>max(dp[i-1][k])+1, &amp;k \\in [1, j-1] \\wedge b[k] &lt; b[j] \\wedge a[i] = b[i]<br>\\end{cases}<br>$$</p>\n<p>这里的k可以在循环中找出，时间复杂度为$O(n^2)$.</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX], a[MAX], b[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;b[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> maxn = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//不相等时的转移</span></div><div class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">                <span class=\"comment\">//更新maxn变量，表示当前小于a[i]的dp[i-1][k]的最大值</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (a[i] &gt; b[j] &amp;&amp; maxn &lt; dp[i<span class=\"number\">-1</span>][j])</div><div class=\"line\">                    maxn = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">                <span class=\"comment\">//相等的话</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (a[i] == b[j])</div><div class=\"line\">                    dp[i][j] = maxn+<span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            ans = max(ans, dp[n][i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/UVA-12511\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/UVA-12511</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定两个序列，求出两个序列的最长公共上升子序列（严格上升）。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>比赛的时候没有做出来，非常咸鱼的一场比赛，当时是想错了状态。当时想的状态是定义$dp[i][j]$，意味以第一个串第前i个元素，第二个串前j个元素的最长公共上升子序列长度。</p>\n<p>但是这样定义状态有后效性，比如当前我知道$dp[i][j]$要以这个状态进行转移的话，需要他是以那个状态转移而来的，换句话说，我转移的时候要知道他是以前j个数中那一个结尾的。</p>\n<p>如果换一种方式，$dp[i][j]$代表以第一个序列前i个元素并且以第i个结束，第二个序列前j个元素并且以第j个元素结尾的最长上升子序列的长度。</p>\n<p>这样加入的限制太多，不容易找出状态转移方程，或者转移起来太麻烦。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里以$dp[i][j]$表示第一个序列中前i个元素，第二个序列前j个元素并且以第j个元素为结尾的最长上升子序列。</p>\n<p>这样对比前两种状态表示方式有两种好处，一是无后效性，$dp[i][j]$的第二维就确定了这个序列是以那一个元素结尾。二是容易进行转移，对于$dp[i][j]$可由两种方式转移而来：</p>\n<p>$$<br>dp[i][j] =<br>\\begin{cases}<br>dp[i-1][j] , &amp;a[i]  \\ne b[i] \\<br>max(dp[i-1][k])+1, &amp;k \\in [1, j-1] \\wedge b[k] &lt; b[j] \\wedge a[i] = b[i]<br>\\end{cases}<br>$$</p>\n<p>这里的k可以在循环中找出，时间复杂度为$O(n^2)$.</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[MAX][MAX], a[MAX], b[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;b[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> maxn = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</div><div class=\"line\">                <span class=\"comment\">//不相等时的转移</span></div><div class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">                <span class=\"comment\">//更新maxn变量，表示当前小于a[i]的dp[i-1][k]的最大值</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (a[i] &gt; b[j] &amp;&amp; maxn &lt; dp[i<span class=\"number\">-1</span>][j])</div><div class=\"line\">                    maxn = dp[i<span class=\"number\">-1</span>][j];</div><div class=\"line\">                <span class=\"comment\">//相等的话</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (a[i] == b[j])</div><div class=\"line\">                    dp[i][j] = maxn+<span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            ans = max(ans, dp[n][i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"UVA11235 - Frequent values（游程编码+线段树）","date":"2017-06-28T08:56:32.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/UVA-11235\n\n\n-------------------\n# 题目大意：\n给定一个递增序列，询问一段区间内出现频率最多的数出现的次数。\n\n----------------------\n# 解题过程：\n之前图灵杯比赛的题，当时照着板子敲A的，现在突发奇想补一下题，感觉还是挺简单的，就是用到了游程编码。\n\n-----------------------------\n# 题目分析：\n由于题目是有序的，那么可以很方便的将一段相同的数合为一个区间，`data[i]`表示第i段区间元素个数，`lb[i]`记录第`i`段区间的左边界，`rb[i]`记录第`i`段区间的右边界，用`id[i]`表示原序列的第i个数处于哪个区间。\n\n那么对于查询l到r的区间，如果`l`和`r`在同一段区间内，那么显然答案就是`r-l+1`。\n如果l和r不在同一段区间，那么答案为以下三个中的最大值，`rb[id[l]] - l + 1`,` r - lb[id[r]] + 1`, `id[l]+1`区间到`id[r]-1`区间中的最大值`。\n\n\n-------------------\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint tree[MAX<<2];\nint data[MAX];\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nvoid build(int o, int l, int r) {\n    if (l == r) {\n        tree[o] = data[l];\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[o] = max(tree[lson], tree[rson]);\n}\n\nint query(int o, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql) return 0;\n    if (ql <= l && r <= qr) {\n        return tree[o];\n    }\n    MID;\n    return max(query(lson, l, m, ql, qr), query(rson, m+1, r, ql, qr));\n}\n\nint raw_data[MAX], n, q, lb[MAX], rb[MAX], id[MAX], top;\n\nvoid init() {\n    top = 1;\n    lb[top] = data[top] = id[1] = 1;\n    for (int i = 2; i <= n+1; i++) {\n        if (raw_data[i] != raw_data[i-1] || i == n+1) {\n            rb[top++] = i-1;\n            lb[top] = i;\n        }\n        data[top]++;\n        id[i] = top;\n    }\n}\n\nint main() {\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n    while (~scanf(\"%d\", &n) && n) {\n        scanf(\"%d\", &q);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", raw_data+i);\n        }\n        memset(data, 0, sizeof(data));\n        init();\n        n = top-1;\n        build(1, 1, n);\n        int l, r;\n        while (q--) {\n            scanf(\"%d %d\", &l, &r);\n            //如果l和r在同一个区间内\n            if (id[l] == id[r]) {\n                printf(\"%d\\n\", r-l+1);\n                continue;\n            }\n            //l和r不在一个区间内\n            int a = id[l], b = id[r];\n            a = rb[a] - l + 1;\n            b = r - lb[b] + 1;\n            int t = max(a, b);\n            a = id[l] + 1, b = id[r] - 1;\n            if (a <= b) {\n                //查询id[l]+1区间到id[r]-1区间中的最大值\n                t = max(t, query(1, 1, n, a, b));\n            }\n            printf(\"%d\\n\", t);\n        }\n    }\n}\n```","source":"_posts/UVA11235-Frequent-values（游程编码-线段树）.md","raw":"---\ntitle: UVA11235 - Frequent values（游程编码+线段树）\ndate: 2017-06-28 16:56:32\ncategories: [ACM, 数据结构, 线段树]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/UVA-11235\n\n\n-------------------\n# 题目大意：\n给定一个递增序列，询问一段区间内出现频率最多的数出现的次数。\n\n----------------------\n# 解题过程：\n之前图灵杯比赛的题，当时照着板子敲A的，现在突发奇想补一下题，感觉还是挺简单的，就是用到了游程编码。\n\n-----------------------------\n# 题目分析：\n由于题目是有序的，那么可以很方便的将一段相同的数合为一个区间，`data[i]`表示第i段区间元素个数，`lb[i]`记录第`i`段区间的左边界，`rb[i]`记录第`i`段区间的右边界，用`id[i]`表示原序列的第i个数处于哪个区间。\n\n那么对于查询l到r的区间，如果`l`和`r`在同一段区间内，那么显然答案就是`r-l+1`。\n如果l和r不在同一段区间，那么答案为以下三个中的最大值，`rb[id[l]] - l + 1`,` r - lb[id[r]] + 1`, `id[l]+1`区间到`id[r]-1`区间中的最大值`。\n\n\n-------------------\n# AC代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112345;\n\nint tree[MAX<<2];\nint data[MAX];\n\n#define lson o<<1\n#define rson o<<1|1\n#define MID int m = (l+r)/2\n\nvoid build(int o, int l, int r) {\n    if (l == r) {\n        tree[o] = data[l];\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[o] = max(tree[lson], tree[rson]);\n}\n\nint query(int o, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql) return 0;\n    if (ql <= l && r <= qr) {\n        return tree[o];\n    }\n    MID;\n    return max(query(lson, l, m, ql, qr), query(rson, m+1, r, ql, qr));\n}\n\nint raw_data[MAX], n, q, lb[MAX], rb[MAX], id[MAX], top;\n\nvoid init() {\n    top = 1;\n    lb[top] = data[top] = id[1] = 1;\n    for (int i = 2; i <= n+1; i++) {\n        if (raw_data[i] != raw_data[i-1] || i == n+1) {\n            rb[top++] = i-1;\n            lb[top] = i;\n        }\n        data[top]++;\n        id[i] = top;\n    }\n}\n\nint main() {\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n    while (~scanf(\"%d\", &n) && n) {\n        scanf(\"%d\", &q);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", raw_data+i);\n        }\n        memset(data, 0, sizeof(data));\n        init();\n        n = top-1;\n        build(1, 1, n);\n        int l, r;\n        while (q--) {\n            scanf(\"%d %d\", &l, &r);\n            //如果l和r在同一个区间内\n            if (id[l] == id[r]) {\n                printf(\"%d\\n\", r-l+1);\n                continue;\n            }\n            //l和r不在一个区间内\n            int a = id[l], b = id[r];\n            a = rb[a] - l + 1;\n            b = r - lb[b] + 1;\n            int t = max(a, b);\n            a = id[l] + 1, b = id[r] - 1;\n            if (a <= b) {\n                //查询id[l]+1区间到id[r]-1区间中的最大值\n                t = max(t, query(1, 1, n, a, b));\n            }\n            printf(\"%d\\n\", t);\n        }\n    }\n}\n```","slug":"UVA11235-Frequent-values（游程编码-线段树）","published":1,"updated":"2017-07-23T01:49:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nec0057y9id8m2n46xl","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/UVA-11235\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/UVA-11235</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个递增序列，询问一段区间内出现频率最多的数出现的次数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前图灵杯比赛的题，当时照着板子敲A的，现在突发奇想补一下题，感觉还是挺简单的，就是用到了游程编码。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于题目是有序的，那么可以很方便的将一段相同的数合为一个区间，<code>data[i]</code>表示第i段区间元素个数，<code>lb[i]</code>记录第<code>i</code>段区间的左边界，<code>rb[i]</code>记录第<code>i</code>段区间的右边界，用<code>id[i]</code>表示原序列的第i个数处于哪个区间。</p>\n<p>那么对于查询l到r的区间，如果<code>l</code>和<code>r</code>在同一段区间内，那么显然答案就是<code>r-l+1</code>。<br>如果l和r不在同一段区间，那么答案为以下三个中的最大值，<code>rb[id[l]] - l + 1</code>,<code>r - lb[id[r]] + 1</code>, <code>id[l]+1</code>区间到<code>id[r]-1</code>区间中的最大值`。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[o] = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[o] = max(tree[lson], tree[rson]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> max(query(lson, l, m, ql, qr), query(rson, m+<span class=\"number\">1</span>, r, ql, qr));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> raw_data[MAX], n, q, lb[MAX], rb[MAX], id[MAX], top;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    top = <span class=\"number\">1</span>;</div><div class=\"line\">    lb[top] = data[top] = id[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n+<span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (raw_data[i] != raw_data[i<span class=\"number\">-1</span>] || i == n+<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            rb[top++] = i<span class=\"number\">-1</span>;</div><div class=\"line\">            lb[top] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[top]++;</div><div class=\"line\">        id[i] = top;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\">    <span class=\"comment\">//freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, raw_data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        init();</div><div class=\"line\">        n = top<span class=\"number\">-1</span>;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">        <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;l, &amp;r);</div><div class=\"line\">            <span class=\"comment\">//如果l和r在同一个区间内</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (id[l] == id[r]) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r-l+<span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//l和r不在一个区间内</span></div><div class=\"line\">            <span class=\"keyword\">int</span> a = id[l], b = id[r];</div><div class=\"line\">            a = rb[a] - l + <span class=\"number\">1</span>;</div><div class=\"line\">            b = r - lb[b] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = max(a, b);</div><div class=\"line\">            a = id[l] + <span class=\"number\">1</span>, b = id[r] - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a &lt;= b) &#123;</div><div class=\"line\">                <span class=\"comment\">//查询id[l]+1区间到id[r]-1区间中的最大值</span></div><div class=\"line\">                t = max(t, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, a, b));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/UVA-11235\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/UVA-11235</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个递增序列，询问一段区间内出现频率最多的数出现的次数。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>之前图灵杯比赛的题，当时照着板子敲A的，现在突发奇想补一下题，感觉还是挺简单的，就是用到了游程编码。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>由于题目是有序的，那么可以很方便的将一段相同的数合为一个区间，<code>data[i]</code>表示第i段区间元素个数，<code>lb[i]</code>记录第<code>i</code>段区间的左边界，<code>rb[i]</code>记录第<code>i</code>段区间的右边界，用<code>id[i]</code>表示原序列的第i个数处于哪个区间。</p>\n<p>那么对于查询l到r的区间，如果<code>l</code>和<code>r</code>在同一段区间内，那么显然答案就是<code>r-l+1</code>。<br>如果l和r不在同一段区间，那么答案为以下三个中的最大值，<code>rb[id[l]] - l + 1</code>,<code>r - lb[id[r]] + 1</code>, <code>id[l]+1</code>区间到<code>id[r]-1</code>区间中的最大值`。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> tree[MAX&lt;&lt;<span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson o&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson o&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l+r)/2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[o] = data[l];</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[o] = max(tree[lson], tree[rson]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> o, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[o];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> max(query(lson, l, m, ql, qr), query(rson, m+<span class=\"number\">1</span>, r, ql, qr));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> raw_data[MAX], n, q, lb[MAX], rb[MAX], id[MAX], top;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    top = <span class=\"number\">1</span>;</div><div class=\"line\">    lb[top] = data[top] = id[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n+<span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (raw_data[i] != raw_data[i<span class=\"number\">-1</span>] || i == n+<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            rb[top++] = i<span class=\"number\">-1</span>;</div><div class=\"line\">            lb[top] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[top]++;</div><div class=\"line\">        id[i] = top;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\">    <span class=\"comment\">//freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;q);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, raw_data+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">        init();</div><div class=\"line\">        n = top<span class=\"number\">-1</span>;</div><div class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</div><div class=\"line\">        <span class=\"keyword\">int</span> l, r;</div><div class=\"line\">        <span class=\"keyword\">while</span> (q--) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;l, &amp;r);</div><div class=\"line\">            <span class=\"comment\">//如果l和r在同一个区间内</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (id[l] == id[r]) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r-l+<span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//l和r不在一个区间内</span></div><div class=\"line\">            <span class=\"keyword\">int</span> a = id[l], b = id[r];</div><div class=\"line\">            a = rb[a] - l + <span class=\"number\">1</span>;</div><div class=\"line\">            b = r - lb[b] + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t = max(a, b);</div><div class=\"line\">            a = id[l] + <span class=\"number\">1</span>, b = id[r] - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a &lt;= b) &#123;</div><div class=\"line\">                <span class=\"comment\">//查询id[l]+1区间到id[r]-1区间中的最大值</span></div><div class=\"line\">                t = max(t, query(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, a, b));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, t);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVA140 - Bandwidth （暴力dfs+排列+剪枝）","date":"2017-02-15T13:09:14.000Z","_content":"# 题目链接：\n--------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=76\n\n# 题目大意\n----------\n有一个图，有n个节点 (n < 8) ，讲这些节点排成一列。定义节点i的带宽为与相邻节点在排列中的最远距离，所有节点的带宽最大值为图的带宽。求将这些节点排列后，带宽最小的一种排列方式。\n\n# 解题过程：\n---------\n这个题写了两遍，之前一次，写了差不多一半了，不在状态，感觉又很烦，于是直接不想写了。今天网上状态很好，正好切换下了命名规范，以后还是以下划线分割好了，普通变量名和函数小写，类首字母大写。\n\n这里把这道题放上来，是因为 get 了新知识，**解答树的剪枝**，当一种情况已经预知到不符合条件的时候，就不需要继续 dfs 下去了，直接舍弃，相当于剪掉了解答树的一条分支。\n\n# 题目分析：\n---------------\n+ 先处理输入数据，这里自己写了两个辅助函数，用来处理输入数据和初始化一些变量。\n+ 这里选择用矩阵储存图，之前用邻接表感觉太麻烦了，因为直接添加的话，可能有重边。\n+ 然后是类似紫书上面全排列示例程序那样写的 dfs 函数，需要注意的是剪枝，和标记。\n\t+ 当一个节点还有m个相邻的节点未分配时，如果 m >= k (当前取得的最小带宽) 时就舍弃掉这种情况，因为就算后面 m 个节点和当前节点紧挨着，那么最小带宽也是 m ，题目要求是最小字典序的所以等于 k 的情况也舍掉。\n\t+ 另外如果一个节点的相邻节点已经分配了，如果这两个节点的距离大于等于 k 也舍弃掉，理由同上。\n\t+ 每次尝试后，都需要把标记撤回。\n# AC代码：\n------------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 30;\nbool edges[MAX][MAX];\nchar raw_data[1123];\nint node_num, book_num[MAX];\nint pos[MAX], ans[MAX], k;\n\nvoid put()\n{\n    char result[112];\n\n    for (int i = 0; i < MAX; i++)\n    {\n        if (ans[i] != -1)\n            result[ans[i]] = 'A'+i;\n    }\n\n    for (int i = 0; i < node_num; i++)\n        printf(\"%c \", result[i]);\n    printf(\"-> %d\\n\", k);\n}\n\n\nvoid add_edge(int l, int r)\n{\n    int u = raw_data[l] - 'A';\n\n    for (int i = l+2; i <= r; i++)\n    {\n        int v = raw_data[i] - 'A';\n        edges[u][v] = 1;\n        edges[v][u] = 1;\n    }\n}\n\nvoid analysis()\n{\n    node_num = 0, k = 9999;\n    memset(pos, -1, sizeof(pos));\n    memset(edges, 0, sizeof(edges));\n    memset(book_num, 0, sizeof(book_num));\n\n    int len = strlen(raw_data);\n\n    int head = 0;\n    for (int i = 0; i < len; i++)\n    {\n        if (isalpha(raw_data[i]) && book_num[raw_data[i]-'A'] == 0)\n        {\n            book_num[raw_data[i]-'A'] = 1;\n            node_num++;\n        }\n        if (i == len-1 || raw_data[i+1] == ';')\n        {\n            add_edge(head, i);\n            head = i+2;\n        }\n    }\n}\n\nvoid solve(int cur, int cnt)\n{\n    if (cur == node_num)\n    {\n        if (cnt < k)\n        {\n            for (int i = 0 ; i < MAX; i++)\n                ans[i] = pos[i];\n            k = cnt;\n            return;\n        }\n    }\n    else\n    {\n        for (int i = 0; i < MAX; i++)\n        {\n            if (!book_num[i] || pos[i] != -1)\n                continue;\n\n            pos[i] = cur;\n\n            int dis = 0, flag = 1;\n            for (int j = 0; j < MAX; j++)\n            {\n                if (edges[i][j])\n                {\n                    if (pos[j] == -1)\n                        dis++;\n                    else if (cur - pos[j] >= k)\n                    {\n                        flag = 0;\n                        break;\n                    }\n                    else\n                        cnt = max(cnt, cur - pos[j]);\n                }\n            }\n\n            if (dis >= k)\n                flag = 0;\n\n            if (flag)\n                solve(cur+1, cnt);\n\n            pos[i] = -1;\n        }\n    }\n}\n\n\n\nint main()\n{\n    while (cin >> raw_data && raw_data[0] != '#')\n    {\n        analysis();\n        solve(0, 0);\n        put();\n    }\n}\n\n```\n\n# 小结：\n-------------------\n感觉有时候状态真的挺重要的，没状态的时候，写的很长，而且很乱。有状态的时候，写的很长，但是写的很爽，各种函数，功能分离开来，单独调试。这题看着很麻烦，写起来也很麻烦，但是这次状态很好，然后写起来顺心的话，细节也不容易出bug，写出来过了样例就一次AC了。感觉好玄学的样子。","source":"_posts/UVA140-Bandwidth-（暴力dfs-排列-剪枝）.md","raw":"---\ntitle: UVA140 - Bandwidth （暴力dfs+排列+剪枝）\ndate: 2017-02-15 21:09:14\ncategories: [ACM, 搜索]\ntags:\n---\n# 题目链接：\n--------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=76\n\n# 题目大意\n----------\n有一个图，有n个节点 (n < 8) ，讲这些节点排成一列。定义节点i的带宽为与相邻节点在排列中的最远距离，所有节点的带宽最大值为图的带宽。求将这些节点排列后，带宽最小的一种排列方式。\n\n# 解题过程：\n---------\n这个题写了两遍，之前一次，写了差不多一半了，不在状态，感觉又很烦，于是直接不想写了。今天网上状态很好，正好切换下了命名规范，以后还是以下划线分割好了，普通变量名和函数小写，类首字母大写。\n\n这里把这道题放上来，是因为 get 了新知识，**解答树的剪枝**，当一种情况已经预知到不符合条件的时候，就不需要继续 dfs 下去了，直接舍弃，相当于剪掉了解答树的一条分支。\n\n# 题目分析：\n---------------\n+ 先处理输入数据，这里自己写了两个辅助函数，用来处理输入数据和初始化一些变量。\n+ 这里选择用矩阵储存图，之前用邻接表感觉太麻烦了，因为直接添加的话，可能有重边。\n+ 然后是类似紫书上面全排列示例程序那样写的 dfs 函数，需要注意的是剪枝，和标记。\n\t+ 当一个节点还有m个相邻的节点未分配时，如果 m >= k (当前取得的最小带宽) 时就舍弃掉这种情况，因为就算后面 m 个节点和当前节点紧挨着，那么最小带宽也是 m ，题目要求是最小字典序的所以等于 k 的情况也舍掉。\n\t+ 另外如果一个节点的相邻节点已经分配了，如果这两个节点的距离大于等于 k 也舍弃掉，理由同上。\n\t+ 每次尝试后，都需要把标记撤回。\n# AC代码：\n------------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 30;\nbool edges[MAX][MAX];\nchar raw_data[1123];\nint node_num, book_num[MAX];\nint pos[MAX], ans[MAX], k;\n\nvoid put()\n{\n    char result[112];\n\n    for (int i = 0; i < MAX; i++)\n    {\n        if (ans[i] != -1)\n            result[ans[i]] = 'A'+i;\n    }\n\n    for (int i = 0; i < node_num; i++)\n        printf(\"%c \", result[i]);\n    printf(\"-> %d\\n\", k);\n}\n\n\nvoid add_edge(int l, int r)\n{\n    int u = raw_data[l] - 'A';\n\n    for (int i = l+2; i <= r; i++)\n    {\n        int v = raw_data[i] - 'A';\n        edges[u][v] = 1;\n        edges[v][u] = 1;\n    }\n}\n\nvoid analysis()\n{\n    node_num = 0, k = 9999;\n    memset(pos, -1, sizeof(pos));\n    memset(edges, 0, sizeof(edges));\n    memset(book_num, 0, sizeof(book_num));\n\n    int len = strlen(raw_data);\n\n    int head = 0;\n    for (int i = 0; i < len; i++)\n    {\n        if (isalpha(raw_data[i]) && book_num[raw_data[i]-'A'] == 0)\n        {\n            book_num[raw_data[i]-'A'] = 1;\n            node_num++;\n        }\n        if (i == len-1 || raw_data[i+1] == ';')\n        {\n            add_edge(head, i);\n            head = i+2;\n        }\n    }\n}\n\nvoid solve(int cur, int cnt)\n{\n    if (cur == node_num)\n    {\n        if (cnt < k)\n        {\n            for (int i = 0 ; i < MAX; i++)\n                ans[i] = pos[i];\n            k = cnt;\n            return;\n        }\n    }\n    else\n    {\n        for (int i = 0; i < MAX; i++)\n        {\n            if (!book_num[i] || pos[i] != -1)\n                continue;\n\n            pos[i] = cur;\n\n            int dis = 0, flag = 1;\n            for (int j = 0; j < MAX; j++)\n            {\n                if (edges[i][j])\n                {\n                    if (pos[j] == -1)\n                        dis++;\n                    else if (cur - pos[j] >= k)\n                    {\n                        flag = 0;\n                        break;\n                    }\n                    else\n                        cnt = max(cnt, cur - pos[j]);\n                }\n            }\n\n            if (dis >= k)\n                flag = 0;\n\n            if (flag)\n                solve(cur+1, cnt);\n\n            pos[i] = -1;\n        }\n    }\n}\n\n\n\nint main()\n{\n    while (cin >> raw_data && raw_data[0] != '#')\n    {\n        analysis();\n        solve(0, 0);\n        put();\n    }\n}\n\n```\n\n# 小结：\n-------------------\n感觉有时候状态真的挺重要的，没状态的时候，写的很长，而且很乱。有状态的时候，写的很长，但是写的很爽，各种函数，功能分离开来，单独调试。这题看着很麻烦，写起来也很麻烦，但是这次状态很好，然后写起来顺心的话，细节也不容易出bug，写出来过了样例就一次AC了。感觉好玄学的样子。","slug":"UVA140-Bandwidth-（暴力dfs-排列-剪枝）","published":1,"updated":"2017-07-23T03:38:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ned0059y9ids5n7fm7s","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=76\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=76</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有一个图，有n个节点 (n &lt; 8) ，讲这些节点排成一列。定义节点i的带宽为与相邻节点在排列中的最远距离，所有节点的带宽最大值为图的带宽。求将这些节点排列后，带宽最小的一种排列方式。</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><hr>\n<p>这个题写了两遍，之前一次，写了差不多一半了，不在状态，感觉又很烦，于是直接不想写了。今天网上状态很好，正好切换下了命名规范，以后还是以下划线分割好了，普通变量名和函数小写，类首字母大写。</p>\n<p>这里把这道题放上来，是因为 get 了新知识，<strong>解答树的剪枝</strong>，当一种情况已经预知到不符合条件的时候，就不需要继续 dfs 下去了，直接舍弃，相当于剪掉了解答树的一条分支。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>先处理输入数据，这里自己写了两个辅助函数，用来处理输入数据和初始化一些变量。</li>\n<li>这里选择用矩阵储存图，之前用邻接表感觉太麻烦了，因为直接添加的话，可能有重边。</li>\n<li>然后是类似紫书上面全排列示例程序那样写的 dfs 函数，需要注意的是剪枝，和标记。<ul>\n<li>当一个节点还有m个相邻的节点未分配时，如果 m &gt;= k (当前取得的最小带宽) 时就舍弃掉这种情况，因为就算后面 m 个节点和当前节点紧挨着，那么最小带宽也是 m ，题目要求是最小字典序的所以等于 k 的情况也舍掉。</li>\n<li>另外如果一个节点的相邻节点已经分配了，如果这两个节点的距离大于等于 k 也舍弃掉，理由同上。</li>\n<li>每次尝试后，都需要把标记撤回。<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1></li>\n</ul>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">30</span>;</div><div class=\"line\"><span class=\"keyword\">bool</span> edges[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">char</span> raw_data[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> node_num, book_num[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> pos[MAX], ans[MAX], k;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> result[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[i] != <span class=\"number\">-1</span>)</div><div class=\"line\">            result[ans[i]] = <span class=\"string\">'A'</span>+i;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; node_num; i++)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>, result[i]);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"-&gt; %d\\n\"</span>, k);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> u = raw_data[l] - <span class=\"string\">'A'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l+<span class=\"number\">2</span>; i &lt;= r; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = raw_data[i] - <span class=\"string\">'A'</span>;</div><div class=\"line\">        edges[u][v] = <span class=\"number\">1</span>;</div><div class=\"line\">        edges[v][u] = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">analysis</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    node_num = <span class=\"number\">0</span>, k = <span class=\"number\">9999</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pos, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(pos));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(edges, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edges));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(book_num, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book_num));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(raw_data);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> head = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isalpha</span>(raw_data[i]) &amp;&amp; book_num[raw_data[i]-<span class=\"string\">'A'</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            book_num[raw_data[i]-<span class=\"string\">'A'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            node_num++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i == len<span class=\"number\">-1</span> || raw_data[i+<span class=\"number\">1</span>] == <span class=\"string\">';'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            add_edge(head, i);</div><div class=\"line\">            head = i+<span class=\"number\">2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span> cnt)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur == node_num)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cnt &lt; k)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; MAX; i++)</div><div class=\"line\">                ans[i] = pos[i];</div><div class=\"line\">            k = cnt;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!book_num[i] || pos[i] != <span class=\"number\">-1</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            pos[i] = cur;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> dis = <span class=\"number\">0</span>, flag = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; MAX; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (edges[i][j])</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (pos[j] == <span class=\"number\">-1</span>)</div><div class=\"line\">                        dis++;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur - pos[j] &gt;= k)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        flag = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        cnt = max(cnt, cur - pos[j]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (dis &gt;= k)</div><div class=\"line\">                flag = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">                solve(cur+<span class=\"number\">1</span>, cnt);</div><div class=\"line\"></div><div class=\"line\">            pos[i] = <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; raw_data &amp;&amp; raw_data[<span class=\"number\">0</span>] != <span class=\"string\">'#'</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        analysis();</div><div class=\"line\">        solve(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h1><hr>\n<p>感觉有时候状态真的挺重要的，没状态的时候，写的很长，而且很乱。有状态的时候，写的很长，但是写的很爽，各种函数，功能分离开来，单独调试。这题看着很麻烦，写起来也很麻烦，但是这次状态很好，然后写起来顺心的话，细节也不容易出bug，写出来过了样例就一次AC了。感觉好玄学的样子。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=76\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=76</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>有一个图，有n个节点 (n &lt; 8) ，讲这些节点排成一列。定义节点i的带宽为与相邻节点在排列中的最远距离，所有节点的带宽最大值为图的带宽。求将这些节点排列后，带宽最小的一种排列方式。</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><hr>\n<p>这个题写了两遍，之前一次，写了差不多一半了，不在状态，感觉又很烦，于是直接不想写了。今天网上状态很好，正好切换下了命名规范，以后还是以下划线分割好了，普通变量名和函数小写，类首字母大写。</p>\n<p>这里把这道题放上来，是因为 get 了新知识，<strong>解答树的剪枝</strong>，当一种情况已经预知到不符合条件的时候，就不需要继续 dfs 下去了，直接舍弃，相当于剪掉了解答树的一条分支。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>先处理输入数据，这里自己写了两个辅助函数，用来处理输入数据和初始化一些变量。</li>\n<li>这里选择用矩阵储存图，之前用邻接表感觉太麻烦了，因为直接添加的话，可能有重边。</li>\n<li>然后是类似紫书上面全排列示例程序那样写的 dfs 函数，需要注意的是剪枝，和标记。<ul>\n<li>当一个节点还有m个相邻的节点未分配时，如果 m &gt;= k (当前取得的最小带宽) 时就舍弃掉这种情况，因为就算后面 m 个节点和当前节点紧挨着，那么最小带宽也是 m ，题目要求是最小字典序的所以等于 k 的情况也舍掉。</li>\n<li>另外如果一个节点的相邻节点已经分配了，如果这两个节点的距离大于等于 k 也舍弃掉，理由同上。</li>\n<li>每次尝试后，都需要把标记撤回。<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1></li>\n</ul>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">30</span>;</div><div class=\"line\"><span class=\"keyword\">bool</span> edges[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">char</span> raw_data[<span class=\"number\">1123</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> node_num, book_num[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> pos[MAX], ans[MAX], k;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> result[<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans[i] != <span class=\"number\">-1</span>)</div><div class=\"line\">            result[ans[i]] = <span class=\"string\">'A'</span>+i;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; node_num; i++)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>, result[i]);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"-&gt; %d\\n\"</span>, k);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> u = raw_data[l] - <span class=\"string\">'A'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l+<span class=\"number\">2</span>; i &lt;= r; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = raw_data[i] - <span class=\"string\">'A'</span>;</div><div class=\"line\">        edges[u][v] = <span class=\"number\">1</span>;</div><div class=\"line\">        edges[v][u] = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">analysis</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    node_num = <span class=\"number\">0</span>, k = <span class=\"number\">9999</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(pos, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(pos));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(edges, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(edges));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(book_num, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book_num));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(raw_data);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> head = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isalpha</span>(raw_data[i]) &amp;&amp; book_num[raw_data[i]-<span class=\"string\">'A'</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            book_num[raw_data[i]-<span class=\"string\">'A'</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">            node_num++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (i == len<span class=\"number\">-1</span> || raw_data[i+<span class=\"number\">1</span>] == <span class=\"string\">';'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            add_edge(head, i);</div><div class=\"line\">            head = i+<span class=\"number\">2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span> cnt)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (cur == node_num)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cnt &lt; k)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; MAX; i++)</div><div class=\"line\">                ans[i] = pos[i];</div><div class=\"line\">            k = cnt;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!book_num[i] || pos[i] != <span class=\"number\">-1</span>)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            pos[i] = cur;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> dis = <span class=\"number\">0</span>, flag = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; MAX; j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (edges[i][j])</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (pos[j] == <span class=\"number\">-1</span>)</div><div class=\"line\">                        dis++;</div><div class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur - pos[j] &gt;= k)</div><div class=\"line\">                    &#123;</div><div class=\"line\">                        flag = <span class=\"number\">0</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        cnt = max(cnt, cur - pos[j]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (dis &gt;= k)</div><div class=\"line\">                flag = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (flag)</div><div class=\"line\">                solve(cur+<span class=\"number\">1</span>, cnt);</div><div class=\"line\"></div><div class=\"line\">            pos[i] = <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; raw_data &amp;&amp; raw_data[<span class=\"number\">0</span>] != <span class=\"string\">'#'</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        analysis();</div><div class=\"line\">        solve(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h1><hr>\n<p>感觉有时候状态真的挺重要的，没状态的时候，写的很长，而且很乱。有状态的时候，写的很长，但是写的很爽，各种函数，功能分离开来，单独调试。这题看着很麻烦，写起来也很麻烦，但是这次状态很好，然后写起来顺心的话，细节也不容易出bug，写出来过了样例就一次AC了。感觉好玄学的样子。</p>\n"},{"title":"UVA506 System Dependencies（模拟）","date":"2017-02-07T11:00:11.000Z","_content":"# 题目链接：\nhttps://vjudge.net/problem/31990/origin\n\n\n----------\n# 题目大意：\n模拟安装软件，分显式好隐式安装两种情况。安装一个软件的时候，指明安装的就是显式安装。\n比如：\n\n> INSTALL    A \n\n这里A是显示安装，如果A必须要B和C软件的支持的话，顺便安装上B和C，这里B和C就是隐式安装上的。\n\n然后是删除软件，删除的时候以递归的形式删除，先删除指明安装的软件，然后删除这个软件的支持软件，但是如果支持软件是显式安装上的话，就不删除了。\n\n> INSTALL   B\n> INSTALL   A\n> REMOVE   A \n\n\n这里的B就不会被删除，安装A时同时安装的C会被删除掉。此外如果A的支持软件是另一个软件的支持软件的话，也不会被删除掉。\n\n\n----------\n# 解题过程：\n题目本身不难，有是一个复杂的模拟题，书上给了些提示和代码，对比着，写出来不难。\n需要映射下软件的名字，这里用到了之前 UVA-12096 里面的映射方法。\n\n----------\n# 题目分析：\n先把字符串名称用MAP映射成整数，容易处理些。\n安装和删除的函数，注意递归处理。\n把depend的输入分离的时候使用stringstream处理。\n\n题目不难，不过用到了好多有用的方法，这里Mark下。\n\n----------\n# AC代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112345;\n\nmap<string, int> nameList;\nvector<string> getName, nameTable;\nstring str;\nvector<int> depend1[MAX], depend2[MAX];\nint status[MAX];\nstring blank = \"   \";\n\nint ID(string name)\n{\n    if (nameList.count(name))\n        return nameList[name];\n\n    getName.push_back(name);\n    return nameList[name] = getName.size()-1;\n}\n\nvoid depend()\n{\n    stringstream ss;\n    string item_name;\n    int item1, item2;\n    ss << str;\n    ss >> item_name;\n\n    ss >> item_name;\n    item1 = ID(item_name);\n\n    while (ss >> item_name)\n    {\n        item2 = ID(item_name);\n        depend1[item1].push_back(item2);\n        depend2[item2].push_back(item1);\n    }\n}\n\nvoid install(int item, bool topLevel)\n{\n    if (!status[item])\n    {\n        for (int i = 0; i < depend1[item].size(); i++)\n            install(depend1[item][i], false);\n\n        string item_name = getName[item];\n        cout << blank << \"Installing \" << item_name << endl;\n        nameTable.push_back(item_name);\n        status[item] = topLevel? 1:2;\n    }\n    else if (topLevel)\n        cout << blank << getName[item] << \" is already installed.\" << endl;\n}\n\nvoid list_()\n{\n    for (int i = 0; i < nameTable.size(); i++)\n        cout << blank << nameTable[i] << endl;\n}\n\nbool needed(int item)\n{\n    for (int i = 0; i < depend2[item].size(); i++)\n        if (status[depend2[item][i]])\n            return true;\n    return false;\n}\n\nvoid remove_(int item, bool topLevel)\n{\n    string item_name = getName[item];\n    if (status[item] == 0 && topLevel)\n    {\n        cout << blank << item_name << \" is not installed.\" << endl;\n        return;\n    }\n\n    if (!needed(item) && (status[item] == 2 || topLevel))\n    {\n        status[item] = 0;\n        for (int i = 0; i < nameTable.size(); i++)\n        {\n            if (nameTable[i] == item_name)\n            {\n                nameTable.erase(nameTable.begin()+i);\n                break;\n            }\n        }\n        cout << blank << \"Removing \" << item_name << endl;\n\n        for (int i = 0; i < depend1[item].size(); i++)\n            remove_(depend1[item][i], false);\n    }\n    else if (topLevel)\n        cout << blank << item_name << \" is still needed.\" << endl;\n}\n\nint main()\n{\n//    freopen(\"in\",\"r\",stdin);\n    while(getline(cin, str))\n    {\n        cout << str << endl;\n        if (str[0] == 'D')\n        {\n            depend();\n        }\n\n        if (str[0] == 'I')\n        {\n            stringstream ss;\n            ss << str;\n            string item_name;\n            ss >> item_name;\n            ss >> item_name;\n\n            int item = ID(item_name);\n\n            install(item, true);\n        }\n\n        if (str[0] == 'E')\n        {\n            break;\n        }\n\n        if (str[0] == 'R')\n        {\n            stringstream ss;\n            ss << str;\n            string item_name;\n            ss >> item_name;\n            ss >> item_name;\n\n            int item = ID(item_name);\n\n            remove_(item, true);\n        }\n\n        if (str[0] == 'L')\n        {\n            list_();\n        }\n    }\n}\n\n```","source":"_posts/UVA506-System-Dependencies（模拟）.md","raw":"---\ntitle: UVA506 System Dependencies（模拟）\ndate: 2017-02-07 19:00:11\ncategories: [ACM, 模拟]\ntags:\n---\n# 题目链接：\nhttps://vjudge.net/problem/31990/origin\n\n\n----------\n# 题目大意：\n模拟安装软件，分显式好隐式安装两种情况。安装一个软件的时候，指明安装的就是显式安装。\n比如：\n\n> INSTALL    A \n\n这里A是显示安装，如果A必须要B和C软件的支持的话，顺便安装上B和C，这里B和C就是隐式安装上的。\n\n然后是删除软件，删除的时候以递归的形式删除，先删除指明安装的软件，然后删除这个软件的支持软件，但是如果支持软件是显式安装上的话，就不删除了。\n\n> INSTALL   B\n> INSTALL   A\n> REMOVE   A \n\n\n这里的B就不会被删除，安装A时同时安装的C会被删除掉。此外如果A的支持软件是另一个软件的支持软件的话，也不会被删除掉。\n\n\n----------\n# 解题过程：\n题目本身不难，有是一个复杂的模拟题，书上给了些提示和代码，对比着，写出来不难。\n需要映射下软件的名字，这里用到了之前 UVA-12096 里面的映射方法。\n\n----------\n# 题目分析：\n先把字符串名称用MAP映射成整数，容易处理些。\n安装和删除的函数，注意递归处理。\n把depend的输入分离的时候使用stringstream处理。\n\n题目不难，不过用到了好多有用的方法，这里Mark下。\n\n----------\n# AC代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112345;\n\nmap<string, int> nameList;\nvector<string> getName, nameTable;\nstring str;\nvector<int> depend1[MAX], depend2[MAX];\nint status[MAX];\nstring blank = \"   \";\n\nint ID(string name)\n{\n    if (nameList.count(name))\n        return nameList[name];\n\n    getName.push_back(name);\n    return nameList[name] = getName.size()-1;\n}\n\nvoid depend()\n{\n    stringstream ss;\n    string item_name;\n    int item1, item2;\n    ss << str;\n    ss >> item_name;\n\n    ss >> item_name;\n    item1 = ID(item_name);\n\n    while (ss >> item_name)\n    {\n        item2 = ID(item_name);\n        depend1[item1].push_back(item2);\n        depend2[item2].push_back(item1);\n    }\n}\n\nvoid install(int item, bool topLevel)\n{\n    if (!status[item])\n    {\n        for (int i = 0; i < depend1[item].size(); i++)\n            install(depend1[item][i], false);\n\n        string item_name = getName[item];\n        cout << blank << \"Installing \" << item_name << endl;\n        nameTable.push_back(item_name);\n        status[item] = topLevel? 1:2;\n    }\n    else if (topLevel)\n        cout << blank << getName[item] << \" is already installed.\" << endl;\n}\n\nvoid list_()\n{\n    for (int i = 0; i < nameTable.size(); i++)\n        cout << blank << nameTable[i] << endl;\n}\n\nbool needed(int item)\n{\n    for (int i = 0; i < depend2[item].size(); i++)\n        if (status[depend2[item][i]])\n            return true;\n    return false;\n}\n\nvoid remove_(int item, bool topLevel)\n{\n    string item_name = getName[item];\n    if (status[item] == 0 && topLevel)\n    {\n        cout << blank << item_name << \" is not installed.\" << endl;\n        return;\n    }\n\n    if (!needed(item) && (status[item] == 2 || topLevel))\n    {\n        status[item] = 0;\n        for (int i = 0; i < nameTable.size(); i++)\n        {\n            if (nameTable[i] == item_name)\n            {\n                nameTable.erase(nameTable.begin()+i);\n                break;\n            }\n        }\n        cout << blank << \"Removing \" << item_name << endl;\n\n        for (int i = 0; i < depend1[item].size(); i++)\n            remove_(depend1[item][i], false);\n    }\n    else if (topLevel)\n        cout << blank << item_name << \" is still needed.\" << endl;\n}\n\nint main()\n{\n//    freopen(\"in\",\"r\",stdin);\n    while(getline(cin, str))\n    {\n        cout << str << endl;\n        if (str[0] == 'D')\n        {\n            depend();\n        }\n\n        if (str[0] == 'I')\n        {\n            stringstream ss;\n            ss << str;\n            string item_name;\n            ss >> item_name;\n            ss >> item_name;\n\n            int item = ID(item_name);\n\n            install(item, true);\n        }\n\n        if (str[0] == 'E')\n        {\n            break;\n        }\n\n        if (str[0] == 'R')\n        {\n            stringstream ss;\n            ss << str;\n            string item_name;\n            ss >> item_name;\n            ss >> item_name;\n\n            int item = ID(item_name);\n\n            remove_(item, true);\n        }\n\n        if (str[0] == 'L')\n        {\n            list_();\n        }\n    }\n}\n\n```","slug":"UVA506-System-Dependencies（模拟）","published":1,"updated":"2017-07-23T03:46:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nef005cy9id23k6w2sf","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/31990/origin\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/31990/origin</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>模拟安装软件，分显式好隐式安装两种情况。安装一个软件的时候，指明安装的就是显式安装。<br>比如：</p>\n<blockquote>\n<p>INSTALL    A </p>\n</blockquote>\n<p>这里A是显示安装，如果A必须要B和C软件的支持的话，顺便安装上B和C，这里B和C就是隐式安装上的。</p>\n<p>然后是删除软件，删除的时候以递归的形式删除，先删除指明安装的软件，然后删除这个软件的支持软件，但是如果支持软件是显式安装上的话，就不删除了。</p>\n<blockquote>\n<p>INSTALL   B<br>INSTALL   A<br>REMOVE   A </p>\n</blockquote>\n<p>这里的B就不会被删除，安装A时同时安装的C会被删除掉。此外如果A的支持软件是另一个软件的支持软件的话，也不会被删除掉。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>题目本身不难，有是一个复杂的模拟题，书上给了些提示和代码，对比着，写出来不难。<br>需要映射下软件的名字，这里用到了之前 UVA-12096 里面的映射方法。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先把字符串名称用MAP映射成整数，容易处理些。<br>安装和删除的函数，注意递归处理。<br>把depend的输入分离的时候使用stringstream处理。</p>\n<p>题目不难，不过用到了好多有用的方法，这里Mark下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; nameList;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; getName, nameTable;</div><div class=\"line\"><span class=\"built_in\">string</span> str;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; depend1[MAX], depend2[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> status[MAX];</div><div class=\"line\"><span class=\"built_in\">string</span> blank = <span class=\"string\">\"   \"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nameList.count(name))</div><div class=\"line\">        <span class=\"keyword\">return</span> nameList[name];</div><div class=\"line\"></div><div class=\"line\">    getName.push_back(name);</div><div class=\"line\">    <span class=\"keyword\">return</span> nameList[name] = getName.size()<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">depend</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">    <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">    <span class=\"keyword\">int</span> item1, item2;</div><div class=\"line\">    ss &lt;&lt; str;</div><div class=\"line\">    ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">    ss &gt;&gt; item_name;</div><div class=\"line\">    item1 = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (ss &gt;&gt; item_name)</div><div class=\"line\">    &#123;</div><div class=\"line\">        item2 = ID(item_name);</div><div class=\"line\">        depend1[item1].push_back(item2);</div><div class=\"line\">        depend2[item2].push_back(item1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(<span class=\"keyword\">int</span> item, <span class=\"keyword\">bool</span> topLevel)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!status[item])</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend1[item].size(); i++)</div><div class=\"line\">            install(depend1[item][i], <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">string</span> item_name = getName[item];</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; <span class=\"string\">\"Installing \"</span> &lt;&lt; item_name &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        nameTable.push_back(item_name);</div><div class=\"line\">        status[item] = topLevel? <span class=\"number\">1</span>:<span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (topLevel)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; getName[item] &lt;&lt; <span class=\"string\">\" is already installed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">list_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nameTable.size(); i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; nameTable[i] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">needed</span><span class=\"params\">(<span class=\"keyword\">int</span> item)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend2[item].size(); i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (status[depend2[item][i]])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove_</span><span class=\"params\">(<span class=\"keyword\">int</span> item, <span class=\"keyword\">bool</span> topLevel)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> item_name = getName[item];</div><div class=\"line\">    <span class=\"keyword\">if</span> (status[item] == <span class=\"number\">0</span> &amp;&amp; topLevel)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; item_name &lt;&lt; <span class=\"string\">\" is not installed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!needed(item) &amp;&amp; (status[item] == <span class=\"number\">2</span> || topLevel))</div><div class=\"line\">    &#123;</div><div class=\"line\">        status[item] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nameTable.size(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (nameTable[i] == item_name)</div><div class=\"line\">            &#123;</div><div class=\"line\">                nameTable.erase(nameTable.begin()+i);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; <span class=\"string\">\"Removing \"</span> &lt;&lt; item_name &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend1[item].size(); i++)</div><div class=\"line\">            remove_(depend1[item][i], <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (topLevel)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; item_name &lt;&lt; <span class=\"string\">\" is still needed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\",\"r\",stdin);</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>, str))</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            depend();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">            ss &lt;&lt; str;</div><div class=\"line\">            <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> item = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">            install(item, <span class=\"literal\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'E'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'R'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">            ss &lt;&lt; str;</div><div class=\"line\">            <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> item = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">            remove_(item, <span class=\"literal\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'L'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            list_();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://vjudge.net/problem/31990/origin\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/31990/origin</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>模拟安装软件，分显式好隐式安装两种情况。安装一个软件的时候，指明安装的就是显式安装。<br>比如：</p>\n<blockquote>\n<p>INSTALL    A </p>\n</blockquote>\n<p>这里A是显示安装，如果A必须要B和C软件的支持的话，顺便安装上B和C，这里B和C就是隐式安装上的。</p>\n<p>然后是删除软件，删除的时候以递归的形式删除，先删除指明安装的软件，然后删除这个软件的支持软件，但是如果支持软件是显式安装上的话，就不删除了。</p>\n<blockquote>\n<p>INSTALL   B<br>INSTALL   A<br>REMOVE   A </p>\n</blockquote>\n<p>这里的B就不会被删除，安装A时同时安装的C会被删除掉。此外如果A的支持软件是另一个软件的支持软件的话，也不会被删除掉。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>题目本身不难，有是一个复杂的模拟题，书上给了些提示和代码，对比着，写出来不难。<br>需要映射下软件的名字，这里用到了之前 UVA-12096 里面的映射方法。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>先把字符串名称用MAP映射成整数，容易处理些。<br>安装和删除的函数，注意递归处理。<br>把depend的输入分离的时候使用stringstream处理。</p>\n<p>题目不难，不过用到了好多有用的方法，这里Mark下。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; nameList;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; getName, nameTable;</div><div class=\"line\"><span class=\"built_in\">string</span> str;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; depend1[MAX], depend2[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> status[MAX];</div><div class=\"line\"><span class=\"built_in\">string</span> blank = <span class=\"string\">\"   \"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nameList.count(name))</div><div class=\"line\">        <span class=\"keyword\">return</span> nameList[name];</div><div class=\"line\"></div><div class=\"line\">    getName.push_back(name);</div><div class=\"line\">    <span class=\"keyword\">return</span> nameList[name] = getName.size()<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">depend</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">    <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">    <span class=\"keyword\">int</span> item1, item2;</div><div class=\"line\">    ss &lt;&lt; str;</div><div class=\"line\">    ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">    ss &gt;&gt; item_name;</div><div class=\"line\">    item1 = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (ss &gt;&gt; item_name)</div><div class=\"line\">    &#123;</div><div class=\"line\">        item2 = ID(item_name);</div><div class=\"line\">        depend1[item1].push_back(item2);</div><div class=\"line\">        depend2[item2].push_back(item1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(<span class=\"keyword\">int</span> item, <span class=\"keyword\">bool</span> topLevel)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!status[item])</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend1[item].size(); i++)</div><div class=\"line\">            install(depend1[item][i], <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">string</span> item_name = getName[item];</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; <span class=\"string\">\"Installing \"</span> &lt;&lt; item_name &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        nameTable.push_back(item_name);</div><div class=\"line\">        status[item] = topLevel? <span class=\"number\">1</span>:<span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (topLevel)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; getName[item] &lt;&lt; <span class=\"string\">\" is already installed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">list_</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nameTable.size(); i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; nameTable[i] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">needed</span><span class=\"params\">(<span class=\"keyword\">int</span> item)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend2[item].size(); i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (status[depend2[item][i]])</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove_</span><span class=\"params\">(<span class=\"keyword\">int</span> item, <span class=\"keyword\">bool</span> topLevel)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> item_name = getName[item];</div><div class=\"line\">    <span class=\"keyword\">if</span> (status[item] == <span class=\"number\">0</span> &amp;&amp; topLevel)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; item_name &lt;&lt; <span class=\"string\">\" is not installed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!needed(item) &amp;&amp; (status[item] == <span class=\"number\">2</span> || topLevel))</div><div class=\"line\">    &#123;</div><div class=\"line\">        status[item] = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nameTable.size(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (nameTable[i] == item_name)</div><div class=\"line\">            &#123;</div><div class=\"line\">                nameTable.erase(nameTable.begin()+i);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; <span class=\"string\">\"Removing \"</span> &lt;&lt; item_name &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; depend1[item].size(); i++)</div><div class=\"line\">            remove_(depend1[item][i], <span class=\"literal\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (topLevel)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; blank &lt;&lt; item_name &lt;&lt; <span class=\"string\">\" is still needed.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\",\"r\",stdin);</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>, str))</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            depend();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">            ss &lt;&lt; str;</div><div class=\"line\">            <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> item = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">            install(item, <span class=\"literal\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'E'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'R'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</div><div class=\"line\">            ss &lt;&lt; str;</div><div class=\"line\">            <span class=\"built_in\">string</span> item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\">            ss &gt;&gt; item_name;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> item = ID(item_name);</div><div class=\"line\"></div><div class=\"line\">            remove_(item, <span class=\"literal\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (str[<span class=\"number\">0</span>] == <span class=\"string\">'L'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            list_();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVa 11426 - GCD - Extreme (II)","date":"2017-07-25T00:13:04.000Z","_content":"# 题目大意：\n\n输入$N$对公式$ \\sum ^{n-1} \\_{i=1} \\sum ^{n} \\_{j=i+1} GCD(i, j) $求和。\n\n-------------------\n# 解题过程：\n\n一开始就没思路，然后去翻博客，才发现欧拉函数还可以这么用！\n\n-----------------------\n# 题目分析：\n\n首先对内外两层循环交换下：\n\n$\\sum^{N-1}\\_{i=1} \\sum^{N}\\_{j=i+1} GCD(i, j) = \\sum^{n}\\_{j=2}\\sum^{j-1}\\_{i=1}GCD(i,j)$\n\n然后我们把内层循环拆出来，其实就是$f(n) = \\sum^{n-1}_{i=1}GCD(i, n)$这样问题就是如何对这个函数求和了。\n\n这时候，如果对每个数都分别跑一个循环肯定是超时，那么我们枚举每个数的因素，并且用素数筛的思想。\n\n首先，记$g(i, n)$ 为满足 $gcd(x, n) = i(i \\le x < n)$的$x$个数，那么对于每个数$f(n) = \\sum g(i, n) \\cdot i$。如何对于$gcd(x, n) = i$两边同时除去$i$，$gcd(x/i, n/i) = 1$，即$g(i, n) = \\phi(n/i)$。\n\n--------------------------\n# AC代码:\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 4000001 + 10;\n\nint phi[MAX];\nll ans[MAX];\n\n//欧拉函数打表\nvoid phi_table(int n) {\n    memset(phi, 0, sizeof(phi));\n    phi[1] = 1;\n    for (int i = 2; i < n; i++) if (!phi[i])\n            for (int j = i; j <= n; j += i) {\n                if (!phi[j]) phi[j] = j;\n                phi[j] = phi[j] / i * (i - 1);\n            }\n}\n\nvoid init() {\n    //枚举每个数的因数\n    for (int i = 1; i < MAX; i++) {\n        for (int j = i + i; j < MAX; j += i) {\n            //这里求的是f(j)的其中一个因子\n            ans[j] += (ll)i * phi[j / i];\n        }\n    }\n    for (int i = 2; i < MAX; i++) {\n        ans[i] += ans[i-1];\n    }\n}\n\nint main() {\n    phi_table(MAX);\n    init();\n    int n;\n    while (cin >> n && n) {\n        cout << ans[n] << endl;\n    }\n}\n```","source":"_posts/UVa-11426-GCD-Extreme-II.md","raw":"---\ntitle: UVa 11426 - GCD - Extreme (II)\ndate: 2017-07-25 08:13:04\ncategories: [ACM, 数学, 数论]\ntags:\n---\n# 题目大意：\n\n输入$N$对公式$ \\sum ^{n-1} \\_{i=1} \\sum ^{n} \\_{j=i+1} GCD(i, j) $求和。\n\n-------------------\n# 解题过程：\n\n一开始就没思路，然后去翻博客，才发现欧拉函数还可以这么用！\n\n-----------------------\n# 题目分析：\n\n首先对内外两层循环交换下：\n\n$\\sum^{N-1}\\_{i=1} \\sum^{N}\\_{j=i+1} GCD(i, j) = \\sum^{n}\\_{j=2}\\sum^{j-1}\\_{i=1}GCD(i,j)$\n\n然后我们把内层循环拆出来，其实就是$f(n) = \\sum^{n-1}_{i=1}GCD(i, n)$这样问题就是如何对这个函数求和了。\n\n这时候，如果对每个数都分别跑一个循环肯定是超时，那么我们枚举每个数的因素，并且用素数筛的思想。\n\n首先，记$g(i, n)$ 为满足 $gcd(x, n) = i(i \\le x < n)$的$x$个数，那么对于每个数$f(n) = \\sum g(i, n) \\cdot i$。如何对于$gcd(x, n) = i$两边同时除去$i$，$gcd(x/i, n/i) = 1$，即$g(i, n) = \\phi(n/i)$。\n\n--------------------------\n# AC代码:\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 4000001 + 10;\n\nint phi[MAX];\nll ans[MAX];\n\n//欧拉函数打表\nvoid phi_table(int n) {\n    memset(phi, 0, sizeof(phi));\n    phi[1] = 1;\n    for (int i = 2; i < n; i++) if (!phi[i])\n            for (int j = i; j <= n; j += i) {\n                if (!phi[j]) phi[j] = j;\n                phi[j] = phi[j] / i * (i - 1);\n            }\n}\n\nvoid init() {\n    //枚举每个数的因数\n    for (int i = 1; i < MAX; i++) {\n        for (int j = i + i; j < MAX; j += i) {\n            //这里求的是f(j)的其中一个因子\n            ans[j] += (ll)i * phi[j / i];\n        }\n    }\n    for (int i = 2; i < MAX; i++) {\n        ans[i] += ans[i-1];\n    }\n}\n\nint main() {\n    phi_table(MAX);\n    init();\n    int n;\n    while (cin >> n && n) {\n        cout << ans[n] << endl;\n    }\n}\n```","slug":"UVa-11426-GCD-Extreme-II","published":1,"updated":"2017-08-25T03:03:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6neh005ey9idnodck9re","content":"<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>输入$N$对公式$ \\sum ^{n-1} _{i=1} \\sum ^{n} _{j=i+1} GCD(i, j) $求和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>一开始就没思路，然后去翻博客，才发现欧拉函数还可以这么用！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对内外两层循环交换下：</p>\n<p>$\\sum^{N-1}_{i=1} \\sum^{N}_{j=i+1} GCD(i, j) = \\sum^{n}_{j=2}\\sum^{j-1}_{i=1}GCD(i,j)$</p>\n<p>然后我们把内层循环拆出来，其实就是$f(n) = \\sum^{n-1}_{i=1}GCD(i, n)$这样问题就是如何对这个函数求和了。</p>\n<p>这时候，如果对每个数都分别跑一个循环肯定是超时，那么我们枚举每个数的因素，并且用素数筛的思想。</p>\n<p>首先，记$g(i, n)$ 为满足 $gcd(x, n) = i(i \\le x &lt; n)$的$x$个数，那么对于每个数$f(n) = \\sum g(i, n) \\cdot i$。如何对于$gcd(x, n) = i$两边同时除去$i$，$gcd(x/i, n/i) = 1$，即$g(i, n) = \\phi(n/i)$。</p>\n<hr>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码:\"></a>AC代码:</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4000001</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> phi[MAX];</div><div class=\"line\">ll ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//欧拉函数打表</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">phi_table</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(phi, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(phi));</div><div class=\"line\">    phi[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) <span class=\"keyword\">if</span> (!phi[i])</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= n; j += i) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!phi[j]) phi[j] = j;</div><div class=\"line\">                phi[j] = phi[j] / i * (i - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//枚举每个数的因数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + i; j &lt; MAX; j += i) &#123;</div><div class=\"line\">            <span class=\"comment\">//这里求的是f(j)的其中一个因子</span></div><div class=\"line\">            ans[j] += (ll)i * phi[j / i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        ans[i] += ans[i<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    phi_table(MAX);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans[n] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>输入$N$对公式$ \\sum ^{n-1} _{i=1} \\sum ^{n} _{j=i+1} GCD(i, j) $求和。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>一开始就没思路，然后去翻博客，才发现欧拉函数还可以这么用！</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先对内外两层循环交换下：</p>\n<p>$\\sum^{N-1}_{i=1} \\sum^{N}_{j=i+1} GCD(i, j) = \\sum^{n}_{j=2}\\sum^{j-1}_{i=1}GCD(i,j)$</p>\n<p>然后我们把内层循环拆出来，其实就是$f(n) = \\sum^{n-1}_{i=1}GCD(i, n)$这样问题就是如何对这个函数求和了。</p>\n<p>这时候，如果对每个数都分别跑一个循环肯定是超时，那么我们枚举每个数的因素，并且用素数筛的思想。</p>\n<p>首先，记$g(i, n)$ 为满足 $gcd(x, n) = i(i \\le x &lt; n)$的$x$个数，那么对于每个数$f(n) = \\sum g(i, n) \\cdot i$。如何对于$gcd(x, n) = i$两边同时除去$i$，$gcd(x/i, n/i) = 1$，即$g(i, n) = \\phi(n/i)$。</p>\n<hr>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码:\"></a>AC代码:</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4000001</span> + <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> phi[MAX];</div><div class=\"line\">ll ans[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//欧拉函数打表</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">phi_table</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(phi, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(phi));</div><div class=\"line\">    phi[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) <span class=\"keyword\">if</span> (!phi[i])</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt;= n; j += i) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!phi[j]) phi[j] = j;</div><div class=\"line\">                phi[j] = phi[j] / i * (i - <span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//枚举每个数的因数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + i; j &lt; MAX; j += i) &#123;</div><div class=\"line\">            <span class=\"comment\">//这里求的是f(j)的其中一个因子</span></div><div class=\"line\">            ans[j] += (ll)i * phi[j / i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAX; i++) &#123;</div><div class=\"line\">        ans[i] += ans[i<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    phi_table(MAX);</div><div class=\"line\">    init();</div><div class=\"line\">    <span class=\"keyword\">int</span> n;</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans[n] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVa 12166 - Equilibrium Mobile（二叉树+递归处理括号匹配+模板）","date":"2017-02-08T09:37:38.000Z","_content":"# 题目链接\n[题目](https://vjudge.net/problem/24840/origin)\n\nMark下大神的博客：http://morris821028.github.io/\n简直太强了。\n题解链接：http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem\n\n----------\n# 题目大意：\n給一個天平表達式，請問至少要調整幾個權重才能使之平衡。（直接复制来的）\n\n\n----------\n# 解题过程：\n自己大概废了一个小时想一个特麻烦的解法，首先想的是自顶向下的平衡，然后dfs下去还是从必须从叶节点开始平衡。\n\n于是想自底向上平衡，每次把可以平衡成的质量和调整的次数传给上一层，比如调整[1,2]，给上一层传递三个状态：调整2到1，质量变为1，调整1次；调整1变为2，质量变为2，调整一次；两个都一起调整到一个任意的数，调整两次。\n显然这样需要给每个节点开辟一个空间储存状态，妥妥爆内存。\n\n想了一个小时只是这个结果，于是去百度了下，看到：\n**那麼可以得知道假使一個權重不改，最後的天平重量為何。**\n**假使 depth 上的權重 w 不改，則最後的天平重量就是 w * pow(2, depth)。**\n\n于是想到建树，统计下叶子节点所在的层数，然后拿每个叶子节点跑一边，结果是O(n^2)。\n\n后来看到这个博客确实是惊艳到了……\n\n\n----------\n# 题目分析：\n这里分析下下面的代码好了。\n\n这里map的使用和遍历可以做模板了，要是我的话，就桶排然后遍历一遍了...\n\n这个递归写的真是太强了！！\n\n然后就是sscanf的用法，可以拿来做模板，要我的话，专门写一个字符串转整数的函数了，麻烦的要死。\n\n----------\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nchar exp[1123456];\nmap<long long, int> R;\n\nvoid dfs(int l, int r, int dep)\n{\n    if (exp[l] == '[')\n    {\n        int p = 0;\n        for (int i = l + 1; i <= r - 1; i++)\n        {\n            if (exp[i] == '[')\n                p++;\n            if (exp[i] == ']')\n                p--;\n            if (p == 0 && exp[i] == ',')\n            {\n                dfs(l+1, i-1, dep+1);\n                dfs(i+1, r-1, dep+1);\n            }\n        }\n    }\n    else\n    {\n        int w;\n        exp[r+1] = '\\0';\n        sscanf(exp+l, \"%d\", &w);\n        R[(long long)w<<dep]++;\n    }\n}\n\nint main()\n{\n    int testcase;\n    scanf(\"%d\", &testcase);\n    while (testcase--)\n    {\n        scanf(\"%s\", exp);\n        R.clear();\n        dfs(0,strlen(exp) - 1, 0);\n        int sum = 0, mx = 0;\n        for (map<long long, int>::iterator it = R.begin(); it != R.end(); it++)\n            sum += it->second, mx = max(mx, it->second);\n        printf(\"%d\\n\", sum - mx);\n    }\n    return 0;\n}\n\n```","source":"_posts/UVa-12166-Equilibrium-Mobile（二叉树-递归处理括号匹配-模板）.md","raw":"---\ntitle: UVa 12166 - Equilibrium Mobile（二叉树+递归处理括号匹配+模板）\ndate: 2017-02-08 17:37:38\ncategories: [ACM, 数据结构]\ntags:\n---\n# 题目链接\n[题目](https://vjudge.net/problem/24840/origin)\n\nMark下大神的博客：http://morris821028.github.io/\n简直太强了。\n题解链接：http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem\n\n----------\n# 题目大意：\n給一個天平表達式，請問至少要調整幾個權重才能使之平衡。（直接复制来的）\n\n\n----------\n# 解题过程：\n自己大概废了一个小时想一个特麻烦的解法，首先想的是自顶向下的平衡，然后dfs下去还是从必须从叶节点开始平衡。\n\n于是想自底向上平衡，每次把可以平衡成的质量和调整的次数传给上一层，比如调整[1,2]，给上一层传递三个状态：调整2到1，质量变为1，调整1次；调整1变为2，质量变为2，调整一次；两个都一起调整到一个任意的数，调整两次。\n显然这样需要给每个节点开辟一个空间储存状态，妥妥爆内存。\n\n想了一个小时只是这个结果，于是去百度了下，看到：\n**那麼可以得知道假使一個權重不改，最後的天平重量為何。**\n**假使 depth 上的權重 w 不改，則最後的天平重量就是 w * pow(2, depth)。**\n\n于是想到建树，统计下叶子节点所在的层数，然后拿每个叶子节点跑一边，结果是O(n^2)。\n\n后来看到这个博客确实是惊艳到了……\n\n\n----------\n# 题目分析：\n这里分析下下面的代码好了。\n\n这里map的使用和遍历可以做模板了，要是我的话，就桶排然后遍历一遍了...\n\n这个递归写的真是太强了！！\n\n然后就是sscanf的用法，可以拿来做模板，要我的话，专门写一个字符串转整数的函数了，麻烦的要死。\n\n----------\n# AC代码：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nchar exp[1123456];\nmap<long long, int> R;\n\nvoid dfs(int l, int r, int dep)\n{\n    if (exp[l] == '[')\n    {\n        int p = 0;\n        for (int i = l + 1; i <= r - 1; i++)\n        {\n            if (exp[i] == '[')\n                p++;\n            if (exp[i] == ']')\n                p--;\n            if (p == 0 && exp[i] == ',')\n            {\n                dfs(l+1, i-1, dep+1);\n                dfs(i+1, r-1, dep+1);\n            }\n        }\n    }\n    else\n    {\n        int w;\n        exp[r+1] = '\\0';\n        sscanf(exp+l, \"%d\", &w);\n        R[(long long)w<<dep]++;\n    }\n}\n\nint main()\n{\n    int testcase;\n    scanf(\"%d\", &testcase);\n    while (testcase--)\n    {\n        scanf(\"%s\", exp);\n        R.clear();\n        dfs(0,strlen(exp) - 1, 0);\n        int sum = 0, mx = 0;\n        for (map<long long, int>::iterator it = R.begin(); it != R.end(); it++)\n            sum += it->second, mx = max(mx, it->second);\n        printf(\"%d\\n\", sum - mx);\n    }\n    return 0;\n}\n\n```","slug":"UVa-12166-Equilibrium-Mobile（二叉树-递归处理括号匹配-模板）","published":1,"updated":"2017-07-23T03:41:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nej005hy9id58irob0o","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><p><a href=\"https://vjudge.net/problem/24840/origin\" target=\"_blank\" rel=\"external\">题目</a></p>\n<p>Mark下大神的博客：<a href=\"http://morris821028.github.io/\" target=\"_blank\" rel=\"external\">http://morris821028.github.io/</a><br>简直太强了。<br>题解链接：<a href=\"http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem\" target=\"_blank\" rel=\"external\">http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>給一個天平表達式，請問至少要調整幾個權重才能使之平衡。（直接复制来的）</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己大概废了一个小时想一个特麻烦的解法，首先想的是自顶向下的平衡，然后dfs下去还是从必须从叶节点开始平衡。</p>\n<p>于是想自底向上平衡，每次把可以平衡成的质量和调整的次数传给上一层，比如调整[1,2]，给上一层传递三个状态：调整2到1，质量变为1，调整1次；调整1变为2，质量变为2，调整一次；两个都一起调整到一个任意的数，调整两次。<br>显然这样需要给每个节点开辟一个空间储存状态，妥妥爆内存。</p>\n<p>想了一个小时只是这个结果，于是去百度了下，看到：<br><strong>那麼可以得知道假使一個權重不改，最後的天平重量為何。</strong><br><strong>假使 depth 上的權重 w 不改，則最後的天平重量就是 w * pow(2, depth)。</strong></p>\n<p>于是想到建树，统计下叶子节点所在的层数，然后拿每个叶子节点跑一边，结果是O(n^2)。</p>\n<p>后来看到这个博客确实是惊艳到了……</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里分析下下面的代码好了。</p>\n<p>这里map的使用和遍历可以做模板了，要是我的话，就桶排然后遍历一遍了…</p>\n<p>这个递归写的真是太强了！！</p>\n<p>然后就是sscanf的用法，可以拿来做模板，要我的话，专门写一个字符串转整数的函数了，麻烦的要死。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> <span class=\"built_in\">exp</span>[<span class=\"number\">1123456</span>];</div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt; R;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> dep)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[l] == <span class=\"string\">'['</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l + <span class=\"number\">1</span>; i &lt;= r - <span class=\"number\">1</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[i] == <span class=\"string\">'['</span>)</div><div class=\"line\">                p++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[i] == <span class=\"string\">']'</span>)</div><div class=\"line\">                p--;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">exp</span>[i] == <span class=\"string\">','</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dfs(l+<span class=\"number\">1</span>, i<span class=\"number\">-1</span>, dep+<span class=\"number\">1</span>);</div><div class=\"line\">                dfs(i+<span class=\"number\">1</span>, r<span class=\"number\">-1</span>, dep+<span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> w;</div><div class=\"line\">        <span class=\"built_in\">exp</span>[r+<span class=\"number\">1</span>] = <span class=\"string\">'\\0'</span>;</div><div class=\"line\">        <span class=\"built_in\">sscanf</span>(<span class=\"built_in\">exp</span>+l, <span class=\"string\">\"%d\"</span>, &amp;w);</div><div class=\"line\">        R[(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)w&lt;&lt;dep]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> testcase;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;testcase);</div><div class=\"line\">    <span class=\"keyword\">while</span> (testcase--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, <span class=\"built_in\">exp</span>);</div><div class=\"line\">        R.clear();</div><div class=\"line\">        dfs(<span class=\"number\">0</span>,<span class=\"built_in\">strlen</span>(<span class=\"built_in\">exp</span>) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, mx = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt;::iterator it = R.begin(); it != R.end(); it++)</div><div class=\"line\">            sum += it-&gt;second, mx = max(mx, it-&gt;second);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sum - mx);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><p><a href=\"https://vjudge.net/problem/24840/origin\" target=\"_blank\" rel=\"external\">题目</a></p>\n<p>Mark下大神的博客：<a href=\"http://morris821028.github.io/\" target=\"_blank\" rel=\"external\">http://morris821028.github.io/</a><br>简直太强了。<br>题解链接：<a href=\"http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem\" target=\"_blank\" rel=\"external\">http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/#Problem</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>給一個天平表達式，請問至少要調整幾個權重才能使之平衡。（直接复制来的）</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>自己大概废了一个小时想一个特麻烦的解法，首先想的是自顶向下的平衡，然后dfs下去还是从必须从叶节点开始平衡。</p>\n<p>于是想自底向上平衡，每次把可以平衡成的质量和调整的次数传给上一层，比如调整[1,2]，给上一层传递三个状态：调整2到1，质量变为1，调整1次；调整1变为2，质量变为2，调整一次；两个都一起调整到一个任意的数，调整两次。<br>显然这样需要给每个节点开辟一个空间储存状态，妥妥爆内存。</p>\n<p>想了一个小时只是这个结果，于是去百度了下，看到：<br><strong>那麼可以得知道假使一個權重不改，最後的天平重量為何。</strong><br><strong>假使 depth 上的權重 w 不改，則最後的天平重量就是 w * pow(2, depth)。</strong></p>\n<p>于是想到建树，统计下叶子节点所在的层数，然后拿每个叶子节点跑一边，结果是O(n^2)。</p>\n<p>后来看到这个博客确实是惊艳到了……</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>这里分析下下面的代码好了。</p>\n<p>这里map的使用和遍历可以做模板了，要是我的话，就桶排然后遍历一遍了…</p>\n<p>这个递归写的真是太强了！！</p>\n<p>然后就是sscanf的用法，可以拿来做模板，要我的话，专门写一个字符串转整数的函数了，麻烦的要死。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> <span class=\"built_in\">exp</span>[<span class=\"number\">1123456</span>];</div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt; R;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> dep)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[l] == <span class=\"string\">'['</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l + <span class=\"number\">1</span>; i &lt;= r - <span class=\"number\">1</span>; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[i] == <span class=\"string\">'['</span>)</div><div class=\"line\">                p++;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">exp</span>[i] == <span class=\"string\">']'</span>)</div><div class=\"line\">                p--;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">exp</span>[i] == <span class=\"string\">','</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                dfs(l+<span class=\"number\">1</span>, i<span class=\"number\">-1</span>, dep+<span class=\"number\">1</span>);</div><div class=\"line\">                dfs(i+<span class=\"number\">1</span>, r<span class=\"number\">-1</span>, dep+<span class=\"number\">1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> w;</div><div class=\"line\">        <span class=\"built_in\">exp</span>[r+<span class=\"number\">1</span>] = <span class=\"string\">'\\0'</span>;</div><div class=\"line\">        <span class=\"built_in\">sscanf</span>(<span class=\"built_in\">exp</span>+l, <span class=\"string\">\"%d\"</span>, &amp;w);</div><div class=\"line\">        R[(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)w&lt;&lt;dep]++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> testcase;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;testcase);</div><div class=\"line\">    <span class=\"keyword\">while</span> (testcase--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, <span class=\"built_in\">exp</span>);</div><div class=\"line\">        R.clear();</div><div class=\"line\">        dfs(<span class=\"number\">0</span>,<span class=\"built_in\">strlen</span>(<span class=\"built_in\">exp</span>) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, mx = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt;::iterator it = R.begin(); it != R.end(); it++)</div><div class=\"line\">            sum += it-&gt;second, mx = max(mx, it-&gt;second);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sum - mx);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UVa 1354 - Mobile Computing（二叉树 + DFS）","date":"2017-02-18T08:53:24.000Z","_content":"# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4100\n\n# 题目大意\n------------------\n给定多个二叉树的叶子，每个节点有一个重量，两个节点可以用一个木棍连接，一个木棍的一头可以连接一个叶子节点，或者另一根木棍。\n\n要保证每个木棍平衡，符合胡克定律。\n\n# 解题过程\n--------------\n刚开始写的，状态是用一个 vector 储存的，每次删去两个节点，继续归并其他的。\n然后来回操作非常麻烦，也一直 WA。\n\n于是百度了下别人的博客，他是每一层 dfs 都开一个 vector 数组储存状态，然后以引用传递，传给下级。\n\n每层一个 vector 储存当前的状态，避免了来回操作一个数组造成 bug。\n\n# 题目分析\n------------------\n主要是注意下，这里 dfs 时每层储存状态。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112;\nconst double EPS = 1e-8;\n\nstruct node\n{\n    double first;\n    double second;\n    double right;\n    node (double first, double second, double right):first(first),second(second),right(right){}\n};\n\nint n;\ndouble width, ans = -1;\nvector<node> status;\n\nnode connect(node a, node b)\n{\n    double w = a.second + b.second;\n    double la = b.second / w, lb = a.second / w;\n    node ans = node(max(a.first + la, -lb + b.first), w,max(b.right + lb, -la + a.right));\n    return ans;\n}\n\nvoid solve(vector<node> &status)\n{\n    if (status.size() == 1)\n    {\n        double t = status[0].first + status[0].right;\n        if (t <= width + EPS)\n            ans = max(ans, t);\n        return;\n    }\n\n    for (int i = 0; i < status.size(); i++)\n    {\n        for (int j = 0; j < status.size(); j++)\n        {\n            if (i == j)\n                continue;\n\n            vector<node> nstatus;\n\n            for (int k = 0; k < status.size(); k++)\n            {\n                if (k == i || k == j)\n                    continue;\n                nstatus.push_back(status[k]);\n            }\n\n            node a = status[i], b = status[j];\n            node x = connect(a, b);\n\n            if (x.first + x.right > width + EPS)\n                continue;\n\n            nstatus.push_back(x);\n            solve(nstatus);\n        }\n    }\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        status.clear();\n        ans = -1;\n        scanf(\"%lf\", &width);\n        scanf(\"%d\", &n);\n        while (n--)\n        {\n            double w;\n            scanf(\"%lf\", &w);\n            status.push_back(node(0.0, w, 0.0));\n        }\n        solve(status);\n        if (ans < 0)\n            puts(\"-1\");\n        else\n            printf(\"%.16lf\\n\", ans);\n    }\n}\n```","source":"_posts/UVa-1354-Mobile-Computing（二叉树-DFS）.md","raw":"---\ntitle: UVa 1354 - Mobile Computing（二叉树 + DFS）\ndate: 2017-02-18 16:53:24\ncategories: [ACM, 数据结构]\ntags:\n---\n# 题目链接\n-------------------\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4100\n\n# 题目大意\n------------------\n给定多个二叉树的叶子，每个节点有一个重量，两个节点可以用一个木棍连接，一个木棍的一头可以连接一个叶子节点，或者另一根木棍。\n\n要保证每个木棍平衡，符合胡克定律。\n\n# 解题过程\n--------------\n刚开始写的，状态是用一个 vector 储存的，每次删去两个节点，继续归并其他的。\n然后来回操作非常麻烦，也一直 WA。\n\n于是百度了下别人的博客，他是每一层 dfs 都开一个 vector 数组储存状态，然后以引用传递，传给下级。\n\n每层一个 vector 储存当前的状态，避免了来回操作一个数组造成 bug。\n\n# 题目分析\n------------------\n主要是注意下，这里 dfs 时每层储存状态。\n\n# AC代码\n------------\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 112;\nconst double EPS = 1e-8;\n\nstruct node\n{\n    double first;\n    double second;\n    double right;\n    node (double first, double second, double right):first(first),second(second),right(right){}\n};\n\nint n;\ndouble width, ans = -1;\nvector<node> status;\n\nnode connect(node a, node b)\n{\n    double w = a.second + b.second;\n    double la = b.second / w, lb = a.second / w;\n    node ans = node(max(a.first + la, -lb + b.first), w,max(b.right + lb, -la + a.right));\n    return ans;\n}\n\nvoid solve(vector<node> &status)\n{\n    if (status.size() == 1)\n    {\n        double t = status[0].first + status[0].right;\n        if (t <= width + EPS)\n            ans = max(ans, t);\n        return;\n    }\n\n    for (int i = 0; i < status.size(); i++)\n    {\n        for (int j = 0; j < status.size(); j++)\n        {\n            if (i == j)\n                continue;\n\n            vector<node> nstatus;\n\n            for (int k = 0; k < status.size(); k++)\n            {\n                if (k == i || k == j)\n                    continue;\n                nstatus.push_back(status[k]);\n            }\n\n            node a = status[i], b = status[j];\n            node x = connect(a, b);\n\n            if (x.first + x.right > width + EPS)\n                continue;\n\n            nstatus.push_back(x);\n            solve(nstatus);\n        }\n    }\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        status.clear();\n        ans = -1;\n        scanf(\"%lf\", &width);\n        scanf(\"%d\", &n);\n        while (n--)\n        {\n            double w;\n            scanf(\"%lf\", &w);\n            status.push_back(node(0.0, w, 0.0));\n        }\n        solve(status);\n        if (ans < 0)\n            puts(\"-1\");\n        else\n            printf(\"%.16lf\\n\", ans);\n    }\n}\n```","slug":"UVa-1354-Mobile-Computing（二叉树-DFS）","published":1,"updated":"2017-07-23T02:57:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nel005jy9idbbm2vd23","content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4100\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4100</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定多个二叉树的叶子，每个节点有一个重量，两个节点可以用一个木棍连接，一个木棍的一头可以连接一个叶子节点，或者另一根木棍。</p>\n<p>要保证每个木棍平衡，符合胡克定律。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>刚开始写的，状态是用一个 vector 储存的，每次删去两个节点，继续归并其他的。<br>然后来回操作非常麻烦，也一直 WA。</p>\n<p>于是百度了下别人的博客，他是每一层 dfs 都开一个 vector 数组储存状态，然后以引用传递，传给下级。</p>\n<p>每层一个 vector 储存当前的状态，避免了来回操作一个数组造成 bug。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<p>主要是注意下，这里 dfs 时每层储存状态。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> EPS = <span class=\"number\">1e-8</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">double</span> first;</div><div class=\"line\">    <span class=\"keyword\">double</span> second;</div><div class=\"line\">    <span class=\"keyword\">double</span> right;</div><div class=\"line\">    node (<span class=\"keyword\">double</span> first, <span class=\"keyword\">double</span> second, <span class=\"keyword\">double</span> right):first(first),second(second),right(right)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">double</span> width, ans = <span class=\"number\">-1</span>;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;node&gt; status;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">node <span class=\"title\">connect</span><span class=\"params\">(node a, node b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> w = a.second + b.second;</div><div class=\"line\">    <span class=\"keyword\">double</span> la = b.second / w, lb = a.second / w;</div><div class=\"line\">    node ans = node(max(a.first + la, -lb + b.first), w,max(b.right + lb, -la + a.right));</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;node&gt; &amp;status)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (status.size() == <span class=\"number\">1</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> t = status[<span class=\"number\">0</span>].first + status[<span class=\"number\">0</span>].right;</div><div class=\"line\">        <span class=\"keyword\">if</span> (t &lt;= width + EPS)</div><div class=\"line\">            ans = max(ans, t);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; status.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; status.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">vector</span>&lt;node&gt; nstatus;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; status.size(); k++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (k == i || k == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                nstatus.push_back(status[k]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            node a = status[i], b = status[j];</div><div class=\"line\">            node x = connect(a, b);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (x.first + x.right &gt; width + EPS)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            nstatus.push_back(x);</div><div class=\"line\">            solve(nstatus);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        status.clear();</div><div class=\"line\">        ans = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>, &amp;width);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">double</span> w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>, &amp;w);</div><div class=\"line\">            status.push_back(node(<span class=\"number\">0.0</span>, w, <span class=\"number\">0.0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve(status);</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.16lf\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><hr>\n<p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4100\" target=\"_blank\" rel=\"external\">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4100</a></p>\n<h1 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h1><hr>\n<p>给定多个二叉树的叶子，每个节点有一个重量，两个节点可以用一个木棍连接，一个木棍的一头可以连接一个叶子节点，或者另一根木棍。</p>\n<p>要保证每个木棍平衡，符合胡克定律。</p>\n<h1 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h1><hr>\n<p>刚开始写的，状态是用一个 vector 储存的，每次删去两个节点，继续归并其他的。<br>然后来回操作非常麻烦，也一直 WA。</p>\n<p>于是百度了下别人的博客，他是每一层 dfs 都开一个 vector 数组储存状态，然后以引用传递，传给下级。</p>\n<p>每层一个 vector 储存当前的状态，避免了来回操作一个数组造成 bug。</p>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><hr>\n<p>主要是注意下，这里 dfs 时每层储存状态。</p>\n<h1 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> EPS = <span class=\"number\">1e-8</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">double</span> first;</div><div class=\"line\">    <span class=\"keyword\">double</span> second;</div><div class=\"line\">    <span class=\"keyword\">double</span> right;</div><div class=\"line\">    node (<span class=\"keyword\">double</span> first, <span class=\"keyword\">double</span> second, <span class=\"keyword\">double</span> right):first(first),second(second),right(right)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n;</div><div class=\"line\"><span class=\"keyword\">double</span> width, ans = <span class=\"number\">-1</span>;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;node&gt; status;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">node <span class=\"title\">connect</span><span class=\"params\">(node a, node b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> w = a.second + b.second;</div><div class=\"line\">    <span class=\"keyword\">double</span> la = b.second / w, lb = a.second / w;</div><div class=\"line\">    node ans = node(max(a.first + la, -lb + b.first), w,max(b.right + lb, -la + a.right));</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;node&gt; &amp;status)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (status.size() == <span class=\"number\">1</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> t = status[<span class=\"number\">0</span>].first + status[<span class=\"number\">0</span>].right;</div><div class=\"line\">        <span class=\"keyword\">if</span> (t &lt;= width + EPS)</div><div class=\"line\">            ans = max(ans, t);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; status.size(); i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; status.size(); j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == j)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">vector</span>&lt;node&gt; nstatus;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; status.size(); k++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (k == i || k == j)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                nstatus.push_back(status[k]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            node a = status[i], b = status[j];</div><div class=\"line\">            node x = connect(a, b);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (x.first + x.right &gt; width + EPS)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">            nstatus.push_back(x);</div><div class=\"line\">            solve(nstatus);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--)</div><div class=\"line\">    &#123;</div><div class=\"line\">        status.clear();</div><div class=\"line\">        ans = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>, &amp;width);</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">while</span> (n--)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">double</span> w;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>, &amp;w);</div><div class=\"line\">            status.push_back(node(<span class=\"number\">0.0</span>, w, <span class=\"number\">0.0</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">        solve(status);</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"built_in\">puts</span>(<span class=\"string\">\"-1\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.16lf\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Uva 806 - Spatial Structures（四分树+模板）","date":"2017-02-09T06:58:59.000Z","_content":"# 题目链接：\n-----\nhttps://vjudge.net/problem/24840/origin\n\n# 题目描述：\n-------------\n黑白图像有好几种表示方式，可以用点阵或者路径，路径需要把图像转化成四叉树。\n题目要求就是实现两种表示方式的转换。\n\n# 解题过程：\n-----\n题目不难，注意细节就好，直接的judge函数错了好几次，以后写的严谨点，不拿两个相邻的方块比较了，立一个flag再和flag比较。\n没注意输出格式，pe了好几次，12个数字为一行。\n \n# 题目分析：\n----\n+ 转化为路径，首先以递归的方式建树，每次搜索范围缩小为原来的1/4。\n找到黑块的时候，把搜索时记录下来的路径转化成十进制，储存。\n最后排序输出，12个为一行。\n+ 转化为图像，首先把十进制转化为路径，然后递归式的把图像画出来就好了。\n\n# AC代码：\n-------\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nstruct node\n{\n    int status;\n    node *one, *two, *three, *four;\n    node():status(-1),one(NULL),two(NULL),three(NULL),four(NULL){}\n};\n\nvector<int> ans;\nint num;\nstring drawPath;\nchar data[112][112];\n\nbool judge(int l, int r, int u, int d)\n{\n    int flag = data[u][l];\n    for (int i = u; i < d; i++)\n        for (int j = l; j < r; j++)\n            if (data[i][j] != flag)\n                return false;\n    return true;\n}\n\nvoid trns(int num)\n{\n    drawPath = \"\";\n    if (num == 0)\n    {\n        drawPath += '0';\n        return;\n    }\n\n    while (num)\n    {\n        string temp = \"\";\n        temp += (char) (num%5 + '0');\n        drawPath = temp + drawPath;\n        num /= 5;\n    }\n\n//    cout << drawPath << endl;\n}\n\nvoid add(string path)\n{\n    int len = path.size(), num = 0;\n    for (int i = 0; i < len; i++)\n        num += (path[i] - '0') * pow(5, i);\n\n    ans.push_back(num);\n}\n\nvoid solve(int l, int r, int u, int d, string path)\n{\n\n    if (judge(l, r, u, d))\n    {\n        if (data[u][l] == '1')\n        {\n            add(path);\n            num++;\n        }\n        return;\n    }\n\n    solve(l, (l+r)/2, u, (u+d)/2, path+'1');\n    solve((l+r)/2, r, u, (u+d)/2, path+'2');\n    solve(l, (l+r)/2, (u+d)/2, d, path+'3');\n    solve((l+r)/2, r, (u+d)/2, d, path+'4');\n}\n\nvoid draw(int l, int r, int u, int d, int p)\n{\n    if (p == -1 || drawPath[p] == '0')\n    {\n        for (int i = u; i < d; i++)\n            for (int j = l; j < r; j++)\n                data[i][j] = '*';\n        return;\n    }\n//    printf(\"%c\\n\", drawPath[p]);\n    if (drawPath[p] == '1')\n        draw(l, (l+r)/2, u, (u+d)/2, p-1);\n    if (drawPath[p] == '2')\n        draw((l+r)/2, r, u, (u+d)/2, p-1);\n    if (drawPath[p] == '3')\n        draw(l, (l+r)/2, (u+d)/2, d, p-1);\n    if (drawPath[p] == '4')\n        draw((l+r)/2, r, (u+d)/2, d, p-1);\n}\n\nint main()\n{\n//    freopen(\"in\", \"r\", stdin);\n//    freopen(\"out\", \"w\", stdout);\n    int n, testCase = 0;\n    while (~scanf(\"%d\", &n) && n)\n    {\n        if (testCase)\n            putchar('\\n');\n        printf(\"Image %d\\n\", ++testCase);\n        num = 0;\n        if (n > 0)\n        {\n            ans.clear();\n            for (int i = 0; i < n; i++)\n                scanf(\"%s\", data+i);\n            solve(0, n, 0, n, \"\");\n            sort(ans.begin(), ans.end());\n            for (int i = 0; i < ans.size(); i++)\n            {\n                printf(\"%d\", ans[i]);\n                if ((i+1) % 12 == 0)\n                    printf(\"\\n\");\n                else if (i != ans.size()-1)\n                    putchar(' ');\n            }\n\n            if (num && ans.size()%12 != 0)\n                putchar('\\n');\n            printf(\"Total number of black nodes = %d\\n\", num);\n        }\n        else\n        {\n            memset(data, '.', sizeof(data));\n            n *= -1;\n            int t;\n            while (cin >> t && t != -1)\n            {\n                trns(t);\n                draw(0, n, 0, n, drawPath.size()-1);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                    putchar(data[i][j]);\n                putchar('\\n');\n            }\n        }\n    }\n}\n```","source":"_posts/Uva-806-Spatial-Structures（四分树-模板）.md","raw":"---\ntitle: Uva 806 - Spatial Structures（四分树+模板）\ndate: 2017-02-09 14:58:59\ncategories: [ACM, 数据结构]\ntags:\n---\n# 题目链接：\n-----\nhttps://vjudge.net/problem/24840/origin\n\n# 题目描述：\n-------------\n黑白图像有好几种表示方式，可以用点阵或者路径，路径需要把图像转化成四叉树。\n题目要求就是实现两种表示方式的转换。\n\n# 解题过程：\n-----\n题目不难，注意细节就好，直接的judge函数错了好几次，以后写的严谨点，不拿两个相邻的方块比较了，立一个flag再和flag比较。\n没注意输出格式，pe了好几次，12个数字为一行。\n \n# 题目分析：\n----\n+ 转化为路径，首先以递归的方式建树，每次搜索范围缩小为原来的1/4。\n找到黑块的时候，把搜索时记录下来的路径转化成十进制，储存。\n最后排序输出，12个为一行。\n+ 转化为图像，首先把十进制转化为路径，然后递归式的把图像画出来就好了。\n\n# AC代码：\n-------\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nstruct node\n{\n    int status;\n    node *one, *two, *three, *four;\n    node():status(-1),one(NULL),two(NULL),three(NULL),four(NULL){}\n};\n\nvector<int> ans;\nint num;\nstring drawPath;\nchar data[112][112];\n\nbool judge(int l, int r, int u, int d)\n{\n    int flag = data[u][l];\n    for (int i = u; i < d; i++)\n        for (int j = l; j < r; j++)\n            if (data[i][j] != flag)\n                return false;\n    return true;\n}\n\nvoid trns(int num)\n{\n    drawPath = \"\";\n    if (num == 0)\n    {\n        drawPath += '0';\n        return;\n    }\n\n    while (num)\n    {\n        string temp = \"\";\n        temp += (char) (num%5 + '0');\n        drawPath = temp + drawPath;\n        num /= 5;\n    }\n\n//    cout << drawPath << endl;\n}\n\nvoid add(string path)\n{\n    int len = path.size(), num = 0;\n    for (int i = 0; i < len; i++)\n        num += (path[i] - '0') * pow(5, i);\n\n    ans.push_back(num);\n}\n\nvoid solve(int l, int r, int u, int d, string path)\n{\n\n    if (judge(l, r, u, d))\n    {\n        if (data[u][l] == '1')\n        {\n            add(path);\n            num++;\n        }\n        return;\n    }\n\n    solve(l, (l+r)/2, u, (u+d)/2, path+'1');\n    solve((l+r)/2, r, u, (u+d)/2, path+'2');\n    solve(l, (l+r)/2, (u+d)/2, d, path+'3');\n    solve((l+r)/2, r, (u+d)/2, d, path+'4');\n}\n\nvoid draw(int l, int r, int u, int d, int p)\n{\n    if (p == -1 || drawPath[p] == '0')\n    {\n        for (int i = u; i < d; i++)\n            for (int j = l; j < r; j++)\n                data[i][j] = '*';\n        return;\n    }\n//    printf(\"%c\\n\", drawPath[p]);\n    if (drawPath[p] == '1')\n        draw(l, (l+r)/2, u, (u+d)/2, p-1);\n    if (drawPath[p] == '2')\n        draw((l+r)/2, r, u, (u+d)/2, p-1);\n    if (drawPath[p] == '3')\n        draw(l, (l+r)/2, (u+d)/2, d, p-1);\n    if (drawPath[p] == '4')\n        draw((l+r)/2, r, (u+d)/2, d, p-1);\n}\n\nint main()\n{\n//    freopen(\"in\", \"r\", stdin);\n//    freopen(\"out\", \"w\", stdout);\n    int n, testCase = 0;\n    while (~scanf(\"%d\", &n) && n)\n    {\n        if (testCase)\n            putchar('\\n');\n        printf(\"Image %d\\n\", ++testCase);\n        num = 0;\n        if (n > 0)\n        {\n            ans.clear();\n            for (int i = 0; i < n; i++)\n                scanf(\"%s\", data+i);\n            solve(0, n, 0, n, \"\");\n            sort(ans.begin(), ans.end());\n            for (int i = 0; i < ans.size(); i++)\n            {\n                printf(\"%d\", ans[i]);\n                if ((i+1) % 12 == 0)\n                    printf(\"\\n\");\n                else if (i != ans.size()-1)\n                    putchar(' ');\n            }\n\n            if (num && ans.size()%12 != 0)\n                putchar('\\n');\n            printf(\"Total number of black nodes = %d\\n\", num);\n        }\n        else\n        {\n            memset(data, '.', sizeof(data));\n            n *= -1;\n            int t;\n            while (cin >> t && t != -1)\n            {\n                trns(t);\n                draw(0, n, 0, n, drawPath.size()-1);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                    putchar(data[i][j]);\n                putchar('\\n');\n            }\n        }\n    }\n}\n```","slug":"Uva-806-Spatial-Structures（四分树-模板）","published":1,"updated":"2017-08-08T02:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nem005my9idqau9u7e3","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"https://vjudge.net/problem/24840/origin\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/24840/origin</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>黑白图像有好几种表示方式，可以用点阵或者路径，路径需要把图像转化成四叉树。<br>题目要求就是实现两种表示方式的转换。</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><hr>\n<p>题目不难，注意细节就好，直接的judge函数错了好几次，以后写的严谨点，不拿两个相邻的方块比较了，立一个flag再和flag比较。<br>没注意输出格式，pe了好几次，12个数字为一行。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>转化为路径，首先以递归的方式建树，每次搜索范围缩小为原来的1/4。<br>找到黑块的时候，把搜索时记录下来的路径转化成十进制，储存。<br>最后排序输出，12个为一行。</li>\n<li>转化为图像，首先把十进制转化为路径，然后递归式的把图像画出来就好了。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> status;</div><div class=\"line\">    node *one, *two, *three, *four;</div><div class=\"line\">    node():status(<span class=\"number\">-1</span>),one(<span class=\"literal\">NULL</span>),two(<span class=\"literal\">NULL</span>),three(<span class=\"literal\">NULL</span>),four(<span class=\"literal\">NULL</span>)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</div><div class=\"line\"><span class=\"keyword\">int</span> num;</div><div class=\"line\"><span class=\"built_in\">string</span> drawPath;</div><div class=\"line\"><span class=\"keyword\">char</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flag = data[u][l];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = u; i &lt; d; i++)</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt; r; j++)</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i][j] != flag)</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trns</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    drawPath = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        drawPath += <span class=\"string\">'0'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (num)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> temp = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        temp += (<span class=\"keyword\">char</span>) (num%<span class=\"number\">5</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">        drawPath = temp + drawPath;</div><div class=\"line\">        num /= <span class=\"number\">5</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//    cout &lt;&lt; drawPath &lt;&lt; endl;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = path.size(), num = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</div><div class=\"line\">        num += (path[i] - <span class=\"string\">'0'</span>) * <span class=\"built_in\">pow</span>(<span class=\"number\">5</span>, i);</div><div class=\"line\"></div><div class=\"line\">    ans.push_back(num);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d, <span class=\"built_in\">string</span> path)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (judge(l, r, u, d))</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[u][l] == <span class=\"string\">'1'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            add(path);</div><div class=\"line\">            num++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    solve(l, (l+r)/<span class=\"number\">2</span>, u, (u+d)/<span class=\"number\">2</span>, path+<span class=\"string\">'1'</span>);</div><div class=\"line\">    solve((l+r)/<span class=\"number\">2</span>, r, u, (u+d)/<span class=\"number\">2</span>, path+<span class=\"string\">'2'</span>);</div><div class=\"line\">    solve(l, (l+r)/<span class=\"number\">2</span>, (u+d)/<span class=\"number\">2</span>, d, path+<span class=\"string\">'3'</span>);</div><div class=\"line\">    solve((l+r)/<span class=\"number\">2</span>, r, (u+d)/<span class=\"number\">2</span>, d, path+<span class=\"string\">'4'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d, <span class=\"keyword\">int</span> p)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span> || drawPath[p] == <span class=\"string\">'0'</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = u; i &lt; d; i++)</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt; r; j++)</div><div class=\"line\">                data[i][j] = <span class=\"string\">'*'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//    printf(\"%c\\n\", drawPath[p]);</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'1'</span>)</div><div class=\"line\">        draw(l, (l+r)/<span class=\"number\">2</span>, u, (u+d)/<span class=\"number\">2</span>, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'2'</span>)</div><div class=\"line\">        draw((l+r)/<span class=\"number\">2</span>, r, u, (u+d)/<span class=\"number\">2</span>, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'3'</span>)</div><div class=\"line\">        draw(l, (l+r)/<span class=\"number\">2</span>, (u+d)/<span class=\"number\">2</span>, d, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'4'</span>)</div><div class=\"line\">        draw((l+r)/<span class=\"number\">2</span>, r, (u+d)/<span class=\"number\">2</span>, d, p<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\"><span class=\"comment\">//    freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    <span class=\"keyword\">int</span> n, testCase = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (testCase)</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, ++testCase);</div><div class=\"line\">        num = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            ans.clear();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data+i);</div><div class=\"line\">            solve(<span class=\"number\">0</span>, n, <span class=\"number\">0</span>, n, <span class=\"string\">\"\"</span>);</div><div class=\"line\">            sort(ans.begin(), ans.end());</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans.size(); i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, ans[i]);</div><div class=\"line\">                <span class=\"keyword\">if</span> ((i+<span class=\"number\">1</span>) % <span class=\"number\">12</span> == <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i != ans.size()<span class=\"number\">-1</span>)</div><div class=\"line\">                    <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (num &amp;&amp; ans.size()%<span class=\"number\">12</span> != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total number of black nodes = %d\\n\"</span>, num);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(data, <span class=\"string\">'.'</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">            n *= <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; t &amp;&amp; t != <span class=\"number\">-1</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                trns(t);</div><div class=\"line\">                draw(<span class=\"number\">0</span>, n, <span class=\"number\">0</span>, n, drawPath.size()<span class=\"number\">-1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</div><div class=\"line\">                    <span class=\"built_in\">putchar</span>(data[i][j]);</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><hr>\n<p><a href=\"https://vjudge.net/problem/24840/origin\" target=\"_blank\" rel=\"external\">https://vjudge.net/problem/24840/origin</a></p>\n<h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><hr>\n<p>黑白图像有好几种表示方式，可以用点阵或者路径，路径需要把图像转化成四叉树。<br>题目要求就是实现两种表示方式的转换。</p>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><hr>\n<p>题目不难，注意细节就好，直接的judge函数错了好几次，以后写的严谨点，不拿两个相邻的方块比较了，立一个flag再和flag比较。<br>没注意输出格式，pe了好几次，12个数字为一行。</p>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><hr>\n<ul>\n<li>转化为路径，首先以递归的方式建树，每次搜索范围缩小为原来的1/4。<br>找到黑块的时候，把搜索时记录下来的路径转化成十进制，储存。<br>最后排序输出，12个为一行。</li>\n<li>转化为图像，首先把十进制转化为路径，然后递归式的把图像画出来就好了。</li>\n</ul>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></div><div class=\"line\"><span class=\"class\">&#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> status;</div><div class=\"line\">    node *one, *two, *three, *four;</div><div class=\"line\">    node():status(<span class=\"number\">-1</span>),one(<span class=\"literal\">NULL</span>),two(<span class=\"literal\">NULL</span>),three(<span class=\"literal\">NULL</span>),four(<span class=\"literal\">NULL</span>)&#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</div><div class=\"line\"><span class=\"keyword\">int</span> num;</div><div class=\"line\"><span class=\"built_in\">string</span> drawPath;</div><div class=\"line\"><span class=\"keyword\">char</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flag = data[u][l];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = u; i &lt; d; i++)</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt; r; j++)</div><div class=\"line\">            <span class=\"keyword\">if</span> (data[i][j] != flag)</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trns</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    drawPath = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        drawPath += <span class=\"string\">'0'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (num)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> temp = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        temp += (<span class=\"keyword\">char</span>) (num%<span class=\"number\">5</span> + <span class=\"string\">'0'</span>);</div><div class=\"line\">        drawPath = temp + drawPath;</div><div class=\"line\">        num /= <span class=\"number\">5</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//    cout &lt;&lt; drawPath &lt;&lt; endl;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"built_in\">string</span> path)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = path.size(), num = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</div><div class=\"line\">        num += (path[i] - <span class=\"string\">'0'</span>) * <span class=\"built_in\">pow</span>(<span class=\"number\">5</span>, i);</div><div class=\"line\"></div><div class=\"line\">    ans.push_back(num);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d, <span class=\"built_in\">string</span> path)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (judge(l, r, u, d))</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[u][l] == <span class=\"string\">'1'</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            add(path);</div><div class=\"line\">            num++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    solve(l, (l+r)/<span class=\"number\">2</span>, u, (u+d)/<span class=\"number\">2</span>, path+<span class=\"string\">'1'</span>);</div><div class=\"line\">    solve((l+r)/<span class=\"number\">2</span>, r, u, (u+d)/<span class=\"number\">2</span>, path+<span class=\"string\">'2'</span>);</div><div class=\"line\">    solve(l, (l+r)/<span class=\"number\">2</span>, (u+d)/<span class=\"number\">2</span>, d, path+<span class=\"string\">'3'</span>);</div><div class=\"line\">    solve((l+r)/<span class=\"number\">2</span>, r, (u+d)/<span class=\"number\">2</span>, d, path+<span class=\"string\">'4'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> d, <span class=\"keyword\">int</span> p)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span> || drawPath[p] == <span class=\"string\">'0'</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = u; i &lt; d; i++)</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = l; j &lt; r; j++)</div><div class=\"line\">                data[i][j] = <span class=\"string\">'*'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//    printf(\"%c\\n\", drawPath[p]);</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'1'</span>)</div><div class=\"line\">        draw(l, (l+r)/<span class=\"number\">2</span>, u, (u+d)/<span class=\"number\">2</span>, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'2'</span>)</div><div class=\"line\">        draw((l+r)/<span class=\"number\">2</span>, r, u, (u+d)/<span class=\"number\">2</span>, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'3'</span>)</div><div class=\"line\">        draw(l, (l+r)/<span class=\"number\">2</span>, (u+d)/<span class=\"number\">2</span>, d, p<span class=\"number\">-1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawPath[p] == <span class=\"string\">'4'</span>)</div><div class=\"line\">        draw((l+r)/<span class=\"number\">2</span>, r, (u+d)/<span class=\"number\">2</span>, d, p<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"comment\">//    freopen(\"in\", \"r\", stdin);</span></div><div class=\"line\"><span class=\"comment\">//    freopen(\"out\", \"w\", stdout);</span></div><div class=\"line\">    <span class=\"keyword\">int</span> n, testCase = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n) &amp;&amp; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (testCase)</div><div class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, ++testCase);</div><div class=\"line\">        num = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            ans.clear();</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, data+i);</div><div class=\"line\">            solve(<span class=\"number\">0</span>, n, <span class=\"number\">0</span>, n, <span class=\"string\">\"\"</span>);</div><div class=\"line\">            sort(ans.begin(), ans.end());</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans.size(); i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, ans[i]);</div><div class=\"line\">                <span class=\"keyword\">if</span> ((i+<span class=\"number\">1</span>) % <span class=\"number\">12</span> == <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i != ans.size()<span class=\"number\">-1</span>)</div><div class=\"line\">                    <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (num &amp;&amp; ans.size()%<span class=\"number\">12</span> != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total number of black nodes = %d\\n\"</span>, num);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(data, <span class=\"string\">'.'</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">            n *= <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">int</span> t;</div><div class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; t &amp;&amp; t != <span class=\"number\">-1</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                trns(t);</div><div class=\"line\">                draw(<span class=\"number\">0</span>, n, <span class=\"number\">0</span>, n, drawPath.size()<span class=\"number\">-1</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</div><div class=\"line\">                    <span class=\"built_in\">putchar</span>(data[i][j]);</div><div class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"ZOJ3777 - Problem Arrangement（状压DP）","date":"2017-05-12T13:53:47.000Z","_content":"# 题目链接：\nhttps://cn.vjudge.net/problem/ZOJ-3777\n\n----------\n# 题目大意：\n 现在有一个N×N的矩阵，现在要求在这个矩阵里面取N个来自不同行不同列的数，使这个数大于给定的M。求总共有多少种取法。\n(N < 12, M < 500)\n\n-------------------------\n# 解题过程：\n 组队赛时候的题，当初是暴力DFS的，当作简化的八皇后问题，结果当然是超时。\n\n 最近开始补题，正好在刷DP的题，于是顺手切了，算是一个状压DP的模板题。\n\n-----------------------------\n\n# 题目分析：\n\n 首先看这个数据量，N和M的范围都非常小，显然可以拿来DP。一个题可以状态压缩，通常有几个量比较小，用来把状态压缩成二进制的数直接储存。\n\n 以DP的思路来讲，这题的状态应该是二维的，一个维度是存的状态压缩后的集合，另一个是储存的当前累加的和，DP数组是存的当前解的个数。\n \n 首先对于集合S，储存那些行已经有一个数被取了，这样可以保证一个无后效性，并且产生了许多重复子问题。如果前面已经取的点是集合S，并且前面的累加和是M。那么对于后面的数怎么取，有几个解，只需要计算一次即可。下一次如果一个状态仍是取的点的集合是S，并且累加和是M的话，那么直接用上一次计算的结果就可以了。\n\n 这样总共的复杂度是***O（2^N*M）***，即状态总数。\n\n\n---------------------\n\n# 记忆化搜索：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nint dp[(1<<13)][600];\nint n, m;\nint data[112][112];\n\n//计算阶乘\nint fun(int n) {\n    LL rst = 1;\n    for (int i = 1; i <= n; i++) {\n        rst *= i;\n    }\n    return rst;\n}\n\nint dfs(int dep, int num, int pre) {\n\n\t//递归边界\n    if (dep >= n) {\n        return num >= m;\n    }\n\n    int& ans = dp[pre][num];\n\n    if (ans != -1)\n        return dp[pre][num];\n\n    ans = 0;\n\n\t//剪枝，如果当前已满足了，那么只需要计算下剩下的组合个数\n    if (num >= m)\n        return ans = fun(n-dep);\n\n    for (int i = 0; i < n; i++) {\n        if (pre&(1<<i))\n            continue;\n        int temp = pre|(1<<i);\n        ans += dfs(dep+1, num+data[dep][i], temp);\n    }\n    return ans;\n}\n\n\n\nint main() {\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        memset(dp, -1, sizeof(dp));\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n            }\n        }\n\n        int aa = fun(n);\n        int bb = dfs(0, 0, 0);\n\n        if (bb != 0) {\n            int cc = __gcd(aa, bb);\n            aa /= cc;\n            bb /= cc;\n            printf(\"%d/%d\\n\", aa, bb);\n        }\n        else {\n            printf(\"No solution\\n\");\n        }\n    }\n}\n```\n\n# 递推：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<13][666];\nint data[112][112];\n\nint fun(int n) {\n    int rst = 1;\n    for (int i = 2; i <= n; i++)\n        rst *= i;\n    return rst;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n            }\n        }\n        memset(dp, 0, sizeof(dp));\n        \n        //代表对于前0行，使和为0的取法有1种\n        dp[0][0] = 1;\n\n\t\t\n\t\t//遍历每一种取法\n        for (int i = 0; i < (1<<n); i++) {\n            int cnt = 0;\n\t\t\t\n\t\t\t//计算取到了第几行\n            for (int j = 0; j < n; j++) {\n                if (i&(1<<j))\n                    cnt++;\n            }\n\t\t\t\n\t\t\t//尝试取下一个数\n            for (int j = 0; j < n; j++) {\n                if (i&(1<<j))\n                    continue;\n\t\t\t\t\n\t\t\t\t//遍历取到的和，如果和大于M，那么加到M那里\n                for (int k = 0; k <= m; k++) {\n\t\t\t\t\t\n\t\t\t\t\t//这里的思想类似背包\n                    if (k+data[cnt][j] >= m)\n                        dp[i+(1<<j)][m] += dp[i][k];\n                    else\n                        dp[i+(1<<j)][k+data[cnt][j]] += dp[i][k];\n                }\n            }\n        }\n        int ans = dp[(1<<n)-1][m];\n        if (ans == 0)\n            printf(\"No solution\\n\");\n        else {\n            int aa = fun(n);\n            int bb = __gcd(aa, ans);\n            printf(\"%d/%d\\n\", aa/bb, ans/bb);\n        }\n    }\n}\n```","source":"_posts/ZOJ3777-Problem-Arrangement（状压DP）.md","raw":"---\ntitle: ZOJ3777 - Problem Arrangement（状压DP）\ndate: 2017-05-12 21:53:47\ncategories: [ACM, DP, 状压DP]\ntags:\n---\n# 题目链接：\nhttps://cn.vjudge.net/problem/ZOJ-3777\n\n----------\n# 题目大意：\n 现在有一个N×N的矩阵，现在要求在这个矩阵里面取N个来自不同行不同列的数，使这个数大于给定的M。求总共有多少种取法。\n(N < 12, M < 500)\n\n-------------------------\n# 解题过程：\n 组队赛时候的题，当初是暴力DFS的，当作简化的八皇后问题，结果当然是超时。\n\n 最近开始补题，正好在刷DP的题，于是顺手切了，算是一个状压DP的模板题。\n\n-----------------------------\n\n# 题目分析：\n\n 首先看这个数据量，N和M的范围都非常小，显然可以拿来DP。一个题可以状态压缩，通常有几个量比较小，用来把状态压缩成二进制的数直接储存。\n\n 以DP的思路来讲，这题的状态应该是二维的，一个维度是存的状态压缩后的集合，另一个是储存的当前累加的和，DP数组是存的当前解的个数。\n \n 首先对于集合S，储存那些行已经有一个数被取了，这样可以保证一个无后效性，并且产生了许多重复子问题。如果前面已经取的点是集合S，并且前面的累加和是M。那么对于后面的数怎么取，有几个解，只需要计算一次即可。下一次如果一个状态仍是取的点的集合是S，并且累加和是M的话，那么直接用上一次计算的结果就可以了。\n\n 这样总共的复杂度是***O（2^N*M）***，即状态总数。\n\n\n---------------------\n\n# 记忆化搜索：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nint dp[(1<<13)][600];\nint n, m;\nint data[112][112];\n\n//计算阶乘\nint fun(int n) {\n    LL rst = 1;\n    for (int i = 1; i <= n; i++) {\n        rst *= i;\n    }\n    return rst;\n}\n\nint dfs(int dep, int num, int pre) {\n\n\t//递归边界\n    if (dep >= n) {\n        return num >= m;\n    }\n\n    int& ans = dp[pre][num];\n\n    if (ans != -1)\n        return dp[pre][num];\n\n    ans = 0;\n\n\t//剪枝，如果当前已满足了，那么只需要计算下剩下的组合个数\n    if (num >= m)\n        return ans = fun(n-dep);\n\n    for (int i = 0; i < n; i++) {\n        if (pre&(1<<i))\n            continue;\n        int temp = pre|(1<<i);\n        ans += dfs(dep+1, num+data[dep][i], temp);\n    }\n    return ans;\n}\n\n\n\nint main() {\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        memset(dp, -1, sizeof(dp));\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n            }\n        }\n\n        int aa = fun(n);\n        int bb = dfs(0, 0, 0);\n\n        if (bb != 0) {\n            int cc = __gcd(aa, bb);\n            aa /= cc;\n            bb /= cc;\n            printf(\"%d/%d\\n\", aa, bb);\n        }\n        else {\n            printf(\"No solution\\n\");\n        }\n    }\n}\n```\n\n# 递推：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<13][666];\nint data[112][112];\n\nint fun(int n) {\n    int rst = 1;\n    for (int i = 2; i <= n; i++)\n        rst *= i;\n    return rst;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &data[i][j]);\n            }\n        }\n        memset(dp, 0, sizeof(dp));\n        \n        //代表对于前0行，使和为0的取法有1种\n        dp[0][0] = 1;\n\n\t\t\n\t\t//遍历每一种取法\n        for (int i = 0; i < (1<<n); i++) {\n            int cnt = 0;\n\t\t\t\n\t\t\t//计算取到了第几行\n            for (int j = 0; j < n; j++) {\n                if (i&(1<<j))\n                    cnt++;\n            }\n\t\t\t\n\t\t\t//尝试取下一个数\n            for (int j = 0; j < n; j++) {\n                if (i&(1<<j))\n                    continue;\n\t\t\t\t\n\t\t\t\t//遍历取到的和，如果和大于M，那么加到M那里\n                for (int k = 0; k <= m; k++) {\n\t\t\t\t\t\n\t\t\t\t\t//这里的思想类似背包\n                    if (k+data[cnt][j] >= m)\n                        dp[i+(1<<j)][m] += dp[i][k];\n                    else\n                        dp[i+(1<<j)][k+data[cnt][j]] += dp[i][k];\n                }\n            }\n        }\n        int ans = dp[(1<<n)-1][m];\n        if (ans == 0)\n            printf(\"No solution\\n\");\n        else {\n            int aa = fun(n);\n            int bb = __gcd(aa, ans);\n            printf(\"%d/%d\\n\", aa/bb, ans/bb);\n        }\n    }\n}\n```","slug":"ZOJ3777-Problem-Arrangement（状压DP）","published":1,"updated":"2017-07-23T02:34:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6neo005oy9idpaogdzao","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/ZOJ-3777\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/ZOJ-3777</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有一个N×N的矩阵，现在要求在这个矩阵里面取N个来自不同行不同列的数，使这个数大于给定的M。求总共有多少种取法。<br>(N &lt; 12, M &lt; 500)</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 组队赛时候的题，当初是暴力DFS的，当作简化的八皇后问题，结果当然是超时。</p>\n<p> 最近开始补题，正好在刷DP的题，于是顺手切了，算是一个状压DP的模板题。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先看这个数据量，N和M的范围都非常小，显然可以拿来DP。一个题可以状态压缩，通常有几个量比较小，用来把状态压缩成二进制的数直接储存。</p>\n<p> 以DP的思路来讲，这题的状态应该是二维的，一个维度是存的状态压缩后的集合，另一个是储存的当前累加的和，DP数组是存的当前解的个数。</p>\n<p> 首先对于集合S，储存那些行已经有一个数被取了，这样可以保证一个无后效性，并且产生了许多重复子问题。如果前面已经取的点是集合S，并且前面的累加和是M。那么对于后面的数怎么取，有几个解，只需要计算一次即可。下一次如果一个状态仍是取的点的集合是S，并且累加和是M的话，那么直接用上一次计算的结果就可以了。</p>\n<p> 这样总共的复杂度是<strong><em>O（2^N</em>M）*</strong>，即状态总数。</p>\n<hr>\n<h1 id=\"记忆化搜索：\"><a href=\"#记忆化搜索：\" class=\"headerlink\" title=\"记忆化搜索：\"></a>记忆化搜索：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">13</span>)][<span class=\"number\">600</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//计算阶乘</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    LL rst = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        rst *= i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep, <span class=\"keyword\">int</span> num, <span class=\"keyword\">int</span> pre)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//递归边界</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (dep &gt;= n) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> num &gt;= m;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; ans = dp[pre][num];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans != <span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> dp[pre][num];</div><div class=\"line\"></div><div class=\"line\">    ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//剪枝，如果当前已满足了，那么只需要计算下剩下的组合个数</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (num &gt;= m)</div><div class=\"line\">        <span class=\"keyword\">return</span> ans = fun(n-dep);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pre&amp;(<span class=\"number\">1</span>&lt;&lt;i))</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> temp = pre|(<span class=\"number\">1</span>&lt;&lt;i);</div><div class=\"line\">        ans += dfs(dep+<span class=\"number\">1</span>, num+data[dep][i], temp);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> aa = fun(n);</div><div class=\"line\">        <span class=\"keyword\">int</span> bb = dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cc = __gcd(aa, bb);</div><div class=\"line\">            aa /= cc;</div><div class=\"line\">            bb /= cc;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d/%d\\n\"</span>, aa, bb);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No solution\\n\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"递推：\"><a href=\"#递推：\" class=\"headerlink\" title=\"递推：\"></a>递推：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">13</span>][<span class=\"number\">666</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)</div><div class=\"line\">        rst *= i;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//代表对于前0行，使和为0的取法有1种</span></div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">//遍历每一种取法</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span>&lt;&lt;n); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t<span class=\"comment\">//计算取到了第几行</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i&amp;(<span class=\"number\">1</span>&lt;&lt;j))</div><div class=\"line\">                    cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t<span class=\"comment\">//尝试取下一个数</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i&amp;(<span class=\"number\">1</span>&lt;&lt;j))</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//遍历取到的和，如果和大于M，那么加到M那里</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= m; k++) &#123;</div><div class=\"line\">\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">//这里的思想类似背包</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (k+data[cnt][j] &gt;= m)</div><div class=\"line\">                        dp[i+(<span class=\"number\">1</span>&lt;&lt;j)][m] += dp[i][k];</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        dp[i+(<span class=\"number\">1</span>&lt;&lt;j)][k+data[cnt][j]] += dp[i][k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = dp[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>][m];</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans == <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No solution\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> aa = fun(n);</div><div class=\"line\">            <span class=\"keyword\">int</span> bb = __gcd(aa, ans);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d/%d\\n\"</span>, aa/bb, ans/bb);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"https://cn.vjudge.net/problem/ZOJ-3777\" target=\"_blank\" rel=\"external\">https://cn.vjudge.net/problem/ZOJ-3777</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 现在有一个N×N的矩阵，现在要求在这个矩阵里面取N个来自不同行不同列的数，使这个数大于给定的M。求总共有多少种取法。<br>(N &lt; 12, M &lt; 500)</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 组队赛时候的题，当初是暴力DFS的，当作简化的八皇后问题，结果当然是超时。</p>\n<p> 最近开始补题，正好在刷DP的题，于是顺手切了，算是一个状压DP的模板题。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p> 首先看这个数据量，N和M的范围都非常小，显然可以拿来DP。一个题可以状态压缩，通常有几个量比较小，用来把状态压缩成二进制的数直接储存。</p>\n<p> 以DP的思路来讲，这题的状态应该是二维的，一个维度是存的状态压缩后的集合，另一个是储存的当前累加的和，DP数组是存的当前解的个数。</p>\n<p> 首先对于集合S，储存那些行已经有一个数被取了，这样可以保证一个无后效性，并且产生了许多重复子问题。如果前面已经取的点是集合S，并且前面的累加和是M。那么对于后面的数怎么取，有几个解，只需要计算一次即可。下一次如果一个状态仍是取的点的集合是S，并且累加和是M的话，那么直接用上一次计算的结果就可以了。</p>\n<p> 这样总共的复杂度是<strong><em>O（2^N</em>M）*</strong>，即状态总数。</p>\n<hr>\n<h1 id=\"记忆化搜索：\"><a href=\"#记忆化搜索：\" class=\"headerlink\" title=\"记忆化搜索：\"></a>记忆化搜索：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">13</span>)][<span class=\"number\">600</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> n, m;</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//计算阶乘</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    LL rst = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        rst *= i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep, <span class=\"keyword\">int</span> num, <span class=\"keyword\">int</span> pre)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//递归边界</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (dep &gt;= n) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> num &gt;= m;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span>&amp; ans = dp[pre][num];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (ans != <span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> dp[pre][num];</div><div class=\"line\"></div><div class=\"line\">    ans = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//剪枝，如果当前已满足了，那么只需要计算下剩下的组合个数</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (num &gt;= m)</div><div class=\"line\">        <span class=\"keyword\">return</span> ans = fun(n-dep);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pre&amp;(<span class=\"number\">1</span>&lt;&lt;i))</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> temp = pre|(<span class=\"number\">1</span>&lt;&lt;i);</div><div class=\"line\">        ans += dfs(dep+<span class=\"number\">1</span>, num+data[dep][i], temp);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> aa = fun(n);</div><div class=\"line\">        <span class=\"keyword\">int</span> bb = dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (bb != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cc = __gcd(aa, bb);</div><div class=\"line\">            aa /= cc;</div><div class=\"line\">            bb /= cc;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d/%d\\n\"</span>, aa, bb);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No solution\\n\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"递推：\"><a href=\"#递推：\" class=\"headerlink\" title=\"递推：\"></a>递推：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">13</span>][<span class=\"number\">666</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rst = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)</div><div class=\"line\">        rst *= i;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//代表对于前0行，使和为0的取法有1种</span></div><div class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">//遍历每一种取法</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span>&lt;&lt;n); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t<span class=\"comment\">//计算取到了第几行</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i&amp;(<span class=\"number\">1</span>&lt;&lt;j))</div><div class=\"line\">                    cnt++;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t<span class=\"comment\">//尝试取下一个数</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i&amp;(<span class=\"number\">1</span>&lt;&lt;j))</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//遍历取到的和，如果和大于M，那么加到M那里</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= m; k++) &#123;</div><div class=\"line\">\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">//这里的思想类似背包</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (k+data[cnt][j] &gt;= m)</div><div class=\"line\">                        dp[i+(<span class=\"number\">1</span>&lt;&lt;j)][m] += dp[i][k];</div><div class=\"line\">                    <span class=\"keyword\">else</span></div><div class=\"line\">                        dp[i+(<span class=\"number\">1</span>&lt;&lt;j)][k+data[cnt][j]] += dp[i][k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = dp[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>][m];</div><div class=\"line\">        <span class=\"keyword\">if</span> (ans == <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No solution\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> aa = fun(n);</div><div class=\"line\">            <span class=\"keyword\">int</span> bb = __gcd(aa, ans);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d/%d\\n\"</span>, aa/bb, ans/bb);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"ZOJ3385 - Hanami Party （贪心）","date":"2017-06-25T12:48:24.000Z","_content":"# 题目链接：\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385\n\n-------------------------\n# 题目大意：\n妖梦要准备一个party，所以需要许多食物，初始化妖梦的烹饪技能为$L$，每天妖梦有两种选择，一是选择当天做$L$个食物，二是提升自己的烹饪技能为$L+1$。\n\n但是幽幽子非常能吃，每天幽幽子都要吃$A_i$的食物，当没食物吃后幽幽子会非常生气，甚至想把妖梦批判一番。所以现在妖梦要保证做出的食物每天够幽幽子吃的情况下尽量的多。\n\n-----------------------------------\n# 解题过程：\n好久好久之前比赛的题，一直没补，当初知道是贪心和栈，感觉这样的思维题加简单的数据结构的题非常难……也可能是直接接触的题太少吧。\n\n--------------------------------\n# 题目分析：\n\n首先用栈去贪心的模拟，在能保证够幽幽子吃的情况下，最多能够将技能提高到几级。\n\n假设每天都提高等级并且将天数入栈，当当前剩下的食物不够幽幽子吃的话，将上一次提升等级的地方换成做食物。如果还是不够幽幽子吃的话，那么就是无解的。\n\n因为提高等级是一个持久性的加成，当然是越早提升越好，所以每次将提高等级换做做食物的地方都是最晚的地方。\n\n这样求解出最高可以升到几级后，再去求下最大能达到多少食物。\n\n同样效仿上面的操作，每次取出最近的提升等级的地方换成做食物，去维护一个最大值。\n\n不过有可能有这样的一个情况，在租个替换掉提升等级时，可能某个地方替换掉提升等级后食物就不够幽幽子吃了。但是这种情况，求出的结果肯定比维护的最大值要小，因为现在食物不够吃了，并且等级还低了，那么最后算出的剩余一定是更小的。\n\n------------------------\n# AC代码：\n```cpp\n#include <stdio.h>\n#include <stack>\nusing namespace std;\n\ntypedef long long LL;\n\nint main() {\n    LL N, L;\n    while (~scanf(\"%lld %lld\", &N, &L)) {\n        LL sum = 0;\n        bool flag = true;\n        stack<LL> ss;\n        for (int i = 1; i <= N; i++) {\n            LL eat;\n            //每天要吃的食物数\n            scanf(\"%lld\", &eat);\n            if (!flag)\n                continue;\n            ss.push(i);\n            L++;\n\n            //如果当前剩余的食物不够的话，去替换掉之前提升等级\n            while (sum < eat && !ss.empty()) {\n                LL t = ss.top();\n                L--;\n                ss.pop();\n                //将提升等级替换成做食物是很容易维护的，首先让等级减一，加上等级，然后当从提升等级那天到至今的提升等级的加成减去\n                sum += L - (i-t);\n            }\n            if (sum < eat) {\n                flag = false;\n                continue;\n            }\n            sum -= eat;\n        }\n        if (!flag) {\n            printf(\"Myon\\n\");\n            continue;\n        }\n        LL ans = sum;\n\n\n        //求出最大值，类似上面的过程\n        while (!ss.empty()) {\n            LL t = ss.top();\n            L--;\n            ss.pop();\n            sum += L - (N - t);\n            ans = max(ans, sum);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}\n```","source":"_posts/ZOJ3385-Hanami-Party-（贪心）.md","raw":"---\ntitle: ZOJ3385 - Hanami Party （贪心）\ndate: 2017-06-25 20:48:24\ncategories: [ACM, 贪心]\ntags:\n---\n# 题目链接：\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385\n\n-------------------------\n# 题目大意：\n妖梦要准备一个party，所以需要许多食物，初始化妖梦的烹饪技能为$L$，每天妖梦有两种选择，一是选择当天做$L$个食物，二是提升自己的烹饪技能为$L+1$。\n\n但是幽幽子非常能吃，每天幽幽子都要吃$A_i$的食物，当没食物吃后幽幽子会非常生气，甚至想把妖梦批判一番。所以现在妖梦要保证做出的食物每天够幽幽子吃的情况下尽量的多。\n\n-----------------------------------\n# 解题过程：\n好久好久之前比赛的题，一直没补，当初知道是贪心和栈，感觉这样的思维题加简单的数据结构的题非常难……也可能是直接接触的题太少吧。\n\n--------------------------------\n# 题目分析：\n\n首先用栈去贪心的模拟，在能保证够幽幽子吃的情况下，最多能够将技能提高到几级。\n\n假设每天都提高等级并且将天数入栈，当当前剩下的食物不够幽幽子吃的话，将上一次提升等级的地方换成做食物。如果还是不够幽幽子吃的话，那么就是无解的。\n\n因为提高等级是一个持久性的加成，当然是越早提升越好，所以每次将提高等级换做做食物的地方都是最晚的地方。\n\n这样求解出最高可以升到几级后，再去求下最大能达到多少食物。\n\n同样效仿上面的操作，每次取出最近的提升等级的地方换成做食物，去维护一个最大值。\n\n不过有可能有这样的一个情况，在租个替换掉提升等级时，可能某个地方替换掉提升等级后食物就不够幽幽子吃了。但是这种情况，求出的结果肯定比维护的最大值要小，因为现在食物不够吃了，并且等级还低了，那么最后算出的剩余一定是更小的。\n\n------------------------\n# AC代码：\n```cpp\n#include <stdio.h>\n#include <stack>\nusing namespace std;\n\ntypedef long long LL;\n\nint main() {\n    LL N, L;\n    while (~scanf(\"%lld %lld\", &N, &L)) {\n        LL sum = 0;\n        bool flag = true;\n        stack<LL> ss;\n        for (int i = 1; i <= N; i++) {\n            LL eat;\n            //每天要吃的食物数\n            scanf(\"%lld\", &eat);\n            if (!flag)\n                continue;\n            ss.push(i);\n            L++;\n\n            //如果当前剩余的食物不够的话，去替换掉之前提升等级\n            while (sum < eat && !ss.empty()) {\n                LL t = ss.top();\n                L--;\n                ss.pop();\n                //将提升等级替换成做食物是很容易维护的，首先让等级减一，加上等级，然后当从提升等级那天到至今的提升等级的加成减去\n                sum += L - (i-t);\n            }\n            if (sum < eat) {\n                flag = false;\n                continue;\n            }\n            sum -= eat;\n        }\n        if (!flag) {\n            printf(\"Myon\\n\");\n            continue;\n        }\n        LL ans = sum;\n\n\n        //求出最大值，类似上面的过程\n        while (!ss.empty()) {\n            LL t = ss.top();\n            L--;\n            ss.pop();\n            sum += L - (N - t);\n            ans = max(ans, sum);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}\n```","slug":"ZOJ3385-Hanami-Party-（贪心）","published":1,"updated":"2017-07-23T01:54:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6neq005ry9iduggwnpxb","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385\" target=\"_blank\" rel=\"external\">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>妖梦要准备一个party，所以需要许多食物，初始化妖梦的烹饪技能为$L$，每天妖梦有两种选择，一是选择当天做$L$个食物，二是提升自己的烹饪技能为$L+1$。</p>\n<p>但是幽幽子非常能吃，每天幽幽子都要吃$A_i$的食物，当没食物吃后幽幽子会非常生气，甚至想把妖梦批判一番。所以现在妖梦要保证做出的食物每天够幽幽子吃的情况下尽量的多。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>好久好久之前比赛的题，一直没补，当初知道是贪心和栈，感觉这样的思维题加简单的数据结构的题非常难……也可能是直接接触的题太少吧。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先用栈去贪心的模拟，在能保证够幽幽子吃的情况下，最多能够将技能提高到几级。</p>\n<p>假设每天都提高等级并且将天数入栈，当当前剩下的食物不够幽幽子吃的话，将上一次提升等级的地方换成做食物。如果还是不够幽幽子吃的话，那么就是无解的。</p>\n<p>因为提高等级是一个持久性的加成，当然是越早提升越好，所以每次将提高等级换做做食物的地方都是最晚的地方。</p>\n<p>这样求解出最高可以升到几级后，再去求下最大能达到多少食物。</p>\n<p>同样效仿上面的操作，每次取出最近的提升等级的地方换成做食物，去维护一个最大值。</p>\n<p>不过有可能有这样的一个情况，在租个替换掉提升等级时，可能某个地方替换掉提升等级后食物就不够幽幽子吃了。但是这种情况，求出的结果肯定比维护的最大值要小，因为现在食物不够吃了，并且等级还低了，那么最后算出的剩余一定是更小的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    LL N, L;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;N, &amp;L)) &#123;</div><div class=\"line\">        LL sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"built_in\">stack</span>&lt;LL&gt; ss;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            LL eat;</div><div class=\"line\">            <span class=\"comment\">//每天要吃的食物数</span></div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;eat);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!flag)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            ss.push(i);</div><div class=\"line\">            L++;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果当前剩余的食物不够的话，去替换掉之前提升等级</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (sum &lt; eat &amp;&amp; !ss.empty()) &#123;</div><div class=\"line\">                LL t = ss.top();</div><div class=\"line\">                L--;</div><div class=\"line\">                ss.pop();</div><div class=\"line\">                <span class=\"comment\">//将提升等级替换成做食物是很容易维护的，首先让等级减一，加上等级，然后当从提升等级那天到至今的提升等级的加成减去</span></div><div class=\"line\">                sum += L - (i-t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; eat) &#123;</div><div class=\"line\">                flag = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum -= eat;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Myon\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        LL ans = sum;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//求出最大值，类似上面的过程</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (!ss.empty()) &#123;</div><div class=\"line\">            LL t = ss.top();</div><div class=\"line\">            L--;</div><div class=\"line\">            ss.pop();</div><div class=\"line\">            sum += L - (N - t);</div><div class=\"line\">            ans = max(ans, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385\" target=\"_blank\" rel=\"external\">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3385</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>妖梦要准备一个party，所以需要许多食物，初始化妖梦的烹饪技能为$L$，每天妖梦有两种选择，一是选择当天做$L$个食物，二是提升自己的烹饪技能为$L+1$。</p>\n<p>但是幽幽子非常能吃，每天幽幽子都要吃$A_i$的食物，当没食物吃后幽幽子会非常生气，甚至想把妖梦批判一番。所以现在妖梦要保证做出的食物每天够幽幽子吃的情况下尽量的多。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>好久好久之前比赛的题，一直没补，当初知道是贪心和栈，感觉这样的思维题加简单的数据结构的题非常难……也可能是直接接触的题太少吧。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>首先用栈去贪心的模拟，在能保证够幽幽子吃的情况下，最多能够将技能提高到几级。</p>\n<p>假设每天都提高等级并且将天数入栈，当当前剩下的食物不够幽幽子吃的话，将上一次提升等级的地方换成做食物。如果还是不够幽幽子吃的话，那么就是无解的。</p>\n<p>因为提高等级是一个持久性的加成，当然是越早提升越好，所以每次将提高等级换做做食物的地方都是最晚的地方。</p>\n<p>这样求解出最高可以升到几级后，再去求下最大能达到多少食物。</p>\n<p>同样效仿上面的操作，每次取出最近的提升等级的地方换成做食物，去维护一个最大值。</p>\n<p>不过有可能有这样的一个情况，在租个替换掉提升等级时，可能某个地方替换掉提升等级后食物就不够幽幽子吃了。但是这种情况，求出的结果肯定比维护的最大值要小，因为现在食物不够吃了，并且等级还低了，那么最后算出的剩余一定是更小的。</p>\n<hr>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    LL N, L;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>, &amp;N, &amp;L)) &#123;</div><div class=\"line\">        LL sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"built_in\">stack</span>&lt;LL&gt; ss;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</div><div class=\"line\">            LL eat;</div><div class=\"line\">            <span class=\"comment\">//每天要吃的食物数</span></div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;eat);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!flag)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            ss.push(i);</div><div class=\"line\">            L++;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果当前剩余的食物不够的话，去替换掉之前提升等级</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (sum &lt; eat &amp;&amp; !ss.empty()) &#123;</div><div class=\"line\">                LL t = ss.top();</div><div class=\"line\">                L--;</div><div class=\"line\">                ss.pop();</div><div class=\"line\">                <span class=\"comment\">//将提升等级替换成做食物是很容易维护的，首先让等级减一，加上等级，然后当从提升等级那天到至今的提升等级的加成减去</span></div><div class=\"line\">                sum += L - (i-t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; eat) &#123;</div><div class=\"line\">                flag = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sum -= eat;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Myon\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        LL ans = sum;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//求出最大值，类似上面的过程</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (!ss.empty()) &#123;</div><div class=\"line\">            LL t = ss.top();</div><div class=\"line\">            L--;</div><div class=\"line\">            ss.pop();</div><div class=\"line\">            sum += L - (N - t);</div><div class=\"line\">            ans = max(ans, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"webpy服务器（Linux+Web+HTML）","date":"2017-02-17T03:38:51.000Z","_content":"# 前言：\n--------------\n刚开始在慕课网上面看到了一个webpy的视频，正好自己有个服务器，想搭个网站玩玩，然后webpy比较简单，所以拿这个动手了，以后可能去用别的库去做网页。\n\n网页也是看了一下午的HTML的标签什么的，CSS还没学，随手写了个简单的，带个 POST 请求。\n\n\n# Web程序：\n--------------------\n## URL解析：\n---------------\n首先在程序开头放上这样一段代码：\n```python\nurls = ('/','index',\n        '/(\\d+)', 'read',\n        '/(.*)', 'other')\napp = web.application(urls, globals())\n```\n这样用来匹配访问url，要去执行那个类。\n\n匹配方式，分**精确匹配**，**模糊匹配**两种，模糊匹配可以实现带组匹配，即上面加的那一个括号，这样会把括号中匹配的数据以 **name** 变量传递给类的方法。\n\n## 实现响应：\n--------------------\n每个url匹配后对应一个类，在类里面实现网页中请求的方法就好了，比如 **GET**，**POST** 。\n\n```python\nclass index:\n\n    def __init__(self):\n        self.reader = read()\n\n    def GET(self):\n        with open('html/index.html', 'rb') as f:\n            html = f.read()\n        return html\n\n    def POST(self):\n        data = web.data()\n        data = urllib.unquote_plus(data)\n        with open('temp ', 'wb') as f:\n            f.write(data)\n\n\nclass read:\n\n    def GET(self, name):\n        print name\n\n```\n## 启动Web程序：\n---------------\n因为是在 Linux 服务器上运行的，直接输入一下代码：\n```shell\nnohup python test.py 45.76.206.109:80 &\n```\n记得 ip 后面带上端口号。\n\n# HTML网页：\n---------------\n## from标签：\n--------------\n这里的 action 大概是指用 method 里面的方法，访问了** [主域名] + [action]**。\n例如下面的，相当于 **POST** 了 **acmfish.top/**，然后根据 URL 匹配，调用了 **index** 类的 **POST** 方法。\n```html\n<form method=\"post\" action=\"/\">\n\t<div align=\"center\">\n\t\t<label>PID:</label>\n\t\t<input type=\"text\" name=\"PID\">\n\t\t<input type=\"submit\" value=\"Submit\">\n\t</div>\n</form>\n```\n\n# 全部代码：\n--------------\n## Web程序：\n------------------\n```python\nimport web\n\nurls = ('/','index',\n        '/(\\d+)', 'read',\n        '/(.*)', 'other')\napp = web.application(urls, globals())\n\nclass index:\n\n    def __init__(self):\n        self.reader = read()\n\n    def GET(self):\n        with open('html/index.html', 'rb') as f:\n            html = f.read()\n        return html\n\n    def POST(self):\n        data = web.data()\n        return self.reader.GET(data[4:])\n\nclass read:\n\n    def __init__(self):\n        self.head = '''<html>\n<head>\n        <meta charset=\"utf-8\"/>\n        <title>Code</title>\n</head>\n<body>\n<pre>'''\n        self.tail = '''</pre>\n</body>\n</html>'''\n\n    def GET(self, name):\n        path = 'code/'+name\n        try:\n            with open(path, 'rb') as f:\n                text = f.read()\n                return text\n        except IOError:\n            return 'File not find'\n\nclass other:\n    def GET(self, name):\n        return 'Not find'\n\nif __name__ == \"__main__\":\n    app.run()\n\n```\n## HTML：\n-----------------\n```html\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\n\t<title>Get Code</title>\n\t<style>\n\t\ta{\n\t\tcolor:#40668c;\n\t\t}\n\t\tlabel{\n\t\tcolor:#000000;\n\t\t}\n\t\tinput{\n\t\tcolor:#000000;\n\t\t}\n\t</style>\n</head>\n<body>\n<h1 align=\"center\">Get Code</h1> <hr color=\"#000000\">\n<br><br><br>\n<h2 align=\"center\">请直接访问<a href=\"/1000\">45.76.206.109/1000</a>以获取PID为1000题目代码。</h2>\n<h2 align=\"center\">或</h2>\n<h2 align=\"center\">快捷搜索</h2>\n<form method=\"post\" action=\"/\">\n\t<div align=\"center\">\n\t\t<label>PID:</label>\n\t\t<input type=\"text\" name=\"PID\">\n\t\t<input type=\"submit\" value=\"Submit\">\n\t</div>\n</form>\n\n\n</body></html>\n\n```","source":"_posts/webpy服务器（Linux-Web-HTML）.md","raw":"---\ntitle: webpy服务器（Linux+Web+HTML）\ndate: 2017-02-17 11:38:51\ncategories: [网页设计, Web服务器]\ntags:\n---\n# 前言：\n--------------\n刚开始在慕课网上面看到了一个webpy的视频，正好自己有个服务器，想搭个网站玩玩，然后webpy比较简单，所以拿这个动手了，以后可能去用别的库去做网页。\n\n网页也是看了一下午的HTML的标签什么的，CSS还没学，随手写了个简单的，带个 POST 请求。\n\n\n# Web程序：\n--------------------\n## URL解析：\n---------------\n首先在程序开头放上这样一段代码：\n```python\nurls = ('/','index',\n        '/(\\d+)', 'read',\n        '/(.*)', 'other')\napp = web.application(urls, globals())\n```\n这样用来匹配访问url，要去执行那个类。\n\n匹配方式，分**精确匹配**，**模糊匹配**两种，模糊匹配可以实现带组匹配，即上面加的那一个括号，这样会把括号中匹配的数据以 **name** 变量传递给类的方法。\n\n## 实现响应：\n--------------------\n每个url匹配后对应一个类，在类里面实现网页中请求的方法就好了，比如 **GET**，**POST** 。\n\n```python\nclass index:\n\n    def __init__(self):\n        self.reader = read()\n\n    def GET(self):\n        with open('html/index.html', 'rb') as f:\n            html = f.read()\n        return html\n\n    def POST(self):\n        data = web.data()\n        data = urllib.unquote_plus(data)\n        with open('temp ', 'wb') as f:\n            f.write(data)\n\n\nclass read:\n\n    def GET(self, name):\n        print name\n\n```\n## 启动Web程序：\n---------------\n因为是在 Linux 服务器上运行的，直接输入一下代码：\n```shell\nnohup python test.py 45.76.206.109:80 &\n```\n记得 ip 后面带上端口号。\n\n# HTML网页：\n---------------\n## from标签：\n--------------\n这里的 action 大概是指用 method 里面的方法，访问了** [主域名] + [action]**。\n例如下面的，相当于 **POST** 了 **acmfish.top/**，然后根据 URL 匹配，调用了 **index** 类的 **POST** 方法。\n```html\n<form method=\"post\" action=\"/\">\n\t<div align=\"center\">\n\t\t<label>PID:</label>\n\t\t<input type=\"text\" name=\"PID\">\n\t\t<input type=\"submit\" value=\"Submit\">\n\t</div>\n</form>\n```\n\n# 全部代码：\n--------------\n## Web程序：\n------------------\n```python\nimport web\n\nurls = ('/','index',\n        '/(\\d+)', 'read',\n        '/(.*)', 'other')\napp = web.application(urls, globals())\n\nclass index:\n\n    def __init__(self):\n        self.reader = read()\n\n    def GET(self):\n        with open('html/index.html', 'rb') as f:\n            html = f.read()\n        return html\n\n    def POST(self):\n        data = web.data()\n        return self.reader.GET(data[4:])\n\nclass read:\n\n    def __init__(self):\n        self.head = '''<html>\n<head>\n        <meta charset=\"utf-8\"/>\n        <title>Code</title>\n</head>\n<body>\n<pre>'''\n        self.tail = '''</pre>\n</body>\n</html>'''\n\n    def GET(self, name):\n        path = 'code/'+name\n        try:\n            with open(path, 'rb') as f:\n                text = f.read()\n                return text\n        except IOError:\n            return 'File not find'\n\nclass other:\n    def GET(self, name):\n        return 'Not find'\n\nif __name__ == \"__main__\":\n    app.run()\n\n```\n## HTML：\n-----------------\n```html\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\n\t<title>Get Code</title>\n\t<style>\n\t\ta{\n\t\tcolor:#40668c;\n\t\t}\n\t\tlabel{\n\t\tcolor:#000000;\n\t\t}\n\t\tinput{\n\t\tcolor:#000000;\n\t\t}\n\t</style>\n</head>\n<body>\n<h1 align=\"center\">Get Code</h1> <hr color=\"#000000\">\n<br><br><br>\n<h2 align=\"center\">请直接访问<a href=\"/1000\">45.76.206.109/1000</a>以获取PID为1000题目代码。</h2>\n<h2 align=\"center\">或</h2>\n<h2 align=\"center\">快捷搜索</h2>\n<form method=\"post\" action=\"/\">\n\t<div align=\"center\">\n\t\t<label>PID:</label>\n\t\t<input type=\"text\" name=\"PID\">\n\t\t<input type=\"submit\" value=\"Submit\">\n\t</div>\n</form>\n\n\n</body></html>\n\n```","slug":"webpy服务器（Linux-Web-HTML）","published":1,"updated":"2017-07-23T03:03:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6net005ty9idw9a9jlci","content":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><hr>\n<p>刚开始在慕课网上面看到了一个webpy的视频，正好自己有个服务器，想搭个网站玩玩，然后webpy比较简单，所以拿这个动手了，以后可能去用别的库去做网页。</p>\n<p>网页也是看了一下午的HTML的标签什么的，CSS还没学，随手写了个简单的，带个 POST 请求。</p>\n<h1 id=\"Web程序：\"><a href=\"#Web程序：\" class=\"headerlink\" title=\"Web程序：\"></a>Web程序：</h1><hr>\n<h2 id=\"URL解析：\"><a href=\"#URL解析：\" class=\"headerlink\" title=\"URL解析：\"></a>URL解析：</h2><hr>\n<p>首先在程序开头放上这样一段代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">urls = (<span class=\"string\">'/'</span>,<span class=\"string\">'index'</span>,</div><div class=\"line\">        <span class=\"string\">'/(\\d+)'</span>, <span class=\"string\">'read'</span>,</div><div class=\"line\">        <span class=\"string\">'/(.*)'</span>, <span class=\"string\">'other'</span>)</div><div class=\"line\">app = web.application(urls, globals())</div></pre></td></tr></table></figure></p>\n<p>这样用来匹配访问url，要去执行那个类。</p>\n<p>匹配方式，分<strong>精确匹配</strong>，<strong>模糊匹配</strong>两种，模糊匹配可以实现带组匹配，即上面加的那一个括号，这样会把括号中匹配的数据以 <strong>name</strong> 变量传递给类的方法。</p>\n<h2 id=\"实现响应：\"><a href=\"#实现响应：\" class=\"headerlink\" title=\"实现响应：\"></a>实现响应：</h2><hr>\n<p>每个url匹配后对应一个类，在类里面实现网页中请求的方法就好了，比如 <strong>GET</strong>，<strong>POST</strong> 。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">index</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.reader = read()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'html/index.html'</span>, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            html = f.read()</div><div class=\"line\">        <span class=\"keyword\">return</span> html</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">POST</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = web.data()</div><div class=\"line\">        data = urllib.unquote_plus(data)</div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'temp '</span>, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(data)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">read</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> name</div></pre></td></tr></table></figure>\n<h2 id=\"启动Web程序：\"><a href=\"#启动Web程序：\" class=\"headerlink\" title=\"启动Web程序：\"></a>启动Web程序：</h2><hr>\n<p>因为是在 Linux 服务器上运行的，直接输入一下代码：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup python test.py 45.76.206.109:80 &amp;</div></pre></td></tr></table></figure></p>\n<p>记得 ip 后面带上端口号。</p>\n<h1 id=\"HTML网页：\"><a href=\"#HTML网页：\" class=\"headerlink\" title=\"HTML网页：\"></a>HTML网页：</h1><hr>\n<h2 id=\"from标签：\"><a href=\"#from标签：\" class=\"headerlink\" title=\"from标签：\"></a>from标签：</h2><hr>\n<p>这里的 action 大概是指用 method 里面的方法，访问了<strong> [主域名] + [action]</strong>。<br>例如下面的，相当于 <strong>POST</strong> 了 <strong>acmfish.top/</strong>，然后根据 URL 匹配，调用了 <strong>index</strong> 类的 <strong>POST</strong> 方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>PID:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"PID\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"全部代码：\"><a href=\"#全部代码：\" class=\"headerlink\" title=\"全部代码：\"></a>全部代码：</h1><hr>\n<h2 id=\"Web程序：-1\"><a href=\"#Web程序：-1\" class=\"headerlink\" title=\"Web程序：\"></a>Web程序：</h2><hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> web</div><div class=\"line\"></div><div class=\"line\">urls = (<span class=\"string\">'/'</span>,<span class=\"string\">'index'</span>,</div><div class=\"line\">        <span class=\"string\">'/(\\d+)'</span>, <span class=\"string\">'read'</span>,</div><div class=\"line\">        <span class=\"string\">'/(.*)'</span>, <span class=\"string\">'other'</span>)</div><div class=\"line\">app = web.application(urls, globals())</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">index</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.reader = read()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'html/index.html'</span>, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            html = f.read()</div><div class=\"line\">        <span class=\"keyword\">return</span> html</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">POST</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = web.data()</div><div class=\"line\">        <span class=\"keyword\">return</span> self.reader.GET(data[<span class=\"number\">4</span>:])</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">read</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.head = <span class=\"string\">'''&lt;html&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;head&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;meta charset=\"utf-8\"/&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;title&gt;Code&lt;/title&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/head&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;pre&gt;'''</span></div><div class=\"line\">        self.tail = <span class=\"string\">'''&lt;/pre&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/html&gt;'''</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        path = <span class=\"string\">'code/'</span>+name</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">with</span> open(path, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">                text = f.read()</div><div class=\"line\">                <span class=\"keyword\">return</span> text</div><div class=\"line\">        <span class=\"keyword\">except</span> IOError:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'File not find'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">other</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Not find'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"HTML：\"><a href=\"#HTML：\" class=\"headerlink\" title=\"HTML：\"></a>HTML：</h2><hr>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=UTF-8\"</span>&gt;</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Get Code<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">\t\ta&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#40668c;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t\tlabel&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#000000;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t\tinput&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#000000;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>Get Code<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">hr</span> <span class=\"attr\">color</span>=<span class=\"string\">\"#000000\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>请直接访问<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/1000\"</span>&gt;</span>45.76.206.109/1000<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>以获取PID为1000题目代码。<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>或<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>快捷搜索<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>PID:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"PID\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><hr>\n<p>刚开始在慕课网上面看到了一个webpy的视频，正好自己有个服务器，想搭个网站玩玩，然后webpy比较简单，所以拿这个动手了，以后可能去用别的库去做网页。</p>\n<p>网页也是看了一下午的HTML的标签什么的，CSS还没学，随手写了个简单的，带个 POST 请求。</p>\n<h1 id=\"Web程序：\"><a href=\"#Web程序：\" class=\"headerlink\" title=\"Web程序：\"></a>Web程序：</h1><hr>\n<h2 id=\"URL解析：\"><a href=\"#URL解析：\" class=\"headerlink\" title=\"URL解析：\"></a>URL解析：</h2><hr>\n<p>首先在程序开头放上这样一段代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">urls = (<span class=\"string\">'/'</span>,<span class=\"string\">'index'</span>,</div><div class=\"line\">        <span class=\"string\">'/(\\d+)'</span>, <span class=\"string\">'read'</span>,</div><div class=\"line\">        <span class=\"string\">'/(.*)'</span>, <span class=\"string\">'other'</span>)</div><div class=\"line\">app = web.application(urls, globals())</div></pre></td></tr></table></figure></p>\n<p>这样用来匹配访问url，要去执行那个类。</p>\n<p>匹配方式，分<strong>精确匹配</strong>，<strong>模糊匹配</strong>两种，模糊匹配可以实现带组匹配，即上面加的那一个括号，这样会把括号中匹配的数据以 <strong>name</strong> 变量传递给类的方法。</p>\n<h2 id=\"实现响应：\"><a href=\"#实现响应：\" class=\"headerlink\" title=\"实现响应：\"></a>实现响应：</h2><hr>\n<p>每个url匹配后对应一个类，在类里面实现网页中请求的方法就好了，比如 <strong>GET</strong>，<strong>POST</strong> 。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">index</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.reader = read()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'html/index.html'</span>, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            html = f.read()</div><div class=\"line\">        <span class=\"keyword\">return</span> html</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">POST</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = web.data()</div><div class=\"line\">        data = urllib.unquote_plus(data)</div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'temp '</span>, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(data)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">read</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> name</div></pre></td></tr></table></figure>\n<h2 id=\"启动Web程序：\"><a href=\"#启动Web程序：\" class=\"headerlink\" title=\"启动Web程序：\"></a>启动Web程序：</h2><hr>\n<p>因为是在 Linux 服务器上运行的，直接输入一下代码：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup python test.py 45.76.206.109:80 &amp;</div></pre></td></tr></table></figure></p>\n<p>记得 ip 后面带上端口号。</p>\n<h1 id=\"HTML网页：\"><a href=\"#HTML网页：\" class=\"headerlink\" title=\"HTML网页：\"></a>HTML网页：</h1><hr>\n<h2 id=\"from标签：\"><a href=\"#from标签：\" class=\"headerlink\" title=\"from标签：\"></a>from标签：</h2><hr>\n<p>这里的 action 大概是指用 method 里面的方法，访问了<strong> [主域名] + [action]</strong>。<br>例如下面的，相当于 <strong>POST</strong> 了 <strong>acmfish.top/</strong>，然后根据 URL 匹配，调用了 <strong>index</strong> 类的 <strong>POST</strong> 方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>PID:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"PID\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"全部代码：\"><a href=\"#全部代码：\" class=\"headerlink\" title=\"全部代码：\"></a>全部代码：</h1><hr>\n<h2 id=\"Web程序：-1\"><a href=\"#Web程序：-1\" class=\"headerlink\" title=\"Web程序：\"></a>Web程序：</h2><hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> web</div><div class=\"line\"></div><div class=\"line\">urls = (<span class=\"string\">'/'</span>,<span class=\"string\">'index'</span>,</div><div class=\"line\">        <span class=\"string\">'/(\\d+)'</span>, <span class=\"string\">'read'</span>,</div><div class=\"line\">        <span class=\"string\">'/(.*)'</span>, <span class=\"string\">'other'</span>)</div><div class=\"line\">app = web.application(urls, globals())</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">index</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.reader = read()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'html/index.html'</span>, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            html = f.read()</div><div class=\"line\">        <span class=\"keyword\">return</span> html</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">POST</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = web.data()</div><div class=\"line\">        <span class=\"keyword\">return</span> self.reader.GET(data[<span class=\"number\">4</span>:])</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">read</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.head = <span class=\"string\">'''&lt;html&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;head&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;meta charset=\"utf-8\"/&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;title&gt;Code&lt;/title&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/head&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;pre&gt;'''</span></div><div class=\"line\">        self.tail = <span class=\"string\">'''&lt;/pre&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/html&gt;'''</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        path = <span class=\"string\">'code/'</span>+name</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">with</span> open(path, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">                text = f.read()</div><div class=\"line\">                <span class=\"keyword\">return</span> text</div><div class=\"line\">        <span class=\"keyword\">except</span> IOError:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'File not find'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">other</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GET</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Not find'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"HTML：\"><a href=\"#HTML：\" class=\"headerlink\" title=\"HTML：\"></a>HTML：</h2><hr>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=UTF-8\"</span>&gt;</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Get Code<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">\t\ta&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#40668c;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t\tlabel&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#000000;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t\tinput&#123;</span></div><div class=\"line\"><span class=\"undefined\">\t\tcolor:#000000;</span></div><div class=\"line\"><span class=\"undefined\">\t\t&#125;</span></div><div class=\"line\"><span class=\"undefined\">\t</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>Get Code<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">hr</span> <span class=\"attr\">color</span>=<span class=\"string\">\"#000000\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>请直接访问<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/1000\"</span>&gt;</span>45.76.206.109/1000<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>以获取PID为1000题目代码。<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>或<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span>快捷搜索<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">\"center\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>PID:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"PID\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>"},{"title":"ZOJ3781 - Paint the Grid Reloaded（缩点+最短路）","date":"2017-06-13T03:36:05.000Z","_content":"# 题目链接：\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\n\n--------------------------\n# 题目大意：\n给定一个$N\\times M$的矩阵，每个格子涂着黑色或白色。现在有一种涂色操作，每次涂色可以将一个格子与这个格子连通的格子涂成一个颜色。连通是指上下左右的边相接。\n\n求最少的操作次数，将这个矩阵涂成一种颜色。\n\n-----------------------\n# 解题过程：\n很久以前比赛的题，当时看到这个题一点想法都没有，后来补题看到了是缩点和求最长路，感觉非常神奇，也是第一次接触缩点的思想。\n\n----------------------------\n# 题目分析：\n\n因为每次操作可以将相邻的格子涂成一个颜色，那么我可以将相同颜色连通的格子缩成一个点，与这一块连通格子相邻的相反颜色的点建边。\n\n我们以一块连通块为中心，不断重复的将这一连通块涂成相反的颜色，那么最终会把整个矩阵涂成一个颜色。因为将这个连通块涂成反色的话，这个连通块就会和周围反色的连通块连成一个更大的连通块。\n\n那么最少的操作次数，就遍历所有的点，以某个点为起点，BFS求出的最大步数为以这个点为起点的最少操作数。\n\n为什么这样操作是最少的呢？这样建图构成的是一个二分图，然后想一下就知道了。\n\n\n# AC代码：\n## BFS染色：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1600+5, INF = 0x3f3f3f3f;\n\nint n, m, top;\nchar map_data[MAX][MAX];\nint data[MAX][MAX], vis[MAX];\nint dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nvector<int> G[MAX];\n\n//判断是否出界\ninline bool edge(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < m;\n}\n\n\n//用来BFS给图染色\nvoid bfs(int x, int y) {\n    queue<pair<int, int> > q;\n    data[x][y] = top;\n    q.push(make_pair(x, y));\n    while (!q.empty()) {\n        x = q.front().first;\n        y = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int tx = x + dirc[i][0];\n            int ty = y + dirc[i][1];\n            if (edge(tx, ty) && map_data[x][y] == map_data[tx][ty] && !data[tx][ty]) {\n                q.push(make_pair(tx, ty));\n                data[tx][ty] = top;\n            }\n            else if (edge(tx, ty) && data[tx][ty] && data[tx][ty] != data[x][y]) {\n                int a = data[x][y], b = data[tx][ty];\n                G[a].push_back(b);\n                G[b].push_back(a);\n            }\n        }\n    }\n}\n\n\n//染色\nvoid flood_fill() {\n    memset(data, 0, sizeof(data));\n    top = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!data[i][j]) {\n                top++;\n                bfs(i, j);\n            }\n        }\n    }\n}\n\n//找出以当前点为起点的最长路\nint check_depth(int u) {\n    queue<pair<int, int> > q;\n    q.push(make_pair(u, 0));\n    memset(vis, 0, sizeof(vis));\n    vis[u] = 1;\n    int max_depth = 0;\n    while (!q.empty()) {\n        u = q.front().first;\n        int depth = q.front().second;\n        max_depth = max(depth, max_depth);\n        q.pop();\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if (!vis[v]) {\n                q.push(make_pair(v, depth+1));\n                vis[v] = 1;\n            }\n        }\n    }\n    return max_depth;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n*m; i++) {\n            G[i].clear();\n        }\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", map_data[i]);\n        }\n        flood_fill();\n        int ans = INF;\n        for (int i = 1; i <= top; i++) {\n            ans = min(check_depth(i), ans);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```\n\n\n## DFS染色：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1600+5, INF = 0x3f3f3f3f;\n\nint n, m, top;\nchar map_data[MAX][MAX];\nint data[MAX][MAX], vis[MAX];\nint dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\nvector<int> G[MAX];\n\ninline bool edge(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < m;\n}\n\nvoid dfs(int x, int y, int num, char c) {\n    for (int i = 0; i < 4; i++) {\n        int tx = x + dirc[i][0];\n        int ty = y + dirc[i][1];\n        if (!edge(tx, ty))\n            continue;\n        if (!data[tx][ty] && map_data[tx][ty] == c) {\n            data[tx][ty] = num;\n            dfs(tx, ty, num, c);\n        }\n        else if (map_data[tx][ty] != c && data[tx][ty]) {\n            int v = data[tx][ty];\n            G[v].push_back(num);\n            G[num].push_back(v);\n        }\n    }\n}\n\nvoid flood_fill() {\n    memset(data, 0, sizeof(data));\n    top = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!data[i][j]) {\n                data[i][j] = ++top;\n                dfs(i, j, top, map_data[i][j]);\n            }\n        }\n    }\n}\n\nint check_depth(int u) {\n    queue<pair<int, int> > q;\n    q.push(make_pair(u, 0));\n    memset(vis, 0, sizeof(vis));\n    vis[u] = 1;\n    int max_depth = 0;\n    while (!q.empty()) {\n        u = q.front().first;\n        int depth = q.front().second;\n        max_depth = max(depth, max_depth);\n        q.pop();\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if (!vis[v]) {\n                q.push(make_pair(v, depth+1));\n                vis[v] = 1;\n            }\n        }\n    }\n    return max_depth;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n*m; i++) {\n            G[i].clear();\n        }\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", map_data[i]);\n        }\n        flood_fill();\n        int ans = INF;\n        for (int i = 1; i <= top; i++) {\n            ans = min(check_depth(i), ans);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```","source":"_posts/ZOJ3781-Paint-the-Grid-Reloaded（缩点-最短路）.md","raw":"---\ntitle: ZOJ3781 - Paint the Grid Reloaded（缩点+最短路）\ndate: 2017-06-13 11:36:05\ncategories: [ACM, 搜索, BFS]\ntags:\n---\n# 题目链接：\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\n\n--------------------------\n# 题目大意：\n给定一个$N\\times M$的矩阵，每个格子涂着黑色或白色。现在有一种涂色操作，每次涂色可以将一个格子与这个格子连通的格子涂成一个颜色。连通是指上下左右的边相接。\n\n求最少的操作次数，将这个矩阵涂成一种颜色。\n\n-----------------------\n# 解题过程：\n很久以前比赛的题，当时看到这个题一点想法都没有，后来补题看到了是缩点和求最长路，感觉非常神奇，也是第一次接触缩点的思想。\n\n----------------------------\n# 题目分析：\n\n因为每次操作可以将相邻的格子涂成一个颜色，那么我可以将相同颜色连通的格子缩成一个点，与这一块连通格子相邻的相反颜色的点建边。\n\n我们以一块连通块为中心，不断重复的将这一连通块涂成相反的颜色，那么最终会把整个矩阵涂成一个颜色。因为将这个连通块涂成反色的话，这个连通块就会和周围反色的连通块连成一个更大的连通块。\n\n那么最少的操作次数，就遍历所有的点，以某个点为起点，BFS求出的最大步数为以这个点为起点的最少操作数。\n\n为什么这样操作是最少的呢？这样建图构成的是一个二分图，然后想一下就知道了。\n\n\n# AC代码：\n## BFS染色：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1600+5, INF = 0x3f3f3f3f;\n\nint n, m, top;\nchar map_data[MAX][MAX];\nint data[MAX][MAX], vis[MAX];\nint dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nvector<int> G[MAX];\n\n//判断是否出界\ninline bool edge(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < m;\n}\n\n\n//用来BFS给图染色\nvoid bfs(int x, int y) {\n    queue<pair<int, int> > q;\n    data[x][y] = top;\n    q.push(make_pair(x, y));\n    while (!q.empty()) {\n        x = q.front().first;\n        y = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int tx = x + dirc[i][0];\n            int ty = y + dirc[i][1];\n            if (edge(tx, ty) && map_data[x][y] == map_data[tx][ty] && !data[tx][ty]) {\n                q.push(make_pair(tx, ty));\n                data[tx][ty] = top;\n            }\n            else if (edge(tx, ty) && data[tx][ty] && data[tx][ty] != data[x][y]) {\n                int a = data[x][y], b = data[tx][ty];\n                G[a].push_back(b);\n                G[b].push_back(a);\n            }\n        }\n    }\n}\n\n\n//染色\nvoid flood_fill() {\n    memset(data, 0, sizeof(data));\n    top = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!data[i][j]) {\n                top++;\n                bfs(i, j);\n            }\n        }\n    }\n}\n\n//找出以当前点为起点的最长路\nint check_depth(int u) {\n    queue<pair<int, int> > q;\n    q.push(make_pair(u, 0));\n    memset(vis, 0, sizeof(vis));\n    vis[u] = 1;\n    int max_depth = 0;\n    while (!q.empty()) {\n        u = q.front().first;\n        int depth = q.front().second;\n        max_depth = max(depth, max_depth);\n        q.pop();\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if (!vis[v]) {\n                q.push(make_pair(v, depth+1));\n                vis[v] = 1;\n            }\n        }\n    }\n    return max_depth;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n*m; i++) {\n            G[i].clear();\n        }\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", map_data[i]);\n        }\n        flood_fill();\n        int ans = INF;\n        for (int i = 1; i <= top; i++) {\n            ans = min(check_depth(i), ans);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```\n\n\n## DFS染色：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1600+5, INF = 0x3f3f3f3f;\n\nint n, m, top;\nchar map_data[MAX][MAX];\nint data[MAX][MAX], vis[MAX];\nint dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\nvector<int> G[MAX];\n\ninline bool edge(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < m;\n}\n\nvoid dfs(int x, int y, int num, char c) {\n    for (int i = 0; i < 4; i++) {\n        int tx = x + dirc[i][0];\n        int ty = y + dirc[i][1];\n        if (!edge(tx, ty))\n            continue;\n        if (!data[tx][ty] && map_data[tx][ty] == c) {\n            data[tx][ty] = num;\n            dfs(tx, ty, num, c);\n        }\n        else if (map_data[tx][ty] != c && data[tx][ty]) {\n            int v = data[tx][ty];\n            G[v].push_back(num);\n            G[num].push_back(v);\n        }\n    }\n}\n\nvoid flood_fill() {\n    memset(data, 0, sizeof(data));\n    top = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!data[i][j]) {\n                data[i][j] = ++top;\n                dfs(i, j, top, map_data[i][j]);\n            }\n        }\n    }\n}\n\nint check_depth(int u) {\n    queue<pair<int, int> > q;\n    q.push(make_pair(u, 0));\n    memset(vis, 0, sizeof(vis));\n    vis[u] = 1;\n    int max_depth = 0;\n    while (!q.empty()) {\n        u = q.front().first;\n        int depth = q.front().second;\n        max_depth = max(depth, max_depth);\n        q.pop();\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if (!vis[v]) {\n                q.push(make_pair(v, depth+1));\n                vis[v] = 1;\n            }\n        }\n    }\n    return max_depth;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i <= n*m; i++) {\n            G[i].clear();\n        }\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", map_data[i]);\n        }\n        flood_fill();\n        int ans = INF;\n        for (int i = 1; i <= top; i++) {\n            ans = min(check_depth(i), ans);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```","slug":"ZOJ3781-Paint-the-Grid-Reloaded（缩点-最短路）","published":1,"updated":"2017-07-23T02:03:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6neu005wy9idr78ce3mq","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\" target=\"_blank\" rel=\"external\">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个$N\\times M$的矩阵，每个格子涂着黑色或白色。现在有一种涂色操作，每次涂色可以将一个格子与这个格子连通的格子涂成一个颜色。连通是指上下左右的边相接。</p>\n<p>求最少的操作次数，将这个矩阵涂成一种颜色。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>很久以前比赛的题，当时看到这个题一点想法都没有，后来补题看到了是缩点和求最长路，感觉非常神奇，也是第一次接触缩点的思想。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为每次操作可以将相邻的格子涂成一个颜色，那么我可以将相同颜色连通的格子缩成一个点，与这一块连通格子相邻的相反颜色的点建边。</p>\n<p>我们以一块连通块为中心，不断重复的将这一连通块涂成相反的颜色，那么最终会把整个矩阵涂成一个颜色。因为将这个连通块涂成反色的话，这个连通块就会和周围反色的连通块连成一个更大的连通块。</p>\n<p>那么最少的操作次数，就遍历所有的点，以某个点为起点，BFS求出的最大步数为以这个点为起点的最少操作数。</p>\n<p>为什么这样操作是最少的呢？这样建图构成的是一个二分图，然后想一下就知道了。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"BFS染色：\"><a href=\"#BFS染色：\" class=\"headerlink\" title=\"BFS染色：\"></a>BFS染色：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1600</span>+<span class=\"number\">5</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, top;</div><div class=\"line\"><span class=\"keyword\">char</span> map_data[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dirc[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断是否出界</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">edge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来BFS给图染色</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    data[x][y] = top;</div><div class=\"line\">    q.push(make_pair(x, y));</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        x = q.front().first;</div><div class=\"line\">        y = q.front().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tx = x + dirc[i][<span class=\"number\">0</span>];</div><div class=\"line\">            <span class=\"keyword\">int</span> ty = y + dirc[i][<span class=\"number\">1</span>];</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge(tx, ty) &amp;&amp; map_data[x][y] == map_data[tx][ty] &amp;&amp; !data[tx][ty]) &#123;</div><div class=\"line\">                q.push(make_pair(tx, ty));</div><div class=\"line\">                data[tx][ty] = top;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edge(tx, ty) &amp;&amp; data[tx][ty] &amp;&amp; data[tx][ty] != data[x][y]) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> a = data[x][y], b = data[tx][ty];</div><div class=\"line\">                G[a].push_back(b);</div><div class=\"line\">                G[b].push_back(a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//染色</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flood_fill</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    top = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i][j]) &#123;</div><div class=\"line\">                top++;</div><div class=\"line\">                bfs(i, j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//找出以当前点为起点的最长路</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_depth</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(u, <span class=\"number\">0</span>));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_depth = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front().first;</div><div class=\"line\">        <span class=\"keyword\">int</span> depth = q.front().second;</div><div class=\"line\">        max_depth = max(depth, max_depth);</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                q.push(make_pair(v, depth+<span class=\"number\">1</span>));</div><div class=\"line\">                vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max_depth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n*m; i++) &#123;</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, map_data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        flood_fill();</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = INF;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= top; i++) &#123;</div><div class=\"line\">            ans = min(check_depth(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"DFS染色：\"><a href=\"#DFS染色：\" class=\"headerlink\" title=\"DFS染色：\"></a>DFS染色：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1600</span>+<span class=\"number\">5</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, top;</div><div class=\"line\"><span class=\"keyword\">char</span> map_data[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dirc[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">edge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> num, <span class=\"keyword\">char</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> tx = x + dirc[i][<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">int</span> ty = y + dirc[i][<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!edge(tx, ty))</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!data[tx][ty] &amp;&amp; map_data[tx][ty] == c) &#123;</div><div class=\"line\">            data[tx][ty] = num;</div><div class=\"line\">            dfs(tx, ty, num, c);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (map_data[tx][ty] != c &amp;&amp; data[tx][ty]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = data[tx][ty];</div><div class=\"line\">            G[v].push_back(num);</div><div class=\"line\">            G[num].push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flood_fill</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    top = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i][j]) &#123;</div><div class=\"line\">                data[i][j] = ++top;</div><div class=\"line\">                dfs(i, j, top, map_data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_depth</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(u, <span class=\"number\">0</span>));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_depth = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front().first;</div><div class=\"line\">        <span class=\"keyword\">int</span> depth = q.front().second;</div><div class=\"line\">        max_depth = max(depth, max_depth);</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                q.push(make_pair(v, depth+<span class=\"number\">1</span>));</div><div class=\"line\">                vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max_depth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n*m; i++) &#123;</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, map_data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        flood_fill();</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = INF;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= top; i++) &#123;</div><div class=\"line\">            ans = min(check_depth(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p><a href=\"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781\" target=\"_blank\" rel=\"external\">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3781</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p>给定一个$N\\times M$的矩阵，每个格子涂着黑色或白色。现在有一种涂色操作，每次涂色可以将一个格子与这个格子连通的格子涂成一个颜色。连通是指上下左右的边相接。</p>\n<p>求最少的操作次数，将这个矩阵涂成一种颜色。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p>很久以前比赛的题，当时看到这个题一点想法都没有，后来补题看到了是缩点和求最长路，感觉非常神奇，也是第一次接触缩点的思想。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>因为每次操作可以将相邻的格子涂成一个颜色，那么我可以将相同颜色连通的格子缩成一个点，与这一块连通格子相邻的相反颜色的点建边。</p>\n<p>我们以一块连通块为中心，不断重复的将这一连通块涂成相反的颜色，那么最终会把整个矩阵涂成一个颜色。因为将这个连通块涂成反色的话，这个连通块就会和周围反色的连通块连成一个更大的连通块。</p>\n<p>那么最少的操作次数，就遍历所有的点，以某个点为起点，BFS求出的最大步数为以这个点为起点的最少操作数。</p>\n<p>为什么这样操作是最少的呢？这样建图构成的是一个二分图，然后想一下就知道了。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><h2 id=\"BFS染色：\"><a href=\"#BFS染色：\" class=\"headerlink\" title=\"BFS染色：\"></a>BFS染色：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1600</span>+<span class=\"number\">5</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, top;</div><div class=\"line\"><span class=\"keyword\">char</span> map_data[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dirc[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断是否出界</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">edge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来BFS给图染色</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    data[x][y] = top;</div><div class=\"line\">    q.push(make_pair(x, y));</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        x = q.front().first;</div><div class=\"line\">        y = q.front().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tx = x + dirc[i][<span class=\"number\">0</span>];</div><div class=\"line\">            <span class=\"keyword\">int</span> ty = y + dirc[i][<span class=\"number\">1</span>];</div><div class=\"line\">            <span class=\"keyword\">if</span> (edge(tx, ty) &amp;&amp; map_data[x][y] == map_data[tx][ty] &amp;&amp; !data[tx][ty]) &#123;</div><div class=\"line\">                q.push(make_pair(tx, ty));</div><div class=\"line\">                data[tx][ty] = top;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edge(tx, ty) &amp;&amp; data[tx][ty] &amp;&amp; data[tx][ty] != data[x][y]) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> a = data[x][y], b = data[tx][ty];</div><div class=\"line\">                G[a].push_back(b);</div><div class=\"line\">                G[b].push_back(a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//染色</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flood_fill</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    top = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i][j]) &#123;</div><div class=\"line\">                top++;</div><div class=\"line\">                bfs(i, j);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//找出以当前点为起点的最长路</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_depth</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(u, <span class=\"number\">0</span>));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_depth = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front().first;</div><div class=\"line\">        <span class=\"keyword\">int</span> depth = q.front().second;</div><div class=\"line\">        max_depth = max(depth, max_depth);</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                q.push(make_pair(v, depth+<span class=\"number\">1</span>));</div><div class=\"line\">                vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max_depth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n*m; i++) &#123;</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, map_data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        flood_fill();</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = INF;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= top; i++) &#123;</div><div class=\"line\">            ans = min(check_depth(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"DFS染色：\"><a href=\"#DFS染色：\" class=\"headerlink\" title=\"DFS染色：\"></a>DFS染色：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1600</span>+<span class=\"number\">5</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> n, m, top;</div><div class=\"line\"><span class=\"keyword\">char</span> map_data[MAX][MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX][MAX], vis[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dirc[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; G[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">edge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> num, <span class=\"keyword\">char</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> tx = x + dirc[i][<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">int</span> ty = y + dirc[i][<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!edge(tx, ty))</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!data[tx][ty] &amp;&amp; map_data[tx][ty] == c) &#123;</div><div class=\"line\">            data[tx][ty] = num;</div><div class=\"line\">            dfs(tx, ty, num, c);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (map_data[tx][ty] != c &amp;&amp; data[tx][ty]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = data[tx][ty];</div><div class=\"line\">            G[v].push_back(num);</div><div class=\"line\">            G[num].push_back(v);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flood_fill</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</div><div class=\"line\">    top = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!data[i][j]) &#123;</div><div class=\"line\">                data[i][j] = ++top;</div><div class=\"line\">                dfs(i, j, top, map_data[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_depth</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    q.push(make_pair(u, <span class=\"number\">0</span>));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</div><div class=\"line\">    vis[u] = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_depth = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        u = q.front().first;</div><div class=\"line\">        <span class=\"keyword\">int</span> depth = q.front().second;</div><div class=\"line\">        max_depth = max(depth, max_depth);</div><div class=\"line\">        q.pop();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = G[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (!vis[v]) &#123;</div><div class=\"line\">                q.push(make_pair(v, depth+<span class=\"number\">1</span>));</div><div class=\"line\">                vis[v] = <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> max_depth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n*m; i++) &#123;</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, map_data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        flood_fill();</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = INF;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= top; i++) &#123;</div><div class=\"line\">            ans = min(check_depth(i), ans);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"主席树（模板）","date":"2017-09-25T06:50:46.000Z","_content":"\n\n# 感谢&资料：\n\n感谢 bLue 学长的讲堂（虽然之前就差不多学会了），和[卿学姐的视频](https://www.bilibili.com/video/av4619406/)。\n\n\n\n# 简介：\n\n只是刚入门，这里当做存一个模板，主席树的功能是可以存储历史版本的线段树，然后可以干很多神奇的事情。\n\n\n\n# 代码：\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 112345;\n\nstruct Node {\n    int sum, l, r;\n} tree[MAX * 40];\n\nint root[MAX], cnt;\nint data[MAX];\nvector<int> sorted;\n\n//离散化获得ID\nint get_id(int x) {\n    return lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin() + 1;\n}\n\nvoid init() {\n    cnt = 0;\n    root[0] = 0;\n}\n\n//根据旧版本的线段树创建新线段树的节点\nint create_node(int po) {\n    int idx = ++cnt;\n    tree[idx].sum = tree[po].sum + 1;\n    tree[idx].l = tree[po].l;\n    tree[idx].r = tree[po].r;\n    return idx;\n}\n\nvoid updata(int &o, int po, int l, int r, int pos) {\n    o = create_node(po);\n    if (l == r) return;\n    int m = (l + r) >> 1;\n    if (pos <= m) updata(tree[o].l, tree[po].l, l, m, pos);\n    else updata(tree[o].r, tree[po].r, m + 1, r, pos);\n}\n\n//二分查询\nint query(int s, int e, int l, int r, int k) {\n    if (l == r) return l;\n    int m = (l + r) >> 1;\n    int sum = tree[tree[e].l].sum - tree[tree[s].l].sum;\n    if (k <= sum) return query(tree[s].l, tree[e].l, l, m, k);\n    else return query(tree[s].r, tree[e].r, m + 1, r, k - sum);\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        init();\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &data[i]);\n            sorted.push_back(data[i]);\n        }\n        sort(sorted.begin(), sorted.end());\n        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n        int num = sorted.size();\n        for (int i = 1; i <= n; i++) {\n            updata(root[i], root[i - 1], 1, num, get_id(data[i]));\n        }\n        for (int i = 1; i <= m; i++) {\n            int x, y, k;\n            scanf(\"%d %d %d\", &x, &y, &k);\n            printf(\"%d\\n\", sorted[query(root[x - 1], root[y], 1, num, k) - 1]);\n        }\n    }\n}\n```\n\n\n\n","source":"_posts/主席树（模板）.md","raw":"---\ntitle: 主席树（模板）\ndate: 2017-09-25 14:50:46\ncategories: [ACM, 数据结构, 主席树]\ntags:\n---\n\n\n# 感谢&资料：\n\n感谢 bLue 学长的讲堂（虽然之前就差不多学会了），和[卿学姐的视频](https://www.bilibili.com/video/av4619406/)。\n\n\n\n# 简介：\n\n只是刚入门，这里当做存一个模板，主席树的功能是可以存储历史版本的线段树，然后可以干很多神奇的事情。\n\n\n\n# 代码：\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 112345;\n\nstruct Node {\n    int sum, l, r;\n} tree[MAX * 40];\n\nint root[MAX], cnt;\nint data[MAX];\nvector<int> sorted;\n\n//离散化获得ID\nint get_id(int x) {\n    return lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin() + 1;\n}\n\nvoid init() {\n    cnt = 0;\n    root[0] = 0;\n}\n\n//根据旧版本的线段树创建新线段树的节点\nint create_node(int po) {\n    int idx = ++cnt;\n    tree[idx].sum = tree[po].sum + 1;\n    tree[idx].l = tree[po].l;\n    tree[idx].r = tree[po].r;\n    return idx;\n}\n\nvoid updata(int &o, int po, int l, int r, int pos) {\n    o = create_node(po);\n    if (l == r) return;\n    int m = (l + r) >> 1;\n    if (pos <= m) updata(tree[o].l, tree[po].l, l, m, pos);\n    else updata(tree[o].r, tree[po].r, m + 1, r, pos);\n}\n\n//二分查询\nint query(int s, int e, int l, int r, int k) {\n    if (l == r) return l;\n    int m = (l + r) >> 1;\n    int sum = tree[tree[e].l].sum - tree[tree[s].l].sum;\n    if (k <= sum) return query(tree[s].l, tree[e].l, l, m, k);\n    else return query(tree[s].r, tree[e].r, m + 1, r, k - sum);\n}\n\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m)) {\n        init();\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &data[i]);\n            sorted.push_back(data[i]);\n        }\n        sort(sorted.begin(), sorted.end());\n        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n        int num = sorted.size();\n        for (int i = 1; i <= n; i++) {\n            updata(root[i], root[i - 1], 1, num, get_id(data[i]));\n        }\n        for (int i = 1; i <= m; i++) {\n            int x, y, k;\n            scanf(\"%d %d %d\", &x, &y, &k);\n            printf(\"%d\\n\", sorted[query(root[x - 1], root[y], 1, num, k) - 1]);\n        }\n    }\n}\n```\n\n\n\n","slug":"主席树（模板）","published":1,"updated":"2017-10-09T08:54:29.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6new005yy9id2p5d2jwf","content":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>感谢 bLue 学长的讲堂（虽然之前就差不多学会了），和<a href=\"https://www.bilibili.com/video/av4619406/\" target=\"_blank\" rel=\"external\">卿学姐的视频</a>。</p>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>只是刚入门，这里当做存一个模板，主席树的功能是可以存储历史版本的线段树，然后可以干很多神奇的事情。</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sum, l, r;</div><div class=\"line\">&#125; tree[MAX * <span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root[MAX], cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sorted;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//离散化获得ID</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_id</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin() + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    root[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//根据旧版本的线段树创建新线段树的节点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> po)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> idx = ++cnt;</div><div class=\"line\">    tree[idx].sum = tree[po].sum + <span class=\"number\">1</span>;</div><div class=\"line\">    tree[idx].l = tree[po].l;</div><div class=\"line\">    tree[idx].r = tree[po].r;</div><div class=\"line\">    <span class=\"keyword\">return</span> idx;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;o, <span class=\"keyword\">int</span> po, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    o = create_node(po);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt;= m) updata(tree[o].l, tree[po].l, l, m, pos);</div><div class=\"line\">    <span class=\"keyword\">else</span> updata(tree[o].r, tree[po].r, m + <span class=\"number\">1</span>, r, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//二分查询</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = tree[tree[e].l].sum - tree[tree[s].l].sum;</div><div class=\"line\">    <span class=\"keyword\">if</span> (k &lt;= sum) <span class=\"keyword\">return</span> query(tree[s].l, tree[e].l, l, m, k);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> query(tree[s].r, tree[e].r, m + <span class=\"number\">1</span>, r, k - sum);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">            sorted.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(sorted.begin(), sorted.end());</div><div class=\"line\">        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());</div><div class=\"line\">        <span class=\"keyword\">int</span> num = sorted.size();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            updata(root[i], root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, num, get_id(data[i]));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y, k;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;k);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sorted[query(root[x - <span class=\"number\">1</span>], root[y], <span class=\"number\">1</span>, num, k) - <span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>感谢 bLue 学长的讲堂（虽然之前就差不多学会了），和<a href=\"https://www.bilibili.com/video/av4619406/\" target=\"_blank\" rel=\"external\">卿学姐的视频</a>。</p>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>只是刚入门，这里当做存一个模板，主席树的功能是可以存储历史版本的线段树，然后可以干很多神奇的事情。</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">112345</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sum, l, r;</div><div class=\"line\">&#125; tree[MAX * <span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> root[MAX], cnt;</div><div class=\"line\"><span class=\"keyword\">int</span> data[MAX];</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sorted;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//离散化获得ID</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_id</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin() + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    cnt = <span class=\"number\">0</span>;</div><div class=\"line\">    root[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//根据旧版本的线段树创建新线段树的节点</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> po)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> idx = ++cnt;</div><div class=\"line\">    tree[idx].sum = tree[po].sum + <span class=\"number\">1</span>;</div><div class=\"line\">    tree[idx].l = tree[po].l;</div><div class=\"line\">    tree[idx].r = tree[po].r;</div><div class=\"line\">    <span class=\"keyword\">return</span> idx;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;o, <span class=\"keyword\">int</span> po, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</div><div class=\"line\">    o = create_node(po);</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt;= m) updata(tree[o].l, tree[po].l, l, m, pos);</div><div class=\"line\">    <span class=\"keyword\">else</span> updata(tree[o].r, tree[po].r, m + <span class=\"number\">1</span>, r, pos);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//二分查询</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> l;</div><div class=\"line\">    <span class=\"keyword\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = tree[tree[e].l].sum - tree[tree[s].l].sum;</div><div class=\"line\">    <span class=\"keyword\">if</span> (k &lt;= sum) <span class=\"keyword\">return</span> query(tree[s].l, tree[e].l, l, m, k);</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> query(tree[s].r, tree[e].r, m + <span class=\"number\">1</span>, r, k - sum);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m)) &#123;</div><div class=\"line\">        init();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;data[i]);</div><div class=\"line\">            sorted.push_back(data[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(sorted.begin(), sorted.end());</div><div class=\"line\">        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());</div><div class=\"line\">        <span class=\"keyword\">int</span> num = sorted.size();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            updata(root[i], root[i - <span class=\"number\">1</span>], <span class=\"number\">1</span>, num, get_id(data[i]));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x, y, k;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>, &amp;x, &amp;y, &amp;k);</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, sorted[query(root[x - <span class=\"number\">1</span>], root[y], <span class=\"number\">1</span>, num, k) - <span class=\"number\">1</span>]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"使用OpenMP实现并行归并排序（Report）","date":"2017-06-05T08:41:18.000Z","_content":"# 归并排序算法：\n\n归并排序算法是一种经典的分治算法。\n\n## 分治\n分治算法分为由三部分组成：\n分解：将原问题分解为一系列子问题；\n解决：递归的解决各个子问题。若子问题足够小，那么直接求解。\n合并：将子问题的结果合并成原问题。\n\n## 归并排序步骤\n归并排序完全依照了上述模式，直观的操作如下：\n分解：将n个元素分成各含n/2个元素的子序列；\n解决：用合并排序法对两个子序列递归地排序；\n合并：合并两个已经排序的子序列，已得到排序结果。\n这里递归的边界是序列长度为1时，显然是有序的。\n\n\n## 合并过程\n这里最关键的步骤，是合并步骤里如何合并两个有序的序列，并保证合并后的序列依然有序。\n\n假设有序的序列为递增的，A、B为需要合并的序列，C为合并后的结果序列，p、q分别为A和B的下标，top为C的下标。定义如果一个下标大于序列的长度后，表示的值为无穷大。\n\n初始状态：p、q、top均为0.\n\n操作：选择A[p]和B[q]中的小的元素，加入到C[top]中，然后让较小的元素所在的序列的下标加一，top加一。当A[p]和B[q]均为无穷大时，结束操作。\n\n由于每次操作均是比较A[p]和B[q]，然后取较小者加入C中，显然时间复杂度是O(n)的。\n\n## 归并排序时间复杂度分析：\n假设归并排序一个长度为n的序列需要的时间为T(n)。\n首先归并排序分如下三个步骤：\n分解：这一步是把序列分为两个子序列，只需要常量时间，O(1)；\n解决：递归的解决规模为n/2的两个子问题，时间为2*T(n/2)；\n合并：上面已经证明，只需时间O(n)。\n\n那么接下来可以UI递归的表示出所需的时间T(n):\n当n = 1是，T(n) = O(1)；\n否则：T(n) = 2*T(n/2) + O(n)。\n\n可以证明出上述的T(n)其实就是O(n*log(n))。\n\nT(n) = 2*T(n/2) + O(n)\n\t\t= 2*(2*T(n/4) + O(n/2) + O(n)\n\t\t= 4*T(n/4) + 2*O(n/2) + O(n)\n\t\t= 4*T(n/4) + 2*O(n)\n\t\t= 8*T(n/8) + 8*O(n/8) + 2*O(n)\n\t\t= 8*T(n/8) + 3*O(n)\n\t\t= x*T(1) + y*O(n)\n\n显然y即为n除多少次才为1，y = log2(n)，x等于2^y，那么T(n) = O(n*log(n))。\n\n\n## 一个容易理解的代码：\nPython is very beautiful！\n```python\ndef merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) / 2\n        left = merge_sort(array[:mid])\n        right = merge_sort(array[mid:])\n        return merge(left, right)\n    return array\n\n\ndef merge(left, right):\n    rst = []\n    while len(left) > 0 or len(right) > 0:\n        if len(right) == 0 or len(left) != 0 and left[0] < right[0]:\n            rst.append(left.pop(0))\n        else:\n            rst.append(right.pop(0))\n    return rst\n```\n\n\n# 串行过程：\n## 串行排序代码：\n```cpp\nvoid merge_sort(int *A, int x, int y, int *T) {\n    if (y - x > 1) {\n        int m = x + (y-x)/2;\n        int p = x, q = m, i = x;\n        merge_sort(A, x, m, T);\n        merge_sort(A, m, y, T);\n        \n        while (p < m || q < y) {\n            if (q >= y || (p < m && A[p] <= A[q])) {\n                T[i++] = A[p++];\n            }\n            else {\n                T[i++] = A[q++];\n            }\n        }\n        for (i = x; i < y; i++) {\n            A[i] = T[i];\n        }\n    }\n}\n```\n\n## 串行求和代码：\n```cpp\nint get_sum(int* data, int N) {\n    int sum = 0, i;\n    for (i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    return sum;\n}\n```\n\n## 运行时间：\n\nnum_elements|sort time| sum time\n---|------|-----------\n100|0.000012|0.000001\n1000|0.000166|0.000005\n10000|0.002162|0.000045\n100000|0.022915|0.000384\n1000000|0.216075|0.003397\n10000000|2.404543|0.034109\n100000000|27.204318|0.340051\n\nignore the input time.\n\n# 并行过程：\n## 归并排序算法的并行化：\n\n首先，归并排序的步骤分为已下三步：\n\n分解：将n个元素分成各含n/2个元素的子序列；\n解决：用合并排序法对两个子序列递归地排序；\n合并：合并两个已经排序的子序列，已得到排序结果。\n\n然后发现，按照这个思路很难并行化，因为许多过程有依赖的，比如当[1, 1], [2, 2] 区间没有合并之前，那么[1, 2], [3, 4]区间是不能进行合并的。\n\n但是我们可以把归并的步骤反过来。原来归并是要不断的分解一个序列，直到分解成长度为1的区间，最后依次合并。我们现在假设有N个区间，要分别合并，最后合并成一个区间。那么我现在的操作是没有前后依赖的，对于任意两个区间，只需要合并就好，不用考虑其他的线程。\n\n这样排序的过程就类似一颗线段树（严格的来讲并不是），自底向上的不断合并。\n\n![这里写图片描述](http://img.blog.csdn.net/20170605171543250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n## 排序代码：\n```cpp\n//合并两个区间\nvoid merge(int l1, int r1, int r2, int* data, int* temp) {\n    int top = l1, p = l1, q = r1;\n    while (p < r1 || q < r2) {\n        if (q >= r2 || (p < r1 && data[p] <= data[q])) {\n            temp[top++] = data[p++];\n        }\n        else {\n            temp[top++] = data[q++];\n        }\n    }\n    for (top = l1; top < r2; top++) {\n        data[top] = temp[top];\n    }\n}\n\nvoid merge_sort(int l, int r, int* data, int N) {\n    int i, j, t, *temp;\n    temp = (int*)malloc(N * sizeof(int));\n    //这里做了一些优化，预处理合并了单个的区间，略微提高的速度\n\t#pragma omp parallel for private(i, t) shared(N, data)\n    for (i = 0; i < N/2; i++)\n        if (data[i*2] > data[i*2+1]) {\n            t = data[i*2];\n            data[i*2] = data[i*2+1];\n            data[i*2+1] = t;\n        }\n\n\t//i代表每次归并的区间长度，j代表需要归并的两个区间中最小的下标\n    for (i = 2; i < r; i *= 2) {\n\t\t#pragma omp parallel for private(j) shared(r, i)\n        for (j = 0; j < r-i; j += i*2) {\n            merge(j, j+i, (j+i*2 < r ? j+i*2 : r), data, temp);\n        }\n    }\n}\n```\n\n## 求和代码：\n```cpp\nint get_sum(int* data, int N) {\n    int sum = 0, i;\n    #pragma omp parallel for private(i) reduct(+:sum)\n    for (i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    return sum;\n}\n```\n\n## 运行时间：\n\nnum_elements|sort time| sum time\n---|------|-----------\n100|0.000164|0.000009\n1000|0.000209|0.000009\n10000|0.002318|0.000052\n100000|0.010589|0.000166\n1000000|0.110090|0.001279\n10000000|1.093572|0.013541\n100000000|11.872408|0.127646\n\nignore the input time.\n\n# 运行时间分析：\n## 排序时间对比：\n![这里写图片描述](http://img.blog.csdn.net/20170605210453384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 求和时间对比：\n![这里写图片描述](http://img.blog.csdn.net/20170605210516264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 结论：\n增加线程数在是可以加快程序的运行速度的，但是随着线程的增加，加速的效果逐渐变得不明显，双线程与单线程的差异较大，整体上多线程的用时为单线程的一半。","source":"_posts/使用OpenMP实现并行归并排序（Report）.md","raw":"---\ntitle: 使用OpenMP实现并行归并排序（Report）\ndate: 2017-06-05 16:41:18\ncategories: [CS课程]\ntags:\n---\n# 归并排序算法：\n\n归并排序算法是一种经典的分治算法。\n\n## 分治\n分治算法分为由三部分组成：\n分解：将原问题分解为一系列子问题；\n解决：递归的解决各个子问题。若子问题足够小，那么直接求解。\n合并：将子问题的结果合并成原问题。\n\n## 归并排序步骤\n归并排序完全依照了上述模式，直观的操作如下：\n分解：将n个元素分成各含n/2个元素的子序列；\n解决：用合并排序法对两个子序列递归地排序；\n合并：合并两个已经排序的子序列，已得到排序结果。\n这里递归的边界是序列长度为1时，显然是有序的。\n\n\n## 合并过程\n这里最关键的步骤，是合并步骤里如何合并两个有序的序列，并保证合并后的序列依然有序。\n\n假设有序的序列为递增的，A、B为需要合并的序列，C为合并后的结果序列，p、q分别为A和B的下标，top为C的下标。定义如果一个下标大于序列的长度后，表示的值为无穷大。\n\n初始状态：p、q、top均为0.\n\n操作：选择A[p]和B[q]中的小的元素，加入到C[top]中，然后让较小的元素所在的序列的下标加一，top加一。当A[p]和B[q]均为无穷大时，结束操作。\n\n由于每次操作均是比较A[p]和B[q]，然后取较小者加入C中，显然时间复杂度是O(n)的。\n\n## 归并排序时间复杂度分析：\n假设归并排序一个长度为n的序列需要的时间为T(n)。\n首先归并排序分如下三个步骤：\n分解：这一步是把序列分为两个子序列，只需要常量时间，O(1)；\n解决：递归的解决规模为n/2的两个子问题，时间为2*T(n/2)；\n合并：上面已经证明，只需时间O(n)。\n\n那么接下来可以UI递归的表示出所需的时间T(n):\n当n = 1是，T(n) = O(1)；\n否则：T(n) = 2*T(n/2) + O(n)。\n\n可以证明出上述的T(n)其实就是O(n*log(n))。\n\nT(n) = 2*T(n/2) + O(n)\n\t\t= 2*(2*T(n/4) + O(n/2) + O(n)\n\t\t= 4*T(n/4) + 2*O(n/2) + O(n)\n\t\t= 4*T(n/4) + 2*O(n)\n\t\t= 8*T(n/8) + 8*O(n/8) + 2*O(n)\n\t\t= 8*T(n/8) + 3*O(n)\n\t\t= x*T(1) + y*O(n)\n\n显然y即为n除多少次才为1，y = log2(n)，x等于2^y，那么T(n) = O(n*log(n))。\n\n\n## 一个容易理解的代码：\nPython is very beautiful！\n```python\ndef merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) / 2\n        left = merge_sort(array[:mid])\n        right = merge_sort(array[mid:])\n        return merge(left, right)\n    return array\n\n\ndef merge(left, right):\n    rst = []\n    while len(left) > 0 or len(right) > 0:\n        if len(right) == 0 or len(left) != 0 and left[0] < right[0]:\n            rst.append(left.pop(0))\n        else:\n            rst.append(right.pop(0))\n    return rst\n```\n\n\n# 串行过程：\n## 串行排序代码：\n```cpp\nvoid merge_sort(int *A, int x, int y, int *T) {\n    if (y - x > 1) {\n        int m = x + (y-x)/2;\n        int p = x, q = m, i = x;\n        merge_sort(A, x, m, T);\n        merge_sort(A, m, y, T);\n        \n        while (p < m || q < y) {\n            if (q >= y || (p < m && A[p] <= A[q])) {\n                T[i++] = A[p++];\n            }\n            else {\n                T[i++] = A[q++];\n            }\n        }\n        for (i = x; i < y; i++) {\n            A[i] = T[i];\n        }\n    }\n}\n```\n\n## 串行求和代码：\n```cpp\nint get_sum(int* data, int N) {\n    int sum = 0, i;\n    for (i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    return sum;\n}\n```\n\n## 运行时间：\n\nnum_elements|sort time| sum time\n---|------|-----------\n100|0.000012|0.000001\n1000|0.000166|0.000005\n10000|0.002162|0.000045\n100000|0.022915|0.000384\n1000000|0.216075|0.003397\n10000000|2.404543|0.034109\n100000000|27.204318|0.340051\n\nignore the input time.\n\n# 并行过程：\n## 归并排序算法的并行化：\n\n首先，归并排序的步骤分为已下三步：\n\n分解：将n个元素分成各含n/2个元素的子序列；\n解决：用合并排序法对两个子序列递归地排序；\n合并：合并两个已经排序的子序列，已得到排序结果。\n\n然后发现，按照这个思路很难并行化，因为许多过程有依赖的，比如当[1, 1], [2, 2] 区间没有合并之前，那么[1, 2], [3, 4]区间是不能进行合并的。\n\n但是我们可以把归并的步骤反过来。原来归并是要不断的分解一个序列，直到分解成长度为1的区间，最后依次合并。我们现在假设有N个区间，要分别合并，最后合并成一个区间。那么我现在的操作是没有前后依赖的，对于任意两个区间，只需要合并就好，不用考虑其他的线程。\n\n这样排序的过程就类似一颗线段树（严格的来讲并不是），自底向上的不断合并。\n\n![这里写图片描述](http://img.blog.csdn.net/20170605171543250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n## 排序代码：\n```cpp\n//合并两个区间\nvoid merge(int l1, int r1, int r2, int* data, int* temp) {\n    int top = l1, p = l1, q = r1;\n    while (p < r1 || q < r2) {\n        if (q >= r2 || (p < r1 && data[p] <= data[q])) {\n            temp[top++] = data[p++];\n        }\n        else {\n            temp[top++] = data[q++];\n        }\n    }\n    for (top = l1; top < r2; top++) {\n        data[top] = temp[top];\n    }\n}\n\nvoid merge_sort(int l, int r, int* data, int N) {\n    int i, j, t, *temp;\n    temp = (int*)malloc(N * sizeof(int));\n    //这里做了一些优化，预处理合并了单个的区间，略微提高的速度\n\t#pragma omp parallel for private(i, t) shared(N, data)\n    for (i = 0; i < N/2; i++)\n        if (data[i*2] > data[i*2+1]) {\n            t = data[i*2];\n            data[i*2] = data[i*2+1];\n            data[i*2+1] = t;\n        }\n\n\t//i代表每次归并的区间长度，j代表需要归并的两个区间中最小的下标\n    for (i = 2; i < r; i *= 2) {\n\t\t#pragma omp parallel for private(j) shared(r, i)\n        for (j = 0; j < r-i; j += i*2) {\n            merge(j, j+i, (j+i*2 < r ? j+i*2 : r), data, temp);\n        }\n    }\n}\n```\n\n## 求和代码：\n```cpp\nint get_sum(int* data, int N) {\n    int sum = 0, i;\n    #pragma omp parallel for private(i) reduct(+:sum)\n    for (i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    return sum;\n}\n```\n\n## 运行时间：\n\nnum_elements|sort time| sum time\n---|------|-----------\n100|0.000164|0.000009\n1000|0.000209|0.000009\n10000|0.002318|0.000052\n100000|0.010589|0.000166\n1000000|0.110090|0.001279\n10000000|1.093572|0.013541\n100000000|11.872408|0.127646\n\nignore the input time.\n\n# 运行时间分析：\n## 排序时间对比：\n![这里写图片描述](http://img.blog.csdn.net/20170605210453384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 求和时间对比：\n![这里写图片描述](http://img.blog.csdn.net/20170605210516264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 结论：\n增加线程数在是可以加快程序的运行速度的，但是随着线程的增加，加速的效果逐渐变得不明显，双线程与单线程的差异较大，整体上多线程的用时为单线程的一半。","slug":"使用OpenMP实现并行归并排序（Report）","published":1,"updated":"2017-07-23T02:21:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6ney0061y9idf28vycmn","content":"<h1 id=\"归并排序算法：\"><a href=\"#归并排序算法：\" class=\"headerlink\" title=\"归并排序算法：\"></a>归并排序算法：</h1><p>归并排序算法是一种经典的分治算法。</p>\n<h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><p>分治算法分为由三部分组成：<br>分解：将原问题分解为一系列子问题；<br>解决：递归的解决各个子问题。若子问题足够小，那么直接求解。<br>合并：将子问题的结果合并成原问题。</p>\n<h2 id=\"归并排序步骤\"><a href=\"#归并排序步骤\" class=\"headerlink\" title=\"归并排序步骤\"></a>归并排序步骤</h2><p>归并排序完全依照了上述模式，直观的操作如下：<br>分解：将n个元素分成各含n/2个元素的子序列；<br>解决：用合并排序法对两个子序列递归地排序；<br>合并：合并两个已经排序的子序列，已得到排序结果。<br>这里递归的边界是序列长度为1时，显然是有序的。</p>\n<h2 id=\"合并过程\"><a href=\"#合并过程\" class=\"headerlink\" title=\"合并过程\"></a>合并过程</h2><p>这里最关键的步骤，是合并步骤里如何合并两个有序的序列，并保证合并后的序列依然有序。</p>\n<p>假设有序的序列为递增的，A、B为需要合并的序列，C为合并后的结果序列，p、q分别为A和B的下标，top为C的下标。定义如果一个下标大于序列的长度后，表示的值为无穷大。</p>\n<p>初始状态：p、q、top均为0.</p>\n<p>操作：选择A[p]和B[q]中的小的元素，加入到C[top]中，然后让较小的元素所在的序列的下标加一，top加一。当A[p]和B[q]均为无穷大时，结束操作。</p>\n<p>由于每次操作均是比较A[p]和B[q]，然后取较小者加入C中，显然时间复杂度是O(n)的。</p>\n<h2 id=\"归并排序时间复杂度分析：\"><a href=\"#归并排序时间复杂度分析：\" class=\"headerlink\" title=\"归并排序时间复杂度分析：\"></a>归并排序时间复杂度分析：</h2><p>假设归并排序一个长度为n的序列需要的时间为T(n)。<br>首先归并排序分如下三个步骤：<br>分解：这一步是把序列分为两个子序列，只需要常量时间，O(1)；<br>解决：递归的解决规模为n/2的两个子问题，时间为2*T(n/2)；<br>合并：上面已经证明，只需时间O(n)。</p>\n<p>那么接下来可以UI递归的表示出所需的时间T(n):<br>当n = 1是，T(n) = O(1)；<br>否则：T(n) = 2*T(n/2) + O(n)。</p>\n<p>可以证明出上述的T(n)其实就是O(n*log(n))。</p>\n<p>T(n) = 2<em>T(n/2) + O(n)<br>        = 2</em>(2<em>T(n/4) + O(n/2) + O(n)<br>        = 4</em>T(n/4) + 2<em>O(n/2) + O(n)<br>        = 4</em>T(n/4) + 2<em>O(n)<br>        = 8</em>T(n/8) + 8<em>O(n/8) + 2</em>O(n)<br>        = 8<em>T(n/8) + 3</em>O(n)<br>        = x<em>T(1) + y</em>O(n)</p>\n<p>显然y即为n除多少次才为1，y = log2(n)，x等于2^y，那么T(n) = O(n*log(n))。</p>\n<h2 id=\"一个容易理解的代码：\"><a href=\"#一个容易理解的代码：\" class=\"headerlink\" title=\"一个容易理解的代码：\"></a>一个容易理解的代码：</h2><p>Python is very beautiful！<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(array)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> len(array) &gt; <span class=\"number\">1</span>:</div><div class=\"line\">        mid = len(array) / <span class=\"number\">2</span></div><div class=\"line\">        left = merge_sort(array[:mid])</div><div class=\"line\">        right = merge_sort(array[mid:])</div><div class=\"line\">        <span class=\"keyword\">return</span> merge(left, right)</div><div class=\"line\">    <span class=\"keyword\">return</span> array</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></div><div class=\"line\">    rst = []</div><div class=\"line\">    <span class=\"keyword\">while</span> len(left) &gt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> len(right) &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">if</span> len(right) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> len(left) != <span class=\"number\">0</span> <span class=\"keyword\">and</span> left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]:</div><div class=\"line\">            rst.append(left.pop(<span class=\"number\">0</span>))</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            rst.append(right.pop(<span class=\"number\">0</span>))</div><div class=\"line\">    <span class=\"keyword\">return</span> rst</div></pre></td></tr></table></figure></p>\n<h1 id=\"串行过程：\"><a href=\"#串行过程：\" class=\"headerlink\" title=\"串行过程：\"></a>串行过程：</h1><h2 id=\"串行排序代码：\"><a href=\"#串行排序代码：\" class=\"headerlink\" title=\"串行排序代码：\"></a>串行排序代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> *T)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (y - x &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = x + (y-x)/<span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> p = x, q = m, i = x;</div><div class=\"line\">        merge_sort(A, x, m, T);</div><div class=\"line\">        merge_sort(A, m, y, T);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">while</span> (p &lt; m || q &lt; y) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) &#123;</div><div class=\"line\">                T[i++] = A[p++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                T[i++] = A[q++];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (i = x; i &lt; y; i++) &#123;</div><div class=\"line\">            A[i] = T[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"串行求和代码：\"><a href=\"#串行求和代码：\" class=\"headerlink\" title=\"串行求和代码：\"></a>串行求和代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_sum</span><span class=\"params\">(<span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, i;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"运行时间：\"><a href=\"#运行时间：\" class=\"headerlink\" title=\"运行时间：\"></a>运行时间：</h2><table>\n<thead>\n<tr>\n<th>num_elements</th>\n<th>sort time</th>\n<th>sum time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>0.000012</td>\n<td>0.000001</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.000166</td>\n<td>0.000005</td>\n</tr>\n<tr>\n<td>10000</td>\n<td>0.002162</td>\n<td>0.000045</td>\n</tr>\n<tr>\n<td>100000</td>\n<td>0.022915</td>\n<td>0.000384</td>\n</tr>\n<tr>\n<td>1000000</td>\n<td>0.216075</td>\n<td>0.003397</td>\n</tr>\n<tr>\n<td>10000000</td>\n<td>2.404543</td>\n<td>0.034109</td>\n</tr>\n<tr>\n<td>100000000</td>\n<td>27.204318</td>\n<td>0.340051</td>\n</tr>\n</tbody>\n</table>\n<p>ignore the input time.</p>\n<h1 id=\"并行过程：\"><a href=\"#并行过程：\" class=\"headerlink\" title=\"并行过程：\"></a>并行过程：</h1><h2 id=\"归并排序算法的并行化：\"><a href=\"#归并排序算法的并行化：\" class=\"headerlink\" title=\"归并排序算法的并行化：\"></a>归并排序算法的并行化：</h2><p>首先，归并排序的步骤分为已下三步：</p>\n<p>分解：将n个元素分成各含n/2个元素的子序列；<br>解决：用合并排序法对两个子序列递归地排序；<br>合并：合并两个已经排序的子序列，已得到排序结果。</p>\n<p>然后发现，按照这个思路很难并行化，因为许多过程有依赖的，比如当[1, 1], [2, 2] 区间没有合并之前，那么[1, 2], [3, 4]区间是不能进行合并的。</p>\n<p>但是我们可以把归并的步骤反过来。原来归并是要不断的分解一个序列，直到分解成长度为1的区间，最后依次合并。我们现在假设有N个区间，要分别合并，最后合并成一个区间。那么我现在的操作是没有前后依赖的，对于任意两个区间，只需要合并就好，不用考虑其他的线程。</p>\n<p>这样排序的过程就类似一颗线段树（严格的来讲并不是），自底向上的不断合并。</p>\n<p><img src=\"http://img.blog.csdn.net/20170605171543250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"排序代码：\"><a href=\"#排序代码：\" class=\"headerlink\" title=\"排序代码：\"></a>排序代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//合并两个区间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span>* temp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> top = l1, p = l1, q = r1;</div><div class=\"line\">    <span class=\"keyword\">while</span> (p &lt; r1 || q &lt; r2) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (q &gt;= r2 || (p &lt; r1 &amp;&amp; data[p] &lt;= data[q])) &#123;</div><div class=\"line\">            temp[top++] = data[p++];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            temp[top++] = data[q++];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (top = l1; top &lt; r2; top++) &#123;</div><div class=\"line\">        data[top] = temp[top];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t, *temp;</div><div class=\"line\">    temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(N * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"comment\">//这里做了一些优化，预处理合并了单个的区间，略微提高的速度</span></div><div class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(i, t) shared(N, data)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N/<span class=\"number\">2</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[i*<span class=\"number\">2</span>] &gt; data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">            t = data[i*<span class=\"number\">2</span>];</div><div class=\"line\">            data[i*<span class=\"number\">2</span>] = data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>];</div><div class=\"line\">            data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//i代表每次归并的区间长度，j代表需要归并的两个区间中最小的下标</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; r; i *= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(j) shared(r, i)</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; r-i; j += i*<span class=\"number\">2</span>) &#123;</div><div class=\"line\">            merge(j, j+i, (j+i*<span class=\"number\">2</span> &lt; r ? j+i*<span class=\"number\">2</span> : r), data, temp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"求和代码：\"><a href=\"#求和代码：\" class=\"headerlink\" title=\"求和代码：\"></a>求和代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_sum</span><span class=\"params\">(<span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, i;</div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(i) reduct(+:sum)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"运行时间：-1\"><a href=\"#运行时间：-1\" class=\"headerlink\" title=\"运行时间：\"></a>运行时间：</h2><table>\n<thead>\n<tr>\n<th>num_elements</th>\n<th>sort time</th>\n<th>sum time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>0.000164</td>\n<td>0.000009</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.000209</td>\n<td>0.000009</td>\n</tr>\n<tr>\n<td>10000</td>\n<td>0.002318</td>\n<td>0.000052</td>\n</tr>\n<tr>\n<td>100000</td>\n<td>0.010589</td>\n<td>0.000166</td>\n</tr>\n<tr>\n<td>1000000</td>\n<td>0.110090</td>\n<td>0.001279</td>\n</tr>\n<tr>\n<td>10000000</td>\n<td>1.093572</td>\n<td>0.013541</td>\n</tr>\n<tr>\n<td>100000000</td>\n<td>11.872408</td>\n<td>0.127646</td>\n</tr>\n</tbody>\n</table>\n<p>ignore the input time.</p>\n<h1 id=\"运行时间分析：\"><a href=\"#运行时间分析：\" class=\"headerlink\" title=\"运行时间分析：\"></a>运行时间分析：</h1><h2 id=\"排序时间对比：\"><a href=\"#排序时间对比：\" class=\"headerlink\" title=\"排序时间对比：\"></a>排序时间对比：</h2><p><img src=\"http://img.blog.csdn.net/20170605210453384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"求和时间对比：\"><a href=\"#求和时间对比：\" class=\"headerlink\" title=\"求和时间对比：\"></a>求和时间对比：</h2><p><img src=\"http://img.blog.csdn.net/20170605210516264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>增加线程数在是可以加快程序的运行速度的，但是随着线程的增加，加速的效果逐渐变得不明显，双线程与单线程的差异较大，整体上多线程的用时为单线程的一半。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"归并排序算法：\"><a href=\"#归并排序算法：\" class=\"headerlink\" title=\"归并排序算法：\"></a>归并排序算法：</h1><p>归并排序算法是一种经典的分治算法。</p>\n<h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><p>分治算法分为由三部分组成：<br>分解：将原问题分解为一系列子问题；<br>解决：递归的解决各个子问题。若子问题足够小，那么直接求解。<br>合并：将子问题的结果合并成原问题。</p>\n<h2 id=\"归并排序步骤\"><a href=\"#归并排序步骤\" class=\"headerlink\" title=\"归并排序步骤\"></a>归并排序步骤</h2><p>归并排序完全依照了上述模式，直观的操作如下：<br>分解：将n个元素分成各含n/2个元素的子序列；<br>解决：用合并排序法对两个子序列递归地排序；<br>合并：合并两个已经排序的子序列，已得到排序结果。<br>这里递归的边界是序列长度为1时，显然是有序的。</p>\n<h2 id=\"合并过程\"><a href=\"#合并过程\" class=\"headerlink\" title=\"合并过程\"></a>合并过程</h2><p>这里最关键的步骤，是合并步骤里如何合并两个有序的序列，并保证合并后的序列依然有序。</p>\n<p>假设有序的序列为递增的，A、B为需要合并的序列，C为合并后的结果序列，p、q分别为A和B的下标，top为C的下标。定义如果一个下标大于序列的长度后，表示的值为无穷大。</p>\n<p>初始状态：p、q、top均为0.</p>\n<p>操作：选择A[p]和B[q]中的小的元素，加入到C[top]中，然后让较小的元素所在的序列的下标加一，top加一。当A[p]和B[q]均为无穷大时，结束操作。</p>\n<p>由于每次操作均是比较A[p]和B[q]，然后取较小者加入C中，显然时间复杂度是O(n)的。</p>\n<h2 id=\"归并排序时间复杂度分析：\"><a href=\"#归并排序时间复杂度分析：\" class=\"headerlink\" title=\"归并排序时间复杂度分析：\"></a>归并排序时间复杂度分析：</h2><p>假设归并排序一个长度为n的序列需要的时间为T(n)。<br>首先归并排序分如下三个步骤：<br>分解：这一步是把序列分为两个子序列，只需要常量时间，O(1)；<br>解决：递归的解决规模为n/2的两个子问题，时间为2*T(n/2)；<br>合并：上面已经证明，只需时间O(n)。</p>\n<p>那么接下来可以UI递归的表示出所需的时间T(n):<br>当n = 1是，T(n) = O(1)；<br>否则：T(n) = 2*T(n/2) + O(n)。</p>\n<p>可以证明出上述的T(n)其实就是O(n*log(n))。</p>\n<p>T(n) = 2<em>T(n/2) + O(n)<br>        = 2</em>(2<em>T(n/4) + O(n/2) + O(n)<br>        = 4</em>T(n/4) + 2<em>O(n/2) + O(n)<br>        = 4</em>T(n/4) + 2<em>O(n)<br>        = 8</em>T(n/8) + 8<em>O(n/8) + 2</em>O(n)<br>        = 8<em>T(n/8) + 3</em>O(n)<br>        = x<em>T(1) + y</em>O(n)</p>\n<p>显然y即为n除多少次才为1，y = log2(n)，x等于2^y，那么T(n) = O(n*log(n))。</p>\n<h2 id=\"一个容易理解的代码：\"><a href=\"#一个容易理解的代码：\" class=\"headerlink\" title=\"一个容易理解的代码：\"></a>一个容易理解的代码：</h2><p>Python is very beautiful！<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(array)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> len(array) &gt; <span class=\"number\">1</span>:</div><div class=\"line\">        mid = len(array) / <span class=\"number\">2</span></div><div class=\"line\">        left = merge_sort(array[:mid])</div><div class=\"line\">        right = merge_sort(array[mid:])</div><div class=\"line\">        <span class=\"keyword\">return</span> merge(left, right)</div><div class=\"line\">    <span class=\"keyword\">return</span> array</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></div><div class=\"line\">    rst = []</div><div class=\"line\">    <span class=\"keyword\">while</span> len(left) &gt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> len(right) &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">if</span> len(right) == <span class=\"number\">0</span> <span class=\"keyword\">or</span> len(left) != <span class=\"number\">0</span> <span class=\"keyword\">and</span> left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]:</div><div class=\"line\">            rst.append(left.pop(<span class=\"number\">0</span>))</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            rst.append(right.pop(<span class=\"number\">0</span>))</div><div class=\"line\">    <span class=\"keyword\">return</span> rst</div></pre></td></tr></table></figure></p>\n<h1 id=\"串行过程：\"><a href=\"#串行过程：\" class=\"headerlink\" title=\"串行过程：\"></a>串行过程：</h1><h2 id=\"串行排序代码：\"><a href=\"#串行排序代码：\" class=\"headerlink\" title=\"串行排序代码：\"></a>串行排序代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> *T)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (y - x &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = x + (y-x)/<span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> p = x, q = m, i = x;</div><div class=\"line\">        merge_sort(A, x, m, T);</div><div class=\"line\">        merge_sort(A, m, y, T);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">while</span> (p &lt; m || q &lt; y) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) &#123;</div><div class=\"line\">                T[i++] = A[p++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                T[i++] = A[q++];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (i = x; i &lt; y; i++) &#123;</div><div class=\"line\">            A[i] = T[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"串行求和代码：\"><a href=\"#串行求和代码：\" class=\"headerlink\" title=\"串行求和代码：\"></a>串行求和代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_sum</span><span class=\"params\">(<span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, i;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"运行时间：\"><a href=\"#运行时间：\" class=\"headerlink\" title=\"运行时间：\"></a>运行时间：</h2><table>\n<thead>\n<tr>\n<th>num_elements</th>\n<th>sort time</th>\n<th>sum time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>0.000012</td>\n<td>0.000001</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.000166</td>\n<td>0.000005</td>\n</tr>\n<tr>\n<td>10000</td>\n<td>0.002162</td>\n<td>0.000045</td>\n</tr>\n<tr>\n<td>100000</td>\n<td>0.022915</td>\n<td>0.000384</td>\n</tr>\n<tr>\n<td>1000000</td>\n<td>0.216075</td>\n<td>0.003397</td>\n</tr>\n<tr>\n<td>10000000</td>\n<td>2.404543</td>\n<td>0.034109</td>\n</tr>\n<tr>\n<td>100000000</td>\n<td>27.204318</td>\n<td>0.340051</td>\n</tr>\n</tbody>\n</table>\n<p>ignore the input time.</p>\n<h1 id=\"并行过程：\"><a href=\"#并行过程：\" class=\"headerlink\" title=\"并行过程：\"></a>并行过程：</h1><h2 id=\"归并排序算法的并行化：\"><a href=\"#归并排序算法的并行化：\" class=\"headerlink\" title=\"归并排序算法的并行化：\"></a>归并排序算法的并行化：</h2><p>首先，归并排序的步骤分为已下三步：</p>\n<p>分解：将n个元素分成各含n/2个元素的子序列；<br>解决：用合并排序法对两个子序列递归地排序；<br>合并：合并两个已经排序的子序列，已得到排序结果。</p>\n<p>然后发现，按照这个思路很难并行化，因为许多过程有依赖的，比如当[1, 1], [2, 2] 区间没有合并之前，那么[1, 2], [3, 4]区间是不能进行合并的。</p>\n<p>但是我们可以把归并的步骤反过来。原来归并是要不断的分解一个序列，直到分解成长度为1的区间，最后依次合并。我们现在假设有N个区间，要分别合并，最后合并成一个区间。那么我现在的操作是没有前后依赖的，对于任意两个区间，只需要合并就好，不用考虑其他的线程。</p>\n<p>这样排序的过程就类似一颗线段树（严格的来讲并不是），自底向上的不断合并。</p>\n<p><img src=\"http://img.blog.csdn.net/20170605171543250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"排序代码：\"><a href=\"#排序代码：\" class=\"headerlink\" title=\"排序代码：\"></a>排序代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//合并两个区间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span>* temp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> top = l1, p = l1, q = r1;</div><div class=\"line\">    <span class=\"keyword\">while</span> (p &lt; r1 || q &lt; r2) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (q &gt;= r2 || (p &lt; r1 &amp;&amp; data[p] &lt;= data[q])) &#123;</div><div class=\"line\">            temp[top++] = data[p++];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            temp[top++] = data[q++];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (top = l1; top &lt; r2; top++) &#123;</div><div class=\"line\">        data[top] = temp[top];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i, j, t, *temp;</div><div class=\"line\">    temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(N * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"comment\">//这里做了一些优化，预处理合并了单个的区间，略微提高的速度</span></div><div class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(i, t) shared(N, data)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N/<span class=\"number\">2</span>; i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (data[i*<span class=\"number\">2</span>] &gt; data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">            t = data[i*<span class=\"number\">2</span>];</div><div class=\"line\">            data[i*<span class=\"number\">2</span>] = data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>];</div><div class=\"line\">            data[i*<span class=\"number\">2</span>+<span class=\"number\">1</span>] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//i代表每次归并的区间长度，j代表需要归并的两个区间中最小的下标</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; r; i *= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(j) shared(r, i)</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; r-i; j += i*<span class=\"number\">2</span>) &#123;</div><div class=\"line\">            merge(j, j+i, (j+i*<span class=\"number\">2</span> &lt; r ? j+i*<span class=\"number\">2</span> : r), data, temp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"求和代码：\"><a href=\"#求和代码：\" class=\"headerlink\" title=\"求和代码：\"></a>求和代码：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_sum</span><span class=\"params\">(<span class=\"keyword\">int</span>* data, <span class=\"keyword\">int</span> N)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, i;</div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> omp parallel for private(i) reduct(+:sum)</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">        sum += data[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"运行时间：-1\"><a href=\"#运行时间：-1\" class=\"headerlink\" title=\"运行时间：\"></a>运行时间：</h2><table>\n<thead>\n<tr>\n<th>num_elements</th>\n<th>sort time</th>\n<th>sum time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>0.000164</td>\n<td>0.000009</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.000209</td>\n<td>0.000009</td>\n</tr>\n<tr>\n<td>10000</td>\n<td>0.002318</td>\n<td>0.000052</td>\n</tr>\n<tr>\n<td>100000</td>\n<td>0.010589</td>\n<td>0.000166</td>\n</tr>\n<tr>\n<td>1000000</td>\n<td>0.110090</td>\n<td>0.001279</td>\n</tr>\n<tr>\n<td>10000000</td>\n<td>1.093572</td>\n<td>0.013541</td>\n</tr>\n<tr>\n<td>100000000</td>\n<td>11.872408</td>\n<td>0.127646</td>\n</tr>\n</tbody>\n</table>\n<p>ignore the input time.</p>\n<h1 id=\"运行时间分析：\"><a href=\"#运行时间分析：\" class=\"headerlink\" title=\"运行时间分析：\"></a>运行时间分析：</h1><h2 id=\"排序时间对比：\"><a href=\"#排序时间对比：\" class=\"headerlink\" title=\"排序时间对比：\"></a>排序时间对比：</h2><p><img src=\"http://img.blog.csdn.net/20170605210453384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"求和时间对比：\"><a href=\"#求和时间对比：\" class=\"headerlink\" title=\"求和时间对比：\"></a>求和时间对比：</h2><p><img src=\"http://img.blog.csdn.net/20170605210516264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>增加线程数在是可以加快程序的运行速度的，但是随着线程的增加，加速的效果逐渐变得不明显，双线程与单线程的差异较大，整体上多线程的用时为单线程的一半。</p>\n"},{"title":"常见错误清单（长期更新）","date":"2017-05-22T09:22:24.000Z","_content":"+ 素数筛打表的时候默认为1为素数\n\n+ DP转移过程中记录路径的情况，如果是从后向前算的，可能路径会被更新掉\n\n+ 每组数据初始化的时候，注意把建的边清掉一下\n\n+ 对一堆数字进行取LCM的时候，可能会爆int\n\n+ 结构体注意初始化问题，不要以为默认会被初始化为0，最好手写构造函数\n\n+ ～是按位取反，只需要把一位取反的时候不要用\n\n+ 线段树区间更新时updata忘记加lazy标记\n\n+ 输出结果的时候，有时直接输出结构体本地不会错，交上RE，注意下要输出结构体的属性\n\n+ 容斥原理判断某范围内模一些数为0的数的个数的时候，要求这些数之间不能一个数是另一个的倍数，比如2, 3, 4, 5，那么应该舍弃掉4，只取2\n\n+ SPFA用栈替换成队列后，要注意出栈的顺序，要在加入新元素前把旧的出栈，加入新元素后取消出栈元素的标记\n\n+ BFS某些情况应该在入队的时候标记，如果在出队的时候标记，有可能会出现一些不可描述的情况导致MLE\n\n+ 数据太大爆int\n\n+ 计算过程中爆int\n\n+ 取模姿势不对爆int\n\n+ vis，book等标记数组没初始化\n\n+ bfs队列没有pop\n\n+ 类似走迷宫那样的题，下一步要走的地方计算错误(比如ty 本应该是y+dirc[i][0]，结果写成x+dirc[i][0])\n\n+ 浮点数精度误差，要加eps\n\n+ 数组过大每次都要memset初始化，导致超时\n\n+ Case： 和数组之间有个空格，导致pe\n\n+ 直接拿输入的数据当下标，因为有负数re\n\n+ DP过程累加爆int\n\n+ 题目卡SPFA换Dijstra AC\n\n+ 题目卡Vector，用前向星AC\n\n+ DP输出路径时，尽量要从末状态从后往前推，这样容易处理字典序\n\n+ 解方程中，可能爆 int ，比如二元一次方程中的 B 来自输入的两个数据相乘，然后又用到了 B * B 结果 1000 的数据就会爆 int\n\n+ 位运算一定要括起来，某些位运算操作优先级比等于号还低\n\n+ 计算一组数据需要取膜时，记得手动初始化的也要取膜，比如斐波那契数列，f(1) = f(0) = 1 时， 如果模数为 1 那么应该初始化为 0 才对，保险写法为 f(1) = f(0) = 1 % mod\n\n+ 代码WA的时候要多检查下比较长的公式是否错误\n\n+ 对于 long long a = b * b * b 这样的式子要注意 b 是否为 long long 类型，如果不是运算过程中为 int 类型，检查下是否爆 int\n\n+ 注意数据范围， 2^31 是爆 int 的\n\n+ 用矩阵存图的时候，注意重边，如果有重边看情况更新","source":"_posts/常见错误清单（长期更新）.md","raw":"---\ntitle: 常见错误清单（长期更新）\ndate: 2017-05-22 17:22:24\ncategories: [ACM, 知识小结]\ntags:\n---\n+ 素数筛打表的时候默认为1为素数\n\n+ DP转移过程中记录路径的情况，如果是从后向前算的，可能路径会被更新掉\n\n+ 每组数据初始化的时候，注意把建的边清掉一下\n\n+ 对一堆数字进行取LCM的时候，可能会爆int\n\n+ 结构体注意初始化问题，不要以为默认会被初始化为0，最好手写构造函数\n\n+ ～是按位取反，只需要把一位取反的时候不要用\n\n+ 线段树区间更新时updata忘记加lazy标记\n\n+ 输出结果的时候，有时直接输出结构体本地不会错，交上RE，注意下要输出结构体的属性\n\n+ 容斥原理判断某范围内模一些数为0的数的个数的时候，要求这些数之间不能一个数是另一个的倍数，比如2, 3, 4, 5，那么应该舍弃掉4，只取2\n\n+ SPFA用栈替换成队列后，要注意出栈的顺序，要在加入新元素前把旧的出栈，加入新元素后取消出栈元素的标记\n\n+ BFS某些情况应该在入队的时候标记，如果在出队的时候标记，有可能会出现一些不可描述的情况导致MLE\n\n+ 数据太大爆int\n\n+ 计算过程中爆int\n\n+ 取模姿势不对爆int\n\n+ vis，book等标记数组没初始化\n\n+ bfs队列没有pop\n\n+ 类似走迷宫那样的题，下一步要走的地方计算错误(比如ty 本应该是y+dirc[i][0]，结果写成x+dirc[i][0])\n\n+ 浮点数精度误差，要加eps\n\n+ 数组过大每次都要memset初始化，导致超时\n\n+ Case： 和数组之间有个空格，导致pe\n\n+ 直接拿输入的数据当下标，因为有负数re\n\n+ DP过程累加爆int\n\n+ 题目卡SPFA换Dijstra AC\n\n+ 题目卡Vector，用前向星AC\n\n+ DP输出路径时，尽量要从末状态从后往前推，这样容易处理字典序\n\n+ 解方程中，可能爆 int ，比如二元一次方程中的 B 来自输入的两个数据相乘，然后又用到了 B * B 结果 1000 的数据就会爆 int\n\n+ 位运算一定要括起来，某些位运算操作优先级比等于号还低\n\n+ 计算一组数据需要取膜时，记得手动初始化的也要取膜，比如斐波那契数列，f(1) = f(0) = 1 时， 如果模数为 1 那么应该初始化为 0 才对，保险写法为 f(1) = f(0) = 1 % mod\n\n+ 代码WA的时候要多检查下比较长的公式是否错误\n\n+ 对于 long long a = b * b * b 这样的式子要注意 b 是否为 long long 类型，如果不是运算过程中为 int 类型，检查下是否爆 int\n\n+ 注意数据范围， 2^31 是爆 int 的\n\n+ 用矩阵存图的时候，注意重边，如果有重边看情况更新","slug":"常见错误清单（长期更新）","published":1,"updated":"2017-07-23T02:25:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf00063y9idfb4jfl3d","content":"<ul>\n<li><p>素数筛打表的时候默认为1为素数</p>\n</li>\n<li><p>DP转移过程中记录路径的情况，如果是从后向前算的，可能路径会被更新掉</p>\n</li>\n<li><p>每组数据初始化的时候，注意把建的边清掉一下</p>\n</li>\n<li><p>对一堆数字进行取LCM的时候，可能会爆int</p>\n</li>\n<li><p>结构体注意初始化问题，不要以为默认会被初始化为0，最好手写构造函数</p>\n</li>\n<li><p>～是按位取反，只需要把一位取反的时候不要用</p>\n</li>\n<li><p>线段树区间更新时updata忘记加lazy标记</p>\n</li>\n<li><p>输出结果的时候，有时直接输出结构体本地不会错，交上RE，注意下要输出结构体的属性</p>\n</li>\n<li><p>容斥原理判断某范围内模一些数为0的数的个数的时候，要求这些数之间不能一个数是另一个的倍数，比如2, 3, 4, 5，那么应该舍弃掉4，只取2</p>\n</li>\n<li><p>SPFA用栈替换成队列后，要注意出栈的顺序，要在加入新元素前把旧的出栈，加入新元素后取消出栈元素的标记</p>\n</li>\n<li><p>BFS某些情况应该在入队的时候标记，如果在出队的时候标记，有可能会出现一些不可描述的情况导致MLE</p>\n</li>\n<li><p>数据太大爆int</p>\n</li>\n<li><p>计算过程中爆int</p>\n</li>\n<li><p>取模姿势不对爆int</p>\n</li>\n<li><p>vis，book等标记数组没初始化</p>\n</li>\n<li><p>bfs队列没有pop</p>\n</li>\n<li><p>类似走迷宫那样的题，下一步要走的地方计算错误(比如ty 本应该是y+dirc[i][0]，结果写成x+dirc[i][0])</p>\n</li>\n<li><p>浮点数精度误差，要加eps</p>\n</li>\n<li><p>数组过大每次都要memset初始化，导致超时</p>\n</li>\n<li><p>Case： 和数组之间有个空格，导致pe</p>\n</li>\n<li><p>直接拿输入的数据当下标，因为有负数re</p>\n</li>\n<li><p>DP过程累加爆int</p>\n</li>\n<li><p>题目卡SPFA换Dijstra AC</p>\n</li>\n<li><p>题目卡Vector，用前向星AC</p>\n</li>\n<li><p>DP输出路径时，尽量要从末状态从后往前推，这样容易处理字典序</p>\n</li>\n<li><p>解方程中，可能爆 int ，比如二元一次方程中的 B 来自输入的两个数据相乘，然后又用到了 B * B 结果 1000 的数据就会爆 int</p>\n</li>\n<li><p>位运算一定要括起来，某些位运算操作优先级比等于号还低</p>\n</li>\n<li><p>计算一组数据需要取膜时，记得手动初始化的也要取膜，比如斐波那契数列，f(1) = f(0) = 1 时， 如果模数为 1 那么应该初始化为 0 才对，保险写法为 f(1) = f(0) = 1 % mod</p>\n</li>\n<li><p>代码WA的时候要多检查下比较长的公式是否错误</p>\n</li>\n<li><p>对于 long long a = b <em> b </em> b 这样的式子要注意 b 是否为 long long 类型，如果不是运算过程中为 int 类型，检查下是否爆 int</p>\n</li>\n<li><p>注意数据范围， 2^31 是爆 int 的</p>\n</li>\n<li><p>用矩阵存图的时候，注意重边，如果有重边看情况更新</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>素数筛打表的时候默认为1为素数</p>\n</li>\n<li><p>DP转移过程中记录路径的情况，如果是从后向前算的，可能路径会被更新掉</p>\n</li>\n<li><p>每组数据初始化的时候，注意把建的边清掉一下</p>\n</li>\n<li><p>对一堆数字进行取LCM的时候，可能会爆int</p>\n</li>\n<li><p>结构体注意初始化问题，不要以为默认会被初始化为0，最好手写构造函数</p>\n</li>\n<li><p>～是按位取反，只需要把一位取反的时候不要用</p>\n</li>\n<li><p>线段树区间更新时updata忘记加lazy标记</p>\n</li>\n<li><p>输出结果的时候，有时直接输出结构体本地不会错，交上RE，注意下要输出结构体的属性</p>\n</li>\n<li><p>容斥原理判断某范围内模一些数为0的数的个数的时候，要求这些数之间不能一个数是另一个的倍数，比如2, 3, 4, 5，那么应该舍弃掉4，只取2</p>\n</li>\n<li><p>SPFA用栈替换成队列后，要注意出栈的顺序，要在加入新元素前把旧的出栈，加入新元素后取消出栈元素的标记</p>\n</li>\n<li><p>BFS某些情况应该在入队的时候标记，如果在出队的时候标记，有可能会出现一些不可描述的情况导致MLE</p>\n</li>\n<li><p>数据太大爆int</p>\n</li>\n<li><p>计算过程中爆int</p>\n</li>\n<li><p>取模姿势不对爆int</p>\n</li>\n<li><p>vis，book等标记数组没初始化</p>\n</li>\n<li><p>bfs队列没有pop</p>\n</li>\n<li><p>类似走迷宫那样的题，下一步要走的地方计算错误(比如ty 本应该是y+dirc[i][0]，结果写成x+dirc[i][0])</p>\n</li>\n<li><p>浮点数精度误差，要加eps</p>\n</li>\n<li><p>数组过大每次都要memset初始化，导致超时</p>\n</li>\n<li><p>Case： 和数组之间有个空格，导致pe</p>\n</li>\n<li><p>直接拿输入的数据当下标，因为有负数re</p>\n</li>\n<li><p>DP过程累加爆int</p>\n</li>\n<li><p>题目卡SPFA换Dijstra AC</p>\n</li>\n<li><p>题目卡Vector，用前向星AC</p>\n</li>\n<li><p>DP输出路径时，尽量要从末状态从后往前推，这样容易处理字典序</p>\n</li>\n<li><p>解方程中，可能爆 int ，比如二元一次方程中的 B 来自输入的两个数据相乘，然后又用到了 B * B 结果 1000 的数据就会爆 int</p>\n</li>\n<li><p>位运算一定要括起来，某些位运算操作优先级比等于号还低</p>\n</li>\n<li><p>计算一组数据需要取膜时，记得手动初始化的也要取膜，比如斐波那契数列，f(1) = f(0) = 1 时， 如果模数为 1 那么应该初始化为 0 才对，保险写法为 f(1) = f(0) = 1 % mod</p>\n</li>\n<li><p>代码WA的时候要多检查下比较长的公式是否错误</p>\n</li>\n<li><p>对于 long long a = b <em> b </em> b 这样的式子要注意 b 是否为 long long 类型，如果不是运算过程中为 int 类型，检查下是否爆 int</p>\n</li>\n<li><p>注意数据范围， 2^31 是爆 int 的</p>\n</li>\n<li><p>用矩阵存图的时候，注意重边，如果有重边看情况更新</p>\n</li>\n</ul>\n"},{"title":"数位DP（模板）","date":"2017-04-24T08:53:28.000Z","_content":"# 推荐博客：\nhttp://zyk1997.github.io/2015/03/20/ShuWeiDP/\n\n-----------------------------\n# 模板题：\nhttp://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3555\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2089\n\n----------------------------------------\n# 模板：\n```cpp\n//pos当前的位置，pre上一位的数字，ok现在是否已满足题目的条件，bound是否受到限制。\nLL dfs(int pos,int pre,int ok,int bound){\n\t//如果递归到个位，就到达了边界并返回。\n    if(pos < 0)\n        return ok;\n        \n    //如果不受限制，那么可以查看dp数组当前状态是否计算过。\n    if(!bound && dp[x][pre][ok]!=-1)\n        return dp[x][pre][ok];\n       \n    //根据是否受限制，确定需要枚举的数。\n    int last=bound? num[x]:9;\n    \n    LL rst=0;\n    \n    for(int i=0;i<=last;i++)\n\t    //成立条件根据题目要求，如果当前枚举的是最后应该是，并且受限制，那么下一位也受限制。\n        re+=dfs(x-1, i, ok || (成立条件), bound && (i==last));\n    \n    //如果不受限制，那么更新dp数组。\n    if(!bound) f[x][pre][ok]=re;\n    return re;\n} \n\nLL solve(LL n){\n    int len=0;\n    while(n){\n        num[len++]=n%10;\n        n/=10;\n    }\n    return dfs(len-1,0,0,1);\n}\n```\n","source":"_posts/数位DP（模板）.md","raw":"---\ntitle: 数位DP（模板）\ndate: 2017-04-24 16:53:28\ncategories: [ACM, DP, 数位DP]\ntags:\n---\n# 推荐博客：\nhttp://zyk1997.github.io/2015/03/20/ShuWeiDP/\n\n-----------------------------\n# 模板题：\nhttp://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3555\n\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2089\n\n----------------------------------------\n# 模板：\n```cpp\n//pos当前的位置，pre上一位的数字，ok现在是否已满足题目的条件，bound是否受到限制。\nLL dfs(int pos,int pre,int ok,int bound){\n\t//如果递归到个位，就到达了边界并返回。\n    if(pos < 0)\n        return ok;\n        \n    //如果不受限制，那么可以查看dp数组当前状态是否计算过。\n    if(!bound && dp[x][pre][ok]!=-1)\n        return dp[x][pre][ok];\n       \n    //根据是否受限制，确定需要枚举的数。\n    int last=bound? num[x]:9;\n    \n    LL rst=0;\n    \n    for(int i=0;i<=last;i++)\n\t    //成立条件根据题目要求，如果当前枚举的是最后应该是，并且受限制，那么下一位也受限制。\n        re+=dfs(x-1, i, ok || (成立条件), bound && (i==last));\n    \n    //如果不受限制，那么更新dp数组。\n    if(!bound) f[x][pre][ok]=re;\n    return re;\n} \n\nLL solve(LL n){\n    int len=0;\n    while(n){\n        num[len++]=n%10;\n        n/=10;\n    }\n    return dfs(len-1,0,0,1);\n}\n```\n","slug":"数位DP（模板）","published":1,"updated":"2017-07-23T02:39:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf30066y9idaes7wvy6","content":"<h1 id=\"推荐博客：\"><a href=\"#推荐博客：\" class=\"headerlink\" title=\"推荐博客：\"></a>推荐博客：</h1><p><a href=\"http://zyk1997.github.io/2015/03/20/ShuWeiDP/\" target=\"_blank\" rel=\"external\">http://zyk1997.github.io/2015/03/20/ShuWeiDP/</a></p>\n<hr>\n<h1 id=\"模板题：\"><a href=\"#模板题：\" class=\"headerlink\" title=\"模板题：\"></a>模板题：</h1><p><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009\" target=\"_blank\" rel=\"external\">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3555\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3555</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2089\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2089</a></p>\n<hr>\n<h1 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//pos当前的位置，pre上一位的数字，ok现在是否已满足题目的条件，bound是否受到限制。</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> ok,<span class=\"keyword\">int</span> bound)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//如果递归到个位，就到达了边界并返回。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(pos &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> ok;</div><div class=\"line\">        </div><div class=\"line\">    <span class=\"comment\">//如果不受限制，那么可以查看dp数组当前状态是否计算过。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!bound &amp;&amp; dp[x][pre][ok]!=<span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> dp[x][pre][ok];</div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">//根据是否受限制，确定需要枚举的数。</span></div><div class=\"line\">    <span class=\"keyword\">int</span> last=bound? num[x]:<span class=\"number\">9</span>;</div><div class=\"line\">    </div><div class=\"line\">    LL rst=<span class=\"number\">0</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=last;i++)</div><div class=\"line\">\t    <span class=\"comment\">//成立条件根据题目要求，如果当前枚举的是最后应该是，并且受限制，那么下一位也受限制。</span></div><div class=\"line\">        re+=dfs(x<span class=\"number\">-1</span>, i, ok || (成立条件), bound &amp;&amp; (i==last));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//如果不受限制，那么更新dp数组。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!bound) f[x][pre][ok]=re;</div><div class=\"line\">    <span class=\"keyword\">return</span> re;</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">solve</span><span class=\"params\">(LL n)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n)&#123;</div><div class=\"line\">        num[len++]=n%<span class=\"number\">10</span>;</div><div class=\"line\">        n/=<span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dfs(len<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"推荐博客：\"><a href=\"#推荐博客：\" class=\"headerlink\" title=\"推荐博客：\"></a>推荐博客：</h1><p><a href=\"http://zyk1997.github.io/2015/03/20/ShuWeiDP/\" target=\"_blank\" rel=\"external\">http://zyk1997.github.io/2015/03/20/ShuWeiDP/</a></p>\n<hr>\n<h1 id=\"模板题：\"><a href=\"#模板题：\" class=\"headerlink\" title=\"模板题：\"></a>模板题：</h1><p><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009\" target=\"_blank\" rel=\"external\">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3555\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=3555</a></p>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2089\" target=\"_blank\" rel=\"external\">http://acm.hdu.edu.cn/showproblem.php?pid=2089</a></p>\n<hr>\n<h1 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//pos当前的位置，pre上一位的数字，ok现在是否已满足题目的条件，bound是否受到限制。</span></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> ok,<span class=\"keyword\">int</span> bound)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//如果递归到个位，就到达了边界并返回。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(pos &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> ok;</div><div class=\"line\">        </div><div class=\"line\">    <span class=\"comment\">//如果不受限制，那么可以查看dp数组当前状态是否计算过。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!bound &amp;&amp; dp[x][pre][ok]!=<span class=\"number\">-1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> dp[x][pre][ok];</div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">//根据是否受限制，确定需要枚举的数。</span></div><div class=\"line\">    <span class=\"keyword\">int</span> last=bound? num[x]:<span class=\"number\">9</span>;</div><div class=\"line\">    </div><div class=\"line\">    LL rst=<span class=\"number\">0</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=last;i++)</div><div class=\"line\">\t    <span class=\"comment\">//成立条件根据题目要求，如果当前枚举的是最后应该是，并且受限制，那么下一位也受限制。</span></div><div class=\"line\">        re+=dfs(x<span class=\"number\">-1</span>, i, ok || (成立条件), bound &amp;&amp; (i==last));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//如果不受限制，那么更新dp数组。</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!bound) f[x][pre][ok]=re;</div><div class=\"line\">    <span class=\"keyword\">return</span> re;</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">LL <span class=\"title\">solve</span><span class=\"params\">(LL n)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n)&#123;</div><div class=\"line\">        num[len++]=n%<span class=\"number\">10</span>;</div><div class=\"line\">        n/=<span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> dfs(len<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"口琴用简谱简易教程","date":"2017-10-08T11:19:55.000Z","_content":"\n\n# 简介\n\n音乐的构成主要由以下四个要素：\n\n+ 音的高低\n+ 音的长短\n+ 音的强弱\n+ 音的音质\n\n这里主要说下简谱对于音的高低和音的长短是怎么表示的。\n\n\n\n# 音高\n\n在简谱中最基本的符号就是音符，音符用 1 - 7 的数字来表示，分别代表音的高低，对应读法依次是 do re mi fa so la si。所以说一个音符的写法就代表了这个音的高低。\n\n但是只用 7 个数字来表示所有音的高低未免太少了些，而且人们发现声音的高低之间也是有规律的，所以可以把音的高低分为七个一组。于是有了低音，中音，高音之分，对于口琴来说了解这些已经够用了。\n\n中音就是直接用 1 - 7 来表示，高音是给数字上面加一个点从 $\\dot{1} $ - $\\dot{7}$，低音同理不过点是画在下面的。\n\n![](http://chuantu.biz/t6/85/1507462318x2890149721.png)\n\n\n\n上图对应半音阶的孔位布局，还是比较容易理解的，每个孔对应两个音高，左边的是吹音，右边的是吸音。口琴是包括吹和吸的（所以不像网上别人说的那样，“这个人口琴好厉害呀，肺活量一定很大吧”之类的）。\n\n这里需要注意的是，半音阶是有一个半音的，加音符前面加一个 #，例如 #1，这个半音就是指一个介于 1 与 2 之间的音。\n\n所以半音阶对比其他孔数相同的口琴，多了一倍的音。比如 12 孔的半音阶，吹吸分别是两个音，然后按下推键之后又是两个音，所以是 $12 \\times 2 \\times 2 = 48$ 个音。\n\n\n\n# 音长\n\n很多谱子上面有一个 $\\frac{4}{4}$的符号，对于$\\frac{a}{b}$ 的含义是，以 b 分音符为一拍，每小节有 a 拍。\n\n至于一拍有多长时间，这个就见仁见智了，所以说每一拍的时长都是相对的，但是节奏是有序的。\n\n音符分为\n\n+ 全音符 1———\n+ 二分音符1—\n+ 四分音符1\n+ 八分音符$\\underline{1}$\n\n（其实还有十六分音符，三十二分音符，对应的把下划线多划几道就是了）\n\n乐谱中基本上以四分音符为主，确定号四分音符的时长，其他的都是根据四分音符得来的。\n\n比如，一个四分音符吹 1 s 那么对应的一个八分音符需要吹 0.5 s 。\n\n\n\n另外还有一种经常见到的是连音线。这里无法用数学公式打出，只好复制图片了。\n\n\n\n![](http://chuantu.biz/t6/85/1507471897x2890149721.png)\n\n最后，乐谱中常见的那一个竖线，是小节线，表示一小结的结束。\n\n\n\n# 常见的纯数字谱\n\n好多人为了在网上记谱方便，用 1 代表中音 1，(1) 代表低音 1，[1] 代表高音1。\n\n但是这并不是硬性规定，也可以用 1 代表低音，[1]，至于这点，一般会给出说明的，如果没有的话试一下就好了。\n\n\n\n例如下面的天空之城谱子 [] 表示高音，不加任何括号是低音。\n\n```\n7[#1] [2][#1][2][#4][#1]\n#4#4767[2]6\n#4#45#45[2]#4\n[2] [2] [2][#1]#5#5[#1][#1]\n7[#1] [2][#1][2][#4][#1]\n#4#4767[2]6\n#45[2][#1][#1][2][3][3][#4][2]\n[2][#1]77[#1]#67\n[2][3][#4][3][#4][6][3]\n66[2][#1][2][#4][#4]\n7[#1][2][#1][3][3][2]66\n[5][#4][3][2][#4]\n[#4][7][6] [6][#4][3][2]\n[2][3][2][3][3][6][#4]\n[#4][7][6][#4][3][2]\n[2][3][2][3][3][#1]7\n```\n\n不过这样完全看不出来音长了，只能凭感觉，所以建议找铺子的时候去找规范的简谱，这种谱子到时比较普及就是了。","source":"_posts/口琴用简谱简易教程.md","raw":"---\ntitle: 口琴用简谱简易教程\ndate: 2017-10-08 19:19:55\ncategories: [音乐, 乐理]\ntags:\n---\n\n\n# 简介\n\n音乐的构成主要由以下四个要素：\n\n+ 音的高低\n+ 音的长短\n+ 音的强弱\n+ 音的音质\n\n这里主要说下简谱对于音的高低和音的长短是怎么表示的。\n\n\n\n# 音高\n\n在简谱中最基本的符号就是音符，音符用 1 - 7 的数字来表示，分别代表音的高低，对应读法依次是 do re mi fa so la si。所以说一个音符的写法就代表了这个音的高低。\n\n但是只用 7 个数字来表示所有音的高低未免太少了些，而且人们发现声音的高低之间也是有规律的，所以可以把音的高低分为七个一组。于是有了低音，中音，高音之分，对于口琴来说了解这些已经够用了。\n\n中音就是直接用 1 - 7 来表示，高音是给数字上面加一个点从 $\\dot{1} $ - $\\dot{7}$，低音同理不过点是画在下面的。\n\n![](http://chuantu.biz/t6/85/1507462318x2890149721.png)\n\n\n\n上图对应半音阶的孔位布局，还是比较容易理解的，每个孔对应两个音高，左边的是吹音，右边的是吸音。口琴是包括吹和吸的（所以不像网上别人说的那样，“这个人口琴好厉害呀，肺活量一定很大吧”之类的）。\n\n这里需要注意的是，半音阶是有一个半音的，加音符前面加一个 #，例如 #1，这个半音就是指一个介于 1 与 2 之间的音。\n\n所以半音阶对比其他孔数相同的口琴，多了一倍的音。比如 12 孔的半音阶，吹吸分别是两个音，然后按下推键之后又是两个音，所以是 $12 \\times 2 \\times 2 = 48$ 个音。\n\n\n\n# 音长\n\n很多谱子上面有一个 $\\frac{4}{4}$的符号，对于$\\frac{a}{b}$ 的含义是，以 b 分音符为一拍，每小节有 a 拍。\n\n至于一拍有多长时间，这个就见仁见智了，所以说每一拍的时长都是相对的，但是节奏是有序的。\n\n音符分为\n\n+ 全音符 1———\n+ 二分音符1—\n+ 四分音符1\n+ 八分音符$\\underline{1}$\n\n（其实还有十六分音符，三十二分音符，对应的把下划线多划几道就是了）\n\n乐谱中基本上以四分音符为主，确定号四分音符的时长，其他的都是根据四分音符得来的。\n\n比如，一个四分音符吹 1 s 那么对应的一个八分音符需要吹 0.5 s 。\n\n\n\n另外还有一种经常见到的是连音线。这里无法用数学公式打出，只好复制图片了。\n\n\n\n![](http://chuantu.biz/t6/85/1507471897x2890149721.png)\n\n最后，乐谱中常见的那一个竖线，是小节线，表示一小结的结束。\n\n\n\n# 常见的纯数字谱\n\n好多人为了在网上记谱方便，用 1 代表中音 1，(1) 代表低音 1，[1] 代表高音1。\n\n但是这并不是硬性规定，也可以用 1 代表低音，[1]，至于这点，一般会给出说明的，如果没有的话试一下就好了。\n\n\n\n例如下面的天空之城谱子 [] 表示高音，不加任何括号是低音。\n\n```\n7[#1] [2][#1][2][#4][#1]\n#4#4767[2]6\n#4#45#45[2]#4\n[2] [2] [2][#1]#5#5[#1][#1]\n7[#1] [2][#1][2][#4][#1]\n#4#4767[2]6\n#45[2][#1][#1][2][3][3][#4][2]\n[2][#1]77[#1]#67\n[2][3][#4][3][#4][6][3]\n66[2][#1][2][#4][#4]\n7[#1][2][#1][3][3][2]66\n[5][#4][3][2][#4]\n[#4][7][6] [6][#4][3][2]\n[2][3][2][3][3][6][#4]\n[#4][7][6][#4][3][2]\n[2][3][2][3][3][#1]7\n```\n\n不过这样完全看不出来音长了，只能凭感觉，所以建议找铺子的时候去找规范的简谱，这种谱子到时比较普及就是了。","slug":"口琴用简谱简易教程","published":1,"updated":"2017-10-08T14:20:53.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf40068y9idd2reblc5","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>音乐的构成主要由以下四个要素：</p>\n<ul>\n<li>音的高低</li>\n<li>音的长短</li>\n<li>音的强弱</li>\n<li>音的音质</li>\n</ul>\n<p>这里主要说下简谱对于音的高低和音的长短是怎么表示的。</p>\n<h1 id=\"音高\"><a href=\"#音高\" class=\"headerlink\" title=\"音高\"></a>音高</h1><p>在简谱中最基本的符号就是音符，音符用 1 - 7 的数字来表示，分别代表音的高低，对应读法依次是 do re mi fa so la si。所以说一个音符的写法就代表了这个音的高低。</p>\n<p>但是只用 7 个数字来表示所有音的高低未免太少了些，而且人们发现声音的高低之间也是有规律的，所以可以把音的高低分为七个一组。于是有了低音，中音，高音之分，对于口琴来说了解这些已经够用了。</p>\n<p>中音就是直接用 1 - 7 来表示，高音是给数字上面加一个点从 $\\dot{1} $ - $\\dot{7}$，低音同理不过点是画在下面的。</p>\n<p><img src=\"http://chuantu.biz/t6/85/1507462318x2890149721.png\" alt=\"\"></p>\n<p>上图对应半音阶的孔位布局，还是比较容易理解的，每个孔对应两个音高，左边的是吹音，右边的是吸音。口琴是包括吹和吸的（所以不像网上别人说的那样，“这个人口琴好厉害呀，肺活量一定很大吧”之类的）。</p>\n<p>这里需要注意的是，半音阶是有一个半音的，加音符前面加一个 #，例如 #1，这个半音就是指一个介于 1 与 2 之间的音。</p>\n<p>所以半音阶对比其他孔数相同的口琴，多了一倍的音。比如 12 孔的半音阶，吹吸分别是两个音，然后按下推键之后又是两个音，所以是 $12 \\times 2 \\times 2 = 48$ 个音。</p>\n<h1 id=\"音长\"><a href=\"#音长\" class=\"headerlink\" title=\"音长\"></a>音长</h1><p>很多谱子上面有一个 $\\frac{4}{4}$的符号，对于$\\frac{a}{b}$ 的含义是，以 b 分音符为一拍，每小节有 a 拍。</p>\n<p>至于一拍有多长时间，这个就见仁见智了，所以说每一拍的时长都是相对的，但是节奏是有序的。</p>\n<p>音符分为</p>\n<ul>\n<li>全音符 1———</li>\n<li>二分音符1—</li>\n<li>四分音符1</li>\n<li>八分音符$\\underline{1}$</li>\n</ul>\n<p>（其实还有十六分音符，三十二分音符，对应的把下划线多划几道就是了）</p>\n<p>乐谱中基本上以四分音符为主，确定号四分音符的时长，其他的都是根据四分音符得来的。</p>\n<p>比如，一个四分音符吹 1 s 那么对应的一个八分音符需要吹 0.5 s 。</p>\n<p>另外还有一种经常见到的是连音线。这里无法用数学公式打出，只好复制图片了。</p>\n<p><img src=\"http://chuantu.biz/t6/85/1507471897x2890149721.png\" alt=\"\"></p>\n<p>最后，乐谱中常见的那一个竖线，是小节线，表示一小结的结束。</p>\n<h1 id=\"常见的纯数字谱\"><a href=\"#常见的纯数字谱\" class=\"headerlink\" title=\"常见的纯数字谱\"></a>常见的纯数字谱</h1><p>好多人为了在网上记谱方便，用 1 代表中音 1，(1) 代表低音 1，[1] 代表高音1。</p>\n<p>但是这并不是硬性规定，也可以用 1 代表低音，[1]，至于这点，一般会给出说明的，如果没有的话试一下就好了。</p>\n<p>例如下面的天空之城谱子 [] 表示高音，不加任何括号是低音。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">7[#1] [2][#1][2][#4][#1]</div><div class=\"line\">#4#4767[2]6</div><div class=\"line\">#4#45#45[2]#4</div><div class=\"line\">[2] [2] [2][#1]#5#5[#1][#1]</div><div class=\"line\">7[#1] [2][#1][2][#4][#1]</div><div class=\"line\">#4#4767[2]6</div><div class=\"line\">#45[2][#1][#1][2][3][3][#4][2]</div><div class=\"line\">[2][#1]77[#1]#67</div><div class=\"line\">[2][3][#4][3][#4][6][3]</div><div class=\"line\">66[2][#1][2][#4][#4]</div><div class=\"line\">7[#1][2][#1][3][3][2]66</div><div class=\"line\">[5][#4][3][2][#4]</div><div class=\"line\">[#4][7][6] [6][#4][3][2]</div><div class=\"line\">[2][3][2][3][3][6][#4]</div><div class=\"line\">[#4][7][6][#4][3][2]</div><div class=\"line\">[2][3][2][3][3][#1]7</div></pre></td></tr></table></figure>\n<p>不过这样完全看不出来音长了，只能凭感觉，所以建议找铺子的时候去找规范的简谱，这种谱子到时比较普及就是了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>音乐的构成主要由以下四个要素：</p>\n<ul>\n<li>音的高低</li>\n<li>音的长短</li>\n<li>音的强弱</li>\n<li>音的音质</li>\n</ul>\n<p>这里主要说下简谱对于音的高低和音的长短是怎么表示的。</p>\n<h1 id=\"音高\"><a href=\"#音高\" class=\"headerlink\" title=\"音高\"></a>音高</h1><p>在简谱中最基本的符号就是音符，音符用 1 - 7 的数字来表示，分别代表音的高低，对应读法依次是 do re mi fa so la si。所以说一个音符的写法就代表了这个音的高低。</p>\n<p>但是只用 7 个数字来表示所有音的高低未免太少了些，而且人们发现声音的高低之间也是有规律的，所以可以把音的高低分为七个一组。于是有了低音，中音，高音之分，对于口琴来说了解这些已经够用了。</p>\n<p>中音就是直接用 1 - 7 来表示，高音是给数字上面加一个点从 $\\dot{1} $ - $\\dot{7}$，低音同理不过点是画在下面的。</p>\n<p><img src=\"http://chuantu.biz/t6/85/1507462318x2890149721.png\" alt=\"\"></p>\n<p>上图对应半音阶的孔位布局，还是比较容易理解的，每个孔对应两个音高，左边的是吹音，右边的是吸音。口琴是包括吹和吸的（所以不像网上别人说的那样，“这个人口琴好厉害呀，肺活量一定很大吧”之类的）。</p>\n<p>这里需要注意的是，半音阶是有一个半音的，加音符前面加一个 #，例如 #1，这个半音就是指一个介于 1 与 2 之间的音。</p>\n<p>所以半音阶对比其他孔数相同的口琴，多了一倍的音。比如 12 孔的半音阶，吹吸分别是两个音，然后按下推键之后又是两个音，所以是 $12 \\times 2 \\times 2 = 48$ 个音。</p>\n<h1 id=\"音长\"><a href=\"#音长\" class=\"headerlink\" title=\"音长\"></a>音长</h1><p>很多谱子上面有一个 $\\frac{4}{4}$的符号，对于$\\frac{a}{b}$ 的含义是，以 b 分音符为一拍，每小节有 a 拍。</p>\n<p>至于一拍有多长时间，这个就见仁见智了，所以说每一拍的时长都是相对的，但是节奏是有序的。</p>\n<p>音符分为</p>\n<ul>\n<li>全音符 1———</li>\n<li>二分音符1—</li>\n<li>四分音符1</li>\n<li>八分音符$\\underline{1}$</li>\n</ul>\n<p>（其实还有十六分音符，三十二分音符，对应的把下划线多划几道就是了）</p>\n<p>乐谱中基本上以四分音符为主，确定号四分音符的时长，其他的都是根据四分音符得来的。</p>\n<p>比如，一个四分音符吹 1 s 那么对应的一个八分音符需要吹 0.5 s 。</p>\n<p>另外还有一种经常见到的是连音线。这里无法用数学公式打出，只好复制图片了。</p>\n<p><img src=\"http://chuantu.biz/t6/85/1507471897x2890149721.png\" alt=\"\"></p>\n<p>最后，乐谱中常见的那一个竖线，是小节线，表示一小结的结束。</p>\n<h1 id=\"常见的纯数字谱\"><a href=\"#常见的纯数字谱\" class=\"headerlink\" title=\"常见的纯数字谱\"></a>常见的纯数字谱</h1><p>好多人为了在网上记谱方便，用 1 代表中音 1，(1) 代表低音 1，[1] 代表高音1。</p>\n<p>但是这并不是硬性规定，也可以用 1 代表低音，[1]，至于这点，一般会给出说明的，如果没有的话试一下就好了。</p>\n<p>例如下面的天空之城谱子 [] 表示高音，不加任何括号是低音。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">7[#1] [2][#1][2][#4][#1]</div><div class=\"line\">#4#4767[2]6</div><div class=\"line\">#4#45#45[2]#4</div><div class=\"line\">[2] [2] [2][#1]#5#5[#1][#1]</div><div class=\"line\">7[#1] [2][#1][2][#4][#1]</div><div class=\"line\">#4#4767[2]6</div><div class=\"line\">#45[2][#1][#1][2][3][3][#4][2]</div><div class=\"line\">[2][#1]77[#1]#67</div><div class=\"line\">[2][3][#4][3][#4][6][3]</div><div class=\"line\">66[2][#1][2][#4][#4]</div><div class=\"line\">7[#1][2][#1][3][3][2]66</div><div class=\"line\">[5][#4][3][2][#4]</div><div class=\"line\">[#4][7][6] [6][#4][3][2]</div><div class=\"line\">[2][3][2][3][3][6][#4]</div><div class=\"line\">[#4][7][6][#4][3][2]</div><div class=\"line\">[2][3][2][3][3][#1]7</div></pre></td></tr></table></figure>\n<p>不过这样完全看不出来音长了，只能凭感觉，所以建议找铺子的时候去找规范的简谱，这种谱子到时比较普及就是了。</p>\n"},{"title":"最长上升子序列（DP+模板）","date":"2017-04-09T08:22:35.000Z","_content":"# 题目链接：\n http://poj.org/problem?id=1631\n \n-------------------------------------\n# 题目大意：\n 有两个不可描述的线段，每个上面有 n 个接口，现在给定了一个连接，求如果减去一些连接的话，最大的不交叉连接个数是多少。\n\n-----------------------------------------------\n# 解题过程：\n 省赛选拔赛的题，英文题面太长直接没看。\n 理解题意后挺简单的，只要找到规律。\n\n---------------\n# 题目分析：\n  要求最大的不交叉，可以找到一个规律，就是求不递减子序列，不过这里用 O(n^2) 的会超时，所以用了一个 O(nlongn) 的模板。\n\n# AC代码：\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint dp[40000+100];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, ans = 0, t;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &t);\n            if (!ans || t >= dp[ans-1])\n                dp[ans++] = t;\n            else\n                dp[lower_bound(dp, dp+ans, t)-dp] = t;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```","source":"_posts/最长上升子序列（DP-模板）.md","raw":"---\ntitle: 最长上升子序列（DP+模板）\ndate: 2017-04-09 16:22:35\ncategories: [ACM, DP]\ntags:\n---\n# 题目链接：\n http://poj.org/problem?id=1631\n \n-------------------------------------\n# 题目大意：\n 有两个不可描述的线段，每个上面有 n 个接口，现在给定了一个连接，求如果减去一些连接的话，最大的不交叉连接个数是多少。\n\n-----------------------------------------------\n# 解题过程：\n 省赛选拔赛的题，英文题面太长直接没看。\n 理解题意后挺简单的，只要找到规律。\n\n---------------\n# 题目分析：\n  要求最大的不交叉，可以找到一个规律，就是求不递减子序列，不过这里用 O(n^2) 的会超时，所以用了一个 O(nlongn) 的模板。\n\n# AC代码：\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint dp[40000+100];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, ans = 0, t;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &t);\n            if (!ans || t >= dp[ans-1])\n                dp[ans++] = t;\n            else\n                dp[lower_bound(dp, dp+ans, t)-dp] = t;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}\n```","slug":"最长上升子序列（DP-模板）","published":1,"updated":"2017-07-23T02:44:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf6006by9idth3xz6b3","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p> <a href=\"http://poj.org/problem?id=1631\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1631</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有两个不可描述的线段，每个上面有 n 个接口，现在给定了一个连接，求如果减去一些连接的话，最大的不交叉连接个数是多少。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 省赛选拔赛的题，英文题面太长直接没看。<br> 理解题意后挺简单的，只要找到规律。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>  要求最大的不交叉，可以找到一个规律，就是求不递减子序列，不过这里用 O(n^2) 的会超时，所以用了一个 O(nlongn) 的模板。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">40000</span>+<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, t;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!ans || t &gt;= dp[ans<span class=\"number\">-1</span>])</div><div class=\"line\">                dp[ans++] = t;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[lower_bound(dp, dp+ans, t)-dp] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><p> <a href=\"http://poj.org/problem?id=1631\" target=\"_blank\" rel=\"external\">http://poj.org/problem?id=1631</a></p>\n<hr>\n<h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><p> 有两个不可描述的线段，每个上面有 n 个接口，现在给定了一个连接，求如果减去一些连接的话，最大的不交叉连接个数是多少。</p>\n<hr>\n<h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 省赛选拔赛的题，英文题面太长直接没看。<br> 理解题意后挺简单的，只要找到规律。</p>\n<hr>\n<h1 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h1><p>  要求最大的不交叉，可以找到一个规律，就是求不递减子序列，不过这里用 O(n^2) 的会超时，所以用了一个 O(nlongn) 的模板。</p>\n<h1 id=\"AC代码：\"><a href=\"#AC代码：\" class=\"headerlink\" title=\"AC代码：\"></a>AC代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">40000</span>+<span class=\"number\">100</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> T;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</div><div class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, t;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!ans || t &gt;= dp[ans<span class=\"number\">-1</span>])</div><div class=\"line\">                dp[ans++] = t;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                dp[lower_bound(dp, dp+ans, t)-dp] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"持续正反馈的任务清单计划","date":"2017-09-03T11:17:28.000Z","_content":"![](http://chuantu.biz/t6/34/1504437603x2890149823.jpg)\n\n# 碎碎念：\n\n封面（姑且算是吧）是缘之空里的瑛，也算是主角之一了，最近推了缘之空的穹线和瑛线，无法自拔...\n\n好吧接下来说下正题，这个其实就是一个任务清单，不过一般任务清单自己一般懒得的去完成，然后逐渐就忘记了这东西，并且涉及人物计划还可能很费时，之前也算是尝试了好多次，但都是以失败告终，一是当时高中时间安排的比较严格，没有自由安排的时间，完全不需要任务清单这种东西，另外就是这里的重点。对于一个任务清单，可能完成一项任务，任务本身对自己的正反馈不一定可以补偿完成任务的付出。然后现在也算是大二了，怕没有个任务清单的话，导致一学期过得浑浑噩噩的，需要一个东西来设定自己的计划。\n\n\n\n# 介绍：\n\n然后这次打算用一种方式解决上面的问题，首先重要的一点是，完成一项任务后要得到一定的奖励，这个奖励要对应完成任务所需要的付出，于是想来想去，感觉最好的奖励就是金钱了，然后就是给自己设定一些计划，用金钱去衡量完成任务得到的收益，以及完成任务所需要的付出。\n\n这里有两点需要严格遵守的，一个是自己要严格一些，一些杂七杂八的东西就不要加到计划清单了，并且必须要完成的东西不要加进来，例如完成学校的作业等，这里列举一下算是值得加到任务清单事情：\n\n+ 阅读一本书的第 x 章\n+ 学习主席树并完成习题\n+ 打完一场 Codeforce 并把力所能及的题补掉（这个任务可重复完成）\n\n另外一个重点是，每个任务的任务量一定小，不要上来就抛出一个 “阅读《算法导论》”的任务，对于这样难以完成的任务一定要拆开，比如拆成阅读完第几章等。\n\n另外一点是拿金钱当奖励的，所以某些日常需求用到的钱是要和这里的奖励分开的，比如要买几点应季的衣服，或者普通吃顿饭，买书，就不必用奖励的前，对于“想要买个好一点的耳机”、“这个游戏真好玩，想买”这样的需求，就要从奖励里拿出了。\n\n# 实现：\n\n计划大概是那样的，这里我打算暂时用印象笔记当工具，每个计划对应一个提醒，每次添加计划的时候输入计划的名字和奖励。\n\n以后打算写一个网页或移动端的程序的，想来想去有点复杂，还是用印象笔记实现好了。\n\n# 最后：\n\n以上大概就是全部的计划了，可以看得出来，完全要靠直接去遵守规则的，看起来有点像小孩子的过家家。不过如果能进行下去，感觉对自己应该是非常有益的，写这篇博客也算是警示一下自己吧，看看能坚持多久。","source":"_posts/持续正反馈的任务清单计划.md","raw":"---\ntitle: 持续正反馈的任务清单计划\ndate: 2017-09-03 19:17:28\ncategories: [想法]\ntags:\n---\n![](http://chuantu.biz/t6/34/1504437603x2890149823.jpg)\n\n# 碎碎念：\n\n封面（姑且算是吧）是缘之空里的瑛，也算是主角之一了，最近推了缘之空的穹线和瑛线，无法自拔...\n\n好吧接下来说下正题，这个其实就是一个任务清单，不过一般任务清单自己一般懒得的去完成，然后逐渐就忘记了这东西，并且涉及人物计划还可能很费时，之前也算是尝试了好多次，但都是以失败告终，一是当时高中时间安排的比较严格，没有自由安排的时间，完全不需要任务清单这种东西，另外就是这里的重点。对于一个任务清单，可能完成一项任务，任务本身对自己的正反馈不一定可以补偿完成任务的付出。然后现在也算是大二了，怕没有个任务清单的话，导致一学期过得浑浑噩噩的，需要一个东西来设定自己的计划。\n\n\n\n# 介绍：\n\n然后这次打算用一种方式解决上面的问题，首先重要的一点是，完成一项任务后要得到一定的奖励，这个奖励要对应完成任务所需要的付出，于是想来想去，感觉最好的奖励就是金钱了，然后就是给自己设定一些计划，用金钱去衡量完成任务得到的收益，以及完成任务所需要的付出。\n\n这里有两点需要严格遵守的，一个是自己要严格一些，一些杂七杂八的东西就不要加到计划清单了，并且必须要完成的东西不要加进来，例如完成学校的作业等，这里列举一下算是值得加到任务清单事情：\n\n+ 阅读一本书的第 x 章\n+ 学习主席树并完成习题\n+ 打完一场 Codeforce 并把力所能及的题补掉（这个任务可重复完成）\n\n另外一个重点是，每个任务的任务量一定小，不要上来就抛出一个 “阅读《算法导论》”的任务，对于这样难以完成的任务一定要拆开，比如拆成阅读完第几章等。\n\n另外一点是拿金钱当奖励的，所以某些日常需求用到的钱是要和这里的奖励分开的，比如要买几点应季的衣服，或者普通吃顿饭，买书，就不必用奖励的前，对于“想要买个好一点的耳机”、“这个游戏真好玩，想买”这样的需求，就要从奖励里拿出了。\n\n# 实现：\n\n计划大概是那样的，这里我打算暂时用印象笔记当工具，每个计划对应一个提醒，每次添加计划的时候输入计划的名字和奖励。\n\n以后打算写一个网页或移动端的程序的，想来想去有点复杂，还是用印象笔记实现好了。\n\n# 最后：\n\n以上大概就是全部的计划了，可以看得出来，完全要靠直接去遵守规则的，看起来有点像小孩子的过家家。不过如果能进行下去，感觉对自己应该是非常有益的，写这篇博客也算是警示一下自己吧，看看能坚持多久。","slug":"持续正反馈的任务清单计划","published":1,"updated":"2017-09-03T11:46:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf7006dy9id4xxujhwj","content":"<p><img src=\"http://chuantu.biz/t6/34/1504437603x2890149823.jpg\" alt=\"\"></p>\n<h1 id=\"碎碎念：\"><a href=\"#碎碎念：\" class=\"headerlink\" title=\"碎碎念：\"></a>碎碎念：</h1><p>封面（姑且算是吧）是缘之空里的瑛，也算是主角之一了，最近推了缘之空的穹线和瑛线，无法自拔…</p>\n<p>好吧接下来说下正题，这个其实就是一个任务清单，不过一般任务清单自己一般懒得的去完成，然后逐渐就忘记了这东西，并且涉及人物计划还可能很费时，之前也算是尝试了好多次，但都是以失败告终，一是当时高中时间安排的比较严格，没有自由安排的时间，完全不需要任务清单这种东西，另外就是这里的重点。对于一个任务清单，可能完成一项任务，任务本身对自己的正反馈不一定可以补偿完成任务的付出。然后现在也算是大二了，怕没有个任务清单的话，导致一学期过得浑浑噩噩的，需要一个东西来设定自己的计划。</p>\n<h1 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h1><p>然后这次打算用一种方式解决上面的问题，首先重要的一点是，完成一项任务后要得到一定的奖励，这个奖励要对应完成任务所需要的付出，于是想来想去，感觉最好的奖励就是金钱了，然后就是给自己设定一些计划，用金钱去衡量完成任务得到的收益，以及完成任务所需要的付出。</p>\n<p>这里有两点需要严格遵守的，一个是自己要严格一些，一些杂七杂八的东西就不要加到计划清单了，并且必须要完成的东西不要加进来，例如完成学校的作业等，这里列举一下算是值得加到任务清单事情：</p>\n<ul>\n<li>阅读一本书的第 x 章</li>\n<li>学习主席树并完成习题</li>\n<li>打完一场 Codeforce 并把力所能及的题补掉（这个任务可重复完成）</li>\n</ul>\n<p>另外一个重点是，每个任务的任务量一定小，不要上来就抛出一个 “阅读《算法导论》”的任务，对于这样难以完成的任务一定要拆开，比如拆成阅读完第几章等。</p>\n<p>另外一点是拿金钱当奖励的，所以某些日常需求用到的钱是要和这里的奖励分开的，比如要买几点应季的衣服，或者普通吃顿饭，买书，就不必用奖励的前，对于“想要买个好一点的耳机”、“这个游戏真好玩，想买”这样的需求，就要从奖励里拿出了。</p>\n<h1 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h1><p>计划大概是那样的，这里我打算暂时用印象笔记当工具，每个计划对应一个提醒，每次添加计划的时候输入计划的名字和奖励。</p>\n<p>以后打算写一个网页或移动端的程序的，想来想去有点复杂，还是用印象笔记实现好了。</p>\n<h1 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h1><p>以上大概就是全部的计划了，可以看得出来，完全要靠直接去遵守规则的，看起来有点像小孩子的过家家。不过如果能进行下去，感觉对自己应该是非常有益的，写这篇博客也算是警示一下自己吧，看看能坚持多久。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://chuantu.biz/t6/34/1504437603x2890149823.jpg\" alt=\"\"></p>\n<h1 id=\"碎碎念：\"><a href=\"#碎碎念：\" class=\"headerlink\" title=\"碎碎念：\"></a>碎碎念：</h1><p>封面（姑且算是吧）是缘之空里的瑛，也算是主角之一了，最近推了缘之空的穹线和瑛线，无法自拔…</p>\n<p>好吧接下来说下正题，这个其实就是一个任务清单，不过一般任务清单自己一般懒得的去完成，然后逐渐就忘记了这东西，并且涉及人物计划还可能很费时，之前也算是尝试了好多次，但都是以失败告终，一是当时高中时间安排的比较严格，没有自由安排的时间，完全不需要任务清单这种东西，另外就是这里的重点。对于一个任务清单，可能完成一项任务，任务本身对自己的正反馈不一定可以补偿完成任务的付出。然后现在也算是大二了，怕没有个任务清单的话，导致一学期过得浑浑噩噩的，需要一个东西来设定自己的计划。</p>\n<h1 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h1><p>然后这次打算用一种方式解决上面的问题，首先重要的一点是，完成一项任务后要得到一定的奖励，这个奖励要对应完成任务所需要的付出，于是想来想去，感觉最好的奖励就是金钱了，然后就是给自己设定一些计划，用金钱去衡量完成任务得到的收益，以及完成任务所需要的付出。</p>\n<p>这里有两点需要严格遵守的，一个是自己要严格一些，一些杂七杂八的东西就不要加到计划清单了，并且必须要完成的东西不要加进来，例如完成学校的作业等，这里列举一下算是值得加到任务清单事情：</p>\n<ul>\n<li>阅读一本书的第 x 章</li>\n<li>学习主席树并完成习题</li>\n<li>打完一场 Codeforce 并把力所能及的题补掉（这个任务可重复完成）</li>\n</ul>\n<p>另外一个重点是，每个任务的任务量一定小，不要上来就抛出一个 “阅读《算法导论》”的任务，对于这样难以完成的任务一定要拆开，比如拆成阅读完第几章等。</p>\n<p>另外一点是拿金钱当奖励的，所以某些日常需求用到的钱是要和这里的奖励分开的，比如要买几点应季的衣服，或者普通吃顿饭，买书，就不必用奖励的前，对于“想要买个好一点的耳机”、“这个游戏真好玩，想买”这样的需求，就要从奖励里拿出了。</p>\n<h1 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h1><p>计划大概是那样的，这里我打算暂时用印象笔记当工具，每个计划对应一个提醒，每次添加计划的时候输入计划的名字和奖励。</p>\n<p>以后打算写一个网页或移动端的程序的，想来想去有点复杂，还是用印象笔记实现好了。</p>\n<h1 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h1><p>以上大概就是全部的计划了，可以看得出来，完全要靠直接去遵守规则的，看起来有点像小孩子的过家家。不过如果能进行下去，感觉对自己应该是非常有益的，写这篇博客也算是警示一下自己吧，看看能坚持多久。</p>\n"},{"title":"匹配、覆盖、独立集、二分图与网络流","date":"2017-06-14T09:08:03.000Z","_content":"# 概念：\n设图 $G = \\{V, E\\}$\n\n+ 匹配：在$G$中两两没有公共端点的边集合$M\\subseteq E$\n+ 边覆盖：$G$中任意顶点都至少是$F$中某条边的端点的边集合$F\\subseteq E$\n+ 独立集：在$G$中两两互不相连的顶点集合$S\\subseteq V$\n+ 顶点覆盖：$G$中的任意边都有至少一个端点属于$S$的顶点集合$S\\subseteq V$\n\n\n-----------------------\n# 定理：\n1. 对于不存在独立点的图，$|\\text{最大匹配数}|+|\\text{最小边覆盖}|=|V|$\n2. $|\\text{最大独立集}|+|\\text{最小顶点覆盖}|=|V|$\n3. 对于二分图，$|\\text{最大匹配}| = |\\text{最小顶点覆盖}|$\n\n---------------------\n# 不严谨的理解：\n\n## 一：\n可以想象，最小边覆盖可以通过最大匹配加边来完成，但是要加多少条边呢？\n\n假设图$G$的最大匹配为$M$，那么这时还有$|V|-2\\times|M|$个点没有覆盖，这时需要$|V|-2\\times |M|$条边进行覆盖这些点。可以贪心的想，要尽可能的用一条边覆盖尽量多的点，但是一条边覆盖两个点的情况是不存在的，因为如果一条边可以覆盖两个新的点，那么当前的匹配就不是最大匹配了，与假设矛盾。所以每个点都要加一条边进行覆盖。\n\n由此可知，图G的最小边覆盖为：$|F| = |M|+|V|-2\\times|M| = |V|-|M|$\n移项可得：$|F|+|M|=|V|$\n\n关于为什么不能有孤立的点呢，因为这些孤立点一条边都没有，最后$|V| > |F|+|M|$\n\n-----------------------\n## 二：\n可以这样理解，现在图G要删除一些点，构造最小顶点覆盖，要删除哪些点呢？\n\n一个思路是删除一组两两独立的点，因为这样删除点，不会导致一条边的两个端点都被删去。如果一条边的两个端点都被删去了，那么删去的点也就不是互相独立的了。这样要构造最小的顶点覆盖，就要尽量多的删去两两独立的点，那么就是$V$删去最大独立集了。\n\n\n--------------------\n## 三：暂时还没找到比较容易理解的方式","source":"_posts/匹配、覆盖、独立集、二分图与网络流.md","raw":"---\ntitle: 匹配、覆盖、独立集、二分图与网络流\ndate: 2017-06-14 17:08:03\ncategories: [ACM, 知识小结]\ntags:\n---\n# 概念：\n设图 $G = \\{V, E\\}$\n\n+ 匹配：在$G$中两两没有公共端点的边集合$M\\subseteq E$\n+ 边覆盖：$G$中任意顶点都至少是$F$中某条边的端点的边集合$F\\subseteq E$\n+ 独立集：在$G$中两两互不相连的顶点集合$S\\subseteq V$\n+ 顶点覆盖：$G$中的任意边都有至少一个端点属于$S$的顶点集合$S\\subseteq V$\n\n\n-----------------------\n# 定理：\n1. 对于不存在独立点的图，$|\\text{最大匹配数}|+|\\text{最小边覆盖}|=|V|$\n2. $|\\text{最大独立集}|+|\\text{最小顶点覆盖}|=|V|$\n3. 对于二分图，$|\\text{最大匹配}| = |\\text{最小顶点覆盖}|$\n\n---------------------\n# 不严谨的理解：\n\n## 一：\n可以想象，最小边覆盖可以通过最大匹配加边来完成，但是要加多少条边呢？\n\n假设图$G$的最大匹配为$M$，那么这时还有$|V|-2\\times|M|$个点没有覆盖，这时需要$|V|-2\\times |M|$条边进行覆盖这些点。可以贪心的想，要尽可能的用一条边覆盖尽量多的点，但是一条边覆盖两个点的情况是不存在的，因为如果一条边可以覆盖两个新的点，那么当前的匹配就不是最大匹配了，与假设矛盾。所以每个点都要加一条边进行覆盖。\n\n由此可知，图G的最小边覆盖为：$|F| = |M|+|V|-2\\times|M| = |V|-|M|$\n移项可得：$|F|+|M|=|V|$\n\n关于为什么不能有孤立的点呢，因为这些孤立点一条边都没有，最后$|V| > |F|+|M|$\n\n-----------------------\n## 二：\n可以这样理解，现在图G要删除一些点，构造最小顶点覆盖，要删除哪些点呢？\n\n一个思路是删除一组两两独立的点，因为这样删除点，不会导致一条边的两个端点都被删去。如果一条边的两个端点都被删去了，那么删去的点也就不是互相独立的了。这样要构造最小的顶点覆盖，就要尽量多的删去两两独立的点，那么就是$V$删去最大独立集了。\n\n\n--------------------\n## 三：暂时还没找到比较容易理解的方式","slug":"匹配、覆盖、独立集、二分图与网络流","published":1,"updated":"2017-07-23T02:01:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nf9006fy9id9y0m7s84","content":"<h1 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h1><p>设图 $G = {V, E}$</p>\n<ul>\n<li>匹配：在$G$中两两没有公共端点的边集合$M\\subseteq E$</li>\n<li>边覆盖：$G$中任意顶点都至少是$F$中某条边的端点的边集合$F\\subseteq E$</li>\n<li>独立集：在$G$中两两互不相连的顶点集合$S\\subseteq V$</li>\n<li>顶点覆盖：$G$中的任意边都有至少一个端点属于$S$的顶点集合$S\\subseteq V$</li>\n</ul>\n<hr>\n<h1 id=\"定理：\"><a href=\"#定理：\" class=\"headerlink\" title=\"定理：\"></a>定理：</h1><ol>\n<li>对于不存在独立点的图，$|\\text{最大匹配数}|+|\\text{最小边覆盖}|=|V|$</li>\n<li>$|\\text{最大独立集}|+|\\text{最小顶点覆盖}|=|V|$</li>\n<li>对于二分图，$|\\text{最大匹配}| = |\\text{最小顶点覆盖}|$</li>\n</ol>\n<hr>\n<h1 id=\"不严谨的理解：\"><a href=\"#不严谨的理解：\" class=\"headerlink\" title=\"不严谨的理解：\"></a>不严谨的理解：</h1><h2 id=\"一：\"><a href=\"#一：\" class=\"headerlink\" title=\"一：\"></a>一：</h2><p>可以想象，最小边覆盖可以通过最大匹配加边来完成，但是要加多少条边呢？</p>\n<p>假设图$G$的最大匹配为$M$，那么这时还有$|V|-2\\times|M|$个点没有覆盖，这时需要$|V|-2\\times |M|$条边进行覆盖这些点。可以贪心的想，要尽可能的用一条边覆盖尽量多的点，但是一条边覆盖两个点的情况是不存在的，因为如果一条边可以覆盖两个新的点，那么当前的匹配就不是最大匹配了，与假设矛盾。所以每个点都要加一条边进行覆盖。</p>\n<p>由此可知，图G的最小边覆盖为：$|F| = |M|+|V|-2\\times|M| = |V|-|M|$<br>移项可得：$|F|+|M|=|V|$</p>\n<p>关于为什么不能有孤立的点呢，因为这些孤立点一条边都没有，最后$|V| &gt; |F|+|M|$</p>\n<hr>\n<h2 id=\"二：\"><a href=\"#二：\" class=\"headerlink\" title=\"二：\"></a>二：</h2><p>可以这样理解，现在图G要删除一些点，构造最小顶点覆盖，要删除哪些点呢？</p>\n<p>一个思路是删除一组两两独立的点，因为这样删除点，不会导致一条边的两个端点都被删去。如果一条边的两个端点都被删去了，那么删去的点也就不是互相独立的了。这样要构造最小的顶点覆盖，就要尽量多的删去两两独立的点，那么就是$V$删去最大独立集了。</p>\n<hr>\n<h2 id=\"三：暂时还没找到比较容易理解的方式\"><a href=\"#三：暂时还没找到比较容易理解的方式\" class=\"headerlink\" title=\"三：暂时还没找到比较容易理解的方式\"></a>三：暂时还没找到比较容易理解的方式</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h1><p>设图 $G = {V, E}$</p>\n<ul>\n<li>匹配：在$G$中两两没有公共端点的边集合$M\\subseteq E$</li>\n<li>边覆盖：$G$中任意顶点都至少是$F$中某条边的端点的边集合$F\\subseteq E$</li>\n<li>独立集：在$G$中两两互不相连的顶点集合$S\\subseteq V$</li>\n<li>顶点覆盖：$G$中的任意边都有至少一个端点属于$S$的顶点集合$S\\subseteq V$</li>\n</ul>\n<hr>\n<h1 id=\"定理：\"><a href=\"#定理：\" class=\"headerlink\" title=\"定理：\"></a>定理：</h1><ol>\n<li>对于不存在独立点的图，$|\\text{最大匹配数}|+|\\text{最小边覆盖}|=|V|$</li>\n<li>$|\\text{最大独立集}|+|\\text{最小顶点覆盖}|=|V|$</li>\n<li>对于二分图，$|\\text{最大匹配}| = |\\text{最小顶点覆盖}|$</li>\n</ol>\n<hr>\n<h1 id=\"不严谨的理解：\"><a href=\"#不严谨的理解：\" class=\"headerlink\" title=\"不严谨的理解：\"></a>不严谨的理解：</h1><h2 id=\"一：\"><a href=\"#一：\" class=\"headerlink\" title=\"一：\"></a>一：</h2><p>可以想象，最小边覆盖可以通过最大匹配加边来完成，但是要加多少条边呢？</p>\n<p>假设图$G$的最大匹配为$M$，那么这时还有$|V|-2\\times|M|$个点没有覆盖，这时需要$|V|-2\\times |M|$条边进行覆盖这些点。可以贪心的想，要尽可能的用一条边覆盖尽量多的点，但是一条边覆盖两个点的情况是不存在的，因为如果一条边可以覆盖两个新的点，那么当前的匹配就不是最大匹配了，与假设矛盾。所以每个点都要加一条边进行覆盖。</p>\n<p>由此可知，图G的最小边覆盖为：$|F| = |M|+|V|-2\\times|M| = |V|-|M|$<br>移项可得：$|F|+|M|=|V|$</p>\n<p>关于为什么不能有孤立的点呢，因为这些孤立点一条边都没有，最后$|V| &gt; |F|+|M|$</p>\n<hr>\n<h2 id=\"二：\"><a href=\"#二：\" class=\"headerlink\" title=\"二：\"></a>二：</h2><p>可以这样理解，现在图G要删除一些点，构造最小顶点覆盖，要删除哪些点呢？</p>\n<p>一个思路是删除一组两两独立的点，因为这样删除点，不会导致一条边的两个端点都被删去。如果一条边的两个端点都被删去了，那么删去的点也就不是互相独立的了。这样要构造最小的顶点覆盖，就要尽量多的删去两两独立的点，那么就是$V$删去最大独立集了。</p>\n<hr>\n<h2 id=\"三：暂时还没找到比较容易理解的方式\"><a href=\"#三：暂时还没找到比较容易理解的方式\" class=\"headerlink\" title=\"三：暂时还没找到比较容易理解的方式\"></a>三：暂时还没找到比较容易理解的方式</h2>"},{"title":"矩阵快速幂小结","date":"2017-08-20T05:30:40.000Z","_content":"\n\n# 感谢&资料：\n\n非常感谢一些 up 主和博主分析的资料，矩阵快速幂好多书上没详细讲，于是搜了一些资料。\n\n+ [视频](http://blog.csdn.net/wust_zzwh/article/details/52058209)\n+ [资料](https://www.bilibili.com/video/av8570006/?from=search&seid=16484167781382671487)\n\n\n\n# 简介：\n\n矩阵快速幂其实就是矩阵乘法 + 快速幂，上面的视频还讲了扩展的幂运算的含义，挺不错的，代码上的体现就是，将原本的数字相乘换成了矩阵相乘，其他都是一样的，实质就是加速了矩阵的幂运算，对原本 $O(n)$的幂运算加速到$O(\\log n)$。\n\n\n\n```cpp\nMat pow_mod(Mat a, int k) {\n    Mat rst(a.n, a.m);\n    rst.unit();\n    while (k) {\n        if (k & 1) rst = rst * a;\n        a = a * a;\n        k >>= 1;\n    }\n    return rst;\n}\n```\n\n这就是一个矩阵快速幂的核心代码，我这里重载了乘号，然后看起来和普通的快速幂根本没什么区别，unit 函数是将矩阵初始化为单位矩阵。\n\n\n\n# 应用：\n\n通过上面的描述，矩阵快速幂其实就是加速矩阵的幂运算，但是这个有什么用呢？\n\n在 ACM 竞赛中矩阵快速幂通常用来加速递推式的计算，将原本 $O (n)$ 的计算过程加速到 $O(k\\log n)$ k 与矩阵的大小有关。\n\n一个简单的例子就是用来计算斐波那契数列，假设要求斐波那契数列的第 n 项 $f_n$ 当 n 比较小直接用循环跑就可以了，这样是 $O(n)$ ，但是当 n 非常大甚至高达 $10^9$ 时用过这种朴素的方法进行递推肯定是超时的。\n\n\n\n这时候就要用到矩阵快速幂，首先，也是最核心的一部，要找到递推关系和转移矩阵，对于斐波那契数列，非常任意就可以找到：\n\n$\\begin{bmatrix} 1 & 1 \\\\\\\\ 1 & 0 \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ f\\_{n-2} \\end{bmatrix}  = \\begin{bmatrix} f\\_{n-1} + f\\_{n-2} \\\\\\\\ f\\_{n-1} \\end{bmatrix} = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\end{bmatrix}$\n\n我们称第一个矩阵为转移矩阵，第二个一般是一个$n \\times 1$的向量，右边的向量每乘一次转移矩阵，向量中的每个元素根据递推式往后推了一次。\n\n这时我设 $A\\_n = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\end{bmatrix}$ , $T =  \\begin{bmatrix} 1 & 1 \\\\\\\\ 1 & 0 \\end{bmatrix}$那么显然有 $A\\_n = T^{n-1} \\cdot A\\_{1}$.\n\n转移我们对 T 这个转移矩阵就行快速幂，就可以再乘以 $A_1$ 就能算出来 $A_n$，复杂度是 $O(k\\log n)$ 。\n\n\n\n通过上面的分析，其实矩阵快速幂在应用的时候，难点是找出转移矩阵 T 和 $A_1$ ，下面给出一些简单的递推式练手：\n\n$f\\_n = a\\cdot f\\_{n-1} + b\\cdot f\\_{n-2} + c$ (a, b, c是常数)\n\n$\\begin{bmatrix} a & b & 1 \\\\\\\\ 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ f\\_{n-2} \\\\\\\\\\ c \\end{bmatrix}   = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\\\\\\\\\ c\\end{bmatrix}$\n\n\n\n$f\\_n = c^n - f\\_{n-1}$\n\n$\\begin{bmatrix} -1 & c \\\\\\\\ 0 & c \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ c^{n-1} \\end{bmatrix}  =  \\begin{bmatrix} f\\_n \\\\\\\\ c^{n} \\end{bmatrix}$\n\n\n\n# 板子：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\n\nstruct Mat {\n    ll v[112][112];\n    int n, m;\n\n    Mat(int tn, int tm) {\n        n = tn, m = tm;\n        memset(v, 0, sizeof(v));\n    }\n\n    void unit() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == j) v[i][j] = 1;\n                else v[i][j] = 0;\n            }\n        }\n    }\n\n    void read() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                scanf(\"%lld\", &v[i][j]);\n            }\n        }\n    }\n\n    void out() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                printf(j == m - 1 ? \"%d\\n\" : \"%d \", v[i][j]);\n            }\n        }\n    }\n\n    Mat operator*(const Mat &a) {\n        Mat rst(n, a.m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < a.m; j++) {\n                ll t = 0;\n                for (int k = 0; k < m; k++) {\n                    t += v[i][k] * a.v[k][j] % MOD;\n                    t = t % MOD;\n                }\n                rst.v[i][j] = t;\n            }\n        }\n        return rst;\n    }\n};\n\nMat pow_mod(Mat a, int k) {\n    Mat rst(a.n, a.m);\n    rst.unit();\n    while (k) {\n        if (k & 1) rst = rst * a;\n        a = a * a;\n        k >>= 1;\n    }\n    return rst;\n}\n\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Mat a(n, n);\n    a.read();\n    pow_mod(a, m).out();\n}\n```\n\n\n\n\n\n# 简单练习：\n\n+ [矩阵乘法](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1137)\n+ [裸的矩阵快速幂](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1113)\n+ [计算斐波那契数列](http://poj.org/problem?id=3070)\n+ [简单的推导转移矩阵](http://acm.hdu.edu.cn/showproblem.PHP?pid=1757)\n+ [裸题](http://acm.hdu.edu.cn/showproblem.php?pid=1575)","source":"_posts/矩阵快速幂小结.md","raw":"---\ntitle: 矩阵快速幂小结\ndate: 2017-08-20 13:30:40\ncategories: [ACM, 数学, 矩阵快速幂]\ntags:\n---\n\n\n# 感谢&资料：\n\n非常感谢一些 up 主和博主分析的资料，矩阵快速幂好多书上没详细讲，于是搜了一些资料。\n\n+ [视频](http://blog.csdn.net/wust_zzwh/article/details/52058209)\n+ [资料](https://www.bilibili.com/video/av8570006/?from=search&seid=16484167781382671487)\n\n\n\n# 简介：\n\n矩阵快速幂其实就是矩阵乘法 + 快速幂，上面的视频还讲了扩展的幂运算的含义，挺不错的，代码上的体现就是，将原本的数字相乘换成了矩阵相乘，其他都是一样的，实质就是加速了矩阵的幂运算，对原本 $O(n)$的幂运算加速到$O(\\log n)$。\n\n\n\n```cpp\nMat pow_mod(Mat a, int k) {\n    Mat rst(a.n, a.m);\n    rst.unit();\n    while (k) {\n        if (k & 1) rst = rst * a;\n        a = a * a;\n        k >>= 1;\n    }\n    return rst;\n}\n```\n\n这就是一个矩阵快速幂的核心代码，我这里重载了乘号，然后看起来和普通的快速幂根本没什么区别，unit 函数是将矩阵初始化为单位矩阵。\n\n\n\n# 应用：\n\n通过上面的描述，矩阵快速幂其实就是加速矩阵的幂运算，但是这个有什么用呢？\n\n在 ACM 竞赛中矩阵快速幂通常用来加速递推式的计算，将原本 $O (n)$ 的计算过程加速到 $O(k\\log n)$ k 与矩阵的大小有关。\n\n一个简单的例子就是用来计算斐波那契数列，假设要求斐波那契数列的第 n 项 $f_n$ 当 n 比较小直接用循环跑就可以了，这样是 $O(n)$ ，但是当 n 非常大甚至高达 $10^9$ 时用过这种朴素的方法进行递推肯定是超时的。\n\n\n\n这时候就要用到矩阵快速幂，首先，也是最核心的一部，要找到递推关系和转移矩阵，对于斐波那契数列，非常任意就可以找到：\n\n$\\begin{bmatrix} 1 & 1 \\\\\\\\ 1 & 0 \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ f\\_{n-2} \\end{bmatrix}  = \\begin{bmatrix} f\\_{n-1} + f\\_{n-2} \\\\\\\\ f\\_{n-1} \\end{bmatrix} = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\end{bmatrix}$\n\n我们称第一个矩阵为转移矩阵，第二个一般是一个$n \\times 1$的向量，右边的向量每乘一次转移矩阵，向量中的每个元素根据递推式往后推了一次。\n\n这时我设 $A\\_n = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\end{bmatrix}$ , $T =  \\begin{bmatrix} 1 & 1 \\\\\\\\ 1 & 0 \\end{bmatrix}$那么显然有 $A\\_n = T^{n-1} \\cdot A\\_{1}$.\n\n转移我们对 T 这个转移矩阵就行快速幂，就可以再乘以 $A_1$ 就能算出来 $A_n$，复杂度是 $O(k\\log n)$ 。\n\n\n\n通过上面的分析，其实矩阵快速幂在应用的时候，难点是找出转移矩阵 T 和 $A_1$ ，下面给出一些简单的递推式练手：\n\n$f\\_n = a\\cdot f\\_{n-1} + b\\cdot f\\_{n-2} + c$ (a, b, c是常数)\n\n$\\begin{bmatrix} a & b & 1 \\\\\\\\ 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ f\\_{n-2} \\\\\\\\\\ c \\end{bmatrix}   = \\begin{bmatrix} f\\_n \\\\\\\\ f\\_{n-1} \\\\\\\\\\ c\\end{bmatrix}$\n\n\n\n$f\\_n = c^n - f\\_{n-1}$\n\n$\\begin{bmatrix} -1 & c \\\\\\\\ 0 & c \\end{bmatrix} \\cdot \\begin{bmatrix} f\\_{n-1} \\\\\\\\ c^{n-1} \\end{bmatrix}  =  \\begin{bmatrix} f\\_n \\\\\\\\ c^{n} \\end{bmatrix}$\n\n\n\n# 板子：\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\n\nstruct Mat {\n    ll v[112][112];\n    int n, m;\n\n    Mat(int tn, int tm) {\n        n = tn, m = tm;\n        memset(v, 0, sizeof(v));\n    }\n\n    void unit() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == j) v[i][j] = 1;\n                else v[i][j] = 0;\n            }\n        }\n    }\n\n    void read() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                scanf(\"%lld\", &v[i][j]);\n            }\n        }\n    }\n\n    void out() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                printf(j == m - 1 ? \"%d\\n\" : \"%d \", v[i][j]);\n            }\n        }\n    }\n\n    Mat operator*(const Mat &a) {\n        Mat rst(n, a.m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < a.m; j++) {\n                ll t = 0;\n                for (int k = 0; k < m; k++) {\n                    t += v[i][k] * a.v[k][j] % MOD;\n                    t = t % MOD;\n                }\n                rst.v[i][j] = t;\n            }\n        }\n        return rst;\n    }\n};\n\nMat pow_mod(Mat a, int k) {\n    Mat rst(a.n, a.m);\n    rst.unit();\n    while (k) {\n        if (k & 1) rst = rst * a;\n        a = a * a;\n        k >>= 1;\n    }\n    return rst;\n}\n\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Mat a(n, n);\n    a.read();\n    pow_mod(a, m).out();\n}\n```\n\n\n\n\n\n# 简单练习：\n\n+ [矩阵乘法](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1137)\n+ [裸的矩阵快速幂](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1113)\n+ [计算斐波那契数列](http://poj.org/problem?id=3070)\n+ [简单的推导转移矩阵](http://acm.hdu.edu.cn/showproblem.PHP?pid=1757)\n+ [裸题](http://acm.hdu.edu.cn/showproblem.php?pid=1575)","slug":"矩阵快速幂小结","published":1,"updated":"2017-08-25T03:00:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfa006iy9idzthrncgf","content":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>非常感谢一些 up 主和博主分析的资料，矩阵快速幂好多书上没详细讲，于是搜了一些资料。</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/wust_zzwh/article/details/52058209\" target=\"_blank\" rel=\"external\">视频</a></li>\n<li><a href=\"https://www.bilibili.com/video/av8570006/?from=search&amp;seid=16484167781382671487\" target=\"_blank\" rel=\"external\">资料</a></li>\n</ul>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>矩阵快速幂其实就是矩阵乘法 + 快速幂，上面的视频还讲了扩展的幂运算的含义，挺不错的，代码上的体现就是，将原本的数字相乘换成了矩阵相乘，其他都是一样的，实质就是加速了矩阵的幂运算，对原本 $O(n)$的幂运算加速到$O(\\log n)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Mat <span class=\"title\">pow_mod</span><span class=\"params\">(Mat a, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(a.n, a.m)</span></span>;</div><div class=\"line\">    rst.unit();</div><div class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) rst = rst * a;</div><div class=\"line\">        a = a * a;</div><div class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这就是一个矩阵快速幂的核心代码，我这里重载了乘号，然后看起来和普通的快速幂根本没什么区别，unit 函数是将矩阵初始化为单位矩阵。</p>\n<h1 id=\"应用：\"><a href=\"#应用：\" class=\"headerlink\" title=\"应用：\"></a>应用：</h1><p>通过上面的描述，矩阵快速幂其实就是加速矩阵的幂运算，但是这个有什么用呢？</p>\n<p>在 ACM 竞赛中矩阵快速幂通常用来加速递推式的计算，将原本 $O (n)$ 的计算过程加速到 $O(k\\log n)$ k 与矩阵的大小有关。</p>\n<p>一个简单的例子就是用来计算斐波那契数列，假设要求斐波那契数列的第 n 项 $f_n$ 当 n 比较小直接用循环跑就可以了，这样是 $O(n)$ ，但是当 n 非常大甚至高达 $10^9$ 时用过这种朴素的方法进行递推肯定是超时的。</p>\n<p>这时候就要用到矩阵快速幂，首先，也是最核心的一部，要找到递推关系和转移矩阵，对于斐波那契数列，非常任意就可以找到：</p>\n<p>$\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ f_{n-2} \\end{bmatrix}  = \\begin{bmatrix} f_{n-1} + f_{n-2} \\\\ f_{n-1} \\end{bmatrix} = \\begin{bmatrix} f_n \\\\ f_{n-1} \\end{bmatrix}$</p>\n<p>我们称第一个矩阵为转移矩阵，第二个一般是一个$n \\times 1$的向量，右边的向量每乘一次转移矩阵，向量中的每个元素根据递推式往后推了一次。</p>\n<p>这时我设 $A_n = \\begin{bmatrix} f_n \\\\ f_{n-1} \\end{bmatrix}$ , $T =  \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}$那么显然有 $A_n = T^{n-1} \\cdot A_{1}$.</p>\n<p>转移我们对 T 这个转移矩阵就行快速幂，就可以再乘以 $A_1$ 就能算出来 $A_n$，复杂度是 $O(k\\log n)$ 。</p>\n<p>通过上面的分析，其实矩阵快速幂在应用的时候，难点是找出转移矩阵 T 和 $A_1$ ，下面给出一些简单的递推式练手：</p>\n<p>$f_n = a\\cdot f_{n-1} + b\\cdot f_{n-2} + c$ (a, b, c是常数)</p>\n<p>$\\begin{bmatrix} a &amp; b &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ f_{n-2} \\\\\\ c \\end{bmatrix}   = \\begin{bmatrix} f_n \\\\ f_{n-1} \\\\\\ c\\end{bmatrix}$</p>\n<p>$f_n = c^n - f_{n-1}$</p>\n<p>$\\begin{bmatrix} -1 &amp; c \\\\ 0 &amp; c \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ c^{n-1} \\end{bmatrix}  =  \\begin{bmatrix} f_n \\\\ c^{n} \\end{bmatrix}$</p>\n<h1 id=\"板子：\"><a href=\"#板子：\" class=\"headerlink\" title=\"板子：\"></a>板子：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Mat</span> &#123;</span></div><div class=\"line\">    ll v[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\">    Mat(<span class=\"keyword\">int</span> tn, <span class=\"keyword\">int</span> tm) &#123;</div><div class=\"line\">        n = tn, m = tm;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(v, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(v));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j) v[i][j] = <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> v[i][j] = <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;v[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(j == m - <span class=\"number\">1</span> ? <span class=\"string\">\"%d\\n\"</span> : <span class=\"string\">\"%d \"</span>, v[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Mat <span class=\"keyword\">operator</span>*(<span class=\"keyword\">const</span> Mat &amp;a) &#123;</div><div class=\"line\">        <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(n, a.m)</span></span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; a.m; j++) &#123;</div><div class=\"line\">                ll t = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; m; k++) &#123;</div><div class=\"line\">                    t += v[i][k] * a.v[k][j] % MOD;</div><div class=\"line\">                    t = t % MOD;</div><div class=\"line\">                &#125;</div><div class=\"line\">                rst.v[i][j] = t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Mat <span class=\"title\">pow_mod</span><span class=\"params\">(Mat a, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(a.n, a.m)</span></span>;</div><div class=\"line\">    rst.unit();</div><div class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) rst = rst * a;</div><div class=\"line\">        a = a * a;</div><div class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">a</span><span class=\"params\">(n, n)</span></span>;</div><div class=\"line\">    a.read();</div><div class=\"line\">    pow_mod(a, m).out();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"简单练习：\"><a href=\"#简单练习：\" class=\"headerlink\" title=\"简单练习：\"></a>简单练习：</h1><ul>\n<li><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1137\" target=\"_blank\" rel=\"external\">矩阵乘法</a></li>\n<li><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1113\" target=\"_blank\" rel=\"external\">裸的矩阵快速幂</a></li>\n<li><a href=\"http://poj.org/problem?id=3070\" target=\"_blank\" rel=\"external\">计算斐波那契数列</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.PHP?pid=1757\" target=\"_blank\" rel=\"external\">简单的推导转移矩阵</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1575\" target=\"_blank\" rel=\"external\">裸题</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"感谢-amp-资料：\"><a href=\"#感谢-amp-资料：\" class=\"headerlink\" title=\"感谢&amp;资料：\"></a>感谢&amp;资料：</h1><p>非常感谢一些 up 主和博主分析的资料，矩阵快速幂好多书上没详细讲，于是搜了一些资料。</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/wust_zzwh/article/details/52058209\" target=\"_blank\" rel=\"external\">视频</a></li>\n<li><a href=\"https://www.bilibili.com/video/av8570006/?from=search&amp;seid=16484167781382671487\" target=\"_blank\" rel=\"external\">资料</a></li>\n</ul>\n<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>矩阵快速幂其实就是矩阵乘法 + 快速幂，上面的视频还讲了扩展的幂运算的含义，挺不错的，代码上的体现就是，将原本的数字相乘换成了矩阵相乘，其他都是一样的，实质就是加速了矩阵的幂运算，对原本 $O(n)$的幂运算加速到$O(\\log n)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Mat <span class=\"title\">pow_mod</span><span class=\"params\">(Mat a, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(a.n, a.m)</span></span>;</div><div class=\"line\">    rst.unit();</div><div class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) rst = rst * a;</div><div class=\"line\">        a = a * a;</div><div class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这就是一个矩阵快速幂的核心代码，我这里重载了乘号，然后看起来和普通的快速幂根本没什么区别，unit 函数是将矩阵初始化为单位矩阵。</p>\n<h1 id=\"应用：\"><a href=\"#应用：\" class=\"headerlink\" title=\"应用：\"></a>应用：</h1><p>通过上面的描述，矩阵快速幂其实就是加速矩阵的幂运算，但是这个有什么用呢？</p>\n<p>在 ACM 竞赛中矩阵快速幂通常用来加速递推式的计算，将原本 $O (n)$ 的计算过程加速到 $O(k\\log n)$ k 与矩阵的大小有关。</p>\n<p>一个简单的例子就是用来计算斐波那契数列，假设要求斐波那契数列的第 n 项 $f_n$ 当 n 比较小直接用循环跑就可以了，这样是 $O(n)$ ，但是当 n 非常大甚至高达 $10^9$ 时用过这种朴素的方法进行递推肯定是超时的。</p>\n<p>这时候就要用到矩阵快速幂，首先，也是最核心的一部，要找到递推关系和转移矩阵，对于斐波那契数列，非常任意就可以找到：</p>\n<p>$\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ f_{n-2} \\end{bmatrix}  = \\begin{bmatrix} f_{n-1} + f_{n-2} \\\\ f_{n-1} \\end{bmatrix} = \\begin{bmatrix} f_n \\\\ f_{n-1} \\end{bmatrix}$</p>\n<p>我们称第一个矩阵为转移矩阵，第二个一般是一个$n \\times 1$的向量，右边的向量每乘一次转移矩阵，向量中的每个元素根据递推式往后推了一次。</p>\n<p>这时我设 $A_n = \\begin{bmatrix} f_n \\\\ f_{n-1} \\end{bmatrix}$ , $T =  \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}$那么显然有 $A_n = T^{n-1} \\cdot A_{1}$.</p>\n<p>转移我们对 T 这个转移矩阵就行快速幂，就可以再乘以 $A_1$ 就能算出来 $A_n$，复杂度是 $O(k\\log n)$ 。</p>\n<p>通过上面的分析，其实矩阵快速幂在应用的时候，难点是找出转移矩阵 T 和 $A_1$ ，下面给出一些简单的递推式练手：</p>\n<p>$f_n = a\\cdot f_{n-1} + b\\cdot f_{n-2} + c$ (a, b, c是常数)</p>\n<p>$\\begin{bmatrix} a &amp; b &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ f_{n-2} \\\\\\ c \\end{bmatrix}   = \\begin{bmatrix} f_n \\\\ f_{n-1} \\\\\\ c\\end{bmatrix}$</p>\n<p>$f_n = c^n - f_{n-1}$</p>\n<p>$\\begin{bmatrix} -1 &amp; c \\\\ 0 &amp; c \\end{bmatrix} \\cdot \\begin{bmatrix} f_{n-1} \\\\ c^{n-1} \\end{bmatrix}  =  \\begin{bmatrix} f_n \\\\ c^{n} \\end{bmatrix}$</p>\n<h1 id=\"板子：\"><a href=\"#板子：\" class=\"headerlink\" title=\"板子：\"></a>板子：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Mat</span> &#123;</span></div><div class=\"line\">    ll v[<span class=\"number\">112</span>][<span class=\"number\">112</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\"></div><div class=\"line\">    Mat(<span class=\"keyword\">int</span> tn, <span class=\"keyword\">int</span> tm) &#123;</div><div class=\"line\">        n = tn, m = tm;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(v, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(v));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (i == j) v[i][j] = <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> v[i][j] = <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>, &amp;v[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</div><div class=\"line\">                <span class=\"built_in\">printf</span>(j == m - <span class=\"number\">1</span> ? <span class=\"string\">\"%d\\n\"</span> : <span class=\"string\">\"%d \"</span>, v[i][j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Mat <span class=\"keyword\">operator</span>*(<span class=\"keyword\">const</span> Mat &amp;a) &#123;</div><div class=\"line\">        <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(n, a.m)</span></span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; a.m; j++) &#123;</div><div class=\"line\">                ll t = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; m; k++) &#123;</div><div class=\"line\">                    t += v[i][k] * a.v[k][j] % MOD;</div><div class=\"line\">                    t = t % MOD;</div><div class=\"line\">                &#125;</div><div class=\"line\">                rst.v[i][j] = t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> rst;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Mat <span class=\"title\">pow_mod</span><span class=\"params\">(Mat a, <span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">rst</span><span class=\"params\">(a.n, a.m)</span></span>;</div><div class=\"line\">    rst.unit();</div><div class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) rst = rst * a;</div><div class=\"line\">        a = a * a;</div><div class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"function\">Mat <span class=\"title\">a</span><span class=\"params\">(n, n)</span></span>;</div><div class=\"line\">    a.read();</div><div class=\"line\">    pow_mod(a, m).out();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"简单练习：\"><a href=\"#简单练习：\" class=\"headerlink\" title=\"简单练习：\"></a>简单练习：</h1><ul>\n<li><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1137\" target=\"_blank\" rel=\"external\">矩阵乘法</a></li>\n<li><a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1113\" target=\"_blank\" rel=\"external\">裸的矩阵快速幂</a></li>\n<li><a href=\"http://poj.org/problem?id=3070\" target=\"_blank\" rel=\"external\">计算斐波那契数列</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.PHP?pid=1757\" target=\"_blank\" rel=\"external\">简单的推导转移矩阵</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1575\" target=\"_blank\" rel=\"external\">裸题</a></li>\n</ul>\n"},{"title":"第八届acm山东省赛总结","date":"2017-05-09T13:02:43.000Z","_content":"# 比赛过程：\n\n 首先看到的是F题，我一开始从后面往前看的，然后队友告诉我F比较简单，然后就去让队友去敲了，我去继续看了其他的题，首先过一遍题是为了找到水题。\n \n 不幸的是F题WA了好多次，这时候另一个队友说G是一个水题，好像要算多少次幂的样子，这时就把F打印出来，然后就让队友去敲G了。据说这个题有坑，题目错了，本来是1e9+7的，题面是1e8+7，不过队友好像跳过了这个坑，一次AC。\n \n 这时候F题还是一直卡，然后我发现I题挺简单，只是打表找下规律，然后让队友去找了。\n\n 然后看了下榜，发现J题A的人非常多，于是跟了下榜，刚开始我想得就是贪心，不过没想到怎么动态的维护最大值，想上二分来着，然后和队友I题找到规律了先去用JAVA大数过了I题。\n\n然后和队友讨论了下找到了J题动态维护最大值的办法。果断敲上去就A掉了。\n\n 然后这时候F题还是卡住，这时候只有我还没仔细看过那个题，于是让队友去看别的题了，我去重新敲了一遍，发现是我们理解错题意，然后重新按照正确的理解敲了一边，A掉了。\n\n 这时候差不多两个半小时了，最后看了下C题，推出来是二项式定理，然后就开始发午饭了。直接拿着紫书二项式定理的板子敲了下，但是数太大要取模，然后就GG了，只好靠一个会数论的队友了。我最后又用JAVA大数类敲了敲果断超时。\n\n 然后最后两个小时，一个队友去看D题，一个看了下A题，最后取模要用到逆元，最终没弄出来，A题博弈最后交了几次也是WA。四题结束。\n\n# 总结：\n\n 感觉还是自己实力太弱，如果队里有两个会数论的话，那么C题应该能做出来了，最后知道A题是经典的博弈，如果自己知识面再广一点的话，也不是一定做不出来，K题好象是贪心加DP，也是可以做的。\n\n 以后还是要多训练刷题，提高自己能力……","source":"_posts/第八届acm山东省赛总结.md","raw":"---\ntitle: 第八届acm山东省赛总结\ndate: 2017-05-09 21:02:43\ncategories: [历程]\ntags:\n---\n# 比赛过程：\n\n 首先看到的是F题，我一开始从后面往前看的，然后队友告诉我F比较简单，然后就去让队友去敲了，我去继续看了其他的题，首先过一遍题是为了找到水题。\n \n 不幸的是F题WA了好多次，这时候另一个队友说G是一个水题，好像要算多少次幂的样子，这时就把F打印出来，然后就让队友去敲G了。据说这个题有坑，题目错了，本来是1e9+7的，题面是1e8+7，不过队友好像跳过了这个坑，一次AC。\n \n 这时候F题还是一直卡，然后我发现I题挺简单，只是打表找下规律，然后让队友去找了。\n\n 然后看了下榜，发现J题A的人非常多，于是跟了下榜，刚开始我想得就是贪心，不过没想到怎么动态的维护最大值，想上二分来着，然后和队友I题找到规律了先去用JAVA大数过了I题。\n\n然后和队友讨论了下找到了J题动态维护最大值的办法。果断敲上去就A掉了。\n\n 然后这时候F题还是卡住，这时候只有我还没仔细看过那个题，于是让队友去看别的题了，我去重新敲了一遍，发现是我们理解错题意，然后重新按照正确的理解敲了一边，A掉了。\n\n 这时候差不多两个半小时了，最后看了下C题，推出来是二项式定理，然后就开始发午饭了。直接拿着紫书二项式定理的板子敲了下，但是数太大要取模，然后就GG了，只好靠一个会数论的队友了。我最后又用JAVA大数类敲了敲果断超时。\n\n 然后最后两个小时，一个队友去看D题，一个看了下A题，最后取模要用到逆元，最终没弄出来，A题博弈最后交了几次也是WA。四题结束。\n\n# 总结：\n\n 感觉还是自己实力太弱，如果队里有两个会数论的话，那么C题应该能做出来了，最后知道A题是经典的博弈，如果自己知识面再广一点的话，也不是一定做不出来，K题好象是贪心加DP，也是可以做的。\n\n 以后还是要多训练刷题，提高自己能力……","slug":"第八届acm山东省赛总结","published":1,"updated":"2017-07-23T02:35:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfc006ky9idhng5iv48","content":"<h1 id=\"比赛过程：\"><a href=\"#比赛过程：\" class=\"headerlink\" title=\"比赛过程：\"></a>比赛过程：</h1><p> 首先看到的是F题，我一开始从后面往前看的，然后队友告诉我F比较简单，然后就去让队友去敲了，我去继续看了其他的题，首先过一遍题是为了找到水题。</p>\n<p> 不幸的是F题WA了好多次，这时候另一个队友说G是一个水题，好像要算多少次幂的样子，这时就把F打印出来，然后就让队友去敲G了。据说这个题有坑，题目错了，本来是1e9+7的，题面是1e8+7，不过队友好像跳过了这个坑，一次AC。</p>\n<p> 这时候F题还是一直卡，然后我发现I题挺简单，只是打表找下规律，然后让队友去找了。</p>\n<p> 然后看了下榜，发现J题A的人非常多，于是跟了下榜，刚开始我想得就是贪心，不过没想到怎么动态的维护最大值，想上二分来着，然后和队友I题找到规律了先去用JAVA大数过了I题。</p>\n<p>然后和队友讨论了下找到了J题动态维护最大值的办法。果断敲上去就A掉了。</p>\n<p> 然后这时候F题还是卡住，这时候只有我还没仔细看过那个题，于是让队友去看别的题了，我去重新敲了一遍，发现是我们理解错题意，然后重新按照正确的理解敲了一边，A掉了。</p>\n<p> 这时候差不多两个半小时了，最后看了下C题，推出来是二项式定理，然后就开始发午饭了。直接拿着紫书二项式定理的板子敲了下，但是数太大要取模，然后就GG了，只好靠一个会数论的队友了。我最后又用JAVA大数类敲了敲果断超时。</p>\n<p> 然后最后两个小时，一个队友去看D题，一个看了下A题，最后取模要用到逆元，最终没弄出来，A题博弈最后交了几次也是WA。四题结束。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p> 感觉还是自己实力太弱，如果队里有两个会数论的话，那么C题应该能做出来了，最后知道A题是经典的博弈，如果自己知识面再广一点的话，也不是一定做不出来，K题好象是贪心加DP，也是可以做的。</p>\n<p> 以后还是要多训练刷题，提高自己能力……</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"比赛过程：\"><a href=\"#比赛过程：\" class=\"headerlink\" title=\"比赛过程：\"></a>比赛过程：</h1><p> 首先看到的是F题，我一开始从后面往前看的，然后队友告诉我F比较简单，然后就去让队友去敲了，我去继续看了其他的题，首先过一遍题是为了找到水题。</p>\n<p> 不幸的是F题WA了好多次，这时候另一个队友说G是一个水题，好像要算多少次幂的样子，这时就把F打印出来，然后就让队友去敲G了。据说这个题有坑，题目错了，本来是1e9+7的，题面是1e8+7，不过队友好像跳过了这个坑，一次AC。</p>\n<p> 这时候F题还是一直卡，然后我发现I题挺简单，只是打表找下规律，然后让队友去找了。</p>\n<p> 然后看了下榜，发现J题A的人非常多，于是跟了下榜，刚开始我想得就是贪心，不过没想到怎么动态的维护最大值，想上二分来着，然后和队友I题找到规律了先去用JAVA大数过了I题。</p>\n<p>然后和队友讨论了下找到了J题动态维护最大值的办法。果断敲上去就A掉了。</p>\n<p> 然后这时候F题还是卡住，这时候只有我还没仔细看过那个题，于是让队友去看别的题了，我去重新敲了一遍，发现是我们理解错题意，然后重新按照正确的理解敲了一边，A掉了。</p>\n<p> 这时候差不多两个半小时了，最后看了下C题，推出来是二项式定理，然后就开始发午饭了。直接拿着紫书二项式定理的板子敲了下，但是数太大要取模，然后就GG了，只好靠一个会数论的队友了。我最后又用JAVA大数类敲了敲果断超时。</p>\n<p> 然后最后两个小时，一个队友去看D题，一个看了下A题，最后取模要用到逆元，最终没弄出来，A题博弈最后交了几次也是WA。四题结束。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p> 感觉还是自己实力太弱，如果队里有两个会数论的话，那么C题应该能做出来了，最后知道A题是经典的博弈，如果自己知识面再广一点的话，也不是一定做不出来，K题好象是贪心加DP，也是可以做的。</p>\n<p> 以后还是要多训练刷题，提高自己能力……</p>\n"},{"title":"线段树小结","date":"2017-06-19T04:46:32.000Z","_content":"# 前言：\n实验室要开展每周的算法讲堂活动，大概是每周一个集训队员来给大家将一个知识点，于是我去讲线段树来开头了，但是自己好弱啊，自从寒假集训后就一直没敲过线段树代码了，于是这几天一直在照着金巨巨的博客刷线段树的题（也是抄的金巨巨的模板...）。\n\n这里总结一些做到的题，一些线段树的基本思路，也当做理一下总结的思路。\n\n用到的一些宏定义：\n```cpp\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n```\n\n-------------------------------------------\n# 线段树的基本概念：\n\n如果把线段树当做一个数据结构的话，那么可以这样解释线段树：\n\n首先线段树是一颗二叉树，特殊的是线段树的每个节点，用来维护一段区间的信息，通常的写法都是这样，假设父节点维护的区间是$[a, b]$，那么他的左右儿子维护的区间分别是$[a, (a+b)/2], [(a+b)/2+1, b]$。\n\n一个节点维护的信息通常有，区间和，区间连续子串和，区间最大值，区间最小值等。\n\n\n## 建树过程：\n构造一颗线段树的过程，可以参考分治算法的步骤：\n\n1. 假设要计算区间$[a, b]$中需要维护的信息，我们将这个问题分解成计算$[a, (a+b)/2], [(a+b)/2+1, b]$中需要维护的信息两个子问题，这样子问题与原问题的形式一样，只是规模更小.\n2. 对于第一步分解出的每个子问题，继续使用第一步进行分解得到规模更小的子问题，直到问题的规模足够小，可以直接求解。通常来讲是区间长度为$1$的时候，这样容易计算出需要维护的信息，比如区间和、区间极值等可以以$O(1)$的时间直接计算出。\n3. 最后一步是将上面分解出的子问题的解，合并成原问题的解，通常这一步也是最难的一步。\n\n下面是建树的代码，完美的符合了上述过程。\n这里需要注意的一点是，对于每个节点，要么他是一个叶子节点，要么他是一个同时具有左右儿子的节点。\n```cpp\nvoid build (int root ,int l, int r) {\n    if (l == r) {\n        tree[root].maintain(data[l], l);\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n```\n\n通过上述分治的步骤，我们也可以另一种方式理解线段树：\n我们要解决一个大问题，然后我们用分治的方法是解决这个问题，不过这里我们要把每一步解决的子问题的解都记录下来。这样所有子问题的解，和原问题的解就构成了一颗线段树。\n\n## 更新：\n线段树的更新过程，也是递归来实现的。这里以单点更新来举例，因为线段树是储存着许多子问题的解的，所以对一个点进行更新，可能会对多个子问题有影响，这里我们也用分治算法去更新。\n\n假设要对$[1,n]$的区间下标为$p$的点进行更新。那么对于$[1,n]$区间可以先对他的两个儿子节点$[1,(1+n)/2], [(1+n)/2+1, r]$进行更新，$[1,n]$区间可由更新后的两个儿子节点组合而成。对他的两个儿子节点也进行如下操作，直到一个节点可以直接计算出更新后的变化。\n\n\n下面是更新的代码，符合上述过程，不过这里加入了一个剪枝，如果需要更新的点不在当前节点维护的区间，那么这次更新对当前节点一点没有影响，不需要继续向下更新。\n```cpp\nvoid updata(int root, int l, int r, int pos, int v) {\n    if (pos < l || r < pos)\n        return;\n    if (l == r) {\n        tree[root].maintain(v, pos);\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos, v);\n    updata(rson, m+1, r, pos, v);\n    tree[root] = tree[lson] + tree[rson];\n}\n```\n-------------------------------------------------------\n## 查询：\n查询过程其实就是用已经解决的子问题的解去构造新问题的解的过程。\n\n比如之前说过，对于一个维护$[1,n]$区间的线段树，它里面就存着着分治解决$[1,n]$这个问题的所有子问题的解。那么对于每次查询区间$[l,r],1\\leq l \\leq r \\leq n$，都是一个规模小于$[1,n]$的问题。那么对于这个问题的解，可以用解决$[1,n]$问题的子问题的解构造出来。\n\n\n以下是查询过程中的代码，就是遍历原问题的所有子问题的解，去构造新问题的解，这里加入了剪枝，如果一个区间和需要查询的区间没有交集，那么就可以剪枝。\n```cpp\nInfo query(int root, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql)\n        return Info();\n    if (ql <= l && r <= qr) {\n        return tree[root];\n    }\n    MID;\n    return query(lson, l, m, ql, qr) + query(rson, m+1, r, ql, qr);\n}\n```\n\n--------------------------------------------\n# 合并：\n所谓合并就是合并两个节点为一个节点，也就是合并子问题，构造原问题解的过程。\n\n比如我分别知道$[a, b]$和$[b+1, c]$区间的最大值为$x_1, x_2$，那么区间$[a, b]$的最大值，那么就是$max(x_1, x_2)$。这样就用这两段区间的解构造出了另一个区间的解。\n\n这里重载了加号，用起来比较方便。\n```cpp\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.value = max(a.value, b.value);\n    return rst;\n}\n```\n当然这只是一个简单的例子，在许多线段树中合并起来非常麻烦，比如求一段区间内的最大的连续子串和。\n\n对于区间$[1, n]$，那么最长连续子串和一定来自于以下的三种：\n\n+ 区间$[1,(n+1)/2]$的最长连续子串和；\n+ 区间$[(n+1)/2+1, n]$的最长连续子串和；\n+ 区间$[1,(n+1)/2]$的从右端开始的最长连续子串和加上区间$[(n+1)/2+1,n]$从左端开始的最长连续子串和。\n\n对于每段区间需要维护三个信息，从左端开始的最长连续子串和，从右端开始的最长连续子串和，最长连续子串和。分别记为`lmax,rmax,value`。\n\n那么合并两个区间的代码如下：\n```cpp\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.lmax = max(a.lmax, a.sum + b.lmax);\n    rst.rmax = max(b.rmax, a.rmax + b.sum);\n    rst.sum = a.sum + b.sum;\n    rst.value = max(max(a.value, b.value), a.rmax + b.lmax);\n    return rst;\n}\n```\n这里为了方便操作，记录了区间的和。","source":"_posts/线段树小结.md","raw":"---\ntitle: 线段树小结\ndate: 2017-06-19 12:46:32\ncategories: [ACM, 知识小结]\ntags:\n---\n# 前言：\n实验室要开展每周的算法讲堂活动，大概是每周一个集训队员来给大家将一个知识点，于是我去讲线段树来开头了，但是自己好弱啊，自从寒假集训后就一直没敲过线段树代码了，于是这几天一直在照着金巨巨的博客刷线段树的题（也是抄的金巨巨的模板...）。\n\n这里总结一些做到的题，一些线段树的基本思路，也当做理一下总结的思路。\n\n用到的一些宏定义：\n```cpp\n#define lson root<<1\n#define rson root<<1|1\n#define MID int m = (l + r) / 2\n```\n\n-------------------------------------------\n# 线段树的基本概念：\n\n如果把线段树当做一个数据结构的话，那么可以这样解释线段树：\n\n首先线段树是一颗二叉树，特殊的是线段树的每个节点，用来维护一段区间的信息，通常的写法都是这样，假设父节点维护的区间是$[a, b]$，那么他的左右儿子维护的区间分别是$[a, (a+b)/2], [(a+b)/2+1, b]$。\n\n一个节点维护的信息通常有，区间和，区间连续子串和，区间最大值，区间最小值等。\n\n\n## 建树过程：\n构造一颗线段树的过程，可以参考分治算法的步骤：\n\n1. 假设要计算区间$[a, b]$中需要维护的信息，我们将这个问题分解成计算$[a, (a+b)/2], [(a+b)/2+1, b]$中需要维护的信息两个子问题，这样子问题与原问题的形式一样，只是规模更小.\n2. 对于第一步分解出的每个子问题，继续使用第一步进行分解得到规模更小的子问题，直到问题的规模足够小，可以直接求解。通常来讲是区间长度为$1$的时候，这样容易计算出需要维护的信息，比如区间和、区间极值等可以以$O(1)$的时间直接计算出。\n3. 最后一步是将上面分解出的子问题的解，合并成原问题的解，通常这一步也是最难的一步。\n\n下面是建树的代码，完美的符合了上述过程。\n这里需要注意的一点是，对于每个节点，要么他是一个叶子节点，要么他是一个同时具有左右儿子的节点。\n```cpp\nvoid build (int root ,int l, int r) {\n    if (l == r) {\n        tree[root].maintain(data[l], l);\n        return;\n    }\n    MID;\n    build(lson, l, m);\n    build(rson, m+1, r);\n    tree[root] = tree[lson] + tree[rson];\n}\n```\n\n通过上述分治的步骤，我们也可以另一种方式理解线段树：\n我们要解决一个大问题，然后我们用分治的方法是解决这个问题，不过这里我们要把每一步解决的子问题的解都记录下来。这样所有子问题的解，和原问题的解就构成了一颗线段树。\n\n## 更新：\n线段树的更新过程，也是递归来实现的。这里以单点更新来举例，因为线段树是储存着许多子问题的解的，所以对一个点进行更新，可能会对多个子问题有影响，这里我们也用分治算法去更新。\n\n假设要对$[1,n]$的区间下标为$p$的点进行更新。那么对于$[1,n]$区间可以先对他的两个儿子节点$[1,(1+n)/2], [(1+n)/2+1, r]$进行更新，$[1,n]$区间可由更新后的两个儿子节点组合而成。对他的两个儿子节点也进行如下操作，直到一个节点可以直接计算出更新后的变化。\n\n\n下面是更新的代码，符合上述过程，不过这里加入了一个剪枝，如果需要更新的点不在当前节点维护的区间，那么这次更新对当前节点一点没有影响，不需要继续向下更新。\n```cpp\nvoid updata(int root, int l, int r, int pos, int v) {\n    if (pos < l || r < pos)\n        return;\n    if (l == r) {\n        tree[root].maintain(v, pos);\n        return;\n    }\n    MID;\n    updata(lson, l, m, pos, v);\n    updata(rson, m+1, r, pos, v);\n    tree[root] = tree[lson] + tree[rson];\n}\n```\n-------------------------------------------------------\n## 查询：\n查询过程其实就是用已经解决的子问题的解去构造新问题的解的过程。\n\n比如之前说过，对于一个维护$[1,n]$区间的线段树，它里面就存着着分治解决$[1,n]$这个问题的所有子问题的解。那么对于每次查询区间$[l,r],1\\leq l \\leq r \\leq n$，都是一个规模小于$[1,n]$的问题。那么对于这个问题的解，可以用解决$[1,n]$问题的子问题的解构造出来。\n\n\n以下是查询过程中的代码，就是遍历原问题的所有子问题的解，去构造新问题的解，这里加入了剪枝，如果一个区间和需要查询的区间没有交集，那么就可以剪枝。\n```cpp\nInfo query(int root, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql)\n        return Info();\n    if (ql <= l && r <= qr) {\n        return tree[root];\n    }\n    MID;\n    return query(lson, l, m, ql, qr) + query(rson, m+1, r, ql, qr);\n}\n```\n\n--------------------------------------------\n# 合并：\n所谓合并就是合并两个节点为一个节点，也就是合并子问题，构造原问题解的过程。\n\n比如我分别知道$[a, b]$和$[b+1, c]$区间的最大值为$x_1, x_2$，那么区间$[a, b]$的最大值，那么就是$max(x_1, x_2)$。这样就用这两段区间的解构造出了另一个区间的解。\n\n这里重载了加号，用起来比较方便。\n```cpp\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.value = max(a.value, b.value);\n    return rst;\n}\n```\n当然这只是一个简单的例子，在许多线段树中合并起来非常麻烦，比如求一段区间内的最大的连续子串和。\n\n对于区间$[1, n]$，那么最长连续子串和一定来自于以下的三种：\n\n+ 区间$[1,(n+1)/2]$的最长连续子串和；\n+ 区间$[(n+1)/2+1, n]$的最长连续子串和；\n+ 区间$[1,(n+1)/2]$的从右端开始的最长连续子串和加上区间$[(n+1)/2+1,n]$从左端开始的最长连续子串和。\n\n对于每段区间需要维护三个信息，从左端开始的最长连续子串和，从右端开始的最长连续子串和，最长连续子串和。分别记为`lmax,rmax,value`。\n\n那么合并两个区间的代码如下：\n```cpp\nInfo operator + (const Info & a, const Info & b) {\n    Info rst;\n    rst.lmax = max(a.lmax, a.sum + b.lmax);\n    rst.rmax = max(b.rmax, a.rmax + b.sum);\n    rst.sum = a.sum + b.sum;\n    rst.value = max(max(a.value, b.value), a.rmax + b.lmax);\n    return rst;\n}\n```\n这里为了方便操作，记录了区间的和。","slug":"线段树小结","published":1,"updated":"2017-07-23T02:00:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfe006ny9idt89zhnsb","content":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><p>实验室要开展每周的算法讲堂活动，大概是每周一个集训队员来给大家将一个知识点，于是我去讲线段树来开头了，但是自己好弱啊，自从寒假集训后就一直没敲过线段树代码了，于是这几天一直在照着金巨巨的博客刷线段树的题（也是抄的金巨巨的模板…）。</p>\n<p>这里总结一些做到的题，一些线段树的基本思路，也当做理一下总结的思路。</p>\n<p>用到的一些宏定义：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"线段树的基本概念：\"><a href=\"#线段树的基本概念：\" class=\"headerlink\" title=\"线段树的基本概念：\"></a>线段树的基本概念：</h1><p>如果把线段树当做一个数据结构的话，那么可以这样解释线段树：</p>\n<p>首先线段树是一颗二叉树，特殊的是线段树的每个节点，用来维护一段区间的信息，通常的写法都是这样，假设父节点维护的区间是$[a, b]$，那么他的左右儿子维护的区间分别是$[a, (a+b)/2], [(a+b)/2+1, b]$。</p>\n<p>一个节点维护的信息通常有，区间和，区间连续子串和，区间最大值，区间最小值等。</p>\n<h2 id=\"建树过程：\"><a href=\"#建树过程：\" class=\"headerlink\" title=\"建树过程：\"></a>建树过程：</h2><p>构造一颗线段树的过程，可以参考分治算法的步骤：</p>\n<ol>\n<li>假设要计算区间$[a, b]$中需要维护的信息，我们将这个问题分解成计算$[a, (a+b)/2], [(a+b)/2+1, b]$中需要维护的信息两个子问题，这样子问题与原问题的形式一样，只是规模更小.</li>\n<li>对于第一步分解出的每个子问题，继续使用第一步进行分解得到规模更小的子问题，直到问题的规模足够小，可以直接求解。通常来讲是区间长度为$1$的时候，这样容易计算出需要维护的信息，比如区间和、区间极值等可以以$O(1)$的时间直接计算出。</li>\n<li>最后一步是将上面分解出的子问题的解，合并成原问题的解，通常这一步也是最难的一步。</li>\n</ol>\n<p>下面是建树的代码，完美的符合了上述过程。<br>这里需要注意的一点是，对于每个节点，要么他是一个叶子节点，要么他是一个同时具有左右儿子的节点。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">(<span class=\"keyword\">int</span> root ,<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(data[l], l);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过上述分治的步骤，我们也可以另一种方式理解线段树：<br>我们要解决一个大问题，然后我们用分治的方法是解决这个问题，不过这里我们要把每一步解决的子问题的解都记录下来。这样所有子问题的解，和原问题的解就构成了一颗线段树。</p>\n<h2 id=\"更新：\"><a href=\"#更新：\" class=\"headerlink\" title=\"更新：\"></a>更新：</h2><p>线段树的更新过程，也是递归来实现的。这里以单点更新来举例，因为线段树是储存着许多子问题的解的，所以对一个点进行更新，可能会对多个子问题有影响，这里我们也用分治算法去更新。</p>\n<p>假设要对$[1,n]$的区间下标为$p$的点进行更新。那么对于$[1,n]$区间可以先对他的两个儿子节点$[1,(1+n)/2], [(1+n)/2+1, r]$进行更新，$[1,n]$区间可由更新后的两个儿子节点组合而成。对他的两个儿子节点也进行如下操作，直到一个节点可以直接计算出更新后的变化。</p>\n<p>下面是更新的代码，符合上述过程，不过这里加入了一个剪枝，如果需要更新的点不在当前节点维护的区间，那么这次更新对当前节点一点没有影响，不需要继续向下更新。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt; l || r &lt; pos)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(v, pos);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos, v);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, pos, v);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"查询：\"><a href=\"#查询：\" class=\"headerlink\" title=\"查询：\"></a>查询：</h2><p>查询过程其实就是用已经解决的子问题的解去构造新问题的解的过程。</p>\n<p>比如之前说过，对于一个维护$[1,n]$区间的线段树，它里面就存着着分治解决$[1,n]$这个问题的所有子问题的解。那么对于每次查询区间$[l,r],1\\leq l \\leq r \\leq n$，都是一个规模小于$[1,n]$的问题。那么对于这个问题的解，可以用解决$[1,n]$问题的子问题的解构造出来。</p>\n<p>以下是查询过程中的代码，就是遍历原问题的所有子问题的解，去构造新问题的解，这里加入了剪枝，如果一个区间和需要查询的区间没有交集，那么就可以剪枝。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql)</div><div class=\"line\">        <span class=\"keyword\">return</span> Info();</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"合并：\"><a href=\"#合并：\" class=\"headerlink\" title=\"合并：\"></a>合并：</h1><p>所谓合并就是合并两个节点为一个节点，也就是合并子问题，构造原问题解的过程。</p>\n<p>比如我分别知道$[a, b]$和$[b+1, c]$区间的最大值为$x_1, x_2$，那么区间$[a, b]$的最大值，那么就是$max(x_1, x_2)$。这样就用这两段区间的解构造出了另一个区间的解。</p>\n<p>这里重载了加号，用起来比较方便。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.value = max(a.value, b.value);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然这只是一个简单的例子，在许多线段树中合并起来非常麻烦，比如求一段区间内的最大的连续子串和。</p>\n<p>对于区间$[1, n]$，那么最长连续子串和一定来自于以下的三种：</p>\n<ul>\n<li>区间$[1,(n+1)/2]$的最长连续子串和；</li>\n<li>区间$[(n+1)/2+1, n]$的最长连续子串和；</li>\n<li>区间$[1,(n+1)/2]$的从右端开始的最长连续子串和加上区间$[(n+1)/2+1,n]$从左端开始的最长连续子串和。</li>\n</ul>\n<p>对于每段区间需要维护三个信息，从左端开始的最长连续子串和，从右端开始的最长连续子串和，最长连续子串和。分别记为<code>lmax,rmax,value</code>。</p>\n<p>那么合并两个区间的代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.lmax = max(a.lmax, a.sum + b.lmax);</div><div class=\"line\">    rst.rmax = max(b.rmax, a.rmax + b.sum);</div><div class=\"line\">    rst.sum = a.sum + b.sum;</div><div class=\"line\">    rst.value = max(max(a.value, b.value), a.rmax + b.lmax);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里为了方便操作，记录了区间的和。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h1><p>实验室要开展每周的算法讲堂活动，大概是每周一个集训队员来给大家将一个知识点，于是我去讲线段树来开头了，但是自己好弱啊，自从寒假集训后就一直没敲过线段树代码了，于是这几天一直在照着金巨巨的博客刷线段树的题（也是抄的金巨巨的模板…）。</p>\n<p>这里总结一些做到的题，一些线段树的基本思路，也当做理一下总结的思路。</p>\n<p>用到的一些宏定义：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson root&lt;&lt;1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson root&lt;&lt;1|1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MID int m = (l + r) / 2</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"线段树的基本概念：\"><a href=\"#线段树的基本概念：\" class=\"headerlink\" title=\"线段树的基本概念：\"></a>线段树的基本概念：</h1><p>如果把线段树当做一个数据结构的话，那么可以这样解释线段树：</p>\n<p>首先线段树是一颗二叉树，特殊的是线段树的每个节点，用来维护一段区间的信息，通常的写法都是这样，假设父节点维护的区间是$[a, b]$，那么他的左右儿子维护的区间分别是$[a, (a+b)/2], [(a+b)/2+1, b]$。</p>\n<p>一个节点维护的信息通常有，区间和，区间连续子串和，区间最大值，区间最小值等。</p>\n<h2 id=\"建树过程：\"><a href=\"#建树过程：\" class=\"headerlink\" title=\"建树过程：\"></a>建树过程：</h2><p>构造一颗线段树的过程，可以参考分治算法的步骤：</p>\n<ol>\n<li>假设要计算区间$[a, b]$中需要维护的信息，我们将这个问题分解成计算$[a, (a+b)/2], [(a+b)/2+1, b]$中需要维护的信息两个子问题，这样子问题与原问题的形式一样，只是规模更小.</li>\n<li>对于第一步分解出的每个子问题，继续使用第一步进行分解得到规模更小的子问题，直到问题的规模足够小，可以直接求解。通常来讲是区间长度为$1$的时候，这样容易计算出需要维护的信息，比如区间和、区间极值等可以以$O(1)$的时间直接计算出。</li>\n<li>最后一步是将上面分解出的子问题的解，合并成原问题的解，通常这一步也是最难的一步。</li>\n</ol>\n<p>下面是建树的代码，完美的符合了上述过程。<br>这里需要注意的一点是，对于每个节点，要么他是一个叶子节点，要么他是一个同时具有左右儿子的节点。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">(<span class=\"keyword\">int</span> root ,<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(data[l], l);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    build(lson, l, m);</div><div class=\"line\">    build(rson, m+<span class=\"number\">1</span>, r);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过上述分治的步骤，我们也可以另一种方式理解线段树：<br>我们要解决一个大问题，然后我们用分治的方法是解决这个问题，不过这里我们要把每一步解决的子问题的解都记录下来。这样所有子问题的解，和原问题的解就构成了一颗线段树。</p>\n<h2 id=\"更新：\"><a href=\"#更新：\" class=\"headerlink\" title=\"更新：\"></a>更新：</h2><p>线段树的更新过程，也是递归来实现的。这里以单点更新来举例，因为线段树是储存着许多子问题的解的，所以对一个点进行更新，可能会对多个子问题有影响，这里我们也用分治算法去更新。</p>\n<p>假设要对$[1,n]$的区间下标为$p$的点进行更新。那么对于$[1,n]$区间可以先对他的两个儿子节点$[1,(1+n)/2], [(1+n)/2+1, r]$进行更新，$[1,n]$区间可由更新后的两个儿子节点组合而成。对他的两个儿子节点也进行如下操作，直到一个节点可以直接计算出更新后的变化。</p>\n<p>下面是更新的代码，符合上述过程，不过这里加入了一个剪枝，如果需要更新的点不在当前节点维护的区间，那么这次更新对当前节点一点没有影响，不需要继续向下更新。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updata</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &lt; l || r &lt; pos)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</div><div class=\"line\">        tree[root].maintain(v, pos);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    updata(lson, l, m, pos, v);</div><div class=\"line\">    updata(rson, m+<span class=\"number\">1</span>, r, pos, v);</div><div class=\"line\">    tree[root] = tree[lson] + tree[rson];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"查询：\"><a href=\"#查询：\" class=\"headerlink\" title=\"查询：\"></a>查询：</h2><p>查询过程其实就是用已经解决的子问题的解去构造新问题的解的过程。</p>\n<p>比如之前说过，对于一个维护$[1,n]$区间的线段树，它里面就存着着分治解决$[1,n]$这个问题的所有子问题的解。那么对于每次查询区间$[l,r],1\\leq l \\leq r \\leq n$，都是一个规模小于$[1,n]$的问题。那么对于这个问题的解，可以用解决$[1,n]$问题的子问题的解构造出来。</p>\n<p>以下是查询过程中的代码，就是遍历原问题的所有子问题的解，去构造新问题的解，这里加入了剪枝，如果一个区间和需要查询的区间没有交集，那么就可以剪枝。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Info <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> ql, <span class=\"keyword\">int</span> qr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (qr &lt; l || r &lt; ql)</div><div class=\"line\">        <span class=\"keyword\">return</span> Info();</div><div class=\"line\">    <span class=\"keyword\">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> tree[root];</div><div class=\"line\">    &#125;</div><div class=\"line\">    MID;</div><div class=\"line\">    <span class=\"keyword\">return</span> query(lson, l, m, ql, qr) + query(rson, m+<span class=\"number\">1</span>, r, ql, qr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"合并：\"><a href=\"#合并：\" class=\"headerlink\" title=\"合并：\"></a>合并：</h1><p>所谓合并就是合并两个节点为一个节点，也就是合并子问题，构造原问题解的过程。</p>\n<p>比如我分别知道$[a, b]$和$[b+1, c]$区间的最大值为$x_1, x_2$，那么区间$[a, b]$的最大值，那么就是$max(x_1, x_2)$。这样就用这两段区间的解构造出了另一个区间的解。</p>\n<p>这里重载了加号，用起来比较方便。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.value = max(a.value, b.value);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然这只是一个简单的例子，在许多线段树中合并起来非常麻烦，比如求一段区间内的最大的连续子串和。</p>\n<p>对于区间$[1, n]$，那么最长连续子串和一定来自于以下的三种：</p>\n<ul>\n<li>区间$[1,(n+1)/2]$的最长连续子串和；</li>\n<li>区间$[(n+1)/2+1, n]$的最长连续子串和；</li>\n<li>区间$[1,(n+1)/2]$的从右端开始的最长连续子串和加上区间$[(n+1)/2+1,n]$从左端开始的最长连续子串和。</li>\n</ul>\n<p>对于每段区间需要维护三个信息，从左端开始的最长连续子串和，从右端开始的最长连续子串和，最长连续子串和。分别记为<code>lmax,rmax,value</code>。</p>\n<p>那么合并两个区间的代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Info <span class=\"keyword\">operator</span> + (<span class=\"keyword\">const</span> Info &amp; a, <span class=\"keyword\">const</span> Info &amp; b) &#123;</div><div class=\"line\">    Info rst;</div><div class=\"line\">    rst.lmax = max(a.lmax, a.sum + b.lmax);</div><div class=\"line\">    rst.rmax = max(b.rmax, a.rmax + b.sum);</div><div class=\"line\">    rst.sum = a.sum + b.sum;</div><div class=\"line\">    rst.value = max(max(a.value, b.value), a.rmax + b.lmax);</div><div class=\"line\">    <span class=\"keyword\">return</span> rst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里为了方便操作，记录了区间的和。</p>\n"},{"title":"社交网络图中结点的“重要性“计算（Dijkstra + SPFA + Floyd + 模板）","date":"2017-03-20T07:56:27.000Z","_content":"# 题目链接：\n 无\n ---------------\n# 题目大意：\n  求一个点到其他所有点的最短距离和，保证图连通。\n  -------------------\n# 解题过程：\n 刚开始用 Floyd 水过的，后来用换了几种方法，不错的模板题，Floyd 的时候，要用 vector 存边，否则超内存。   \n\n------------------------\n# 题目分析\n 略\n\n---------------------\n# AC代码（Dijkstra + SPFA）\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234, INF = 0x3f3f3f3f;\n\nvector<int> edges[MAX];\nint dist[MAX], book[MAX];\n\nvoid spfa(int s) {\n    memset(dist, INF, sizeof(dist));\n    memset(book, 0, sizeof(book));\n\n    queue<int> q;\n    q.push(s);\n    book[s] = 1;\n    dist[s] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        for (int i = 0; i < edges[u].size(); i++) {\n            int v = edges[u][i];\n            if (dist[v] > dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n                if (!book[v]) {\n                    q.push(v);\n                    book[v] = 1;\n                }\n            }\n        }\n        q.pop();\n        book[u] = 0;\n    }\n}\n\nvoid dijkstra(int s) {\n    memset(dist, INF, sizeof(dist));\n    priority_queue<pair<int, int> > q;\n    dist[s] = 0;\n    q.push(make_pair(-dist[s], s));\n    while (!q.empty()) {\n        int u = q.top().second;\n        q.pop();\n\n        for (int i = 0; i < edges[u].size(); i++) {\n            int v = edges[u][i];\n            if (dist[v] > dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n                q.push(make_pair(-dist[v], v));\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    while (m--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    int k;\n    scanf(\"%d\", &k);\n    while (k--) {\n        int s;\n        scanf(\"%d\", &s);\n        dijkstra(s);\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i == s)\n                continue;\n            sum += dist[i];\n        }\n        printf(\"Cc(%d)=%.2f\\n\", s, (n-1.0)/sum);\n    }\n}\n\n```\n------------------------\n# AC代码（Floyd）：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, MAX = 10001;\n\nint main()\n{\n    vector<int>edge[MAX];\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            edge[i].push_back(INF);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        edge[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edge[u][v] = edge[v][u] = 1;\n    }\n\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (edge[i][j] > edge[i][k] + edge[k][j])\n                    edge[i][j] = edge[i][k] + edge[k][j];\n            }\n        }\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n    while (k--) {\n        int c;\n        scanf(\"%d\", &c);\n        double sum = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i == c)\n                continue;\n            sum += edge[c][i];\n        }\n        printf(\"Cc(%d)=%.2f\\n\", c, (n-1)/sum);\n    }\n}\n\n```","source":"_posts/社交网络图中结点的“重要性“计算（Dijkstra-SPFA-Floyd-模板）.md","raw":"---\ntitle: 社交网络图中结点的“重要性“计算（Dijkstra + SPFA + Floyd + 模板）\ndate: 2017-03-20 15:56:27\ncategories: [ACM, 图论, 最短路]\ntags:\n---\n# 题目链接：\n 无\n ---------------\n# 题目大意：\n  求一个点到其他所有点的最短距离和，保证图连通。\n  -------------------\n# 解题过程：\n 刚开始用 Floyd 水过的，后来用换了几种方法，不错的模板题，Floyd 的时候，要用 vector 存边，否则超内存。   \n\n------------------------\n# 题目分析\n 略\n\n---------------------\n# AC代码（Dijkstra + SPFA）\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 11234, INF = 0x3f3f3f3f;\n\nvector<int> edges[MAX];\nint dist[MAX], book[MAX];\n\nvoid spfa(int s) {\n    memset(dist, INF, sizeof(dist));\n    memset(book, 0, sizeof(book));\n\n    queue<int> q;\n    q.push(s);\n    book[s] = 1;\n    dist[s] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        for (int i = 0; i < edges[u].size(); i++) {\n            int v = edges[u][i];\n            if (dist[v] > dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n                if (!book[v]) {\n                    q.push(v);\n                    book[v] = 1;\n                }\n            }\n        }\n        q.pop();\n        book[u] = 0;\n    }\n}\n\nvoid dijkstra(int s) {\n    memset(dist, INF, sizeof(dist));\n    priority_queue<pair<int, int> > q;\n    dist[s] = 0;\n    q.push(make_pair(-dist[s], s));\n    while (!q.empty()) {\n        int u = q.top().second;\n        q.pop();\n\n        for (int i = 0; i < edges[u].size(); i++) {\n            int v = edges[u][i];\n            if (dist[v] > dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n                q.push(make_pair(-dist[v], v));\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    while (m--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    int k;\n    scanf(\"%d\", &k);\n    while (k--) {\n        int s;\n        scanf(\"%d\", &s);\n        dijkstra(s);\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i == s)\n                continue;\n            sum += dist[i];\n        }\n        printf(\"Cc(%d)=%.2f\\n\", s, (n-1.0)/sum);\n    }\n}\n\n```\n------------------------\n# AC代码（Floyd）：\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, MAX = 10001;\n\nint main()\n{\n    vector<int>edge[MAX];\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            edge[i].push_back(INF);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        edge[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edge[u][v] = edge[v][u] = 1;\n    }\n\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (edge[i][j] > edge[i][k] + edge[k][j])\n                    edge[i][j] = edge[i][k] + edge[k][j];\n            }\n        }\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n    while (k--) {\n        int c;\n        scanf(\"%d\", &c);\n        double sum = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i == c)\n                continue;\n            sum += edge[c][i];\n        }\n        printf(\"Cc(%d)=%.2f\\n\", c, (n-1)/sum);\n    }\n}\n\n```","slug":"社交网络图中结点的“重要性“计算（Dijkstra-SPFA-Floyd-模板）","published":1,"updated":"2017-07-23T02:46:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfg006py9id60qlp5pa","content":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><h2 id=\"无\"><a href=\"#无\" class=\"headerlink\" title=\" 无\"></a> 无</h2><h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><h2 id=\"求一个点到其他所有点的最短距离和，保证图连通。\"><a href=\"#求一个点到其他所有点的最短距离和，保证图连通。\" class=\"headerlink\" title=\"  求一个点到其他所有点的最短距离和，保证图连通。\"></a>  求一个点到其他所有点的最短距离和，保证图连通。</h2><h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始用 Floyd 水过的，后来用换了几种方法，不错的模板题，Floyd 的时候，要用 vector 存边，否则超内存。   </p>\n<hr>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><p> 略</p>\n<hr>\n<h1 id=\"AC代码（Dijkstra-SPFA）\"><a href=\"#AC代码（Dijkstra-SPFA）\" class=\"headerlink\" title=\"AC代码（Dijkstra + SPFA）\"></a>AC代码（Dijkstra + SPFA）</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edges[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], book[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    book[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edges[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                dist[v] = dist[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!book[v]) &#123;</div><div class=\"line\">                    q.push(v);</div><div class=\"line\">                    book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        book[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    q.push(make_pair(-dist[s], s));</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.top().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edges[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                dist[v] = dist[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(make_pair(-dist[v], v));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edges[u].push_back(v);</div><div class=\"line\">        edges[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">    <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> s;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;s);</div><div class=\"line\">        dijkstra(s);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == s)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            sum += dist[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Cc(%d)=%.2f\\n\"</span>, s, (n<span class=\"number\">-1.0</span>)/sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码（Floyd）：\"><a href=\"#AC代码（Floyd）：\" class=\"headerlink\" title=\"AC代码（Floyd）：\"></a>AC代码（Floyd）：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>, MAX = <span class=\"number\">10001</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;edge[MAX];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">            edge[i].push_back(INF);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        edge[i][i] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edge[u][v] = edge[v][u] = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (edge[i][j] &gt; edge[i][k] + edge[k][j])</div><div class=\"line\">                    edge[i][j] = edge[i][k] + edge[k][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">    <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</div><div class=\"line\">        <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == c)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            sum += edge[c][i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Cc(%d)=%.2f\\n\"</span>, c, (n<span class=\"number\">-1</span>)/sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h1><h2 id=\"无\"><a href=\"#无\" class=\"headerlink\" title=\" 无\"></a> 无</h2><h1 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h1><h2 id=\"求一个点到其他所有点的最短距离和，保证图连通。\"><a href=\"#求一个点到其他所有点的最短距离和，保证图连通。\" class=\"headerlink\" title=\"  求一个点到其他所有点的最短距离和，保证图连通。\"></a>  求一个点到其他所有点的最短距离和，保证图连通。</h2><h1 id=\"解题过程：\"><a href=\"#解题过程：\" class=\"headerlink\" title=\"解题过程：\"></a>解题过程：</h1><p> 刚开始用 Floyd 水过的，后来用换了几种方法，不错的模板题，Floyd 的时候，要用 vector 存边，否则超内存。   </p>\n<hr>\n<h1 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h1><p> 略</p>\n<hr>\n<h1 id=\"AC代码（Dijkstra-SPFA）\"><a href=\"#AC代码（Dijkstra-SPFA）\" class=\"headerlink\" title=\"AC代码（Dijkstra + SPFA）\"></a>AC代码（Dijkstra + SPFA）</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">11234</span>, INF = <span class=\"number\">0x3f3f3f3f</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edges[MAX];</div><div class=\"line\"><span class=\"keyword\">int</span> dist[MAX], book[MAX];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(book));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</div><div class=\"line\">    q.push(s);</div><div class=\"line\">    book[s] = <span class=\"number\">1</span>;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.front();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edges[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                dist[v] = dist[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!book[v]) &#123;</div><div class=\"line\">                    q.push(v);</div><div class=\"line\">                    book[v] = <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        q.pop();</div><div class=\"line\">        book[u] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(dist, INF, <span class=\"keyword\">sizeof</span>(dist));</div><div class=\"line\">    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; q;</div><div class=\"line\">    dist[s] = <span class=\"number\">0</span>;</div><div class=\"line\">    q.push(make_pair(-dist[s], s));</div><div class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u = q.top().second;</div><div class=\"line\">        q.pop();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges[u].size(); i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> v = edges[u][i];</div><div class=\"line\">            <span class=\"keyword\">if</span> (dist[v] &gt; dist[u] + <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                dist[v] = dist[u] + <span class=\"number\">1</span>;</div><div class=\"line\">                q.push(make_pair(-dist[v], v));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\">    <span class=\"keyword\">while</span> (m--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edges[u].push_back(v);</div><div class=\"line\">        edges[v].push_back(u);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">    <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> s;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;s);</div><div class=\"line\">        dijkstra(s);</div><div class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == s)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            sum += dist[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Cc(%d)=%.2f\\n\"</span>, s, (n<span class=\"number\">-1.0</span>)/sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"AC代码（Floyd）：\"><a href=\"#AC代码（Floyd）：\" class=\"headerlink\" title=\"AC代码（Floyd）：\"></a>AC代码（Floyd）：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>, MAX = <span class=\"number\">10001</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;edge[MAX];</div><div class=\"line\">    <span class=\"keyword\">int</span> n, m;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;n, &amp;m);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">            edge[i].push_back(INF);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">        edge[i][i] = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> u, v;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;u, &amp;v);</div><div class=\"line\">        edge[u][v] = edge[v][u] = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (edge[i][j] &gt; edge[i][k] + edge[k][j])</div><div class=\"line\">                    edge[i][j] = edge[i][k] + edge[k][j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> k;</div><div class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k);</div><div class=\"line\">    <span class=\"keyword\">while</span> (k--) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c;</div><div class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</div><div class=\"line\">        <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i == c)</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            sum += edge[c][i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Cc(%d)=%.2f\\n\"</span>, c, (n<span class=\"number\">-1</span>)/sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"计算行列式（高斯消元？+Java+工具）","date":"2017-03-09T07:06:33.000Z","_content":"# 功能：\n-----------------\n#### 计算行列式并输出\n# 用法：\n-------------------------\n首先输入行列式的阶数，然后以输入行列式内容。\n\n例如：\n\n输入：\n4\n1 2 -1 3\n2 3 -1 2\n-1 1 1 0\n0 1 -2 1\n\n输入：\n18.0\n# 实现：\n--------------------\n好像是高斯消元，就是每一行乘一个系数减下去，化三角。\n时间复杂度 O(n^3) .\n# 代码：\n```cpp\nimport java.util.*;\nimport java.lang.*;\n\npublic class Determinant {\n\n    public static void main(String[] Args){\n        Scanner cin = new Scanner(System.in);\n        int size = cin.nextInt();\n        double[][] data = new double[size][size];\n\n        //读取数据\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                data[i][j] = cin.nextDouble();\n            }\n        }\n\n        //标记是否可以提前确定行列式为0\n        boolean zero = false;\n        //记录交换行后的正负号\n        double sign = 1;\n\n        //主体\n        for (int row = 0; row < size-1; row++){\n\n            //如果第i行第i个元素已经是0的话，就去找一行非零的行交换\n            if (data[row][row] == 0) {\n                boolean flag = false;\n                for (int trow = row + 1; trow < size; trow++){\n                    if (data[trow][row] != 0){\n                        flag = true;\n                        swap_row(row, trow, size, data);\n                        sign *= -1;\n                        break;\n                    }\n                }\n                //如果一列全为0，那么行列式为0\n                if (!flag)\n                {\n                    zero = true;\n                    break;\n                }\n            }\n\n            for (int trow = row + 1; trow < size; trow++){\n                double k;\n                //如果当前行已经为0，那么直接跳过，否则用row行乘-k加到trow行\n                if (data[trow][row] == 0)\n                    continue;\n                k = data[trow][row] / data[row][row];\n                for (int col = row; col < size; col++){\n                    data[trow][col] += -k * data[row][col];\n                }\n            }\n        }\n\n        double ans;\n\n\n        //整理答案并输出\n        if (zero)\n            ans = 0;\n        else{\n            ans = sign;\n            for (int row = 0; row < size; row++){\n                ans *= data[row][row];\n            }\n        }\n\n        System.out.print(ans);\n    }\n\n    static void swap_row(int a, int b, int size, double data[][]){\n        for (int i = a; i < size; i++){\n            double temp = data[a][i];\n            data[a][i] = data[b][i];\n            data[b][i] = temp;\n        }\n    }\n}\n\n\n```","source":"_posts/计算行列式（高斯消元？-Java-工具）.md","raw":"---\ntitle: 计算行列式（高斯消元？+Java+工具）\ndate: 2017-03-09 15:06:33\ncategories: [编程语言, Java]\ntags:\n---\n# 功能：\n-----------------\n#### 计算行列式并输出\n# 用法：\n-------------------------\n首先输入行列式的阶数，然后以输入行列式内容。\n\n例如：\n\n输入：\n4\n1 2 -1 3\n2 3 -1 2\n-1 1 1 0\n0 1 -2 1\n\n输入：\n18.0\n# 实现：\n--------------------\n好像是高斯消元，就是每一行乘一个系数减下去，化三角。\n时间复杂度 O(n^3) .\n# 代码：\n```cpp\nimport java.util.*;\nimport java.lang.*;\n\npublic class Determinant {\n\n    public static void main(String[] Args){\n        Scanner cin = new Scanner(System.in);\n        int size = cin.nextInt();\n        double[][] data = new double[size][size];\n\n        //读取数据\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                data[i][j] = cin.nextDouble();\n            }\n        }\n\n        //标记是否可以提前确定行列式为0\n        boolean zero = false;\n        //记录交换行后的正负号\n        double sign = 1;\n\n        //主体\n        for (int row = 0; row < size-1; row++){\n\n            //如果第i行第i个元素已经是0的话，就去找一行非零的行交换\n            if (data[row][row] == 0) {\n                boolean flag = false;\n                for (int trow = row + 1; trow < size; trow++){\n                    if (data[trow][row] != 0){\n                        flag = true;\n                        swap_row(row, trow, size, data);\n                        sign *= -1;\n                        break;\n                    }\n                }\n                //如果一列全为0，那么行列式为0\n                if (!flag)\n                {\n                    zero = true;\n                    break;\n                }\n            }\n\n            for (int trow = row + 1; trow < size; trow++){\n                double k;\n                //如果当前行已经为0，那么直接跳过，否则用row行乘-k加到trow行\n                if (data[trow][row] == 0)\n                    continue;\n                k = data[trow][row] / data[row][row];\n                for (int col = row; col < size; col++){\n                    data[trow][col] += -k * data[row][col];\n                }\n            }\n        }\n\n        double ans;\n\n\n        //整理答案并输出\n        if (zero)\n            ans = 0;\n        else{\n            ans = sign;\n            for (int row = 0; row < size; row++){\n                ans *= data[row][row];\n            }\n        }\n\n        System.out.print(ans);\n    }\n\n    static void swap_row(int a, int b, int size, double data[][]){\n        for (int i = a; i < size; i++){\n            double temp = data[a][i];\n            data[a][i] = data[b][i];\n            data[b][i] = temp;\n        }\n    }\n}\n\n\n```","slug":"计算行列式（高斯消元？-Java-工具）","published":1,"updated":"2017-07-23T02:53:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfi006sy9id56qb06sh","content":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><hr>\n<h4 id=\"计算行列式并输出\"><a href=\"#计算行列式并输出\" class=\"headerlink\" title=\"计算行列式并输出\"></a>计算行列式并输出</h4><h1 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h1><hr>\n<p>首先输入行列式的阶数，然后以输入行列式内容。</p>\n<p>例如：</p>\n<p>输入：<br>4<br>1 2 -1 3<br>2 3 -1 2<br>-1 1 1 0<br>0 1 -2 1</p>\n<p>输入：<br>18.0</p>\n<h1 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h1><hr>\n<p>好像是高斯消元，就是每一行乘一个系数减下去，化三角。<br>时间复杂度 O(n^3) .</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.*;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Determinant</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] Args)</span></span>&#123;</div><div class=\"line\">        Scanner <span class=\"built_in\">cin</span> = <span class=\"keyword\">new</span> Scanner(System.in);</div><div class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"built_in\">cin</span>.nextInt();</div><div class=\"line\">        <span class=\"keyword\">double</span>[][] data = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[size][size];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//读取数据</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; j++) &#123;</div><div class=\"line\">                data[i][j] = <span class=\"built_in\">cin</span>.nextDouble();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//标记是否可以提前确定行列式为0</span></div><div class=\"line\">        boolean zero = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"comment\">//记录交换行后的正负号</span></div><div class=\"line\">        <span class=\"keyword\">double</span> sign = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//主体</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; size<span class=\"number\">-1</span>; row++)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果第i行第i个元素已经是0的话，就去找一行非零的行交换</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (data[row][row] == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                boolean flag = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> trow = row + <span class=\"number\">1</span>; trow &lt; size; trow++)&#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (data[trow][row] != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                        swap_row(row, trow, size, data);</div><div class=\"line\">                        sign *= <span class=\"number\">-1</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//如果一列全为0，那么行列式为0</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!flag)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    zero = <span class=\"literal\">true</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> trow = row + <span class=\"number\">1</span>; trow &lt; size; trow++)&#123;</div><div class=\"line\">                <span class=\"keyword\">double</span> k;</div><div class=\"line\">                <span class=\"comment\">//如果当前行已经为0，那么直接跳过，否则用row行乘-k加到trow行</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (data[trow][row] == <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                k = data[trow][row] / data[row][row];</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> col = row; col &lt; size; col++)&#123;</div><div class=\"line\">                    data[trow][col] += -k * data[row][col];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">double</span> ans;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//整理答案并输出</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (zero)</div><div class=\"line\">            ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            ans = sign;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; size; row++)&#123;</div><div class=\"line\">                ans *= data[row][row];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        System.out.print(ans);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap_row</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> size, <span class=\"keyword\">double</span> data[][])</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = a; i &lt; size; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">double</span> temp = data[a][i];</div><div class=\"line\">            data[a][i] = data[b][i];</div><div class=\"line\">            data[b][i] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><hr>\n<h4 id=\"计算行列式并输出\"><a href=\"#计算行列式并输出\" class=\"headerlink\" title=\"计算行列式并输出\"></a>计算行列式并输出</h4><h1 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h1><hr>\n<p>首先输入行列式的阶数，然后以输入行列式内容。</p>\n<p>例如：</p>\n<p>输入：<br>4<br>1 2 -1 3<br>2 3 -1 2<br>-1 1 1 0<br>0 1 -2 1</p>\n<p>输入：<br>18.0</p>\n<h1 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h1><hr>\n<p>好像是高斯消元，就是每一行乘一个系数减下去，化三角。<br>时间复杂度 O(n^3) .</p>\n<h1 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.*;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Determinant</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] Args)</span></span>&#123;</div><div class=\"line\">        Scanner <span class=\"built_in\">cin</span> = <span class=\"keyword\">new</span> Scanner(System.in);</div><div class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"built_in\">cin</span>.nextInt();</div><div class=\"line\">        <span class=\"keyword\">double</span>[][] data = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[size][size];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//读取数据</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; j++) &#123;</div><div class=\"line\">                data[i][j] = <span class=\"built_in\">cin</span>.nextDouble();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//标记是否可以提前确定行列式为0</span></div><div class=\"line\">        boolean zero = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"comment\">//记录交换行后的正负号</span></div><div class=\"line\">        <span class=\"keyword\">double</span> sign = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//主体</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; size<span class=\"number\">-1</span>; row++)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//如果第i行第i个元素已经是0的话，就去找一行非零的行交换</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (data[row][row] == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                boolean flag = <span class=\"literal\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> trow = row + <span class=\"number\">1</span>; trow &lt; size; trow++)&#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (data[trow][row] != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                        flag = <span class=\"literal\">true</span>;</div><div class=\"line\">                        swap_row(row, trow, size, data);</div><div class=\"line\">                        sign *= <span class=\"number\">-1</span>;</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//如果一列全为0，那么行列式为0</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!flag)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    zero = <span class=\"literal\">true</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> trow = row + <span class=\"number\">1</span>; trow &lt; size; trow++)&#123;</div><div class=\"line\">                <span class=\"keyword\">double</span> k;</div><div class=\"line\">                <span class=\"comment\">//如果当前行已经为0，那么直接跳过，否则用row行乘-k加到trow行</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (data[trow][row] == <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                k = data[trow][row] / data[row][row];</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> col = row; col &lt; size; col++)&#123;</div><div class=\"line\">                    data[trow][col] += -k * data[row][col];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">double</span> ans;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//整理答案并输出</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (zero)</div><div class=\"line\">            ans = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            ans = sign;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; size; row++)&#123;</div><div class=\"line\">                ans *= data[row][row];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        System.out.print(ans);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap_row</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> size, <span class=\"keyword\">double</span> data[][])</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = a; i &lt; size; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">double</span> temp = data[a][i];</div><div class=\"line\">            data[a][i] = data[b][i];</div><div class=\"line\">            data[b][i] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"自动走迷宫（DFS）","date":"2016-12-05T15:12:23.000Z","_content":"# 功能：\n - 输入一张地图，找出一条可到达终点的路径，1代表不可走，0代表可走，2代表终点。\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205230912530)![这里写图片描述](http://img.blog.csdn.net/20161205230940046)\n\n\n----------\n# 实现原理：\n\n - DFS遍历。\n - 二维数组储存地图。\n - \n\n\n----------\n# 源代码：\n因为输入数据太麻烦，附了组数据。\n```\n#include<stdio.h>\ntypedef struct\n{\n    int x;\n    int y;\n    int s;\n    int f;\n}note;\n\nint map[999][999], book[999][999];\nnote queue[999];\n\nint main()\n{\n    int n, i, j, head, tail, x, y, tx, ty, flag;\n    int drct[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    scanf(\"%d\", &n);\n\n    head = 1;\n    tail = 1;\n\n    x = 1;\n    y = 1;\n    //scanf(\"%d %d\", &x, &y);\n\n    queue[tail].x = x;\n    queue[tail].y = y;\n    queue[tail].s = 0;\n    tail++;\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            scanf(\"%d\", &map[i][j]);\n        }\n    }\n\n\n\n\n    while (head < tail)\n    {\n        for (i = 0; i < 4; i++)\n        {\n            tx = queue[head].x + drct[i][0];\n            ty = queue[head].y + drct[i][1];\n\n            if (tx < 1 || tx > n || ty < 1 || ty > n)\n            {\n                continue;\n            }\n\n            if (map[tx][ty] == 0 && book[tx][ty] == 0)\n            {\n                book[tx][ty] = 1;\n\n                queue[tail].x = tx;\n                queue[tail].y = ty;\n                queue[tail].f = head;\n                queue[tail].s = queue[head].s + 1;\n                //printf(\"###%d %d\\n\", tail, queue[tail].f);\n                tail++;\n            }\n\n            //printf(\"###%d %d %d %d %d %d\\n\", tail, queue[tail-1].f, queue[tail - 1].x, queue[tail - 1].y, tx, ty);\n\n            if (map[tx][ty] == 2)\n            {\n                flag = 1;\n                break;\n            }\n        }\n\n        if (flag == 1)\n        {\n            break;\n        }\n        head++;\n    }\n\n    if (flag == 1)\n    {\n\n    map[tx][ty] = 3;\n    for (;;)\n    {\n        map[queue[head].x][queue[head].y] = 3;\n        //printf(\"%d %d  %d\\n\", queue[head].x, queue[head].y, i);//\n        if(head == 1)\n            break;\n        head = queue[head].f;\n        //getchar();\n\n    }\n\n    putchar('\\n');\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            if (map[i][j] == 3)\n                printf(\"! \");\n            else if (map[i][j] == 1)\n                printf(\"# \");\n            else\n                printf(\"* \");\n        }\n        putchar('\\n');\n    }\n\n    }\n\n    else\n        printf(\"NO\\n\");\n\n\n\n\n}\n\n/*\n20\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0\n0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\n1 0 1 1 1 1 0 1 1 0 1 0 1 1 1 1 0 1 1 2\n*/\n\n```\n\n\n----------\n# PS:\n当时刚从啊哈算法上看到DFS，还没实现过，第一次实现写的这东西，也是感兴趣，成就感满满！","source":"_posts/自动走迷宫（DFS）.md","raw":"---\ntitle: 自动走迷宫（DFS）\ndate: 2016-12-05 23:12:23\ncategories: [ACM, 搜索]\ntags:\n---\n# 功能：\n - 输入一张地图，找出一条可到达终点的路径，1代表不可走，0代表可走，2代表终点。\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205230912530)![这里写图片描述](http://img.blog.csdn.net/20161205230940046)\n\n\n----------\n# 实现原理：\n\n - DFS遍历。\n - 二维数组储存地图。\n - \n\n\n----------\n# 源代码：\n因为输入数据太麻烦，附了组数据。\n```\n#include<stdio.h>\ntypedef struct\n{\n    int x;\n    int y;\n    int s;\n    int f;\n}note;\n\nint map[999][999], book[999][999];\nnote queue[999];\n\nint main()\n{\n    int n, i, j, head, tail, x, y, tx, ty, flag;\n    int drct[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    scanf(\"%d\", &n);\n\n    head = 1;\n    tail = 1;\n\n    x = 1;\n    y = 1;\n    //scanf(\"%d %d\", &x, &y);\n\n    queue[tail].x = x;\n    queue[tail].y = y;\n    queue[tail].s = 0;\n    tail++;\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            scanf(\"%d\", &map[i][j]);\n        }\n    }\n\n\n\n\n    while (head < tail)\n    {\n        for (i = 0; i < 4; i++)\n        {\n            tx = queue[head].x + drct[i][0];\n            ty = queue[head].y + drct[i][1];\n\n            if (tx < 1 || tx > n || ty < 1 || ty > n)\n            {\n                continue;\n            }\n\n            if (map[tx][ty] == 0 && book[tx][ty] == 0)\n            {\n                book[tx][ty] = 1;\n\n                queue[tail].x = tx;\n                queue[tail].y = ty;\n                queue[tail].f = head;\n                queue[tail].s = queue[head].s + 1;\n                //printf(\"###%d %d\\n\", tail, queue[tail].f);\n                tail++;\n            }\n\n            //printf(\"###%d %d %d %d %d %d\\n\", tail, queue[tail-1].f, queue[tail - 1].x, queue[tail - 1].y, tx, ty);\n\n            if (map[tx][ty] == 2)\n            {\n                flag = 1;\n                break;\n            }\n        }\n\n        if (flag == 1)\n        {\n            break;\n        }\n        head++;\n    }\n\n    if (flag == 1)\n    {\n\n    map[tx][ty] = 3;\n    for (;;)\n    {\n        map[queue[head].x][queue[head].y] = 3;\n        //printf(\"%d %d  %d\\n\", queue[head].x, queue[head].y, i);//\n        if(head == 1)\n            break;\n        head = queue[head].f;\n        //getchar();\n\n    }\n\n    putchar('\\n');\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            if (map[i][j] == 3)\n                printf(\"! \");\n            else if (map[i][j] == 1)\n                printf(\"# \");\n            else\n                printf(\"* \");\n        }\n        putchar('\\n');\n    }\n\n    }\n\n    else\n        printf(\"NO\\n\");\n\n\n\n\n}\n\n/*\n20\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0\n0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\n0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0\n0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\n1 0 1 1 1 1 0 1 1 0 1 0 1 1 1 1 0 1 1 2\n*/\n\n```\n\n\n----------\n# PS:\n当时刚从啊哈算法上看到DFS，还没实现过，第一次实现写的这东西，也是感兴趣，成就感满满！","slug":"自动走迷宫（DFS）","published":1,"updated":"2017-07-23T04:09:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfk006uy9id1j8kenr4","content":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><ul>\n<li>输入一张地图，找出一条可到达终点的路径，1代表不可走，0代表可走，2代表终点。</li>\n</ul>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205230912530\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161205230940046\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>DFS遍历。</li>\n<li>二维数组储存地图。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><p>因为输入数据太麻烦，附了组数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;stdio.h&gt;</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">    int x;</div><div class=\"line\">    int y;</div><div class=\"line\">    int s;</div><div class=\"line\">    int f;</div><div class=\"line\">&#125;note;</div><div class=\"line\"></div><div class=\"line\">int map[999][999], book[999][999];</div><div class=\"line\">note queue[999];</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n, i, j, head, tail, x, y, tx, ty, flag;</div><div class=\"line\">    int drct[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;</div><div class=\"line\"></div><div class=\"line\">    scanf(&quot;%d&quot;, &amp;n);</div><div class=\"line\"></div><div class=\"line\">    head = 1;</div><div class=\"line\">    tail = 1;</div><div class=\"line\"></div><div class=\"line\">    x = 1;</div><div class=\"line\">    y = 1;</div><div class=\"line\">    //scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</div><div class=\"line\"></div><div class=\"line\">    queue[tail].x = x;</div><div class=\"line\">    queue[tail].y = y;</div><div class=\"line\">    queue[tail].s = 0;</div><div class=\"line\">    tail++;</div><div class=\"line\"></div><div class=\"line\">    for (i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (j = 1; j &lt;= n; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            scanf(&quot;%d&quot;, &amp;map[i][j]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    while (head &lt; tail)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (i = 0; i &lt; 4; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            tx = queue[head].x + drct[i][0];</div><div class=\"line\">            ty = queue[head].y + drct[i][1];</div><div class=\"line\"></div><div class=\"line\">            if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; n)</div><div class=\"line\">            &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (map[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                book[tx][ty] = 1;</div><div class=\"line\"></div><div class=\"line\">                queue[tail].x = tx;</div><div class=\"line\">                queue[tail].y = ty;</div><div class=\"line\">                queue[tail].f = head;</div><div class=\"line\">                queue[tail].s = queue[head].s + 1;</div><div class=\"line\">                //printf(&quot;###%d %d\\n&quot;, tail, queue[tail].f);</div><div class=\"line\">                tail++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            //printf(&quot;###%d %d %d %d %d %d\\n&quot;, tail, queue[tail-1].f, queue[tail - 1].x, queue[tail - 1].y, tx, ty);</div><div class=\"line\"></div><div class=\"line\">            if (map[tx][ty] == 2)</div><div class=\"line\">            &#123;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (flag == 1)</div><div class=\"line\">        &#123;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        head++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (flag == 1)</div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">    map[tx][ty] = 3;</div><div class=\"line\">    for (;;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        map[queue[head].x][queue[head].y] = 3;</div><div class=\"line\">        //printf(&quot;%d %d  %d\\n&quot;, queue[head].x, queue[head].y, i);//</div><div class=\"line\">        if(head == 1)</div><div class=\"line\">            break;</div><div class=\"line\">        head = queue[head].f;</div><div class=\"line\">        //getchar();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    putchar(&apos;\\n&apos;);</div><div class=\"line\"></div><div class=\"line\">    for (i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (j = 1; j &lt;= n; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (map[i][j] == 3)</div><div class=\"line\">                printf(&quot;! &quot;);</div><div class=\"line\">            else if (map[i][j] == 1)</div><div class=\"line\">                printf(&quot;# &quot;);</div><div class=\"line\">            else</div><div class=\"line\">                printf(&quot;* &quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        putchar(&apos;\\n&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    else</div><div class=\"line\">        printf(&quot;NO\\n&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">20</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</div><div class=\"line\">1 0 1 1 1 1 0 1 1 0 1 0 1 1 1 1 0 1 1 2</div><div class=\"line\">*/</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS:\"></a>PS:</h1><p>当时刚从啊哈算法上看到DFS，还没实现过，第一次实现写的这东西，也是感兴趣，成就感满满！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><ul>\n<li>输入一张地图，找出一条可到达终点的路径，1代表不可走，0代表可走，2代表终点。</li>\n</ul>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205230912530\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161205230940046\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>DFS遍历。</li>\n<li>二维数组储存地图。</li>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><p>因为输入数据太麻烦，附了组数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;stdio.h&gt;</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">    int x;</div><div class=\"line\">    int y;</div><div class=\"line\">    int s;</div><div class=\"line\">    int f;</div><div class=\"line\">&#125;note;</div><div class=\"line\"></div><div class=\"line\">int map[999][999], book[999][999];</div><div class=\"line\">note queue[999];</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n, i, j, head, tail, x, y, tx, ty, flag;</div><div class=\"line\">    int drct[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;</div><div class=\"line\"></div><div class=\"line\">    scanf(&quot;%d&quot;, &amp;n);</div><div class=\"line\"></div><div class=\"line\">    head = 1;</div><div class=\"line\">    tail = 1;</div><div class=\"line\"></div><div class=\"line\">    x = 1;</div><div class=\"line\">    y = 1;</div><div class=\"line\">    //scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</div><div class=\"line\"></div><div class=\"line\">    queue[tail].x = x;</div><div class=\"line\">    queue[tail].y = y;</div><div class=\"line\">    queue[tail].s = 0;</div><div class=\"line\">    tail++;</div><div class=\"line\"></div><div class=\"line\">    for (i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (j = 1; j &lt;= n; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            scanf(&quot;%d&quot;, &amp;map[i][j]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    while (head &lt; tail)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (i = 0; i &lt; 4; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            tx = queue[head].x + drct[i][0];</div><div class=\"line\">            ty = queue[head].y + drct[i][1];</div><div class=\"line\"></div><div class=\"line\">            if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; n)</div><div class=\"line\">            &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (map[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                book[tx][ty] = 1;</div><div class=\"line\"></div><div class=\"line\">                queue[tail].x = tx;</div><div class=\"line\">                queue[tail].y = ty;</div><div class=\"line\">                queue[tail].f = head;</div><div class=\"line\">                queue[tail].s = queue[head].s + 1;</div><div class=\"line\">                //printf(&quot;###%d %d\\n&quot;, tail, queue[tail].f);</div><div class=\"line\">                tail++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            //printf(&quot;###%d %d %d %d %d %d\\n&quot;, tail, queue[tail-1].f, queue[tail - 1].x, queue[tail - 1].y, tx, ty);</div><div class=\"line\"></div><div class=\"line\">            if (map[tx][ty] == 2)</div><div class=\"line\">            &#123;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (flag == 1)</div><div class=\"line\">        &#123;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        head++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (flag == 1)</div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">    map[tx][ty] = 3;</div><div class=\"line\">    for (;;)</div><div class=\"line\">    &#123;</div><div class=\"line\">        map[queue[head].x][queue[head].y] = 3;</div><div class=\"line\">        //printf(&quot;%d %d  %d\\n&quot;, queue[head].x, queue[head].y, i);//</div><div class=\"line\">        if(head == 1)</div><div class=\"line\">            break;</div><div class=\"line\">        head = queue[head].f;</div><div class=\"line\">        //getchar();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    putchar(&apos;\\n&apos;);</div><div class=\"line\"></div><div class=\"line\">    for (i = 1; i &lt;= n; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (j = 1; j &lt;= n; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (map[i][j] == 3)</div><div class=\"line\">                printf(&quot;! &quot;);</div><div class=\"line\">            else if (map[i][j] == 1)</div><div class=\"line\">                printf(&quot;# &quot;);</div><div class=\"line\">            else</div><div class=\"line\">                printf(&quot;* &quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        putchar(&apos;\\n&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    else</div><div class=\"line\">        printf(&quot;NO\\n&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">20</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 0 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div><div class=\"line\">1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0</div><div class=\"line\">0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0</div><div class=\"line\">0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0</div><div class=\"line\">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</div><div class=\"line\">1 0 1 1 1 1 0 1 1 0 1 0 1 1 1 1 0 1 1 2</div><div class=\"line\">*/</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS:\"></a>PS:</h1><p>当时刚从啊哈算法上看到DFS，还没实现过，第一次实现写的这东西，也是感兴趣，成就感满满！</p>\n"},{"title":"数独问题（工具）","date":"2016-12-05T14:58:34.000Z","_content":"# 功能：\n\n - 输入一个数独（用二维数组表示），求出数独的解。\n \n\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205225435004)![这里写图片描述](http://img.blog.csdn.net/20161205225446699)\n\n\n----------\n# 实现原理：\n\n - DFS搜索遍历。\n - 二维数组储存数据。\n\n----------\n# 源代码：\n\n```\n#include<iostream>\n#include<cstring>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint data[112][112];\n\nvoid put()\n{\n    cout << \"----------------------\" << endl;\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            cout << data[i][j] << \" \";\n            if ((j+1)%3 == 0)\n                cout << \" \";\n        }\n        cout << endl;\n        if ((i+1)%3 == 0)\n            cout << endl;\n    }\n    cout << \"----------------------\" << endl;\n}\n\n\nbool check(int x, int y)\n{\n    for (int i = 0; i <= 9; i++)\n    {\n        if (data[i][y] == data[x][y] && i != x)\n            return false;\n        if (data[x][i] == data[x][y] && i != y)\n            return false;\n    }\n\n    int x0 = x/3*3;\n    int y0 = y/3*3;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (i+x0 == x && j+y0 == y)\n                continue;\n            if (data[i+x0][j+y0] == data[x][y])\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint fun(int cnt)\n{\n    int x, y;\n    if (cnt == 81)\n        return 1;\n\n    x = cnt/9;\n    y = cnt%9;\n\n\n    if (data[x][y] != 0)\n    {\n        fun(cnt+1);\n    }\n    else\n    {\n        for (int i = 1; i <= 9; i++)\n        {\n            data[x][y] = i;\n            if (check(x, y))\n            {\n                if(fun(cnt+1))\n                    return 1;\n            }\n        }\n        data[x][y] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    int n, x, y, t;\n    while (cin >> n)\n    {\n        memset(data, 0, sizeof(data));\n        for (int i = 0; i < n; i++)\n        {\n            cin >> x >> y >> t;\n            data[x-1][y-1] = t;\n        }\n        fun(0);\n        cout << \"end\" << endl;\n        put();\n    }\n}\n\n```\n# PS：\n当初群里有人问一个数独怎么解时，然后自己DFS也不太熟练，花了半个小时写了这个，满满的成就感！","source":"_posts/数独问题（工具）.md","raw":"---\ntitle: 数独问题（工具）\ndate: 2016-12-05 22:58:34\ncategories: [ACM, 搜索]\ntags:\n---\n# 功能：\n\n - 输入一个数独（用二维数组表示），求出数独的解。\n \n\n\n----------\n# 效果图：\n![这里写图片描述](http://img.blog.csdn.net/20161205225435004)![这里写图片描述](http://img.blog.csdn.net/20161205225446699)\n\n\n----------\n# 实现原理：\n\n - DFS搜索遍历。\n - 二维数组储存数据。\n\n----------\n# 源代码：\n\n```\n#include<iostream>\n#include<cstring>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint data[112][112];\n\nvoid put()\n{\n    cout << \"----------------------\" << endl;\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            cout << data[i][j] << \" \";\n            if ((j+1)%3 == 0)\n                cout << \" \";\n        }\n        cout << endl;\n        if ((i+1)%3 == 0)\n            cout << endl;\n    }\n    cout << \"----------------------\" << endl;\n}\n\n\nbool check(int x, int y)\n{\n    for (int i = 0; i <= 9; i++)\n    {\n        if (data[i][y] == data[x][y] && i != x)\n            return false;\n        if (data[x][i] == data[x][y] && i != y)\n            return false;\n    }\n\n    int x0 = x/3*3;\n    int y0 = y/3*3;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (i+x0 == x && j+y0 == y)\n                continue;\n            if (data[i+x0][j+y0] == data[x][y])\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint fun(int cnt)\n{\n    int x, y;\n    if (cnt == 81)\n        return 1;\n\n    x = cnt/9;\n    y = cnt%9;\n\n\n    if (data[x][y] != 0)\n    {\n        fun(cnt+1);\n    }\n    else\n    {\n        for (int i = 1; i <= 9; i++)\n        {\n            data[x][y] = i;\n            if (check(x, y))\n            {\n                if(fun(cnt+1))\n                    return 1;\n            }\n        }\n        data[x][y] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    int n, x, y, t;\n    while (cin >> n)\n    {\n        memset(data, 0, sizeof(data));\n        for (int i = 0; i < n; i++)\n        {\n            cin >> x >> y >> t;\n            data[x-1][y-1] = t;\n        }\n        fun(0);\n        cout << \"end\" << endl;\n        put();\n    }\n}\n\n```\n# PS：\n当初群里有人问一个数独怎么解时，然后自己DFS也不太熟练，花了半个小时写了这个，满满的成就感！","slug":"数独问题（工具）","published":1,"updated":"2017-07-23T04:11:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj99r6nfm006xy9idwwogiwpb","content":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><ul>\n<li>输入一个数独（用二维数组表示），求出数独的解。</li>\n</ul>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205225435004\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161205225446699\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>DFS搜索遍历。</li>\n<li>二维数组储存数据。</li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;iostream&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstdio&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int data[112][112];</div><div class=\"line\"></div><div class=\"line\">void put()</div><div class=\"line\">&#123;</div><div class=\"line\">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</div><div class=\"line\">    for (int i = 0; i &lt; 9; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = 0; j &lt; 9; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;;</div><div class=\"line\">            if ((j+1)%3 == 0)</div><div class=\"line\">                cout &lt;&lt; &quot; &quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cout &lt;&lt; endl;</div><div class=\"line\">        if ((i+1)%3 == 0)</div><div class=\"line\">            cout &lt;&lt; endl;</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">bool check(int x, int y)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int i = 0; i &lt;= 9; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (data[i][y] == data[x][y] &amp;&amp; i != x)</div><div class=\"line\">            return false;</div><div class=\"line\">        if (data[x][i] == data[x][y] &amp;&amp; i != y)</div><div class=\"line\">            return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int x0 = x/3*3;</div><div class=\"line\">    int y0 = y/3*3;</div><div class=\"line\"></div><div class=\"line\">    for (int i = 0; i &lt; 3; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = 0; j &lt; 3; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (i+x0 == x &amp;&amp; j+y0 == y)</div><div class=\"line\">                continue;</div><div class=\"line\">            if (data[i+x0][j+y0] == data[x][y])</div><div class=\"line\">                return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int fun(int cnt)</div><div class=\"line\">&#123;</div><div class=\"line\">    int x, y;</div><div class=\"line\">    if (cnt == 81)</div><div class=\"line\">        return 1;</div><div class=\"line\"></div><div class=\"line\">    x = cnt/9;</div><div class=\"line\">    y = cnt%9;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    if (data[x][y] != 0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        fun(cnt+1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int i = 1; i &lt;= 9; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[x][y] = i;</div><div class=\"line\">            if (check(x, y))</div><div class=\"line\">            &#123;</div><div class=\"line\">                if(fun(cnt+1))</div><div class=\"line\">                    return 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[x][y] = 0;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n, x, y, t;</div><div class=\"line\">    while (cin &gt;&gt; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        for (int i = 0; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</div><div class=\"line\">            data[x-1][y-1] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\">        fun(0);</div><div class=\"line\">        cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a>PS：</h1><p>当初群里有人问一个数独怎么解时，然后自己DFS也不太熟练，花了半个小时写了这个，满满的成就感！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"功能：\"><a href=\"#功能：\" class=\"headerlink\" title=\"功能：\"></a>功能：</h1><ul>\n<li>输入一个数独（用二维数组表示），求出数独的解。</li>\n</ul>\n<hr>\n<h1 id=\"效果图：\"><a href=\"#效果图：\" class=\"headerlink\" title=\"效果图：\"></a>效果图：</h1><p><img src=\"http://img.blog.csdn.net/20161205225435004\" alt=\"这里写图片描述\"><img src=\"http://img.blog.csdn.net/20161205225446699\" alt=\"这里写图片描述\"></p>\n<hr>\n<h1 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h1><ul>\n<li>DFS搜索遍历。</li>\n<li>二维数组储存数据。</li>\n</ul>\n<hr>\n<h1 id=\"源代码：\"><a href=\"#源代码：\" class=\"headerlink\" title=\"源代码：\"></a>源代码：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;iostream&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;cstdio&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int data[112][112];</div><div class=\"line\"></div><div class=\"line\">void put()</div><div class=\"line\">&#123;</div><div class=\"line\">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</div><div class=\"line\">    for (int i = 0; i &lt; 9; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = 0; j &lt; 9; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;;</div><div class=\"line\">            if ((j+1)%3 == 0)</div><div class=\"line\">                cout &lt;&lt; &quot; &quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cout &lt;&lt; endl;</div><div class=\"line\">        if ((i+1)%3 == 0)</div><div class=\"line\">            cout &lt;&lt; endl;</div><div class=\"line\">    &#125;</div><div class=\"line\">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">bool check(int x, int y)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int i = 0; i &lt;= 9; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (data[i][y] == data[x][y] &amp;&amp; i != x)</div><div class=\"line\">            return false;</div><div class=\"line\">        if (data[x][i] == data[x][y] &amp;&amp; i != y)</div><div class=\"line\">            return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int x0 = x/3*3;</div><div class=\"line\">    int y0 = y/3*3;</div><div class=\"line\"></div><div class=\"line\">    for (int i = 0; i &lt; 3; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int j = 0; j &lt; 3; j++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (i+x0 == x &amp;&amp; j+y0 == y)</div><div class=\"line\">                continue;</div><div class=\"line\">            if (data[i+x0][j+y0] == data[x][y])</div><div class=\"line\">                return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int fun(int cnt)</div><div class=\"line\">&#123;</div><div class=\"line\">    int x, y;</div><div class=\"line\">    if (cnt == 81)</div><div class=\"line\">        return 1;</div><div class=\"line\"></div><div class=\"line\">    x = cnt/9;</div><div class=\"line\">    y = cnt%9;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    if (data[x][y] != 0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        fun(cnt+1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        for (int i = 1; i &lt;= 9; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            data[x][y] = i;</div><div class=\"line\">            if (check(x, y))</div><div class=\"line\">            &#123;</div><div class=\"line\">                if(fun(cnt+1))</div><div class=\"line\">                    return 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        data[x][y] = 0;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int n, x, y, t;</div><div class=\"line\">    while (cin &gt;&gt; n)</div><div class=\"line\">    &#123;</div><div class=\"line\">        memset(data, 0, sizeof(data));</div><div class=\"line\">        for (int i = 0; i &lt; n; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</div><div class=\"line\">            data[x-1][y-1] = t;</div><div class=\"line\">        &#125;</div><div class=\"line\">        fun(0);</div><div class=\"line\">        cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;</div><div class=\"line\">        put();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a>PS：</h1><p>当初群里有人问一个数独怎么解时，然后自己DFS也不太熟练，花了半个小时写了这个，满满的成就感！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj99r6n8m0004y9idfef4afut","category_id":"cj99r6n93000ay9idwfeyqy1t","_id":"cj99r6n9c000gy9id4fj0q41c"},{"post_id":"cj99r6n8q0005y9ids4efdlkv","category_id":"cj99r6n96000dy9idj5gehqu3","_id":"cj99r6n9i000ky9idw5rpqv2f"},{"post_id":"cj99r6n810001y9idx8oqqzfl","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6n9o000oy9idk43zgiyu"},{"post_id":"cj99r6n810001y9idx8oqqzfl","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6n9q000ry9idi68kpllx"},{"post_id":"cj99r6n8t0006y9idb9ri866t","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6n9s000ty9idjo9qq8g6"},{"post_id":"cj99r6n8t0006y9idb9ri866t","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6n9u000wy9id1xd98h4e"},{"post_id":"cj99r6n8x0008y9id1wt65bzk","category_id":"cj99r6n93000ay9idwfeyqy1t","_id":"cj99r6n9w000yy9id9kflhyz5"},{"post_id":"cj99r6n920009y9id9qkbp4yk","category_id":"cj99r6n93000ay9idwfeyqy1t","_id":"cj99r6na70015y9idlx1w79i9"},{"post_id":"cj99r6na20012y9id05bfkjgq","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nac0019y9idm22vop1b"},{"post_id":"cj99r6na20012y9id05bfkjgq","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nad001by9id5d6ji0ct"},{"post_id":"cj99r6n93000by9id3al0un2y","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nah001ey9idn09rc0ix"},{"post_id":"cj99r6n93000by9id3al0un2y","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6naj001gy9iddr6bprlg"},{"post_id":"cj99r6n9a000fy9idnvp04dus","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nat001ny9id32vyfsgh"},{"post_id":"cj99r6n9a000fy9idnvp04dus","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nav001qy9idgp07vd4z"},{"post_id":"cj99r6n9e000iy9id6iu10wpm","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nax001sy9idmmwln9o4"},{"post_id":"cj99r6n9e000iy9id6iu10wpm","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nb0001vy9idl36u7vuq"},{"post_id":"cj99r6n9g000jy9idetwzd4y2","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nb2001xy9idae0v9efu"},{"post_id":"cj99r6n9g000jy9idetwzd4y2","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nb40020y9id7gi8uouf"},{"post_id":"cj99r6n9i000my9id8s2mv5o7","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nb60022y9idx58jl78i"},{"post_id":"cj99r6n9i000my9id8s2mv5o7","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nb90025y9idvfw2rqwr"},{"post_id":"cj99r6n9i000my9id8s2mv5o7","category_id":"cj99r6nax001ty9idt5fpw4no","_id":"cj99r6nbc0027y9id5124zutf"},{"post_id":"cj99r6n9p000qy9idqhjdciea","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nbl002cy9id6n7ekxo4"},{"post_id":"cj99r6n9p000qy9idqhjdciea","category_id":"cj99r6nb70024y9idut313vzl","_id":"cj99r6nbo002fy9idbogjbccd"},{"post_id":"cj99r6nbo002gy9idpad0idsj","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nbx002my9id6yntj37s"},{"post_id":"cj99r6nbo002gy9idpad0idsj","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nc0002oy9idvuwaugg4"},{"post_id":"cj99r6nbr002iy9idqaelq2z0","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nc2002ry9id5oejfkir"},{"post_id":"cj99r6nbr002iy9idqaelq2z0","category_id":"cj99r6nb70024y9idut313vzl","_id":"cj99r6nc5002ty9idfxeqyeu5"},{"post_id":"cj99r6n9v000xy9idr6sicyhp","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nc7002wy9idlyz6l4ap"},{"post_id":"cj99r6n9v000xy9idr6sicyhp","category_id":"cj99r6nbq002hy9idqaqsepd2","_id":"cj99r6nca002yy9idg7v1a83q"},{"post_id":"cj99r6n890002y9idtsby9075","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ncb0031y9idc1oon110"},{"post_id":"cj99r6n890002y9idtsby9075","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ncd0033y9idvjf6cvvg"},{"post_id":"cj99r6n890002y9idtsby9075","category_id":"cj99r6nbv002ky9ido3d0yqwk","_id":"cj99r6ncf0036y9idht0y572a"},{"post_id":"cj99r6n9w000zy9id05qqycee","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ncg0038y9id0x6kmjxw"},{"post_id":"cj99r6n9w000zy9id05qqycee","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nck003by9idxyhr5st6"},{"post_id":"cj99r6na40014y9id830a0opm","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ncm003dy9iddlahwnm1"},{"post_id":"cj99r6na40014y9id830a0opm","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ncn003fy9id9bfdukof"},{"post_id":"cj99r6na70016y9id1lu8mmij","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ncp003iy9idsywqcxic"},{"post_id":"cj99r6na70016y9id1lu8mmij","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ncr003ky9id6xkjsgms"},{"post_id":"cj99r6nab0018y9ido4d4byme","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ncu003ny9idhntc4088"},{"post_id":"cj99r6nab0018y9ido4d4byme","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ncy003py9idqsjax3hm"},{"post_id":"cj99r6ncg0037y9idigwi6o3p","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nd1003sy9idi1x5l5sc"},{"post_id":"cj99r6ncg0037y9idigwi6o3p","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nd3003uy9idubb7rnop"},{"post_id":"cj99r6n95000cy9id2tyd3mpp","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nd6003xy9idtz9a3egu"},{"post_id":"cj99r6n95000cy9id2tyd3mpp","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nd9003zy9idwpsq5kp0"},{"post_id":"cj99r6n95000cy9id2tyd3mpp","category_id":"cj99r6nch0039y9idqmygw8tq","_id":"cj99r6ndb0042y9id26uoypco"},{"post_id":"cj99r6nad001ay9idocxlaw8b","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ndd0044y9id4wvhoigw"},{"post_id":"cj99r6nad001ay9idocxlaw8b","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ndf0047y9ida8gu66si"},{"post_id":"cj99r6naf001dy9idip8bkitv","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ndg0049y9idyo1xt6fs"},{"post_id":"cj99r6naf001dy9idip8bkitv","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ndi004by9ida9w2xdhb"},{"post_id":"cj99r6naf001dy9idip8bkitv","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6ndk004ey9idjodj6oe5"},{"post_id":"cj99r6n98000ey9id64ansv0r","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ndr004gy9ida05b5iw7"},{"post_id":"cj99r6n98000ey9id64ansv0r","category_id":"cj99r6nae001cy9idboobswv2","_id":"cj99r6ndt004jy9idyotqte7q"},{"post_id":"cj99r6n98000ey9id64ansv0r","category_id":"cj99r6ncy003qy9idrbrrrrp6","_id":"cj99r6ndu004ly9id5n47me1o"},{"post_id":"cj99r6nai001fy9id5scpumnq","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ndw004oy9idylajn0dd"},{"post_id":"cj99r6nai001fy9id5scpumnq","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ndx004qy9idarkqyeal"},{"post_id":"cj99r6nai001fy9id5scpumnq","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6ndz004ty9idutrluzwc"},{"post_id":"cj99r6ndb0041y9idxbpl0yuv","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ne1004vy9ido1tlwgfq"},{"post_id":"cj99r6ndb0041y9idxbpl0yuv","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ne2004yy9idhmcxz11t"},{"post_id":"cj99r6ndb0041y9idxbpl0yuv","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6ne50050y9idbw3h4jzq"},{"post_id":"cj99r6nak001iy9idyew6s3zg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ne70053y9idvor3tt2v"},{"post_id":"cj99r6nak001iy9idyew6s3zg","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6neb0055y9id7bxnhnjg"},{"post_id":"cj99r6nak001iy9idyew6s3zg","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6nec0058y9idvn03itm8"},{"post_id":"cj99r6nam001jy9id8w6p6jq6","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nee005ay9idgpdd7p3s"},{"post_id":"cj99r6nam001jy9id8w6p6jq6","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6neg005dy9idsyluxnso"},{"post_id":"cj99r6nam001jy9id8w6p6jq6","category_id":"cj99r6nde0045y9idsvcsfnxh","_id":"cj99r6nei005fy9idtlcmz4zd"},{"post_id":"cj99r6ndg0048y9id2irq134t","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nek005iy9ide8phyglv"},{"post_id":"cj99r6ndg0048y9id2irq134t","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nem005ky9id9l0g5nwm"},{"post_id":"cj99r6ndh004ay9idvw39uhnm","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nen005ny9idrk7q678k"},{"post_id":"cj99r6ndh004ay9idvw39uhnm","category_id":"cj99r6nb70024y9idut313vzl","_id":"cj99r6nep005py9idq07fc8gm"},{"post_id":"cj99r6nan001ly9idulfd4p8d","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ner005sy9id8evmr2uw"},{"post_id":"cj99r6nan001ly9idulfd4p8d","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6net005uy9id6zvrq8in"},{"post_id":"cj99r6nan001ly9idulfd4p8d","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6new005xy9idmd0yh6f0"},{"post_id":"cj99r6ndq004fy9idtflmmhdq","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nex005zy9idw4czf5vb"},{"post_id":"cj99r6ndq004fy9idtflmmhdq","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nez0062y9idi6f5rw6r"},{"post_id":"cj99r6nar001my9id8jfg1kz7","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nf20064y9idkftwus63"},{"post_id":"cj99r6nar001my9id8jfg1kz7","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nf30067y9idr6d01zr2"},{"post_id":"cj99r6nar001my9id8jfg1kz7","category_id":"cj99r6nax001ty9idt5fpw4no","_id":"cj99r6nf50069y9idxuxj296b"},{"post_id":"cj99r6ndu004ky9id8ueazrbg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nf7006cy9idotbv7zvh"},{"post_id":"cj99r6ndu004ky9id8ueazrbg","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nf8006ey9idam0e6tqj"},{"post_id":"cj99r6ndu004ky9id8ueazrbg","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6nfa006gy9idqb3aa0cz"},{"post_id":"cj99r6nau001py9ids49ilbj0","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfb006jy9id3nqeh1fc"},{"post_id":"cj99r6nau001py9ids49ilbj0","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nfd006ly9id8sdmath0"},{"post_id":"cj99r6nau001py9ids49ilbj0","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6nff006oy9ids43fhwqe"},{"post_id":"cj99r6ndv004ny9idsjht8mvh","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfh006qy9idi0kbn3vt"},{"post_id":"cj99r6ndv004ny9idsjht8mvh","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nfj006ty9idjnw0qscq"},{"post_id":"cj99r6nav001ry9idiz430pbd","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfl006vy9iddw56u9og"},{"post_id":"cj99r6nav001ry9idiz430pbd","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nfm006yy9idycsrt8c1"},{"post_id":"cj99r6nav001ry9idiz430pbd","category_id":"cj99r6nch0039y9idqmygw8tq","_id":"cj99r6nfn006zy9idanarxnol"},{"post_id":"cj99r6ndy004sy9idke9p8ixb","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfo0070y9idxxij5dag"},{"post_id":"cj99r6ndy004sy9idke9p8ixb","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nfo0072y9idnjt43p3m"},{"post_id":"cj99r6ne2004xy9id9h2wkm79","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfp0073y9idkz0fgjix"},{"post_id":"cj99r6ne2004xy9id9h2wkm79","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nfp0075y9id7y5ki0fa"},{"post_id":"cj99r6naz001uy9idv5aqf5cy","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfq0076y9idiyhqrjo1"},{"post_id":"cj99r6naz001uy9idv5aqf5cy","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nfq0078y9idllseka1t"},{"post_id":"cj99r6naz001uy9idv5aqf5cy","category_id":"cj99r6ne1004wy9idpo46sqok","_id":"cj99r6nfr0079y9idmlevfe6g"},{"post_id":"cj99r6ne60052y9idrxjq7pqg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfr007by9ids6n3pej6"},{"post_id":"cj99r6ne60052y9idrxjq7pqg","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nfr007cy9idr6otuvjj"},{"post_id":"cj99r6nb0001wy9id1e8sxn1y","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfs007ey9id2m0xgikk"},{"post_id":"cj99r6nb0001wy9id1e8sxn1y","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nfs007fy9idd20au5o2"},{"post_id":"cj99r6nb0001wy9id1e8sxn1y","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6nft007hy9id77iopie4"},{"post_id":"cj99r6nea0054y9idggr7sway","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nft007iy9idd6dr9x6e"},{"post_id":"cj99r6nea0054y9idggr7sway","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nft007ky9idnf6bsfg0"},{"post_id":"cj99r6nec0057y9id8m2n46xl","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nft007ly9idkskq8man"},{"post_id":"cj99r6nec0057y9id8m2n46xl","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nfu007ny9idajzgypio"},{"post_id":"cj99r6nec0057y9id8m2n46xl","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6nfu007oy9idkqxnha6c"},{"post_id":"cj99r6nb2001yy9idrzcpt7h4","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfv007qy9idzzw65is6"},{"post_id":"cj99r6nb2001yy9idrzcpt7h4","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nfv007ry9ide42bc22w"},{"post_id":"cj99r6nb2001yy9idrzcpt7h4","category_id":"cj99r6neb0056y9idwp79bhc1","_id":"cj99r6nfw007ty9idimdfiicl"},{"post_id":"cj99r6ned0059y9ids5n7fm7s","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfw007uy9idzgn02yc2"},{"post_id":"cj99r6ned0059y9ids5n7fm7s","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6nfx007wy9id264otvsr"},{"post_id":"cj99r6n9m000ny9id5fwdxpy9","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nfx007xy9idwo1zs90p"},{"post_id":"cj99r6n9m000ny9id5fwdxpy9","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nfy007zy9idacvfmrs9"},{"post_id":"cj99r6n9m000ny9id5fwdxpy9","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6nfz0080y9idnt48wjeq"},{"post_id":"cj99r6nej005hy9id58irob0o","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng00082y9iduiph7jfl"},{"post_id":"cj99r6nej005hy9id58irob0o","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng00083y9idnkosxafx"},{"post_id":"cj99r6nb50021y9idg7dblxd6","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng20085y9idsn5trv2h"},{"post_id":"cj99r6nb50021y9idg7dblxd6","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng20086y9idmea6y9j5"},{"post_id":"cj99r6nb50021y9idg7dblxd6","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6ng30088y9id2lanp69k"},{"post_id":"cj99r6nel005jy9idbbm2vd23","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng30089y9idwg236gka"},{"post_id":"cj99r6nel005jy9idbbm2vd23","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng4008by9idmvqbyydv"},{"post_id":"cj99r6nem005my9idqau9u7e3","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng4008cy9idqlckigp8"},{"post_id":"cj99r6nem005my9idqau9u7e3","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng5008ey9id7jf54s14"},{"post_id":"cj99r6nb60023y9id0jyto4wg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng5008fy9id49ka1rzk"},{"post_id":"cj99r6nb60023y9id0jyto4wg","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ng6008hy9idpb4dajwl"},{"post_id":"cj99r6nb60023y9id0jyto4wg","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6ng6008iy9idfy7f98fi"},{"post_id":"cj99r6nba0026y9id3x9mz2pg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng7008ky9id8yw35wns"},{"post_id":"cj99r6nba0026y9id3x9mz2pg","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ng7008ly9ideiljr25r"},{"post_id":"cj99r6nba0026y9id3x9mz2pg","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6ng8008my9id6nj0u3td"},{"post_id":"cj99r6neu005wy9idr78ce3mq","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ng8008oy9idxupkip22"},{"post_id":"cj99r6neu005wy9idr78ce3mq","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6ng9008py9id6ju824n9"},{"post_id":"cj99r6neu005wy9idr78ce3mq","category_id":"cj99r6nax001ty9idt5fpw4no","_id":"cj99r6nga008ry9idpavwqv9a"},{"post_id":"cj99r6nbd0028y9idev6nn6e8","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nga008sy9idigyd2hx9"},{"post_id":"cj99r6nbd0028y9idev6nn6e8","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ngb008uy9idoacrs634"},{"post_id":"cj99r6nbd0028y9idev6nn6e8","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6ngb008vy9idzd943fvc"},{"post_id":"cj99r6nbg002ay9id7x5brz7g","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngc008xy9idffmlsqyq"},{"post_id":"cj99r6nbg002ay9id7x5brz7g","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6ngd008yy9id3yibfzdh"},{"post_id":"cj99r6nbg002ay9id7x5brz7g","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6ngd0090y9ida1sluq7i"},{"post_id":"cj99r6n9r000sy9idb9blvq5l","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nge0091y9idym3zuam5"},{"post_id":"cj99r6n9r000sy9idb9blvq5l","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nge0093y9idnypizdy1"},{"post_id":"cj99r6n9r000sy9idb9blvq5l","category_id":"cj99r6nde0045y9idsvcsfnxh","_id":"cj99r6ngf0094y9id45xgdt3x"},{"post_id":"cj99r6nf6006by9idth3xz6b3","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngf0096y9idk97mo29n"},{"post_id":"cj99r6nf6006by9idth3xz6b3","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ngg0097y9idvzsakvng"},{"post_id":"cj99r6nbk002by9id2zfnwyo7","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngg0098y9idbbypiq45"},{"post_id":"cj99r6nbk002by9id2zfnwyo7","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ngh009ay9iddxghgbgg"},{"post_id":"cj99r6nbk002by9id2zfnwyo7","category_id":"cj99r6nf5006ay9idhlkbcf5q","_id":"cj99r6ngi009by9idwlcdkiet"},{"post_id":"cj99r6nbm002ey9idv1xpg3fp","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngj009dy9id26vdo0za"},{"post_id":"cj99r6nbm002ey9idv1xpg3fp","category_id":"cj99r6nfa006hy9idgpspepk2","_id":"cj99r6ngj009ey9idwte5wevo"},{"post_id":"cj99r6nfc006ky9idhng5iv48","category_id":"cj99r6n93000ay9idwfeyqy1t","_id":"cj99r6ngk009gy9id8zip9l08"},{"post_id":"cj99r6n9t000vy9idlp6e0ya0","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngk009hy9iddw3b9ps3"},{"post_id":"cj99r6n9t000vy9idlp6e0ya0","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ngl009jy9idpxd9jq9w"},{"post_id":"cj99r6n9t000vy9idlp6e0ya0","category_id":"cj99r6nfd006my9idxb5t7ese","_id":"cj99r6ngl009ky9idz4zepti7"},{"post_id":"cj99r6nfg006py9id60qlp5pa","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngm009my9idrtcfk6rt"},{"post_id":"cj99r6nfg006py9id60qlp5pa","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ngm009ny9idfviqkme4"},{"post_id":"cj99r6nfg006py9id60qlp5pa","category_id":"cj99r6nf5006ay9idhlkbcf5q","_id":"cj99r6ngm009py9ideuelu9v9"},{"post_id":"cj99r6nbt002jy9idsxqiaa1f","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngn009qy9idrbr8asbf"},{"post_id":"cj99r6nbt002jy9idsxqiaa1f","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6ngn009sy9idru81sw4o"},{"post_id":"cj99r6nbt002jy9idsxqiaa1f","category_id":"cj99r6nfi006ry9idvxhuli20","_id":"cj99r6ngo009ty9idxl4c3of1"},{"post_id":"cj99r6nfk006uy9id1j8kenr4","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngo009uy9idc8itw9gz"},{"post_id":"cj99r6nfk006uy9id1j8kenr4","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6ngp009wy9idfkcj6lzm"},{"post_id":"cj99r6nfm006xy9idwwogiwpb","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngp009xy9idoqqnucea"},{"post_id":"cj99r6nfm006xy9idwwogiwpb","category_id":"cj99r6n9c000hy9ide1wu1nae","_id":"cj99r6ngq009zy9idfu2nghn1"},{"post_id":"cj99r6nbw002ly9idyhetlwfx","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngq00a0y9idhukp6csw"},{"post_id":"cj99r6nbw002ly9idyhetlwfx","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6ngr00a2y9idct2mdwy8"},{"post_id":"cj99r6nbz002ny9idlpgfue9s","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngs00a3y9idzn31iyeq"},{"post_id":"cj99r6nbz002ny9idlpgfue9s","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ngs00a5y9idg3dqbnrt"},{"post_id":"cj99r6nbz002ny9idlpgfue9s","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6ngt00a6y9iduhwk01oy"},{"post_id":"cj99r6nc1002qy9idzcil3mkk","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngu00a8y9idhxq0hn3t"},{"post_id":"cj99r6nc1002qy9idzcil3mkk","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6ngv00a9y9idaflnc069"},{"post_id":"cj99r6nc1002qy9idzcil3mkk","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6ngw00aby9id2l4y4fpu"},{"post_id":"cj99r6nc6002vy9id968bor7z","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngx00acy9idcnjnm0ht"},{"post_id":"cj99r6nc6002vy9id968bor7z","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6ngy00aey9id50svvsbd"},{"post_id":"cj99r6ncb0030y9idsme2lins","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngy00afy9id4opz3yi3"},{"post_id":"cj99r6ncb0030y9idsme2lins","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6ngz00ahy9idkysvzuo2"},{"post_id":"cj99r6nce0035y9ideflmqun3","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6ngz00aiy9ida3sbv35z"},{"post_id":"cj99r6nce0035y9ideflmqun3","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nh000aky9idpf1yojr0"},{"post_id":"cj99r6nce0035y9ideflmqun3","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6nh000aly9id57pzf8i0"},{"post_id":"cj99r6nci003ay9idyznp4nsy","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nh200any9iddo36ktl4"},{"post_id":"cj99r6nci003ay9idyznp4nsy","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nh200aoy9idjz4wrlgu"},{"post_id":"cj99r6nci003ay9idyznp4nsy","category_id":"cj99r6ncs003ly9idj0unhudg","_id":"cj99r6nh400aqy9idanjg1ftm"},{"post_id":"cj99r6nck003cy9idbcx6nkh6","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nh400ary9id0961ogfh"},{"post_id":"cj99r6nck003cy9idbcx6nkh6","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nh500asy9id8xk9o59m"},{"post_id":"cj99r6nck003cy9idbcx6nkh6","category_id":"cj99r6nfv007sy9idanaz2hs6","_id":"cj99r6nh600auy9idfj4boip7"},{"post_id":"cj99r6ncn003ey9idbzsitk7a","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nh600avy9id570e7rv2"},{"post_id":"cj99r6ncn003ey9idbzsitk7a","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nh700axy9idus2a86mw"},{"post_id":"cj99r6ncn003ey9idbzsitk7a","category_id":"cj99r6nd4003vy9idgm464xg2","_id":"cj99r6nh800ayy9idzshjvq5s"},{"post_id":"cj99r6ncp003hy9idytetiobz","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nh900b0y9idok6zlnfv"},{"post_id":"cj99r6ncp003hy9idytetiobz","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nh900b1y9id6uzd9lt5"},{"post_id":"cj99r6ncp003hy9idytetiobz","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6nha00b3y9id87cfy7er"},{"post_id":"cj99r6ncr003jy9idufsjrzl4","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nha00b4y9idw4r6w0pk"},{"post_id":"cj99r6ncr003jy9idufsjrzl4","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhb00b6y9idfl2kbaw1"},{"post_id":"cj99r6ncr003jy9idufsjrzl4","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6nhb00b7y9idbclexapa"},{"post_id":"cj99r6ncs003my9idm1z7c3a2","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhc00b8y9idosugmxi6"},{"post_id":"cj99r6ncs003my9idm1z7c3a2","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nhc00b9y9idsz36jbyd"},{"post_id":"cj99r6ncs003my9idm1z7c3a2","category_id":"cj99r6nfd006my9idxb5t7ese","_id":"cj99r6nhd00bay9idauzoxftf"},{"post_id":"cj99r6ncv003oy9idgumxaeva","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhd00bby9id3gt075i3"},{"post_id":"cj99r6ncv003oy9idgumxaeva","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhd00bcy9idj7t7o2m8"},{"post_id":"cj99r6ncv003oy9idgumxaeva","category_id":"cj99r6nf5006ay9idhlkbcf5q","_id":"cj99r6nhd00bdy9idqm4jyxvp"},{"post_id":"cj99r6ncz003ry9iddgzel8jm","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhd00bey9id49q2vbz7"},{"post_id":"cj99r6ncz003ry9iddgzel8jm","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhe00bfy9iddffabdzn"},{"post_id":"cj99r6ncz003ry9iddgzel8jm","category_id":"cj99r6ng3008ay9idec7md0cr","_id":"cj99r6nhe00bgy9id8zay36l4"},{"post_id":"cj99r6nd2003ty9id1vujp0kw","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhe00bhy9idpl7mw5ds"},{"post_id":"cj99r6nd2003ty9id1vujp0kw","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhe00biy9idnr8z5e2f"},{"post_id":"cj99r6nd2003ty9id1vujp0kw","category_id":"cj99r6nem005ly9id56i7kl0u","_id":"cj99r6nhe00bjy9idjfmpzjhm"},{"post_id":"cj99r6nd5003wy9idm4y63z5y","category_id":"cj99r6ng5008gy9idqg6lcf3u","_id":"cj99r6nhe00bky9idnnae0bmr"},{"post_id":"cj99r6nd8003yy9iddoljiy52","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhe00bly9idyrm7sppj"},{"post_id":"cj99r6nd8003yy9iddoljiy52","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nhe00bmy9idnv714in7"},{"post_id":"cj99r6nd8003yy9iddoljiy52","category_id":"cj99r6ng6008jy9id6b6el40j","_id":"cj99r6nhe00bny9idz9ytuy2n"},{"post_id":"cj99r6ndc0043y9id90ssxuqu","category_id":"cj99r6ng5008gy9idqg6lcf3u","_id":"cj99r6nhe00boy9id8ezpah8t"},{"post_id":"cj99r6nde0046y9idyp87te8z","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhe00bpy9idmsni1lid"},{"post_id":"cj99r6nde0046y9idyp87te8z","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhe00bqy9idx45353ie"},{"post_id":"cj99r6nde0046y9idyp87te8z","category_id":"cj99r6nf5006ay9idhlkbcf5q","_id":"cj99r6nhe00bry9idrzbbtzfx"},{"post_id":"cj99r6ndx004py9id0vp9hy86","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhe00bsy9id4zjguci1"},{"post_id":"cj99r6ndx004py9id0vp9hy86","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nhe00bty9idknctw2ns"},{"post_id":"cj99r6ndx004py9id0vp9hy86","category_id":"cj99r6ngc008wy9idsl48c8uy","_id":"cj99r6nhe00buy9idvmm8cg8b"},{"post_id":"cj99r6ne0004uy9id1kag624e","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhf00bvy9ido74c9pib"},{"post_id":"cj99r6ne0004uy9id1kag624e","category_id":"cj99r6n9s000uy9idamys5was","_id":"cj99r6nhf00bwy9id481aaea4"},{"post_id":"cj99r6ne0004uy9id1kag624e","category_id":"cj99r6nf5006ay9idhlkbcf5q","_id":"cj99r6nhf00bxy9id7nwv72ua"},{"post_id":"cj99r6ne4004zy9idycixlrya","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhf00byy9idv8enxhn4"},{"post_id":"cj99r6ne4004zy9idycixlrya","category_id":"cj99r6nge0092y9idzxpkcgdi","_id":"cj99r6nhf00bzy9idmsuax4v5"},{"post_id":"cj99r6nef005cy9id23k6w2sf","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhf00c0y9id7pzc3te0"},{"post_id":"cj99r6nef005cy9id23k6w2sf","category_id":"cj99r6ngf0095y9iddsh0ukcj","_id":"cj99r6nhf00c1y9idvcynhppn"},{"post_id":"cj99r6neo005oy9idpaogdzao","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhf00c2y9idzt7vt9am"},{"post_id":"cj99r6neo005oy9idpaogdzao","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nhf00c3y9id5vgfo6nm"},{"post_id":"cj99r6neo005oy9idpaogdzao","category_id":"cj99r6nfd006my9idxb5t7ese","_id":"cj99r6nhg00c4y9id4fqtqbhd"},{"post_id":"cj99r6neq005ry9iduggwnpxb","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhg00c5y9idsms5qbvu"},{"post_id":"cj99r6neq005ry9iduggwnpxb","category_id":"cj99r6nfa006hy9idgpspepk2","_id":"cj99r6nhg00c6y9idfhdnon1g"},{"post_id":"cj99r6new005yy9id2p5d2jwf","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhg00c7y9id7xlyr14t"},{"post_id":"cj99r6new005yy9id2p5d2jwf","category_id":"cj99r6naa0017y9ide3bncvb3","_id":"cj99r6nhg00c8y9idtkfnic97"},{"post_id":"cj99r6new005yy9id2p5d2jwf","category_id":"cj99r6ngl009ly9idgk8xjlcc","_id":"cj99r6nhg00c9y9idwp0psxrp"},{"post_id":"cj99r6ney0061y9idf28vycmn","category_id":"cj99r6ngm009oy9ido1fcmmjm","_id":"cj99r6nhg00cay9idp4751q9k"},{"post_id":"cj99r6nf00063y9idfb4jfl3d","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhh00cby9id25rkh4xn"},{"post_id":"cj99r6nf00063y9idfb4jfl3d","category_id":"cj99r6ngn009ry9idsuqz2sis","_id":"cj99r6nhh00ccy9idsc3na4ie"},{"post_id":"cj99r6nf30066y9idaes7wvy6","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhh00cdy9idsckvdm79"},{"post_id":"cj99r6nf30066y9idaes7wvy6","category_id":"cj99r6naj001hy9id0amduhe9","_id":"cj99r6nhh00cey9idbs8bnbqo"},{"post_id":"cj99r6nf30066y9idaes7wvy6","category_id":"cj99r6nfi006ry9idvxhuli20","_id":"cj99r6nhh00cfy9idyqtbr78y"},{"post_id":"cj99r6nf7006dy9id4xxujhwj","category_id":"cj99r6ngq00a1y9id7tfgotxg","_id":"cj99r6nhh00cgy9id9i4l86gg"},{"post_id":"cj99r6nf9006fy9id9y0m7s84","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhh00chy9idzdmt2s54"},{"post_id":"cj99r6nf9006fy9id9y0m7s84","category_id":"cj99r6ngn009ry9idsuqz2sis","_id":"cj99r6nhh00ciy9id3e0pxobn"},{"post_id":"cj99r6nfe006ny9idt89zhnsb","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhh00cjy9idz4d8tea3"},{"post_id":"cj99r6nfe006ny9idt89zhnsb","category_id":"cj99r6ngn009ry9idsuqz2sis","_id":"cj99r6nhh00cky9idktmtzflk"},{"post_id":"cj99r6nc4002sy9idukwlynjx","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhh00cly9idhufllhof"},{"post_id":"cj99r6nc4002sy9idukwlynjx","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nhh00cmy9ida3ktt8lf"},{"post_id":"cj99r6nc4002sy9idukwlynjx","category_id":"cj99r6ngy00agy9idgcl1ot34","_id":"cj99r6nhh00cny9idlj6zh89u"},{"post_id":"cj99r6nc9002xy9id61ojgwmg","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhi00coy9id4wluk4ig"},{"post_id":"cj99r6nc9002xy9id61ojgwmg","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nhi00cpy9idcsafu0dx"},{"post_id":"cj99r6nc9002xy9id61ojgwmg","category_id":"cj99r6ngy00agy9idgcl1ot34","_id":"cj99r6nhi00cqy9id71hs11g3"},{"post_id":"cj99r6ncc0032y9idnd98vb6d","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhi00cry9idnos8zwu0"},{"post_id":"cj99r6ncc0032y9idnd98vb6d","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nhi00csy9idlj6u3nmc"},{"post_id":"cj99r6ncc0032y9idnd98vb6d","category_id":"cj99r6ngy00agy9idgcl1ot34","_id":"cj99r6nhi00cty9idit0f20q4"},{"post_id":"cj99r6ndj004dy9idfdnv7lys","category_id":"cj99r6ngb008ty9iduw0rly9k","_id":"cj99r6nhi00cuy9idbjb9ua7v"},{"post_id":"cj99r6ndj004dy9idfdnv7lys","category_id":"cj99r6nh300apy9idm9syz6xh","_id":"cj99r6nhi00cvy9id35n5rfq7"},{"post_id":"cj99r6neh005ey9idnodck9re","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhi00cwy9id9d2zdfyx"},{"post_id":"cj99r6neh005ey9idnodck9re","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nhi00cxy9id978k148c"},{"post_id":"cj99r6neh005ey9idnodck9re","category_id":"cj99r6ngy00agy9idgcl1ot34","_id":"cj99r6nhi00cyy9ideeiz31im"},{"post_id":"cj99r6net005ty9idw9a9jlci","category_id":"cj99r6ngk009iy9idzf97bzw3","_id":"cj99r6nhi00czy9idhlu4hf60"},{"post_id":"cj99r6net005ty9idw9a9jlci","category_id":"cj99r6nh700awy9idkm6ul9fz","_id":"cj99r6nhi00d0y9idpj75ku8w"},{"post_id":"cj99r6nf40068y9idd2reblc5","category_id":"cj99r6ngp009yy9id22h9iozw","_id":"cj99r6nhi00d1y9idk9unqbga"},{"post_id":"cj99r6nf40068y9idd2reblc5","category_id":"cj99r6nh800azy9ide5lfkhic","_id":"cj99r6nhi00d2y9idnwuytwqs"},{"post_id":"cj99r6nfa006iy9idzthrncgf","category_id":"cj99r6n8f0003y9id4llaw5t8","_id":"cj99r6nhi00d3y9iddc3ulaug"},{"post_id":"cj99r6nfa006iy9idzthrncgf","category_id":"cj99r6nfl006wy9idwz8ldprj","_id":"cj99r6nhj00d4y9id7mbjhoe5"},{"post_id":"cj99r6nfa006iy9idzthrncgf","category_id":"cj99r6nh900b2y9id8tfbf5wl","_id":"cj99r6nhj00d5y9idi4r7vilc"},{"post_id":"cj99r6nfi006sy9id56qb06sh","category_id":"cj99r6ngb008ty9iduw0rly9k","_id":"cj99r6nhj00d6y9idazx2d0j6"},{"post_id":"cj99r6nfi006sy9id56qb06sh","category_id":"cj99r6nha00b5y9idq6m77a8x","_id":"cj99r6nhj00d7y9id27judu5y"}],"PostTag":[],"Tag":[]}}